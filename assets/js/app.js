/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(2);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("var $ = __webpack_require__(7);\nvar fullCalendar = __webpack_require__(132);\n\nconsole.log('Hello, World!');\n\nconsole.log($('h1'));\n\nconsole.log(fullCalendar);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fcmVzb3VyY2VzL2pzL2FwcC5qcz80MjVmIl0sIm5hbWVzIjpbIiQiLCJyZXF1aXJlIiwiZnVsbENhbGVuZGFyIiwiY29uc29sZSIsImxvZyJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxtQkFBQUMsQ0FBUSxDQUFSLENBQVI7QUFDQSxJQUFJQyxlQUFlLG1CQUFBRCxDQUFRLEdBQVIsQ0FBbkI7O0FBR0FFLFFBQVFDLEdBQVIsQ0FBWSxlQUFaOztBQUVBRCxRQUFRQyxHQUFSLENBQVlKLEVBQUUsSUFBRixDQUFaOztBQUVBRyxRQUFRQyxHQUFSLENBQVlGLFlBQVoiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnZhciBmdWxsQ2FsZW5kYXIgPSByZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpO1xuXG5cbmNvbnNvbGUubG9nKCdIZWxsbywgV29ybGQhJyk7XG5cbmNvbnNvbGUubG9nKCQoJ2gxJykpO1xuXG5jb25zb2xlLmxvZyhmdWxsQ2FsZW5kYXIpO1xuXG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX3Jlc291cmNlcy9qcy9hcHAuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fcmVzb3VyY2VzL3Njc3MvYXBwLnNjc3M/NWY5NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL19yZXNvdXJjZXMvc2Nzcy9hcHAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, doc, node ) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\t\t\t\tif ( node[ i ] ) {\n\t\t\t\t\tscript[ i ] = node[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.3.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\t\t) );\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\t\tval = curCSS( elem, dimension, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox;\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = valueIsBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\tif ( val === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\n\n\t\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\n\n\t\t// offsetWidth/offsetHeight provide border-box values\n\t\tvalueIsBorderBox = true;\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\t\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra && boxModelAdjustment(\n\t\t\t\t\telem,\n\t\t\t\t\tdimension,\n\t\t\t\t\textra,\n\t\t\t\t\tisBorderBox,\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzP2VlZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUSw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaURBQWlEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw4QkFBOEI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQ0Y7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLENBQUMiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE4LTAxLTIwVDE3OjI0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBub2RlWyBpIF0gKSB7XG5cdFx0XHRcdFx0c2NyaXB0WyBpIF0gPSBub2RlWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjMuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jLCBub2RlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXCJhYnNvbHV0ZVwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblx0XHQpICk7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3g7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSB7XG5cblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF07XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgPT09IHN0eWxlcy5wb3NpdGlvbiApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IERhdGUubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js\n\n;(function (global, factory) {\n     true ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        } else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            }\n            else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        if (!m) {\n            return isArray(this._weekdays) ? this._weekdays :\n                this._weekdays['standalone'];\n        }\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                var aliasedRequire = require;\n                __webpack_require__(134)(\"./\" + name);\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {}\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n            else {\n                if ((typeof console !==  'undefined') && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                        'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            // MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale != null) {\n                parentConfig = tmpLocale._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').trim();\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n                (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input,units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input,units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n            case 'month': output = monthDiff(this, that); break;\n            case 'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second': output = (this - that) / 1e3; break; // 1000\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n            case 'year':\n                this.month(0);\n                /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n                /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n            case 'date':\n                this.hours(0);\n                /* falls through */\n            case 'hour':\n                this.minutes(0);\n                /* falls through */\n            case 'minute':\n                this.seconds(0);\n                /* falls through */\n            case 'second':\n                this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n\n        // 'date' is an alias for 'day', so it should be considered as such.\n        if (units === 'date') {\n            units = 'day';\n        }\n\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input,\n                this.week(),\n                this.weekday(),\n                this.localeData()._week.dow,\n                this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIOROITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function clone$1 () {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             && ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes] ||\n                hours   <= 1             && ['h']           ||\n                hours   < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             && ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n                months  <= 1             && ['M']           ||\n                months  < thresholds.M   && ['MM', months]  ||\n                years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n            (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign + h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ? hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n    // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    hooks.version = '2.22.0';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(133)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcz8zYzk4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI4Q0FBQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9COztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLElBQUk7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRMQUE0TCxJQUFJOztBQUVoTSxxRUFBcUUsSUFBSTs7QUFFekU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDLDZCQUE2QixFQUFFLEVBQUU7QUFDakMsNkJBQTZCLEVBQUUsRUFBRTtBQUNqQyxrQ0FBa0MsRUFBRSxFQUFFO0FBQ3RDLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckMseUNBQXlDO0FBQ3pDLDZCQUE2QixJQUFJLEVBQUU7QUFDbkMsNkJBQTZCLElBQUksRUFBRTtBQUNuQyxrQ0FBa0MsSUFBSSxFQUFFOztBQUV4QywrQkFBK0I7QUFDL0Isb0NBQW9DOztBQUVwQyw4Q0FBOEM7QUFDOUMscURBQXFEOztBQUVyRCx3Q0FBd0MsSUFBSSxJQUFJOztBQUVoRDtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0sd0VBQXdFLE1BQU0sbUJBQW1CLE1BQU0scUJBQXFCLE1BQU0sRUFBRSxJQUFJOztBQUV6Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUUsSUFBSSxFQUFFO0FBQ25ELHdDQUF3QyxFQUFFLElBQUksRUFBRTs7QUFFaEQ7O0FBRUE7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQywyQkFBMkIsRUFBRTtBQUM3Qiw2QkFBNkIsRUFBRTtBQUMvQiwyQkFBMkIsRUFBRTtBQUM3Qix5QkFBeUIsRUFBRSxJQUFJLEVBQUU7QUFDakMsd0JBQXdCLEVBQUU7QUFDMUIsK0JBQStCLEdBQUc7QUFDbEMseUJBQXlCLEVBQUU7QUFDM0I7QUFDQSwyQkFBMkIsRUFBRSxJQUFJLEVBQUU7QUFDbkMsMEJBQTBCLEVBQUUsSUFBSSxFQUFFO0FBQ2xDLHdCQUF3QixFQUFFO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsSUFBSSwwREFBMEQsSUFBSSxxRUFBcUUsRUFBRTs7QUFFdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdELHlEQUF5RDtBQUN6RCwrREFBK0Q7QUFDL0Qsd0RBQXdELE9BQU87QUFDL0Qsd0RBQXdELE9BQU87QUFDL0QsdURBQXVELE9BQU87QUFDOUQsbUVBQW1FLE9BQU87QUFDMUUscUVBQXFFLE9BQU87QUFDNUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBvYnNPZmZzZXRzID0ge1xuICAgICAgICBVVDogMCxcbiAgICAgICAgR01UOiAwLFxuICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgIEVTVDogLTUgKiA2MCxcbiAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgIE1EVDogLTYgKiA2MCxcbiAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgIFBTVDogLTggKiA2MFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgICAgIHZhciBtID0gaG0gJSAxMDAsIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspKFxcLlxcZCopPyk/JC87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgdmFyIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24gLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAobWF0Y2hbMV0gPT09ICcrJykgPyAxIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9ST0lUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjIyLjAnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICBob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIGhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ1lZWVktW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var af = moment.defineLocale('af', {\n        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),\n        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),\n        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),\n        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),\n        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),\n        meridiemParse: /vm|nm/i,\n        isPM : function (input) {\n            return /^nm$/i.test(input);\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 12) {\n                return isLower ? 'vm' : 'VM';\n            } else {\n                return isLower ? 'nm' : 'NM';\n            }\n        },\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Vandag om] LT',\n            nextDay : '[Mre om] LT',\n            nextWeek : 'dddd [om] LT',\n            lastDay : '[Gister om] LT',\n            lastWeek : '[Laas] dddd [om] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'oor %s',\n            past : '%s gelede',\n            s : '\\'n paar sekondes',\n            ss : '%d sekondes',\n            m : '\\'n minuut',\n            mm : '%d minute',\n            h : '\\'n uur',\n            hh : '%d ure',\n            d : '\\'n dag',\n            dd : '%d dae',\n            M : '\\'n maand',\n            MM : '%d maande',\n            y : '\\'n jaar',\n            yy : '%d jaar'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter\n        },\n        week : {\n            dow : 1, // Maandag is die eerste dag van die week.\n            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.\n        }\n    });\n\n    return af;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hZi5qcz9kYzIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBLDRGQUE0RjtBQUM1RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGFmID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYWYnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJpZV9GZWJydWFyaWVfTWFhcnRfQXByaWxfTWVpX0p1bmllX0p1bGllX0F1Z3VzdHVzX1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0Rlc2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01ydF9BcHJfTWVpX0p1bl9KdWxfQXVnX1NlcF9Pa3RfTm92X0Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnU29uZGFnX01hYW5kYWdfRGluc2RhZ19Xb2Vuc2RhZ19Eb25kZXJkYWdfVnJ5ZGFnX1NhdGVyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1Nvbl9NYWFfRGluX1dvZV9Eb25fVnJ5X1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU29fTWFfRGlfV29fRG9fVnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC92bXxubS9pLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL15ubSQvaS50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAndm0nIDogJ1ZNJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnbm0nIDogJ05NJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW1ZhbmRhZyBvbV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbTcO0cmUgb21dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW29tXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tHaXN0ZXIgb21dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYWFzXSBkZGRkIFtvbV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29vciAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGdlbGVkZScsXG4gICAgICAgICAgICBzIDogJ1xcJ24gcGFhciBzZWtvbmRlcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWtvbmRlcycsXG4gICAgICAgICAgICBtIDogJ1xcJ24gbWludXV0JyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZScsXG4gICAgICAgICAgICBoIDogJ1xcJ24gdXVyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIHVyZScsXG4gICAgICAgICAgICBkIDogJ1xcJ24gZGFnJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZScsXG4gICAgICAgICAgICBNIDogJ1xcJ24gbWFhbmQnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbWFhbmRlJyxcbiAgICAgICAgICAgIHkgOiAnXFwnbiBqYWFyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGphYXInXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdGV8ZGUpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAoKG51bWJlciA9PT0gMSB8fCBudW1iZXIgPT09IDggfHwgbnVtYmVyID49IDIwKSA/ICdzdGUnIDogJ2RlJyk7IC8vIFRoYW5rcyB0byBKb3JpcyBSw7ZsaW5nIDogaHR0cHM6Ly9naXRodWIuY29tL2pqdXBpdGVyXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNYWFuZGFnIGlzIGRpZSBlZXJzdGUgZGFnIHZhbiBkaWUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIERpZSB3ZWVrIHdhdCBkaWUgNGRlIEphbnVhcmllIGJldmF0IGlzIGRpZSBlZXJzdGUgd2VlayB2YW4gZGllIGphYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhZjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYWYuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    }, pluralForm = function (n) {\n        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;\n    }, plurals = {\n        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']\n    }, pluralize = function (u) {\n        return function (number, withoutSuffix, string, isFuture) {\n            var f = pluralForm(number),\n                str = plurals[u][pluralForm(number)];\n            if (f === 2) {\n                str = str[withoutSuffix ? 0 : 1];\n            }\n            return str.replace(/%d/i, number);\n        };\n    }, months = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n\n    var ar = moment.defineLocale('ar', {\n        months : months,\n        monthsShort : months,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'D/\\u200FM/\\u200FYYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : pluralize('s'),\n            ss : pluralize('s'),\n            m : pluralize('m'),\n            mm : pluralize('m'),\n            h : pluralize('h'),\n            hh : pluralize('h'),\n            d : pluralize('d'),\n            dd : pluralize('d'),\n            M : pluralize('M'),\n            MM : pluralize('M'),\n            y : pluralize('y'),\n            yy : pluralize('y')\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            }).replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ar;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci5qcz9kY2M1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfZoScsXG4gICAgICAgICcyJzogJ9miJyxcbiAgICAgICAgJzMnOiAn2aMnLFxuICAgICAgICAnNCc6ICfZpCcsXG4gICAgICAgICc1JzogJ9mlJyxcbiAgICAgICAgJzYnOiAn2aYnLFxuICAgICAgICAnNyc6ICfZpycsXG4gICAgICAgICc4JzogJ9moJyxcbiAgICAgICAgJzknOiAn2aknLFxuICAgICAgICAnMCc6ICfZoCdcbiAgICB9LCBudW1iZXJNYXAgPSB7XG4gICAgICAgICfZoSc6ICcxJyxcbiAgICAgICAgJ9miJzogJzInLFxuICAgICAgICAn2aMnOiAnMycsXG4gICAgICAgICfZpCc6ICc0JyxcbiAgICAgICAgJ9mlJzogJzUnLFxuICAgICAgICAn2aYnOiAnNicsXG4gICAgICAgICfZpyc6ICc3JyxcbiAgICAgICAgJ9moJzogJzgnLFxuICAgICAgICAn2aknOiAnOScsXG4gICAgICAgICfZoCc6ICcwJ1xuICAgIH0sIHBsdXJhbEZvcm0gPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiBuID09PSAxID8gMSA6IG4gPT09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1O1xuICAgIH0sIHBsdXJhbHMgPSB7XG4gICAgICAgIHMgOiBbJ9ij2YLZhCDZhdmGINir2KfZhtmK2KknLCAn2KvYp9mG2YrYqSDZiNin2K3Yr9ipJywgWyfYq9in2YbZitiq2KfZhicsICfYq9in2YbZitiq2YrZhiddLCAnJWQg2KvZiNin2YYnLCAnJWQg2KvYp9mG2YrYqScsICclZCDYq9in2YbZitipJ10sXG4gICAgICAgIG0gOiBbJ9ij2YLZhCDZhdmGINiv2YLZitmC2KknLCAn2K/ZgtmK2YLYqSDZiNin2K3Yr9ipJywgWyfYr9mC2YrZgtiq2KfZhicsICfYr9mC2YrZgtiq2YrZhiddLCAnJWQg2K/Zgtin2KbZgicsICclZCDYr9mC2YrZgtipJywgJyVkINiv2YLZitmC2KknXSxcbiAgICAgICAgaCA6IFsn2KPZgtmEINmF2YYg2LPYp9i52KknLCAn2LPYp9i52Kkg2YjYp9it2K/YqScsIFsn2LPYp9i52KrYp9mGJywgJ9iz2KfYudiq2YrZhiddLCAnJWQg2LPYp9i52KfYqicsICclZCDYs9in2LnYqScsICclZCDYs9in2LnYqSddLFxuICAgICAgICBkIDogWyfYo9mC2YQg2YXZhiDZitmI2YUnLCAn2YrZiNmFINmI2KfYrdivJywgWyfZitmI2YXYp9mGJywgJ9mK2YjZhdmK2YYnXSwgJyVkINij2YrYp9mFJywgJyVkINmK2YjZhdmL2KcnLCAnJWQg2YrZiNmFJ10sXG4gICAgICAgIE0gOiBbJ9ij2YLZhCDZhdmGINi02YfYsScsICfYtNmH2LEg2YjYp9it2K8nLCBbJ9i02YfYsdin2YYnLCAn2LTZh9ix2YrZhiddLCAnJWQg2KPYtNmH2LEnLCAnJWQg2LTZh9ix2KcnLCAnJWQg2LTZh9ixJ10sXG4gICAgICAgIHkgOiBbJ9ij2YLZhCDZhdmGINi52KfZhScsICfYudin2YUg2YjYp9it2K8nLCBbJ9i52KfZhdin2YYnLCAn2LnYp9mF2YrZhiddLCAnJWQg2KPYudmI2KfZhScsICclZCDYudin2YXZi9inJywgJyVkINi52KfZhSddXG4gICAgfSwgcGx1cmFsaXplID0gZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBmID0gcGx1cmFsRm9ybShudW1iZXIpLFxuICAgICAgICAgICAgICAgIHN0ciA9IHBsdXJhbHNbdV1bcGx1cmFsRm9ybShudW1iZXIpXTtcbiAgICAgICAgICAgIGlmIChmID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyW3dpdGhvdXRTdWZmaXggPyAwIDogMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgICAgIH07XG4gICAgfSwgbW9udGhzID0gW1xuICAgICAgICAn2YrZhtin2YrYsScsXG4gICAgICAgICfZgdio2LHYp9mK2LEnLFxuICAgICAgICAn2YXYp9ix2LMnLFxuICAgICAgICAn2KPYqNix2YrZhCcsXG4gICAgICAgICfZhdin2YrZiCcsXG4gICAgICAgICfZitmI2YbZitmIJyxcbiAgICAgICAgJ9mK2YjZhNmK2YgnLFxuICAgICAgICAn2KPYutiz2LfYsycsXG4gICAgICAgICfYs9io2KrZhdio2LEnLFxuICAgICAgICAn2KPZg9iq2YjYqNixJyxcbiAgICAgICAgJ9mG2YjZgdmF2KjYsScsXG4gICAgICAgICfYr9mK2LPZhdio2LEnXG4gICAgXTtcblxuICAgIHZhciBhciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyJywge1xuICAgICAgICBtb250aHMgOiBtb250aHMsXG4gICAgICAgIG1vbnRoc1Nob3J0IDogbW9udGhzLFxuICAgICAgICB3ZWVrZGF5cyA6ICfYp9mE2KPYrdivX9in2YTYpdir2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0QvXFx1MjAwRk0vXFx1MjAwRllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL9i1fNmFLyxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuICfZhScgPT09IGlucHV0O1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9i1JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfZhSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vYp9mE2YrZiNmFINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb2LrYr9mL2Kcg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9io2LnYryAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXG4gICAgICAgICAgICBzIDogcGx1cmFsaXplKCdzJyksXG4gICAgICAgICAgICBzcyA6IHBsdXJhbGl6ZSgncycpLFxuICAgICAgICAgICAgbSA6IHBsdXJhbGl6ZSgnbScpLFxuICAgICAgICAgICAgbW0gOiBwbHVyYWxpemUoJ20nKSxcbiAgICAgICAgICAgIGggOiBwbHVyYWxpemUoJ2gnKSxcbiAgICAgICAgICAgIGhoIDogcGx1cmFsaXplKCdoJyksXG4gICAgICAgICAgICBkIDogcGx1cmFsaXplKCdkJyksXG4gICAgICAgICAgICBkZCA6IHBsdXJhbGl6ZSgnZCcpLFxuICAgICAgICAgICAgTSA6IHBsdXJhbGl6ZSgnTScpLFxuICAgICAgICAgICAgTU0gOiBwbHVyYWxpemUoJ00nKSxcbiAgICAgICAgICAgIHkgOiBwbHVyYWxpemUoJ3knKSxcbiAgICAgICAgICAgIHl5IDogcGx1cmFsaXplKCd5JylcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW9mh2aLZo9mk2aXZptmn2ajZqdmgXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL9iML2csICcsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvLC9nLCAn2IwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXI7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var arDz = moment.defineLocale('ar-dz', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 4  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return arDz;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1kei5qcz9iNjQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBhckR6ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItZHonLCB7XG4gICAgICAgIG1vbnRocyA6ICfYrNin2YbZgdmKX9mB2YrZgdix2Ypf2YXYp9ix2LNf2KPZgdix2YrZhF/Zhdin2Ypf2KzZiNin2YZf2KzZiNmK2YTZitipX9ij2YjYql/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9is2KfZhtmB2Ypf2YHZitmB2LHZil/Zhdin2LHYs1/Yo9mB2LHZitmEX9mF2KfZil/YrNmI2KfZhl/YrNmI2YrZhNmK2Klf2KPZiNiqX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn2KfZhNij2K3Yr1/Yp9mE2KXYq9mG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9in2K3Yr1/Yp9ir2YbZitmGX9ir2YTYp9ir2KfYoV/Yp9ix2KjYudin2KFf2K7ZhdmK2LNf2KzZhdi52Klf2LPYqNiqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfYo9itX9il2Ktf2KvZhNinX9ij2LFf2K7ZhV/YrNmFX9iz2KgnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb2KfZhNmK2YjZhSDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW9i62K/YpyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn2YHZiiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXG4gICAgICAgICAgICBzIDogJ9ir2YjYp9mGJyxcbiAgICAgICAgICAgIHNzIDogJyVkINir2KfZhtmK2KknLFxuICAgICAgICAgICAgbSA6ICfYr9mC2YrZgtipJyxcbiAgICAgICAgICAgIG1tIDogJyVkINiv2YLYp9im2YInLFxuICAgICAgICAgICAgaCA6ICfYs9in2LnYqScsXG4gICAgICAgICAgICBoaCA6ICclZCDYs9in2LnYp9iqJyxcbiAgICAgICAgICAgIGQgOiAn2YrZiNmFJyxcbiAgICAgICAgICAgIGRkIDogJyVkINij2YrYp9mFJyxcbiAgICAgICAgICAgIE0gOiAn2LTZh9ixJyxcbiAgICAgICAgICAgIE1NIDogJyVkINij2LTZh9ixJyxcbiAgICAgICAgICAgIHkgOiAn2LPZhtipJyxcbiAgICAgICAgICAgIHl5IDogJyVkINiz2YbZiNin2KonXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyRHo7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWR6LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var arKw = moment.defineLocale('ar-kw', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return arKw;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1rdy5qcz84ZmM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBhckt3ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXIta3cnLCB7XG4gICAgICAgIG1vbnRocyA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfYp9mE2KPYrdivX9in2YTYpdiq2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn2KfYrdivX9in2KrZhtmK2YZf2KvZhNin2KvYp9ihX9in2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9mB2YogJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxuICAgICAgICAgICAgcyA6ICfYq9mI2KfZhicsXG4gICAgICAgICAgICBzcyA6ICclZCDYq9in2YbZitipJyxcbiAgICAgICAgICAgIG0gOiAn2K/ZgtmK2YLYqScsXG4gICAgICAgICAgICBtbSA6ICclZCDYr9mC2KfYptmCJyxcbiAgICAgICAgICAgIGggOiAn2LPYp9i52KknLFxuICAgICAgICAgICAgaGggOiAnJWQg2LPYp9i52KfYqicsXG4gICAgICAgICAgICBkIDogJ9mK2YjZhScsXG4gICAgICAgICAgICBkZCA6ICclZCDYo9mK2KfZhScsXG4gICAgICAgICAgICBNIDogJ9i02YfYsScsXG4gICAgICAgICAgICBNTSA6ICclZCDYo9i02YfYsScsXG4gICAgICAgICAgICB5IDogJ9iz2YbYqScsXG4gICAgICAgICAgICB5eSA6ICclZCDYs9mG2YjYp9iqJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJLdztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIta3cuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '1',\n        '2': '2',\n        '3': '3',\n        '4': '4',\n        '5': '5',\n        '6': '6',\n        '7': '7',\n        '8': '8',\n        '9': '9',\n        '0': '0'\n    }, pluralForm = function (n) {\n        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;\n    }, plurals = {\n        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']\n    }, pluralize = function (u) {\n        return function (number, withoutSuffix, string, isFuture) {\n            var f = pluralForm(number),\n                str = plurals[u][pluralForm(number)];\n            if (f === 2) {\n                str = str[withoutSuffix ? 0 : 1];\n            }\n            return str.replace(/%d/i, number);\n        };\n    }, months = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n\n    var arLy = moment.defineLocale('ar-ly', {\n        months : months,\n        monthsShort : months,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'D/\\u200FM/\\u200FYYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : pluralize('s'),\n            ss : pluralize('s'),\n            m : pluralize('m'),\n            mm : pluralize('m'),\n            h : pluralize('h'),\n            hh : pluralize('h'),\n            d : pluralize('d'),\n            dd : pluralize('d'),\n            M : pluralize('M'),\n            MM : pluralize('M'),\n            y : pluralize('y'),\n            yy : pluralize('y')\n        },\n        preparse: function (string) {\n            return string.replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return arLy;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1seS5qcz9jMGZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICcxJyxcbiAgICAgICAgJzInOiAnMicsXG4gICAgICAgICczJzogJzMnLFxuICAgICAgICAnNCc6ICc0JyxcbiAgICAgICAgJzUnOiAnNScsXG4gICAgICAgICc2JzogJzYnLFxuICAgICAgICAnNyc6ICc3JyxcbiAgICAgICAgJzgnOiAnOCcsXG4gICAgICAgICc5JzogJzknLFxuICAgICAgICAnMCc6ICcwJ1xuICAgIH0sIHBsdXJhbEZvcm0gPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiBuID09PSAxID8gMSA6IG4gPT09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1O1xuICAgIH0sIHBsdXJhbHMgPSB7XG4gICAgICAgIHMgOiBbJ9ij2YLZhCDZhdmGINir2KfZhtmK2KknLCAn2KvYp9mG2YrYqSDZiNin2K3Yr9ipJywgWyfYq9in2YbZitiq2KfZhicsICfYq9in2YbZitiq2YrZhiddLCAnJWQg2KvZiNin2YYnLCAnJWQg2KvYp9mG2YrYqScsICclZCDYq9in2YbZitipJ10sXG4gICAgICAgIG0gOiBbJ9ij2YLZhCDZhdmGINiv2YLZitmC2KknLCAn2K/ZgtmK2YLYqSDZiNin2K3Yr9ipJywgWyfYr9mC2YrZgtiq2KfZhicsICfYr9mC2YrZgtiq2YrZhiddLCAnJWQg2K/Zgtin2KbZgicsICclZCDYr9mC2YrZgtipJywgJyVkINiv2YLZitmC2KknXSxcbiAgICAgICAgaCA6IFsn2KPZgtmEINmF2YYg2LPYp9i52KknLCAn2LPYp9i52Kkg2YjYp9it2K/YqScsIFsn2LPYp9i52KrYp9mGJywgJ9iz2KfYudiq2YrZhiddLCAnJWQg2LPYp9i52KfYqicsICclZCDYs9in2LnYqScsICclZCDYs9in2LnYqSddLFxuICAgICAgICBkIDogWyfYo9mC2YQg2YXZhiDZitmI2YUnLCAn2YrZiNmFINmI2KfYrdivJywgWyfZitmI2YXYp9mGJywgJ9mK2YjZhdmK2YYnXSwgJyVkINij2YrYp9mFJywgJyVkINmK2YjZhdmL2KcnLCAnJWQg2YrZiNmFJ10sXG4gICAgICAgIE0gOiBbJ9ij2YLZhCDZhdmGINi02YfYsScsICfYtNmH2LEg2YjYp9it2K8nLCBbJ9i02YfYsdin2YYnLCAn2LTZh9ix2YrZhiddLCAnJWQg2KPYtNmH2LEnLCAnJWQg2LTZh9ix2KcnLCAnJWQg2LTZh9ixJ10sXG4gICAgICAgIHkgOiBbJ9ij2YLZhCDZhdmGINi52KfZhScsICfYudin2YUg2YjYp9it2K8nLCBbJ9i52KfZhdin2YYnLCAn2LnYp9mF2YrZhiddLCAnJWQg2KPYudmI2KfZhScsICclZCDYudin2YXZi9inJywgJyVkINi52KfZhSddXG4gICAgfSwgcGx1cmFsaXplID0gZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBmID0gcGx1cmFsRm9ybShudW1iZXIpLFxuICAgICAgICAgICAgICAgIHN0ciA9IHBsdXJhbHNbdV1bcGx1cmFsRm9ybShudW1iZXIpXTtcbiAgICAgICAgICAgIGlmIChmID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyW3dpdGhvdXRTdWZmaXggPyAwIDogMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgICAgIH07XG4gICAgfSwgbW9udGhzID0gW1xuICAgICAgICAn2YrZhtin2YrYsScsXG4gICAgICAgICfZgdio2LHYp9mK2LEnLFxuICAgICAgICAn2YXYp9ix2LMnLFxuICAgICAgICAn2KPYqNix2YrZhCcsXG4gICAgICAgICfZhdin2YrZiCcsXG4gICAgICAgICfZitmI2YbZitmIJyxcbiAgICAgICAgJ9mK2YjZhNmK2YgnLFxuICAgICAgICAn2KPYutiz2LfYsycsXG4gICAgICAgICfYs9io2KrZhdio2LEnLFxuICAgICAgICAn2KPZg9iq2YjYqNixJyxcbiAgICAgICAgJ9mG2YjZgdmF2KjYsScsXG4gICAgICAgICfYr9mK2LPZhdio2LEnXG4gICAgXTtcblxuICAgIHZhciBhckx5ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItbHknLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHMsXG4gICAgICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfYo9it2K9f2KXYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KPYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnRC9cXHUyMDBGTS9cXHUyMDBGWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ9mFJyA9PT0gaW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn2LUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9mFJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2YvYpyDYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn2KjYudivICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcbiAgICAgICAgICAgIHMgOiBwbHVyYWxpemUoJ3MnKSxcbiAgICAgICAgICAgIHNzIDogcGx1cmFsaXplKCdzJyksXG4gICAgICAgICAgICBtIDogcGx1cmFsaXplKCdtJyksXG4gICAgICAgICAgICBtbSA6IHBsdXJhbGl6ZSgnbScpLFxuICAgICAgICAgICAgaCA6IHBsdXJhbGl6ZSgnaCcpLFxuICAgICAgICAgICAgaGggOiBwbHVyYWxpemUoJ2gnKSxcbiAgICAgICAgICAgIGQgOiBwbHVyYWxpemUoJ2QnKSxcbiAgICAgICAgICAgIGRkIDogcGx1cmFsaXplKCdkJyksXG4gICAgICAgICAgICBNIDogcGx1cmFsaXplKCdNJyksXG4gICAgICAgICAgICBNTSA6IHBsdXJhbGl6ZSgnTScpLFxuICAgICAgICAgICAgeSA6IHBsdXJhbGl6ZSgneScpLFxuICAgICAgICAgICAgeXkgOiBwbHVyYWxpemUoJ3knKVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC/YjC9nLCAnLCcpO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLywvZywgJ9iMJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyTHk7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var arMa = moment.defineLocale('ar-ma', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return arMa;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1tYS5qcz83NTQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBhck1hID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItbWEnLCB7XG4gICAgICAgIG1vbnRocyA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfYp9mE2KPYrdivX9in2YTYpdiq2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn2KfYrdivX9in2KrZhtmK2YZf2KvZhNin2KvYp9ihX9in2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9mB2YogJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxuICAgICAgICAgICAgcyA6ICfYq9mI2KfZhicsXG4gICAgICAgICAgICBzcyA6ICclZCDYq9in2YbZitipJyxcbiAgICAgICAgICAgIG0gOiAn2K/ZgtmK2YLYqScsXG4gICAgICAgICAgICBtbSA6ICclZCDYr9mC2KfYptmCJyxcbiAgICAgICAgICAgIGggOiAn2LPYp9i52KknLFxuICAgICAgICAgICAgaGggOiAnJWQg2LPYp9i52KfYqicsXG4gICAgICAgICAgICBkIDogJ9mK2YjZhScsXG4gICAgICAgICAgICBkZCA6ICclZCDYo9mK2KfZhScsXG4gICAgICAgICAgICBNIDogJ9i02YfYsScsXG4gICAgICAgICAgICBNTSA6ICclZCDYo9i02YfYsScsXG4gICAgICAgICAgICB5IDogJ9iz2YbYqScsXG4gICAgICAgICAgICB5eSA6ICclZCDYs9mG2YjYp9iqJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhck1hO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1tYS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var arSa = moment.defineLocale('ar-sa', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            }).replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return arSa;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1zYS5qcz9lY2U5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzeW1ib2xNYXAgPSB7XG4gICAgICAgICcxJzogJ9mhJyxcbiAgICAgICAgJzInOiAn2aInLFxuICAgICAgICAnMyc6ICfZoycsXG4gICAgICAgICc0JzogJ9mkJyxcbiAgICAgICAgJzUnOiAn2aUnLFxuICAgICAgICAnNic6ICfZpicsXG4gICAgICAgICc3JzogJ9mnJyxcbiAgICAgICAgJzgnOiAn2agnLFxuICAgICAgICAnOSc6ICfZqScsXG4gICAgICAgICcwJzogJ9mgJ1xuICAgIH0sIG51bWJlck1hcCA9IHtcbiAgICAgICAgJ9mhJzogJzEnLFxuICAgICAgICAn2aInOiAnMicsXG4gICAgICAgICfZoyc6ICczJyxcbiAgICAgICAgJ9mkJzogJzQnLFxuICAgICAgICAn2aUnOiAnNScsXG4gICAgICAgICfZpic6ICc2JyxcbiAgICAgICAgJ9mnJzogJzcnLFxuICAgICAgICAn2agnOiAnOCcsXG4gICAgICAgICfZqSc6ICc5JyxcbiAgICAgICAgJ9mgJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBhclNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItc2EnLCB7XG4gICAgICAgIG1vbnRocyA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZitmIX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiF/Yo9i62LPYt9izX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2YrZiF/ZitmI2YbZitmIX9mK2YjZhNmK2Yhf2KPYutiz2LfYs1/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfYo9it2K9f2KXYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KPYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ9mFJyA9PT0gaW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn2LUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9mFJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9mB2YogJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxuICAgICAgICAgICAgcyA6ICfYq9mI2KfZhicsXG4gICAgICAgICAgICBzcyA6ICclZCDYq9in2YbZitipJyxcbiAgICAgICAgICAgIG0gOiAn2K/ZgtmK2YLYqScsXG4gICAgICAgICAgICBtbSA6ICclZCDYr9mC2KfYptmCJyxcbiAgICAgICAgICAgIGggOiAn2LPYp9i52KknLFxuICAgICAgICAgICAgaGggOiAnJWQg2LPYp9i52KfYqicsXG4gICAgICAgICAgICBkIDogJ9mK2YjZhScsXG4gICAgICAgICAgICBkZCA6ICclZCDYo9mK2KfZhScsXG4gICAgICAgICAgICBNIDogJ9i02YfYsScsXG4gICAgICAgICAgICBNTSA6ICclZCDYo9i02YfYsScsXG4gICAgICAgICAgICB5IDogJ9iz2YbYqScsXG4gICAgICAgICAgICB5eSA6ICclZCDYs9mG2YjYp9iqJ1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b2aHZotmj2aTZpdmm2afZqNmp2aBdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgv2IwvZywgJywnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC8sL2csICfYjCcpO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhclNhO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1zYS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var arTn = moment.defineLocale('ar-tn', {\n        months: '___________'.split('_'),\n        monthsShort: '___________'.split('_'),\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: ' %s',\n            past: ' %s',\n            s: '',\n            ss : '%d ',\n            m: '',\n            mm: '%d ',\n            h: '',\n            hh: '%d ',\n            d: '',\n            dd: '%d ',\n            M: '',\n            MM: '%d ',\n            y: '',\n            yy: '%d '\n        },\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4 // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return arTn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qcz8wNDQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBhclRuID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItdG4nLCB7XG4gICAgICAgIG1vbnRoczogJ9is2KfZhtmB2Ypf2YHZitmB2LHZil/Zhdin2LHYs1/Yo9mB2LHZitmEX9mF2KfZil/YrNmI2KfZhl/YrNmI2YrZhNmK2Klf2KPZiNiqX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfYrNin2YbZgdmKX9mB2YrZgdix2Ypf2YXYp9ix2LNf2KPZgdix2YrZhF/Zhdin2Ypf2KzZiNin2YZf2KzZiNmK2YTZitipX9ij2YjYql/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzOiAn2KfZhNij2K3Yr1/Yp9mE2KXYq9mG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUzogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiB7XG4gICAgICAgICAgICBmdXR1cmU6ICfZgdmKICVzJyxcbiAgICAgICAgICAgIHBhc3Q6ICfZhdmG2LAgJXMnLFxuICAgICAgICAgICAgczogJ9ir2YjYp9mGJyxcbiAgICAgICAgICAgIHNzIDogJyVkINir2KfZhtmK2KknLFxuICAgICAgICAgICAgbTogJ9iv2YLZitmC2KknLFxuICAgICAgICAgICAgbW06ICclZCDYr9mC2KfYptmCJyxcbiAgICAgICAgICAgIGg6ICfYs9in2LnYqScsXG4gICAgICAgICAgICBoaDogJyVkINiz2KfYudin2KonLFxuICAgICAgICAgICAgZDogJ9mK2YjZhScsXG4gICAgICAgICAgICBkZDogJyVkINij2YrYp9mFJyxcbiAgICAgICAgICAgIE06ICfYtNmH2LEnLFxuICAgICAgICAgICAgTU06ICclZCDYo9i02YfYsScsXG4gICAgICAgICAgICB5OiAn2LPZhtipJyxcbiAgICAgICAgICAgIHl5OiAnJWQg2LPZhtmI2KfYqidcbiAgICAgICAgfSxcbiAgICAgICAgd2Vlazoge1xuICAgICAgICAgICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveTogNCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhclRuO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var suffixes = {\n        1: '-inci',\n        5: '-inci',\n        8: '-inci',\n        70: '-inci',\n        80: '-inci',\n        2: '-nci',\n        7: '-nci',\n        20: '-nci',\n        50: '-nci',\n        3: '-nc',\n        4: '-nc',\n        100: '-nc',\n        6: '-nc',\n        9: '-uncu',\n        10: '-uncu',\n        30: '-uncu',\n        60: '-nc',\n        90: '-nc'\n    };\n\n    var az = moment.defineLocale('az', {\n        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),\n        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),\n        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),\n        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),\n        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[bugn saat] LT',\n            nextDay : '[sabah saat] LT',\n            nextWeek : '[gln hft] dddd [saat] LT',\n            lastDay : '[dnn] LT',\n            lastWeek : '[ken hft] dddd [saat] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s sonra',\n            past : '%s vvl',\n            s : 'birne saniyy',\n            ss : '%d saniy',\n            m : 'bir dqiq',\n            mm : '%d dqiq',\n            h : 'bir saat',\n            hh : '%d saat',\n            d : 'bir gn',\n            dd : '%d gn',\n            M : 'bir ay',\n            MM : '%d ay',\n            y : 'bir il',\n            yy : '%d il'\n        },\n        meridiemParse: /gec|shr|gndz|axam/,\n        isPM : function (input) {\n            return /^(gndz|axam)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return 'gec';\n            } else if (hour < 12) {\n                return 'shr';\n            } else if (hour < 17) {\n                return 'gndz';\n            } else {\n                return 'axam';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,\n        ordinal : function (number) {\n            if (number === 0) {  // special case for zero\n                return number + '-nc';\n            }\n            var a = number % 10,\n                b = number % 100 - a,\n                c = number >= 100 ? 100 : null;\n            return number + (suffixes[a] || suffixes[b] || suffixes[c]);\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return az;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qcz83ODdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3VmZml4ZXMgPSB7XG4gICAgICAgIDE6ICctaW5jaScsXG4gICAgICAgIDU6ICctaW5jaScsXG4gICAgICAgIDg6ICctaW5jaScsXG4gICAgICAgIDcwOiAnLWluY2knLFxuICAgICAgICA4MDogJy1pbmNpJyxcbiAgICAgICAgMjogJy1uY2knLFxuICAgICAgICA3OiAnLW5jaScsXG4gICAgICAgIDIwOiAnLW5jaScsXG4gICAgICAgIDUwOiAnLW5jaScsXG4gICAgICAgIDM6ICctw7xuY8O8JyxcbiAgICAgICAgNDogJy3DvG5jw7wnLFxuICAgICAgICAxMDA6ICctw7xuY8O8JyxcbiAgICAgICAgNjogJy1uY8SxJyxcbiAgICAgICAgOTogJy11bmN1JyxcbiAgICAgICAgMTA6ICctdW5jdScsXG4gICAgICAgIDMwOiAnLXVuY3UnLFxuICAgICAgICA2MDogJy3EsW5jxLEnLFxuICAgICAgICA5MDogJy3EsW5jxLEnXG4gICAgfTtcblxuICAgIHZhciBheiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2F6Jywge1xuICAgICAgICBtb250aHMgOiAneWFudmFyX2ZldnJhbF9tYXJ0X2FwcmVsX21heV9peXVuX2l5dWxfYXZxdXN0X3NlbnR5YWJyX29rdHlhYnJfbm95YWJyX2Rla2Ficicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAneWFuX2Zldl9tYXJfYXByX21heV9peW5faXlsX2F2cV9zZW5fb2t0X25veV9kZWsnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0JhemFyX0JhemFyIGVydMmZc2lfw4fJmXLFn8mZbmLJmSBheMWfYW3EsV/Dh8mZcsWfyZluYsmZX0PDvG3JmSBheMWfYW3EsV9Dw7xtyZlfxZ7JmW5iyZknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnQmF6X0J6RV/Dh0F4X8OHyZlyX0NBeF9Dw7xtX8WeyZluJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdCel9CRV/Dh0Ffw4fJmV9DQV9Dw7xfxZ7JmScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW2J1Z8O8biBzYWF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tzYWJhaCBzYWF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdbZ8mZbMmZbiBoyZlmdMmZXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tkw7xuyZluXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdba2XDp8mZbiBoyZlmdMmZXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMgc29ucmEnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDJmXZ2yZlsJyxcbiAgICAgICAgICAgIHMgOiAnYmlybmXDp8mZIHNhbml5ecmZJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNhbml5yZknLFxuICAgICAgICAgICAgbSA6ICdiaXIgZMmZcWlxyZknLFxuICAgICAgICAgICAgbW0gOiAnJWQgZMmZcWlxyZknLFxuICAgICAgICAgICAgaCA6ICdiaXIgc2FhdCcsXG4gICAgICAgICAgICBoaCA6ICclZCBzYWF0JyxcbiAgICAgICAgICAgIGQgOiAnYmlyIGfDvG4nLFxuICAgICAgICAgICAgZGQgOiAnJWQgZ8O8bicsXG4gICAgICAgICAgICBNIDogJ2JpciBheScsXG4gICAgICAgICAgICBNTSA6ICclZCBheScsXG4gICAgICAgICAgICB5IDogJ2JpciBpbCcsXG4gICAgICAgICAgICB5eSA6ICclZCBpbCdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL2dlY8mZfHPJmWjJmXJ8Z8O8bmTDvHp8YXjFn2FtLyxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eKGfDvG5kw7x6fGF4xZ9hbSkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2dlY8mZJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzyZloyZlyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdnw7xuZMO8eic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYXjFn2FtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjEsW5jxLF8aW5jaXxuY2l8w7xuY8O8fG5jxLF8dW5jdSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMCkgeyAgLy8gc3BlY2lhbCBjYXNlIGZvciB6ZXJvXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICctxLFuY8SxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgYiA9IG51bWJlciAlIDEwMCAtIGEsXG4gICAgICAgICAgICAgICAgYyA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSB8fCBzdWZmaXhlc1tjXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF6O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function plural(word, num) {\n        var forms = word.split('_');\n        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n    }\n    function relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n            'ss': withoutSuffix ? '__' : '__',\n            'mm': withoutSuffix ? '__' : '__',\n            'hh': withoutSuffix ? '__' : '__',\n            'dd': '__',\n            'MM': '__',\n            'yy': '__'\n        };\n        if (key === 'm') {\n            return withoutSuffix ? '' : '';\n        }\n        else if (key === 'h') {\n            return withoutSuffix ? '' : '';\n        }\n        else {\n            return number + ' ' + plural(format[key], +number);\n        }\n    }\n\n    var be = moment.defineLocale('be', {\n        months : {\n            format: '___________'.split('_'),\n            standalone: '___________'.split('_')\n        },\n        monthsShort : '___________'.split('_'),\n        weekdays : {\n            format: '______'.split('_'),\n            standalone: '______'.split('_'),\n            isFormat: /\\[ ?[] ?(?:|)? ?\\] ?dddd/\n        },\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            lastDay: '[ ] LT',\n            nextWeek: function () {\n                return '[] dddd [] LT';\n            },\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                    case 3:\n                    case 5:\n                    case 6:\n                        return '[ ] dddd [] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                        return '[ ] dddd [] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : relativeTimeWithPlural,\n            mm : relativeTimeWithPlural,\n            h : relativeTimeWithPlural,\n            hh : relativeTimeWithPlural,\n            d : '',\n            dd : relativeTimeWithPlural,\n            M : '',\n            MM : relativeTimeWithPlural,\n            y : '',\n            yy : relativeTimeWithPlural\n        },\n        meridiemParse: /|||/,\n        isPM : function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(||)/,\n        ordinal: function (number, period) {\n            switch (period) {\n                case 'M':\n                case 'd':\n                case 'DDD':\n                case 'w':\n                case 'W':\n                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';\n                case 'D':\n                    return number + '-';\n                default:\n                    return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return be;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iZS5qcz9kZTE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwbHVyYWwod29yZCwgbnVtKSB7XG4gICAgICAgIHZhciBmb3JtcyA9IHdvcmQuc3BsaXQoJ18nKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDEwID09PSAxICYmIG51bSAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IChudW0gJSAxMCA+PSAyICYmIG51bSAlIDEwIDw9IDQgJiYgKG51bSAlIDEwMCA8IDEwIHx8IG51bSAlIDEwMCA+PSAyMCkgPyBmb3Jtc1sxXSA6IGZvcm1zWzJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ3NzJzogd2l0aG91dFN1ZmZpeCA/ICfRgdC10LrRg9C90LTQsF/RgdC10LrRg9C90LTRi1/RgdC10LrRg9C90LQnIDogJ9GB0LXQutGD0L3QtNGDX9GB0LXQutGD0L3QtNGLX9GB0LXQutGD0L3QtCcsXG4gICAgICAgICAgICAnbW0nOiB3aXRob3V0U3VmZml4ID8gJ9GF0LLRltC70ZbQvdCwX9GF0LLRltC70ZbQvdGLX9GF0LLRltC70ZbQvScgOiAn0YXQstGW0LvRltC90YNf0YXQstGW0LvRltC90Ytf0YXQstGW0LvRltC9JyxcbiAgICAgICAgICAgICdoaCc6IHdpdGhvdXRTdWZmaXggPyAn0LPQsNC00LfRltC90LBf0LPQsNC00LfRltC90Ytf0LPQsNC00LfRltC9JyA6ICfQs9Cw0LTQt9GW0L3Rg1/Qs9Cw0LTQt9GW0L3Ri1/Qs9Cw0LTQt9GW0L0nLFxuICAgICAgICAgICAgJ2RkJzogJ9C00LfQtdC90Yxf0LTQvdGWX9C00LfRkdC9JyxcbiAgICAgICAgICAgICdNTSc6ICfQvNC10YHRj9GGX9C80LXRgdGP0YbRi1/QvNC10YHRj9GG0LDRnicsXG4gICAgICAgICAgICAneXknOiAn0LPQvtC0X9Cz0LDQtNGLX9Cz0LDQtNC+0Z4nXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXkgPT09ICdtJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0YXQstGW0LvRltC90LAnIDogJ9GF0LLRltC70ZbQvdGDJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdoJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0LPQsNC00LfRltC90LAnIDogJ9Cz0LDQtNC30ZbQvdGDJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBwbHVyYWwoZm9ybWF0W2tleV0sICtudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJlID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYmUnLCB7XG4gICAgICAgIG1vbnRocyA6IHtcbiAgICAgICAgICAgIGZvcm1hdDogJ9GB0YLRg9C00LfQtdC90Y9f0LvRjtGC0LDQs9CwX9GB0LDQutCw0LLRltC60LBf0LrRgNCw0YHQsNCy0ZbQutCwX9GC0YDQsNGe0L3Rj1/Rh9GN0YDQstC10L3Rj1/Qu9GW0L/QtdC90Y9f0LbQvdGW0Z7QvdGPX9Cy0LXRgNCw0YHQvdGPX9C60LDRgdGC0YDRi9GH0L3RltC60LBf0LvRltGB0YLQsNC/0LDQtNCwX9GB0L3QtdC20L3Rjycuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgIHN0YW5kYWxvbmU6ICfRgdGC0YPQtNC30LXQvdGMX9C70Y7RgtGLX9GB0LDQutCw0LLRltC6X9C60YDQsNGB0LDQstGW0Lpf0YLRgNCw0LLQtdC90Yxf0YfRjdGA0LLQtdC90Yxf0LvRltC/0LXQvdGMX9C20L3RltCy0LXQvdGMX9Cy0LXRgNCw0YHQtdC90Yxf0LrQsNGB0YLRgNGL0YfQvdGW0Lpf0LvRltGB0YLQsNC/0LDQtF/RgdC90LXQttCw0L3RjCcuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBtb250aHNTaG9ydCA6ICfRgdGC0YPQtF/Qu9GO0YJf0YHQsNC6X9C60YDQsNGBX9GC0YDQsNCyX9GH0Y3RgNCyX9C70ZbQv1/QttC90ZbQsl/QstC10YBf0LrQsNGB0YJf0LvRltGB0YJf0YHQvdC10LYnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDoge1xuICAgICAgICAgICAgZm9ybWF0OiAn0L3Rj9C00LfQtdC70Y5f0L/QsNC90Y/QtNC30LXQu9Cw0Lpf0LDRntGC0L7RgNCw0Lpf0YHQtdGA0LDQtNGDX9GH0LDRhtCy0LXRgF/Qv9GP0YLQvdGW0YbRg1/RgdGD0LHQvtGC0YMnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBzdGFuZGFsb25lOiAn0L3Rj9C00LfQtdC70Y9f0L/QsNC90Y/QtNC30LXQu9Cw0Lpf0LDRntGC0L7RgNCw0Lpf0YHQtdGA0LDQtNCwX9GH0LDRhtCy0LXRgF/Qv9GP0YLQvdGW0YbQsF/RgdGD0LHQvtGC0LAnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBpc0Zvcm1hdDogL1xcWyA/W9CS0LJdID8oPzrQvNGW0L3Rg9C70YPRjnzQvdCw0YHRgtGD0L/QvdGD0Y4pPyA/XFxdID9kZGRkL1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9C90LRf0L/QvV/QsNGCX9GB0YBf0YfRhl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9C90LRf0L/QvV/QsNGCX9GB0YBf0YfRhl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWSDQsy4nLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINCzLiwgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSDQsy4sIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb0KHRkdC90L3RjyDRnl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vQl9Cw0Z7RgtGA0LAg0Z5dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb0KPRh9C+0YDQsCDRnl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1vQo10gZGRkZCBb0Z5dIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQoyDQvNGW0L3Rg9C70YPRjl0gZGRkZCBb0Z5dIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CjINC80ZbQvdGD0LvRi10gZGRkZCBb0Z5dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn0L/RgNCw0LcgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDRgtCw0LzRgycsXG4gICAgICAgICAgICBzIDogJ9C90LXQutCw0LvRjNC60ZYg0YHQtdC60YPQvdC0JyxcbiAgICAgICAgICAgIG0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBkIDogJ9C00LfQtdC90YwnLFxuICAgICAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgTSA6ICfQvNC10YHRj9GGJyxcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIHkgOiAn0LPQvtC0JyxcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0Yt80YDQsNC90ZbRhtGLfNC00L3Rj3zQstC10YfQsNGA0LAvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9Cw0YDQsCkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9GLJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRgNCw0L3RltGG0YsnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9C00L3Rjyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0LLQtdGH0LDRgNCwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjRlnzRi3zQs9CwKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG51bWJlciAlIDEwID09PSAyIHx8IG51bWJlciAlIDEwID09PSAzKSAmJiAobnVtYmVyICUgMTAwICE9PSAxMiAmJiBudW1iZXIgJSAxMDAgIT09IDEzKSA/IG51bWJlciArICct0ZYnIDogbnVtYmVyICsgJy3Riyc7XG4gICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdCz0LAnO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJlO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var bg = moment.defineLocale('bg', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'D.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd, D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                    case 3:\n                    case 6:\n                        return '[ ] dddd [] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[ ] dddd [] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : ' ',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(|||||)/,\n        ordinal : function (number) {\n            var lastDigit = number % 10,\n                last2Digits = number % 100;\n            if (number === 0) {\n                return number + '-';\n            } else if (last2Digits === 0) {\n                return number + '-';\n            } else if (last2Digits > 10 && last2Digits < 20) {\n                return number + '-';\n            } else if (lastDigit === 1) {\n                return number + '-';\n            } else if (lastDigit === 2) {\n                return number + '-';\n            } else if (lastDigit === 7 || lastDigit === 8) {\n                return number + '-';\n            } else {\n                return number + '-';\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return bg;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iZy5qcz85NGUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgYmcgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdiZycsIHtcbiAgICAgICAgbW9udGhzIDogJ9GP0L3Rg9Cw0YDQuF/RhNC10LLRgNGD0LDRgNC4X9C80LDRgNGCX9Cw0L/RgNC40Ltf0LzQsNC5X9GO0L3QuF/RjtC70Lhf0LDQstCz0YPRgdGCX9GB0LXQv9GC0LXQvNCy0YDQuF/QvtC60YLQvtC80LLRgNC4X9C90L7QtdC80LLRgNC4X9C00LXQutC10LzQstGA0LgnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GP0L3RgF/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Llf0Y7QvdC4X9GO0LvQuF/QsNCy0LNf0YHQtdC/X9C+0LrRgl/QvdC+0LVf0LTQtdC6Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfQvdC10LTQtdC70Y9f0L/QvtC90LXQtNC10LvQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNGP0LTQsF/Rh9C10YLQstGK0YDRgtGK0Lpf0L/QtdGC0YrQul/RgdGK0LHQvtGC0LAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn0L3QtdC0X9C/0L7QvV/QstGC0L5f0YHRgNGPX9GH0LXRgl/Qv9C10YJf0YHRitCxJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW9CU0L3QtdGBINCyXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vQo9GC0YDQtSDQsl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0LJdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW9CS0YfQtdGA0LAg0LJdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0LjQt9C80LjQvdCw0LvQsNGC0LBdIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC40LfQvNC40L3QsNC70LjRj10gZGRkZCBb0LJdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9GB0LvQtdC0ICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAn0L/RgNC10LTQuCAlcycsXG4gICAgICAgICAgICBzIDogJ9C90Y/QutC+0LvQutC+INGB0LXQutGD0L3QtNC4JyxcbiAgICAgICAgICAgIHNzIDogJyVkINGB0LXQutGD0L3QtNC4JyxcbiAgICAgICAgICAgIG0gOiAn0LzQuNC90YPRgtCwJyxcbiAgICAgICAgICAgIG1tIDogJyVkINC80LjQvdGD0YLQuCcsXG4gICAgICAgICAgICBoIDogJ9GH0LDRgScsXG4gICAgICAgICAgICBoaCA6ICclZCDRh9Cw0YHQsCcsXG4gICAgICAgICAgICBkIDogJ9C00LXQvScsXG4gICAgICAgICAgICBkZCA6ICclZCDQtNC90LgnLFxuICAgICAgICAgICAgTSA6ICfQvNC10YHQtdGGJyxcbiAgICAgICAgICAgIE1NIDogJyVkINC80LXRgdC10YbQsCcsXG4gICAgICAgICAgICB5IDogJ9Cz0L7QtNC40L3QsCcsXG4gICAgICAgICAgICB5eSA6ICclZCDQs9C+0LTQuNC90LgnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0LXQsnzQtdC9fNGC0Lh80LLQuHzRgNC4fNC80LgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0RGlnaXQgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBsYXN0MkRpZ2l0cyA9IG51bWJlciAlIDEwMDtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QtdCyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdDJEaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QtdC9JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdDJEaWdpdHMgPiAxMCAmJiBsYXN0MkRpZ2l0cyA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdCy0LgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgNC4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSA3IHx8IGxhc3REaWdpdCA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC80LgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgtC4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYmc7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var bm = moment.defineLocale('bm', {\n        months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),\n        monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),\n        weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),\n        weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),\n        weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'MMMM [tile] D [san] YYYY',\n            LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',\n            LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'\n        },\n        calendar : {\n            sameDay : '[Bi lr] LT',\n            nextDay : '[Sini lr] LT',\n            nextWeek : 'dddd [don lr] LT',\n            lastDay : '[Kunu lr] LT',\n            lastWeek : 'dddd [tmnen lr] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s kn',\n            past : 'a b %s b',\n            s : 'sanga dama dama',\n            ss : 'sekondi %d',\n            m : 'miniti kelen',\n            mm : 'miniti %d',\n            h : 'lr kelen',\n            hh : 'lr %d',\n            d : 'tile kelen',\n            dd : 'tile %d',\n            M : 'kalo kelen',\n            MM : 'kalo %d',\n            y : 'san kelen',\n            yy : 'san %d'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return bm;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibS5qcz84Njc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgYm0gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdibScsIHtcbiAgICAgICAgbW9udGhzIDogJ1phbnd1eWVrYWxvX0Zld3VydXlla2Fsb19NYXJpc2lrYWxvX0F3aXJpbGlrYWxvX03Jm2thbG9fWnV3yZtua2Fsb19adWx1eWVrYWxvX1V0aWthbG9fU8mbdGFuYnVydWthbG9fyZRrdXTJlGJ1cnVrYWxvX05vd2FuYnVydWthbG9fRGVzYW5idXJ1a2Fsbycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnWmFuX0Zld19NYXJfQXdpX03Jm19adXdfWnVsX1V0aV9TyZt0X8mUa3VfTm93X0Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnS2FyaV9OdMmbbsmbbl9UYXJhdGFfQXJhYmFfQWxhbWlzYV9KdW1hX1NpYmlyaScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdLYXJfTnTJm19UYXJfQXJhX0FsYV9KdW1fU2liJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdLYV9OdF9UYV9Bcl9BbF9KdV9TaScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ01NTU0gW3RpbGVdIEQgW3Nhbl0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnTU1NTSBbdGlsZV0gRCBbc2FuXSBZWVlZIFtsyZtyyZtdIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBNTU1NIFt0aWxlXSBEIFtzYW5dIFlZWVkgW2zJm3LJm10gSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbQmkgbMmbcsmbXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tTaW5pIGzJm3LJm10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbZG9uIGzJm3LJm10gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbS3VudSBsyZtyyZtdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW3TJm23Jm25lbiBsyZtyyZtdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyBryZRuyZQnLFxuICAgICAgICAgICAgcGFzdCA6ICdhIGLJmyAlcyBiyZQnLFxuICAgICAgICAgICAgcyA6ICdzYW5nYSBkYW1hIGRhbWEnLFxuICAgICAgICAgICAgc3MgOiAnc2Vrb25kaSAlZCcsXG4gICAgICAgICAgICBtIDogJ21pbml0aSBrZWxlbicsXG4gICAgICAgICAgICBtbSA6ICdtaW5pdGkgJWQnLFxuICAgICAgICAgICAgaCA6ICdsyZtyyZsga2VsZW4nLFxuICAgICAgICAgICAgaGggOiAnbMmbcsmbICVkJyxcbiAgICAgICAgICAgIGQgOiAndGlsZSBrZWxlbicsXG4gICAgICAgICAgICBkZCA6ICd0aWxlICVkJyxcbiAgICAgICAgICAgIE0gOiAna2FsbyBrZWxlbicsXG4gICAgICAgICAgICBNTSA6ICdrYWxvICVkJyxcbiAgICAgICAgICAgIHkgOiAnc2FuIGtlbGVuJyxcbiAgICAgICAgICAgIHl5IDogJ3NhbiAlZCdcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm07XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var bn = moment.defineLocale('bn', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        meridiemParse: /||||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if ((meridiem === '' && hour >= 4) ||\n                    (meridiem === '' && hour < 5) ||\n                    meridiem === '') {\n                return hour + 12;\n            } else {\n                return hour;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return bn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibi5qcz82OGNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4KenJyxcbiAgICAgICAgJzInOiAn4KeoJyxcbiAgICAgICAgJzMnOiAn4KepJyxcbiAgICAgICAgJzQnOiAn4KeqJyxcbiAgICAgICAgJzUnOiAn4KerJyxcbiAgICAgICAgJzYnOiAn4KesJyxcbiAgICAgICAgJzcnOiAn4KetJyxcbiAgICAgICAgJzgnOiAn4KeuJyxcbiAgICAgICAgJzknOiAn4KevJyxcbiAgICAgICAgJzAnOiAn4KemJ1xuICAgIH0sXG4gICAgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4KenJzogJzEnLFxuICAgICAgICAn4KeoJzogJzInLFxuICAgICAgICAn4KepJzogJzMnLFxuICAgICAgICAn4KeqJzogJzQnLFxuICAgICAgICAn4KerJzogJzUnLFxuICAgICAgICAn4KesJzogJzYnLFxuICAgICAgICAn4KetJzogJzcnLFxuICAgICAgICAn4KeuJzogJzgnLFxuICAgICAgICAn4KevJzogJzknLFxuICAgICAgICAn4KemJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBibiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JuJywge1xuICAgICAgICBtb250aHMgOiAn4Kac4Ka+4Kao4KeB4Kef4Ka+4Kaw4KeAX+Cmq+Cnh+CmrOCnjeCmsOCngeCnn+CmvuCmsOCmv1/gpq7gpr7gprDgp43gpppf4KaP4Kaq4KeN4Kaw4Ka/4KayX+CmruCnh1/gppzgp4Hgpqhf4Kac4KeB4Kay4Ka+4KaHX+CmhuCml+CmuOCnjeCmn1/gprjgp4fgpqrgp43gpp/gp4fgpq7gp43gpqzgprBf4KaF4KaV4KeN4Kaf4KeL4Kas4KawX+CmqOCmreCnh+CmruCnjeCmrOCmsF/gpqHgpr/gprjgp4fgpq7gp43gpqzgprAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+CmnOCmvuCmqOCngV/gpqvgp4fgpqxf4Kau4Ka+4Kaw4KeN4KaaX+Cmj+CmquCnjeCmsF/gpq7gp4df4Kac4KeB4KaoX+CmnOCngeCmsl/gpobgppdf4Ka44KeH4Kaq4KeN4KafX+CmheCmleCnjeCmn+Cni1/gpqjgpq3gp4df4Kah4Ka/4Ka44KeHJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfgprDgpqzgpr/gpqzgpr7gprBf4Ka44KeL4Kau4Kas4Ka+4KawX+CmruCmmeCnjeCml+CmsuCmrOCmvuCmsF/gpqzgp4Hgpqfgpqzgpr7gprBf4Kas4KeD4Ka54Ka44KeN4Kaq4Kak4Ka/4Kas4Ka+4KawX+CmtuCngeCmleCnjeCmsOCmrOCmvuCmsF/gprbgpqjgpr/gpqzgpr7gprAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4Kaw4Kas4Ka/X+CmuOCni+Cmrl/gpq7gppngp43gppfgprJf4Kas4KeB4KanX+CmrOCng+CmueCmuOCnjeCmquCmpOCmv1/gprbgp4HgppXgp43gprBf4Ka24Kao4Ka/Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfgprDgpqzgpr9f4Ka44KeL4KauX+CmruCmmeCnjeCml1/gpqzgp4Hgpqdf4Kas4KeD4Ka54KaDX+CmtuCngeCmleCnjeCmsF/gprbgpqjgpr8nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnQSBoOm1tIOCmuOCmruCnnycsXG4gICAgICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIOCmuOCmruCnnycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0g4Ka44Kau4KefJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSDgprjgpq7gp58nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4KaG4KacXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgpobgppfgpr7gpq7gp4DgppXgpr7gprJdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+Cml+CmpOCmleCmvuCmsl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+Cml+CmpF0gZGRkZCwgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIOCmquCmsOCnhycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOCmhuCml+CnhycsXG4gICAgICAgICAgICBzIDogJ+CmleCnn+Cnh+CmlSDgprjgp4fgppXgp4fgpqjgp43gpqEnLFxuICAgICAgICAgICAgc3MgOiAnJWQg4Ka44KeH4KaV4KeH4Kao4KeN4KahJyxcbiAgICAgICAgICAgIG0gOiAn4KaP4KaVIOCmruCmv+CmqOCmv+CmnycsXG4gICAgICAgICAgICBtbSA6ICclZCDgpq7gpr/gpqjgpr/gpp8nLFxuICAgICAgICAgICAgaCA6ICfgpo/gppUg4KaY4Kao4KeN4Kaf4Ka+JyxcbiAgICAgICAgICAgIGhoIDogJyVkIOCmmOCmqOCnjeCmn+CmvicsXG4gICAgICAgICAgICBkIDogJ+Cmj+CmlSDgpqbgpr/gpqgnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4Kam4Ka/4KaoJyxcbiAgICAgICAgICAgIE0gOiAn4KaP4KaVIOCmruCmvuCmuCcsXG4gICAgICAgICAgICBNTSA6ICclZCDgpq7gpr7gprgnLFxuICAgICAgICAgICAgeSA6ICfgpo/gppUg4Kas4Kab4KawJyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCmrOCmm+CmsCdcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Cnp+CnqOCnqeCnquCnq+CnrOCnreCnruCnr+Cnpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+CmsOCmvuCmpHzgprjgppXgpr7gprJ84Kam4KeB4Kaq4KeB4KawfOCmrOCmv+CmleCmvuCmsnzgprDgpr7gpqQvLFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtZXJpZGllbSA9PT0gJ+CmsOCmvuCmpCcgJiYgaG91ciA+PSA0KSB8fFxuICAgICAgICAgICAgICAgICAgICAobWVyaWRpZW0gPT09ICfgpqbgp4Hgpqrgp4HgprAnICYmIGhvdXIgPCA1KSB8fFxuICAgICAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+CmrOCmv+CmleCmvuCmsicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CmsOCmvuCmpCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Ka44KaV4Ka+4KayJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpqbgp4Hgpqrgp4HgprAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CmrOCmv+CmleCmvuCmsic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Kaw4Ka+4KakJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm47XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var bo = moment.defineLocale('bo', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm',\n            LTS : 'A h:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[], LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        meridiemParse: /||||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if ((meridiem === '' && hour >= 4) ||\n                    (meridiem === '' && hour < 5) ||\n                    meridiem === '') {\n                return hour + 12;\n            } else {\n                return hour;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return bo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iby5qcz9jMzYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4LyhJyxcbiAgICAgICAgJzInOiAn4LyiJyxcbiAgICAgICAgJzMnOiAn4LyjJyxcbiAgICAgICAgJzQnOiAn4LykJyxcbiAgICAgICAgJzUnOiAn4LylJyxcbiAgICAgICAgJzYnOiAn4LymJyxcbiAgICAgICAgJzcnOiAn4LynJyxcbiAgICAgICAgJzgnOiAn4LyoJyxcbiAgICAgICAgJzknOiAn4LypJyxcbiAgICAgICAgJzAnOiAn4LygJ1xuICAgIH0sXG4gICAgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4LyhJzogJzEnLFxuICAgICAgICAn4LyiJzogJzInLFxuICAgICAgICAn4LyjJzogJzMnLFxuICAgICAgICAn4LykJzogJzQnLFxuICAgICAgICAn4LylJzogJzUnLFxuICAgICAgICAn4LymJzogJzYnLFxuICAgICAgICAn4LynJzogJzcnLFxuICAgICAgICAn4LyoJzogJzgnLFxuICAgICAgICAn4LypJzogJzknLFxuICAgICAgICAn4LygJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBibyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JvJywge1xuICAgICAgICBtb250aHMgOiAn4L2f4L6z4LyL4L2W4LyL4L2R4L2E4LyL4L2U4L28X+C9n+C+s+C8i+C9luC8i+C9guC9ieC9suC9puC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvYLgvabgvbTgvZjgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2e4L2y4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9o+C+lOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZHgvrLgvbTgvYLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2R4L204L2T4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9ouC+kuC+seC9keC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZHgvYLgvbTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9guC9heC9suC9guC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvYLgvYngvbLgvabgvIvgvZQnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+C9n+C+s+C8i+C9luC8i+C9keC9hOC8i+C9lOC9vF/gvZ/gvrPgvIvgvZbgvIvgvYLgvYngvbLgvabgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2C4L2m4L204L2Y4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9nuC9suC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvaPgvpTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2R4L6y4L204L2C4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9keC9tOC9k+C8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvaLgvpLgvrHgvZHgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2R4L2C4L204LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvYLgvYXgvbLgvYLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2C4L2J4L2y4L2m4LyL4L2UJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfgvYLgvZ/gvaDgvIvgvYngvbLgvIvgvZjgvItf4L2C4L2f4L2g4LyL4L2f4L6z4LyL4L2W4LyLX+C9guC9n+C9oOC8i+C9mOC9suC9guC8i+C9keC9mOC9ouC8i1/gvYLgvZ/gvaDgvIvgvaPgvrfgvYLgvIvgvZTgvItf4L2C4L2f4L2g4LyL4L2V4L204L2i4LyL4L2W4L20X+C9guC9n+C9oOC8i+C9lOC8i+C9puC9hOC9puC8i1/gvYLgvZ/gvaDgvIvgvabgvqTgvbrgvZPgvIvgvZTgvIsnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4L2J4L2y4LyL4L2Y4LyLX+C9n+C+s+C8i+C9luC8i1/gvZjgvbLgvYLgvIvgvZHgvZjgvaLgvItf4L2j4L634L2C4LyL4L2U4LyLX+C9leC9tOC9ouC8i+C9luC9tF/gvZTgvIvgvabgvYTgvabgvItf4L2m4L6k4L264L2T4LyL4L2U4LyLJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfgvYngvbLgvIvgvZjgvItf4L2f4L6z4LyL4L2W4LyLX+C9mOC9suC9guC8i+C9keC9mOC9ouC8i1/gvaPgvrfgvYLgvIvgvZTgvItf4L2V4L204L2i4LyL4L2W4L20X+C9lOC8i+C9puC9hOC9puC8i1/gvabgvqTgvbrgvZPgvIvgvZTgvIsnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnQSBoOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgvZHgvbLgvIvgvaLgvbLgvYRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+C9puC9hOC8i+C9ieC9suC9k10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnW+C9luC9keC9tOC9k+C8i+C9leC+suC9guC8i+C9ouC+l+C9uuC9puC8i+C9mF0sIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+C9geC8i+C9puC9hF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+C9luC9keC9tOC9k+C8i+C9leC+suC9guC8i+C9mOC9kOC9oOC8i+C9mF0gZGRkZCwgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIOC9o+C8iycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOC9puC+lOC9k+C8i+C9oycsXG4gICAgICAgICAgICBzIDogJ+C9o+C9mOC8i+C9puC9hCcsXG4gICAgICAgICAgICBzcyA6ICclZCDgvabgvpDgvaLgvIvgvYbgvI0nLFxuICAgICAgICAgICAgbSA6ICfgvabgvpDgvaLgvIvgvZjgvIvgvYLgvYXgvbLgvYInLFxuICAgICAgICAgICAgbW0gOiAnJWQg4L2m4L6Q4L2i4LyL4L2YJyxcbiAgICAgICAgICAgIGggOiAn4L2G4L204LyL4L2a4L284L2R4LyL4L2C4L2F4L2y4L2CJyxcbiAgICAgICAgICAgIGhoIDogJyVkIOC9huC9tOC8i+C9muC9vOC9kScsXG4gICAgICAgICAgICBkIDogJ+C9ieC9suC9k+C8i+C9guC9heC9suC9gicsXG4gICAgICAgICAgICBkZCA6ICclZCDgvYngvbLgvZPgvIsnLFxuICAgICAgICAgICAgTSA6ICfgvZ/gvrPgvIvgvZbgvIvgvYLgvYXgvbLgvYInLFxuICAgICAgICAgICAgTU0gOiAnJWQg4L2f4L6z4LyL4L2WJyxcbiAgICAgICAgICAgIHkgOiAn4L2j4L284LyL4L2C4L2F4L2y4L2CJyxcbiAgICAgICAgICAgIHl5IDogJyVkIOC9o+C9vCdcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+C8oeC8ouC8o+C8pOC8peC8puC8p+C8qOC8qeC8oF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+C9mOC9muC9k+C8i+C9mOC9vHzgvZ7gvbzgvYLgvabgvIvgvYDgvaZ84L2J4L2y4L2T4LyL4L2C4L204L2EfOC9keC9guC9vOC9hOC8i+C9keC9gnzgvZjgvZrgvZPgvIvgvZjgvbwvLFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtZXJpZGllbSA9PT0gJ+C9mOC9muC9k+C8i+C9mOC9vCcgJiYgaG91ciA+PSA0KSB8fFxuICAgICAgICAgICAgICAgICAgICAobWVyaWRpZW0gPT09ICfgvYngvbLgvZPgvIvgvYLgvbTgvYQnICYmIGhvdXIgPCA1KSB8fFxuICAgICAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+C9keC9guC9vOC9hOC8i+C9keC9gicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C9mOC9muC9k+C8i+C9mOC9vCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4L2e4L284L2C4L2m4LyL4L2A4L2mJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgvYngvbLgvZPgvIvgvYLgvbTgvYQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C9keC9guC9vOC9hOC8i+C9keC9gic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4L2Y4L2a4L2T4LyL4L2Y4L28JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm87XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function relativeTimeWithMutation(number, withoutSuffix, key) {\n        var format = {\n            'mm': 'munutenn',\n            'MM': 'miz',\n            'dd': 'devezh'\n        };\n        return number + ' ' + mutation(format[key], number);\n    }\n    function specialMutationForYears(number) {\n        switch (lastNumber(number)) {\n            case 1:\n            case 3:\n            case 4:\n            case 5:\n            case 9:\n                return number + ' bloaz';\n            default:\n                return number + ' vloaz';\n        }\n    }\n    function lastNumber(number) {\n        if (number > 9) {\n            return lastNumber(number % 10);\n        }\n        return number;\n    }\n    function mutation(text, number) {\n        if (number === 2) {\n            return softMutation(text);\n        }\n        return text;\n    }\n    function softMutation(text) {\n        var mutationTable = {\n            'm': 'v',\n            'b': 'v',\n            'd': 'z'\n        };\n        if (mutationTable[text.charAt(0)] === undefined) {\n            return text;\n        }\n        return mutationTable[text.charAt(0)] + text.substring(1);\n    }\n\n    var br = moment.defineLocale('br', {\n        months : 'Genver_C\\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),\n        monthsShort : 'Gen_C\\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),\n        weekdays : 'Sul_Lun_Meurzh_Merc\\'her_Yaou_Gwener_Sadorn'.split('_'),\n        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),\n        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'h[e]mm A',\n            LTS : 'h[e]mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D [a viz] MMMM YYYY',\n            LLL : 'D [a viz] MMMM YYYY h[e]mm A',\n            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'\n        },\n        calendar : {\n            sameDay : '[Hiziv da] LT',\n            nextDay : '[Warc\\'hoazh da] LT',\n            nextWeek : 'dddd [da] LT',\n            lastDay : '[Dec\\'h da] LT',\n            lastWeek : 'dddd [paset da] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'a-benn %s',\n            past : '%s \\'zo',\n            s : 'un nebeud segondenno',\n            ss : '%d eilenn',\n            m : 'ur vunutenn',\n            mm : relativeTimeWithMutation,\n            h : 'un eur',\n            hh : '%d eur',\n            d : 'un devezh',\n            dd : relativeTimeWithMutation,\n            M : 'ur miz',\n            MM : relativeTimeWithMutation,\n            y : 'ur bloaz',\n            yy : specialMutationForYears\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(a|vet)/,\n        ordinal : function (number) {\n            var output = (number === 1) ? 'a' : 'vet';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return br;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ici5qcz8zOTJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoTXV0YXRpb24obnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHtcbiAgICAgICAgICAgICdtbSc6ICdtdW51dGVubicsXG4gICAgICAgICAgICAnTU0nOiAnbWl6JyxcbiAgICAgICAgICAgICdkZCc6ICdkZXZlemgnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBtdXRhdGlvbihmb3JtYXRba2V5XSwgbnVtYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BlY2lhbE11dGF0aW9uRm9yWWVhcnMobnVtYmVyKSB7XG4gICAgICAgIHN3aXRjaCAobGFzdE51bWJlcihudW1iZXIpKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgYmxvYXonO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyB2bG9heic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGFzdE51bWJlcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0TnVtYmVyKG51bWJlciAlIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdXRhdGlvbih0ZXh0LCBudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHNvZnRNdXRhdGlvbih0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc29mdE11dGF0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIG11dGF0aW9uVGFibGUgPSB7XG4gICAgICAgICAgICAnbSc6ICd2JyxcbiAgICAgICAgICAgICdiJzogJ3YnLFxuICAgICAgICAgICAgJ2QnOiAneidcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG11dGF0aW9uVGFibGVbdGV4dC5jaGFyQXQoMCldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdXRhdGlvblRhYmxlW3RleHQuY2hhckF0KDApXSArIHRleHQuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIHZhciBiciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JyJywge1xuICAgICAgICBtb250aHMgOiAnR2VudmVyX0NcXCdod2V2cmVyX01ldXJ6aF9FYnJlbF9NYWVfTWV6aGV2ZW5fR291ZXJlX0Vvc3RfR3dlbmdvbG9fSGVyZV9EdV9LZXJ6dScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnR2VuX0NcXCdod2VfTWV1X0Vicl9NYWVfRXZlX0dvdV9Fb3NfR3dlX0hlcl9EdV9LZXInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bF9MdW5fTWV1cnpoX01lcmNcXCdoZXJfWWFvdV9Hd2VuZXJfU2Fkb3JuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bF9MdW5fTWV1X01lcl9ZYW9fR3dlX1NhZCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTHVfTWVfTWVyX1lhX0d3X1NhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ2hbZV1tbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoW2VdbW06c3MgQScsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBbYSB2aXpdIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBbYSB2aXpdIE1NTU0gWVlZWSBoW2VdbW0gQScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2Egdml6XSBNTU1NIFlZWVkgaFtlXW1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbSGl6aXYgZGFdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1dhcmNcXCdob2F6aCBkYV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbZGFdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0RlY1xcJ2ggZGFdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW3Bhc2V0IGRhXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnYS1iZW5uICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgXFwnem8nLFxuICAgICAgICAgICAgcyA6ICd1biBuZWJldWQgc2Vnb25kZW5ub8O5JyxcbiAgICAgICAgICAgIHNzIDogJyVkIGVpbGVubicsXG4gICAgICAgICAgICBtIDogJ3VyIHZ1bnV0ZW5uJyxcbiAgICAgICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aE11dGF0aW9uLFxuICAgICAgICAgICAgaCA6ICd1biBldXInLFxuICAgICAgICAgICAgaGggOiAnJWQgZXVyJyxcbiAgICAgICAgICAgIGQgOiAndW4gZGV2ZXpoJyxcbiAgICAgICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aE11dGF0aW9uLFxuICAgICAgICAgICAgTSA6ICd1ciBtaXonLFxuICAgICAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoTXV0YXRpb24sXG4gICAgICAgICAgICB5IDogJ3VyIGJsb2F6JyxcbiAgICAgICAgICAgIHl5IDogc3BlY2lhbE11dGF0aW9uRm9yWWVhcnNcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGHDsXx2ZXQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAobnVtYmVyID09PSAxKSA/ICdhw7EnIDogJ3ZldCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBicjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnIuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function translate(number, withoutSuffix, key) {\n        var result = number + ' ';\n        switch (key) {\n            case 'ss':\n                if (number === 1) {\n                    result += 'sekunda';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'sekunde';\n                } else {\n                    result += 'sekundi';\n                }\n                return result;\n            case 'm':\n                return withoutSuffix ? 'jedna minuta' : 'jedne minute';\n            case 'mm':\n                if (number === 1) {\n                    result += 'minuta';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'minute';\n                } else {\n                    result += 'minuta';\n                }\n                return result;\n            case 'h':\n                return withoutSuffix ? 'jedan sat' : 'jednog sata';\n            case 'hh':\n                if (number === 1) {\n                    result += 'sat';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'sata';\n                } else {\n                    result += 'sati';\n                }\n                return result;\n            case 'dd':\n                if (number === 1) {\n                    result += 'dan';\n                } else {\n                    result += 'dana';\n                }\n                return result;\n            case 'MM':\n                if (number === 1) {\n                    result += 'mjesec';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'mjeseca';\n                } else {\n                    result += 'mjeseci';\n                }\n                return result;\n            case 'yy':\n                if (number === 1) {\n                    result += 'godina';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'godine';\n                } else {\n                    result += 'godina';\n                }\n                return result;\n        }\n    }\n\n    var bs = moment.defineLocale('bs', {\n        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),\n        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n        monthsParseExact: true,\n        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[danas u] LT',\n            nextDay  : '[sutra u] LT',\n            nextWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[u] [nedjelju] [u] LT';\n                    case 3:\n                        return '[u] [srijedu] [u] LT';\n                    case 6:\n                        return '[u] [subotu] [u] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[juer u] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                    case 3:\n                        return '[prolu] dddd [u] LT';\n                    case 6:\n                        return '[prole] [subote] [u] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[proli] dddd [u] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'prije %s',\n            s      : 'par sekundi',\n            ss     : translate,\n            m      : translate,\n            mm     : translate,\n            h      : translate,\n            hh     : translate,\n            d      : 'dan',\n            dd     : translate,\n            M      : 'mjesec',\n            MM     : translate,\n            y      : 'godinu',\n            yy     : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return bs;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9icy5qcz82YWFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnc3MnOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzZWt1bmRhJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2VrdW5kZSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzZWt1bmRpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2plZG5hIG1pbnV0YScgOiAnamVkbmUgbWludXRlJztcbiAgICAgICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRhJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRlJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0YSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdqZWRhbiBzYXQnIDogJ2plZG5vZyBzYXRhJztcbiAgICAgICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0YSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXRpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZGFuJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2RhbmEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWMnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWNhJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2knO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmEnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5hJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBicyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JzJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFydF9hcHJpbF9tYWpfanVuaV9qdWxpX2F1Z3VzdF9zZXB0ZW1iYXJfb2t0b2Jhcl9ub3ZlbWJhcl9kZWNlbWJhcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuLl9mZWIuX21hci5fYXByLl9tYWouX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ25lZGplbGphX3BvbmVkamVsamFrX3V0b3Jha19zcmlqZWRhX8SNZXR2cnRha19wZXRha19zdWJvdGEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVkLl9wb24uX3V0by5fc3JpLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ25lX3BvX3V0X3NyX8SNZV9wZV9zdScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSAgOiAnW2RhbmFzIHVdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgIDogJ1tzdXRyYSB1XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGplbGp1XSBbdV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3JpamVkdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3N1Ym90dV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWVyIHVdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Byb8WhbHVdIGRkZGQgW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsaV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxuICAgICAgICAgICAgcGFzdCAgIDogJ3ByaWplICVzJyxcbiAgICAgICAgICAgIHMgICAgICA6ICdwYXIgc2VrdW5kaScsXG4gICAgICAgICAgICBzcyAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtICAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoICAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkICAgICAgOiAnZGFuJyxcbiAgICAgICAgICAgIGRkICAgICA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gICAgICA6ICdtamVzZWMnLFxuICAgICAgICAgICAgTU0gICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeSAgICAgIDogJ2dvZGludScsXG4gICAgICAgICAgICB5eSAgICAgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBicztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ca = moment.defineLocale('ca', {\n        months : {\n            standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),\n            format: 'de gener_de febrer_de mar_d\\'abril_de maig_de juny_de juliol_d\\'agost_de setembre_d\\'octubre_de novembre_de desembre'.split('_'),\n            isFormat: /D[oD]?(\\s)+MMMM/\n        },\n        monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),\n        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),\n        weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM [de] YYYY',\n            ll : 'D MMM YYYY',\n            LLL : 'D MMMM [de] YYYY [a les] H:mm',\n            lll : 'D MMM YYYY, H:mm',\n            LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',\n            llll : 'ddd D MMM YYYY, H:mm'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            nextDay : function () {\n                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            lastDay : function () {\n                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            lastWeek : function () {\n                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'd\\'aqu %s',\n            past : 'fa %s',\n            s : 'uns segons',\n            ss : '%d segons',\n            m : 'un minut',\n            mm : '%d minuts',\n            h : 'una hora',\n            hh : '%d hores',\n            d : 'un dia',\n            dd : '%d dies',\n            M : 'un mes',\n            MM : '%d mesos',\n            y : 'un any',\n            yy : '%d anys'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(r|n|t||a)/,\n        ordinal : function (number, period) {\n            var output = (number === 1) ? 'r' :\n                (number === 2) ? 'n' :\n                (number === 3) ? 'r' :\n                (number === 4) ? 't' : '';\n            if (period === 'w' || period === 'W') {\n                output = 'a';\n            }\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return ca;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jYS5qcz9jMDg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgY2EgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdjYScsIHtcbiAgICAgICAgbW9udGhzIDoge1xuICAgICAgICAgICAgc3RhbmRhbG9uZTogJ2dlbmVyX2ZlYnJlcl9tYXLDp19hYnJpbF9tYWlnX2p1bnlfanVsaW9sX2Fnb3N0X3NldGVtYnJlX29jdHVicmVfbm92ZW1icmVfZGVzZW1icmUnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBmb3JtYXQ6ICdkZSBnZW5lcl9kZSBmZWJyZXJfZGUgbWFyw6dfZFxcJ2FicmlsX2RlIG1haWdfZGUganVueV9kZSBqdWxpb2xfZFxcJ2Fnb3N0X2RlIHNldGVtYnJlX2RcXCdvY3R1YnJlX2RlIG5vdmVtYnJlX2RlIGRlc2VtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgaXNGb3JtYXQ6IC9EW29EXT8oXFxzKStNTU1NL1xuICAgICAgICB9LFxuICAgICAgICBtb250aHNTaG9ydCA6ICdnZW4uX2ZlYnIuX21hcsOnX2Fici5fbWFpZ19qdW55X2p1bC5fYWcuX3NldC5fb2N0Ll9ub3YuX2Rlcy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdkaXVtZW5nZV9kaWxsdW5zX2RpbWFydHNfZGltZWNyZXNfZGlqb3VzX2RpdmVuZHJlc19kaXNzYWJ0ZScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdkZy5fZGwuX2R0Ll9kYy5fZGouX2R2Ll9kcy4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ2RnX2RsX2R0X2RjX2RqX2R2X2RzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBbZGVdIFlZWVknLFxuICAgICAgICAgICAgbGwgOiAnRCBNTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFtkZV0gWVlZWSBbYSBsZXNdIEg6bW0nLFxuICAgICAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVksIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBbZGVdIFlZWVkgW2EgbGVzXSBIOm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnZGRkIEQgTU1NIFlZWVksIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1thdnVpIGEgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tkZW3DoCBhICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnbGVzJyA6ICdsYScpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGRkZCBbYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW2FoaXIgYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzc2F0IGEgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2RcXCdhcXXDrSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2ZhICVzJyxcbiAgICAgICAgICAgIHMgOiAndW5zIHNlZ29ucycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWdvbnMnLFxuICAgICAgICAgICAgbSA6ICd1biBtaW51dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHMnLFxuICAgICAgICAgICAgaCA6ICd1bmEgaG9yYScsXG4gICAgICAgICAgICBoaCA6ICclZCBob3JlcycsXG4gICAgICAgICAgICBkIDogJ3VuIGRpYScsXG4gICAgICAgICAgICBkZCA6ICclZCBkaWVzJyxcbiAgICAgICAgICAgIE0gOiAndW4gbWVzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1lc29zJyxcbiAgICAgICAgICAgIHkgOiAndW4gYW55JyxcbiAgICAgICAgICAgIHl5IDogJyVkIGFueXMnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShyfG58dHzDqHxhKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAobnVtYmVyID09PSAxKSA/ICdyJyA6XG4gICAgICAgICAgICAgICAgKG51bWJlciA9PT0gMikgPyAnbicgOlxuICAgICAgICAgICAgICAgIChudW1iZXIgPT09IDMpID8gJ3InIDpcbiAgICAgICAgICAgICAgICAobnVtYmVyID09PSA0KSA/ICd0JyA6ICfDqCc7XG4gICAgICAgICAgICBpZiAocGVyaW9kID09PSAndycgfHwgcGVyaW9kID09PSAnVycpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAnYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY2EuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),\n        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');\n    function plural(n) {\n        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);\n    }\n    function translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n            case 's':  // a few seconds / in a few seconds / a few seconds ago\n                return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';\n            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'sekundy' : 'sekund');\n                } else {\n                    return result + 'sekundami';\n                }\n                break;\n            case 'm':  // a minute / in a minute / a minute ago\n                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');\n            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'minuty' : 'minut');\n                } else {\n                    return result + 'minutami';\n                }\n                break;\n            case 'h':  // an hour / in an hour / an hour ago\n                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');\n            case 'hh': // 9 hours / in 9 hours / 9 hours ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'hodiny' : 'hodin');\n                } else {\n                    return result + 'hodinami';\n                }\n                break;\n            case 'd':  // a day / in a day / a day ago\n                return (withoutSuffix || isFuture) ? 'den' : 'dnem';\n            case 'dd': // 9 days / in 9 days / 9 days ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'dny' : 'dn');\n                } else {\n                    return result + 'dny';\n                }\n                break;\n            case 'M':  // a month / in a month / a month ago\n                return (withoutSuffix || isFuture) ? 'msc' : 'mscem';\n            case 'MM': // 9 months / in 9 months / 9 months ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'msce' : 'msc');\n                } else {\n                    return result + 'msci';\n                }\n                break;\n            case 'y':  // a year / in a year / a year ago\n                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';\n            case 'yy': // 9 years / in 9 years / 9 years ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'roky' : 'let');\n                } else {\n                    return result + 'lety';\n                }\n                break;\n        }\n    }\n\n    var cs = moment.defineLocale('cs', {\n        months : months,\n        monthsShort : monthsShort,\n        monthsParse : (function (months, monthsShort) {\n            var i, _monthsParse = [];\n            for (i = 0; i < 12; i++) {\n                // use custom parser to solve problem with July (ervenec)\n                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');\n            }\n            return _monthsParse;\n        }(months, monthsShort)),\n        shortMonthsParse : (function (monthsShort) {\n            var i, _shortMonthsParse = [];\n            for (i = 0; i < 12; i++) {\n                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');\n            }\n            return _shortMonthsParse;\n        }(monthsShort)),\n        longMonthsParse : (function (months) {\n            var i, _longMonthsParse = [];\n            for (i = 0; i < 12; i++) {\n                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');\n            }\n            return _longMonthsParse;\n        }(months)),\n        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),\n        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),\n        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),\n        longDateFormat : {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd D. MMMM YYYY H:mm',\n            l : 'D. M. YYYY'\n        },\n        calendar : {\n            sameDay: '[dnes v] LT',\n            nextDay: '[ztra v] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[v nedli v] LT';\n                    case 1:\n                    case 2:\n                        return '[v] dddd [v] LT';\n                    case 3:\n                        return '[ve stedu v] LT';\n                    case 4:\n                        return '[ve tvrtek v] LT';\n                    case 5:\n                        return '[v ptek v] LT';\n                    case 6:\n                        return '[v sobotu v] LT';\n                }\n            },\n            lastDay: '[vera v] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[minulou nedli v] LT';\n                    case 1:\n                    case 2:\n                        return '[minul] dddd [v] LT';\n                    case 3:\n                        return '[minulou stedu v] LT';\n                    case 4:\n                    case 5:\n                        return '[minul] dddd [v] LT';\n                    case 6:\n                        return '[minulou sobotu v] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past : 'ped %s',\n            s : translate,\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : translate,\n            hh : translate,\n            d : translate,\n            dd : translate,\n            M : translate,\n            MM : translate,\n            y : translate,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return cs;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qcz9iMmNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzID0gJ2xlZGVuX8O6bm9yX2LFmWV6ZW5fZHViZW5fa3bEm3Rlbl/EjWVydmVuX8SNZXJ2ZW5lY19zcnBlbl96w6HFmcOtX8WZw61qZW5fbGlzdG9wYWRfcHJvc2luZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0ID0gJ2xlZF/Dum5vX2LFmWVfZHViX2t2xJtfxI12bl/EjXZjX3NycF96w6HFmV/FmcOtal9saXNfcHJvJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIHBsdXJhbChuKSB7XG4gICAgICAgIHJldHVybiAobiA+IDEpICYmIChuIDwgNSkgJiYgKH5+KG4gLyAxMCkgIT09IDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdzJzogIC8vIGEgZmV3IHNlY29uZHMgLyBpbiBhIGZldyBzZWNvbmRzIC8gYSBmZXcgc2Vjb25kcyBhZ29cbiAgICAgICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3DDoXIgc2VrdW5kJyA6ICdww6FyIHNla3VuZGFtaSc7XG4gICAgICAgICAgICBjYXNlICdzcyc6IC8vIDkgc2Vjb25kcyAvIGluIDkgc2Vjb25kcyAvIDkgc2Vjb25kcyBhZ29cbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ3Nla3VuZHknIDogJ3Nla3VuZCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnc2VrdW5kYW1pJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtJzogIC8vIGEgbWludXRlIC8gaW4gYSBtaW51dGUgLyBhIG1pbnV0ZSBhZ29cbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtaW51dGEnIDogKGlzRnV0dXJlID8gJ21pbnV0dScgOiAnbWludXRvdScpO1xuICAgICAgICAgICAgY2FzZSAnbW0nOiAvLyA5IG1pbnV0ZXMgLyBpbiA5IG1pbnV0ZXMgLyA5IG1pbnV0ZXMgYWdvXG4gICAgICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtaW51dHknIDogJ21pbnV0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtaW51dGFtaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6ICAvLyBhbiBob3VyIC8gaW4gYW4gaG91ciAvIGFuIGhvdXIgYWdvXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnaG9kaW5hJyA6IChpc0Z1dHVyZSA/ICdob2RpbnUnIDogJ2hvZGlub3UnKTtcbiAgICAgICAgICAgIGNhc2UgJ2hoJzogLy8gOSBob3VycyAvIGluIDkgaG91cnMgLyA5IGhvdXJzIGFnb1xuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnaG9kaW55JyA6ICdob2RpbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnaG9kaW5hbWknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2QnOiAgLy8gYSBkYXkgLyBpbiBhIGRheSAvIGEgZGF5IGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAnZGVuJyA6ICdkbmVtJztcbiAgICAgICAgICAgIGNhc2UgJ2RkJzogLy8gOSBkYXlzIC8gaW4gOSBkYXlzIC8gOSBkYXlzIGFnb1xuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnZG55JyA6ICdkbsOtJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdkbnknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ00nOiAgLy8gYSBtb250aCAvIGluIGEgbW9udGggLyBhIG1vbnRoIGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAnbcSbc8OtYycgOiAnbcSbc8OtY2VtJztcbiAgICAgICAgICAgIGNhc2UgJ01NJzogLy8gOSBtb250aHMgLyBpbiA5IG1vbnRocyAvIDkgbW9udGhzIGFnb1xuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbcSbc8OtY2UnIDogJ23Em3PDrWPFrycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcSbc8OtY2knO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOiAgLy8gYSB5ZWFyIC8gaW4gYSB5ZWFyIC8gYSB5ZWFyIGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAncm9rJyA6ICdyb2tlbSc7XG4gICAgICAgICAgICBjYXNlICd5eSc6IC8vIDkgeWVhcnMgLyBpbiA5IHllYXJzIC8gOSB5ZWFycyBhZ29cbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ3Jva3knIDogJ2xldCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbGV0eSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnY3MnLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcbiAgICAgICAgbW9udGhzUGFyc2UgOiAoZnVuY3Rpb24gKG1vbnRocywgbW9udGhzU2hvcnQpIHtcbiAgICAgICAgICAgIHZhciBpLCBfbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSBwYXJzZXIgdG8gc29sdmUgcHJvYmxlbSB3aXRoIEp1bHkgKMSNZXJ2ZW5lYylcbiAgICAgICAgICAgICAgICBfbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIG1vbnRoc1tpXSArICckfF4nICsgbW9udGhzU2hvcnRbaV0gKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX21vbnRoc1BhcnNlO1xuICAgICAgICB9KG1vbnRocywgbW9udGhzU2hvcnQpKSxcbiAgICAgICAgc2hvcnRNb250aHNQYXJzZSA6IChmdW5jdGlvbiAobW9udGhzU2hvcnQpIHtcbiAgICAgICAgICAgIHZhciBpLCBfc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgbW9udGhzU2hvcnRbaV0gKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Nob3J0TW9udGhzUGFyc2U7XG4gICAgICAgIH0obW9udGhzU2hvcnQpKSxcbiAgICAgICAgbG9uZ01vbnRoc1BhcnNlIDogKGZ1bmN0aW9uIChtb250aHMpIHtcbiAgICAgICAgICAgIHZhciBpLCBfbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIG1vbnRoc1tpXSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfbG9uZ01vbnRoc1BhcnNlO1xuICAgICAgICB9KG1vbnRocykpLFxuICAgICAgICB3ZWVrZGF5cyA6ICduZWTEm2xlX3BvbmTEm2zDrV/DunRlcsO9X3N0xZllZGFfxI10dnJ0ZWtfcMOhdGVrX3NvYm90YScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICduZV9wb1/DunRfc3RfxI10X3DDoV9zbycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnbmVfcG9fw7p0X3N0X8SNdF9ww6Ffc28nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQ6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgSDptbScsXG4gICAgICAgICAgICBsIDogJ0QuIE0uIFlZWVknXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tkbmVzIHZdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbesOtdHJhIHZdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3YgbmVkxJtsaSB2XSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gZGRkZCBbdl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2ZSBzdMWZZWR1IHZdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdmUgxI10dnJ0ZWsgdl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2IHDDoXRlayB2XSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Ygc29ib3R1IHZdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheTogJ1t2xI1lcmEgdl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWxvdSBuZWTEm2xpIHZdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMOpXSBkZGRkIFt2XSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsb3Ugc3TFmWVkdSB2XSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDvV0gZGRkZCBbdl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bG91IHNvYm90dSB2XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAncMWZZWQgJXMnLFxuICAgICAgICAgICAgcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHNzIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG1tIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGhoIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGRkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE1NIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHl5IDogdHJhbnNsYXRlXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNzO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var cv = moment.defineLocale('cv', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'YYYY [] MMMM [] D[-]',\n            LLL : 'YYYY [] MMMM [] D[-], HH:mm',\n            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'\n        },\n        calendar : {\n            sameDay: '[] LT []',\n            nextDay: '[] LT []',\n            lastDay: '[] LT []',\n            nextWeek: '[] dddd LT []',\n            lastWeek: '[] dddd LT []',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : function (output) {\n                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';\n                return output + affix;\n            },\n            past : '%s ',\n            s : '- ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-/,\n        ordinal : '%d-',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return cv;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jdi5qcz8zNzdiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGN2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnY3YnLCB7XG4gICAgICAgIG1vbnRocyA6ICfQutOR0YDQu9Cw0Ydf0L3QsNGA05HRgV/Qv9GD0Yhf0LDQutCwX9C80LDQuV/Sq9OX0YDRgtC80LVf0YPRgtORX9Kr0YPRgNC70LBf0LDQstOR0L1f0Y7Qv9CwX9GH07PQul/RgNCw0YjRgtCw0LInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9C605HRgF/QvdCw0YBf0L/Rg9GIX9Cw0LrQsF/QvNCw0Llf0qvTl9GAX9GD0YLTkV/Sq9GD0YBf0LDQstC9X9GO0L/QsF/Rh9Oz0Lpf0YDQsNGIJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfQstGL0YDRgdCw0YDQvdC40LrRg9C9X9GC0YPQvdGC0LjQutGD0L1f0YvRgtC70LDRgNC40LrRg9C9X9GO0L3QutGD0L1f0LrTl9Kr0L3QtdGA0L3QuNC60YPQvV/RjdGA0L3QtdC60YPQvV/RiNOR0LzQsNGC0LrRg9C9Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9Cy0YvRgF/RgtGD0L1f0YvRgtC7X9GO0L1f0LrTl9KrX9GN0YDQvV/RiNOR0LwnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9Cy0YBf0YLQvV/Ri9GCX9GO0L1f0LrSq1/RjdGAX9GI0LwnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQtTU0tWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdZWVlZIFvSq9GD0LvRhdC4XSBNTU1NIFvRg9C505HRhdOX0L1dIERbLdC805fRiNOXXScsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWSBb0qvRg9C70YXQuF0gTU1NTSBb0YPQudOR0YXTl9C9XSBEWy3QvNOX0YjTl10sIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgWVlZWSBb0qvRg9C70YXQuF0gTU1NTSBb0YPQudOR0YXTl9C9XSBEWy3QvNOX0YjTl10sIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb0J/QsNGP0L1dIExUIFvRgdC10YXQtdGC0YDQtV0nLFxuICAgICAgICAgICAgbmV4dERheTogJ1vQq9GA0LDQvV0gTFQgW9GB0LXRhdC10YLRgNC1XScsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9OW0L3QtdGAXSBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnW9Kq0LjRgtC10YFdIGRkZGQgTFQgW9GB0LXRhdC10YLRgNC1XScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1vQmNGA0YLQvdOXXSBkZGRkIExUIFvRgdC10YXQtdGC0YDQtV0nLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZml4ID0gL9GB0LXRhdC10YIkL2kuZXhlYyhvdXRwdXQpID8gJ9GA0LXQvScgOiAv0qvRg9C7JC9pLmV4ZWMob3V0cHV0KSA/ICfRgtCw0L0nIDogJ9GA0LDQvSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIGFmZml4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg0LrQsNGP0LvQu9CwJyxcbiAgICAgICAgICAgIHMgOiAn0L/Tl9GALdC40Log0qvQtdC60LrRg9C90YInLFxuICAgICAgICAgICAgc3MgOiAnJWQg0qvQtdC60LrRg9C90YInLFxuICAgICAgICAgICAgbSA6ICfQv9OX0YAg0LzQuNC90YPRgicsXG4gICAgICAgICAgICBtbSA6ICclZCDQvNC40L3Rg9GCJyxcbiAgICAgICAgICAgIGggOiAn0L/Tl9GAINGB0LXRhdC10YInLFxuICAgICAgICAgICAgaGggOiAnJWQg0YHQtdGF0LXRgicsXG4gICAgICAgICAgICBkIDogJ9C/05fRgCDQutGD0L0nLFxuICAgICAgICAgICAgZGQgOiAnJWQg0LrRg9C9JyxcbiAgICAgICAgICAgIE0gOiAn0L/Tl9GAINGD0LnTkdGFJyxcbiAgICAgICAgICAgIE1NIDogJyVkINGD0LnTkdGFJyxcbiAgICAgICAgICAgIHkgOiAn0L/Tl9GAINKr0YPQuycsXG4gICAgICAgICAgICB5eSA6ICclZCDSq9GD0LsnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS3QvNOX0YgvLFxuICAgICAgICBvcmRpbmFsIDogJyVkLdC805fRiCcsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN2O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jdi5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var cy = moment.defineLocale('cy', {\n        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),\n        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),\n        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),\n        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),\n        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),\n        weekdaysParseExact : true,\n        // time formats are the same as en-gb\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[Heddiw am] LT',\n            nextDay: '[Yfory am] LT',\n            nextWeek: 'dddd [am] LT',\n            lastDay: '[Ddoe am] LT',\n            lastWeek: 'dddd [diwethaf am] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: 'mewn %s',\n            past: '%s yn l',\n            s: 'ychydig eiliadau',\n            ss: '%d eiliad',\n            m: 'munud',\n            mm: '%d munud',\n            h: 'awr',\n            hh: '%d awr',\n            d: 'diwrnod',\n            dd: '%d diwrnod',\n            M: 'mis',\n            MM: '%d mis',\n            y: 'blwyddyn',\n            yy: '%d flynedd'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,\n        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh\n        ordinal: function (number) {\n            var b = number,\n                output = '',\n                lookup = [\n                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed\n                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed\n                ];\n            if (b > 20) {\n                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {\n                    output = 'fed'; // not 30ain, 70ain or 90ain\n                } else {\n                    output = 'ain';\n                }\n            } else if (b > 0) {\n                output = lookup[b];\n            }\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return cy;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jeS5qcz82NDUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBjeSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2N5Jywge1xuICAgICAgICBtb250aHM6ICdJb25hd3JfQ2h3ZWZyb3JfTWF3cnRoX0VicmlsbF9NYWlfTWVoZWZpbl9Hb3JmZmVubmFmX0F3c3RfTWVkaV9IeWRyZWZfVGFjaHdlZGRfUmhhZ2Z5cicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICdJb25fQ2h3ZV9NYXdfRWJyX01haV9NZWhfR29yX0F3c19NZWRfSHlkX1RhY2hfUmhhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXM6ICdEeWRkIFN1bF9EeWRkIExsdW5fRHlkZCBNYXdydGhfRHlkZCBNZXJjaGVyX0R5ZGQgSWF1X0R5ZGQgR3dlbmVyX0R5ZGQgU2Fkd3JuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiAnU3VsX0xsdW5fTWF3X01lcl9JYXVfR3dlX1NhZCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW46ICdTdV9MbF9NYV9NZV9JYV9Hd19TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgLy8gdGltZSBmb3JtYXRzIGFyZSB0aGUgc2FtZSBhcyBlbi1nYlxuICAgICAgICBsb25nRGF0ZUZvcm1hdDoge1xuICAgICAgICAgICAgTFQ6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEw6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0hlZGRpdyBhbV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tZZm9yeSBhbV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthbV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tEZG9lIGFtXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW2Rpd2V0aGFmIGFtXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZToge1xuICAgICAgICAgICAgZnV0dXJlOiAnbWV3biAlcycsXG4gICAgICAgICAgICBwYXN0OiAnJXMgeW4gw7RsJyxcbiAgICAgICAgICAgIHM6ICd5Y2h5ZGlnIGVpbGlhZGF1JyxcbiAgICAgICAgICAgIHNzOiAnJWQgZWlsaWFkJyxcbiAgICAgICAgICAgIG06ICdtdW51ZCcsXG4gICAgICAgICAgICBtbTogJyVkIG11bnVkJyxcbiAgICAgICAgICAgIGg6ICdhd3InLFxuICAgICAgICAgICAgaGg6ICclZCBhd3InLFxuICAgICAgICAgICAgZDogJ2Rpd3Jub2QnLFxuICAgICAgICAgICAgZGQ6ICclZCBkaXdybm9kJyxcbiAgICAgICAgICAgIE06ICdtaXMnLFxuICAgICAgICAgICAgTU06ICclZCBtaXMnLFxuICAgICAgICAgICAgeTogJ2Jsd3lkZHluJyxcbiAgICAgICAgICAgIHl5OiAnJWQgZmx5bmVkZCdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGZlZHxhaW58YWZ8aWx8eWRkfGVkfGVnKS8sXG4gICAgICAgIC8vIHRyYWRpdGlvbmFsIG9yZGluYWwgbnVtYmVycyBhYm92ZSAzMSBhcmUgbm90IGNvbW1vbmx5IHVzZWQgaW4gY29sbG9xdWlhbCBXZWxzaFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlcixcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgICAgICBsb29rdXAgPSBbXG4gICAgICAgICAgICAgICAgICAgICcnLCAnYWYnLCAnaWwnLCAneWRkJywgJ3lkZCcsICdlZCcsICdlZCcsICdlZCcsICdmZWQnLCAnZmVkJywgJ2ZlZCcsIC8vIDFhZiB0byAxMGZlZFxuICAgICAgICAgICAgICAgICAgICAnZWcnLCAnZmVkJywgJ2VnJywgJ2VnJywgJ2ZlZCcsICdlZycsICdlZycsICdmZWQnLCAnZWcnLCAnZmVkJyAvLyAxMWVnIHRvIDIwZmVkXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChiID4gMjApIHtcbiAgICAgICAgICAgICAgICBpZiAoYiA9PT0gNDAgfHwgYiA9PT0gNTAgfHwgYiA9PT0gNjAgfHwgYiA9PT0gODAgfHwgYiA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9ICdmZWQnOyAvLyBub3QgMzBhaW4sIDcwYWluIG9yIDkwYWluXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gJ2Fpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID4gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGxvb2t1cFtiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN5O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jeS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var da = moment.defineLocale('da', {\n        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),\n        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),\n        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'\n        },\n        calendar : {\n            sameDay : '[i dag kl.] LT',\n            nextDay : '[i morgen kl.] LT',\n            nextWeek : 'p dddd [kl.] LT',\n            lastDay : '[i gr kl.] LT',\n            lastWeek : '[i] dddd[s kl.] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : '%s siden',\n            s : 'f sekunder',\n            ss : '%d sekunder',\n            m : 'et minut',\n            mm : '%d minutter',\n            h : 'en time',\n            hh : '%d timer',\n            d : 'en dag',\n            dd : '%d dage',\n            M : 'en mned',\n            MM : '%d mneder',\n            y : 'et r',\n            yy : '%d r'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return da;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kYS5qcz82MDEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBkYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RhJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFydHNfYXByaWxfbWFqX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWpfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzw7huZGFnX21hbmRhZ190aXJzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7hyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3PDuG5fbWFuX3Rpcl9vbnNfdG9yX2ZyZV9sw7hyJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdzw7hfbWFfdGlfb25fdG9fZnJfbMO4Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIFtkLl0gRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW2kgZGFnIGtsLl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbaSBtb3JnZW4ga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdww6UgZGRkZCBba2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tpIGfDpXIga2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbaV0gZGRkZFtzIGtsLl0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29tICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgc2lkZW4nLFxuICAgICAgICAgICAgcyA6ICdmw6Ugc2VrdW5kZXInLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2VrdW5kZXInLFxuICAgICAgICAgICAgbSA6ICdldCBtaW51dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHRlcicsXG4gICAgICAgICAgICBoIDogJ2VuIHRpbWUnLFxuICAgICAgICAgICAgaGggOiAnJWQgdGltZXInLFxuICAgICAgICAgICAgZCA6ICdlbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnZScsXG4gICAgICAgICAgICBNIDogJ2VuIG3DpW5lZCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtw6VuZWRlcicsXG4gICAgICAgICAgICB5IDogJ2V0IMOlcicsXG4gICAgICAgICAgICB5eSA6ICclZCDDpXInXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGE7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var de = moment.defineLocale('de', {\n        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            ss : '%d Sekunden',\n            m : processRelativeTime,\n            mm : '%d Minuten',\n            h : processRelativeTime,\n            hh : '%d Stunden',\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return de;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS5qcz8wY2U5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ20nOiBbJ2VpbmUgTWludXRlJywgJ2VpbmVyIE1pbnV0ZSddLFxuICAgICAgICAgICAgJ2gnOiBbJ2VpbmUgU3R1bmRlJywgJ2VpbmVyIFN0dW5kZSddLFxuICAgICAgICAgICAgJ2QnOiBbJ2VpbiBUYWcnLCAnZWluZW0gVGFnJ10sXG4gICAgICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBUYWdlJywgbnVtYmVyICsgJyBUYWdlbiddLFxuICAgICAgICAgICAgJ00nOiBbJ2VpbiBNb25hdCcsICdlaW5lbSBNb25hdCddLFxuICAgICAgICAgICAgJ01NJzogW251bWJlciArICcgTW9uYXRlJywgbnVtYmVyICsgJyBNb25hdGVuJ10sXG4gICAgICAgICAgICAneSc6IFsnZWluIEphaHInLCAnZWluZW0gSmFociddLFxuICAgICAgICAgICAgJ3l5JzogW251bWJlciArICcgSmFocmUnLCBudW1iZXIgKyAnIEphaHJlbiddXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcbiAgICB9XG5cbiAgICB2YXIgZGUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdkZScsIHtcbiAgICAgICAgbW9udGhzIDogJ0phbnVhcl9GZWJydWFyX03DpHJ6X0FwcmlsX01haV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW4uX0ZlYi5fTcOkcnpfQXByLl9NYWlfSnVuaV9KdWxpX0F1Zy5fU2VwLl9Pa3QuX05vdi5fRGV6Licuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ1Nvbm50YWdfTW9udGFnX0RpZW5zdGFnX01pdHR3b2NoX0Rvbm5lcnN0YWdfRnJlaXRhZ19TYW1zdGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1NvLl9Nby5fRGkuX01pLl9Eby5fRnIuX1NhLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU29fTW9fRGlfTWlfRG9fRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQ6ICdISDptbScsXG4gICAgICAgICAgICBMVFM6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBELiBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1toZXV0ZSB1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbbW9yZ2VuIHVtXSBMVCBbVWhyXScsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3VtXSBMVCBbVWhyXScsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW2dlc3Rlcm4gdW1dIExUIFtVaHJdJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW2xldHp0ZW5dIGRkZGQgW3VtXSBMVCBbVWhyXSdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAndm9yICVzJyxcbiAgICAgICAgICAgIHMgOiAnZWluIHBhYXIgU2VrdW5kZW4nLFxuICAgICAgICAgICAgc3MgOiAnJWQgU2VrdW5kZW4nLFxuICAgICAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtbSA6ICclZCBNaW51dGVuJyxcbiAgICAgICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgaGggOiAnJWQgU3R1bmRlbicsXG4gICAgICAgICAgICBkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGRkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgTU0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICB5eSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkZTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var deAt = moment.defineLocale('de-at', {\n        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            ss : '%d Sekunden',\n            m : processRelativeTime,\n            mm : '%d Minuten',\n            h : processRelativeTime,\n            hh : '%d Stunden',\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return deAt;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1hdC5qcz9mMmZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ20nOiBbJ2VpbmUgTWludXRlJywgJ2VpbmVyIE1pbnV0ZSddLFxuICAgICAgICAgICAgJ2gnOiBbJ2VpbmUgU3R1bmRlJywgJ2VpbmVyIFN0dW5kZSddLFxuICAgICAgICAgICAgJ2QnOiBbJ2VpbiBUYWcnLCAnZWluZW0gVGFnJ10sXG4gICAgICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBUYWdlJywgbnVtYmVyICsgJyBUYWdlbiddLFxuICAgICAgICAgICAgJ00nOiBbJ2VpbiBNb25hdCcsICdlaW5lbSBNb25hdCddLFxuICAgICAgICAgICAgJ01NJzogW251bWJlciArICcgTW9uYXRlJywgbnVtYmVyICsgJyBNb25hdGVuJ10sXG4gICAgICAgICAgICAneSc6IFsnZWluIEphaHInLCAnZWluZW0gSmFociddLFxuICAgICAgICAgICAgJ3l5JzogW251bWJlciArICcgSmFocmUnLCBudW1iZXIgKyAnIEphaHJlbiddXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcbiAgICB9XG5cbiAgICB2YXIgZGVBdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RlLWF0Jywge1xuICAgICAgICBtb250aHMgOiAnSsOkbm5lcl9GZWJydWFyX03DpHJ6X0FwcmlsX01haV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKw6RuLl9GZWIuX03DpHJ6X0Fwci5fTWFpX0p1bmlfSnVsaV9BdWcuX1NlcC5fT2t0Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdTb25udGFnX01vbnRhZ19EaWVuc3RhZ19NaXR0d29jaF9Eb25uZXJzdGFnX0ZyZWl0YWdfU2Ftc3RhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdTby5fTW8uX0RpLl9NaS5fRG8uX0ZyLl9TYS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbaGV1dGUgdW1dIExUIFtVaHJdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW21vcmdlbiB1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbGFzdERheTogJ1tnZXN0ZXJuIHVtXSBMVCBbVWhyXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tsZXR6dGVuXSBkZGRkIFt1bV0gTFQgW1Vocl0nXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ZvciAlcycsXG4gICAgICAgICAgICBzIDogJ2VpbiBwYWFyIFNla3VuZGVuJyxcbiAgICAgICAgICAgIHNzIDogJyVkIFNla3VuZGVuJyxcbiAgICAgICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXG4gICAgICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoIDogJyVkIFN0dW5kZW4nLFxuICAgICAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVBdDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtYXQuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var deCh = moment.defineLocale('de-ch', {\n        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            ss : '%d Sekunden',\n            m : processRelativeTime,\n            mm : '%d Minuten',\n            h : processRelativeTime,\n            hh : '%d Stunden',\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return deCh;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1jaC5qcz8xNmI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ20nOiBbJ2VpbmUgTWludXRlJywgJ2VpbmVyIE1pbnV0ZSddLFxuICAgICAgICAgICAgJ2gnOiBbJ2VpbmUgU3R1bmRlJywgJ2VpbmVyIFN0dW5kZSddLFxuICAgICAgICAgICAgJ2QnOiBbJ2VpbiBUYWcnLCAnZWluZW0gVGFnJ10sXG4gICAgICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBUYWdlJywgbnVtYmVyICsgJyBUYWdlbiddLFxuICAgICAgICAgICAgJ00nOiBbJ2VpbiBNb25hdCcsICdlaW5lbSBNb25hdCddLFxuICAgICAgICAgICAgJ01NJzogW251bWJlciArICcgTW9uYXRlJywgbnVtYmVyICsgJyBNb25hdGVuJ10sXG4gICAgICAgICAgICAneSc6IFsnZWluIEphaHInLCAnZWluZW0gSmFociddLFxuICAgICAgICAgICAgJ3l5JzogW251bWJlciArICcgSmFocmUnLCBudW1iZXIgKyAnIEphaHJlbiddXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcbiAgICB9XG5cbiAgICB2YXIgZGVDaCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RlLWNoJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyX0ZlYnJ1YXJfTcOkcnpfQXByaWxfTWFpX0p1bmlfSnVsaV9BdWd1c3RfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGV6ZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbi5fRmViLl9Nw6Ryel9BcHIuX01haV9KdW5pX0p1bGlfQXVnLl9TZXAuX09rdC5fTm92Ll9EZXouJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAnU29ubnRhZ19Nb250YWdfRGllbnN0YWdfTWl0dHdvY2hfRG9ubmVyc3RhZ19GcmVpdGFnX1NhbXN0YWcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnU29fTW9fRGlfTWlfRG9fRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbaGV1dGUgdW1dIExUIFtVaHJdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW21vcmdlbiB1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbGFzdERheTogJ1tnZXN0ZXJuIHVtXSBMVCBbVWhyXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tsZXR6dGVuXSBkZGRkIFt1bV0gTFQgW1Vocl0nXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ZvciAlcycsXG4gICAgICAgICAgICBzIDogJ2VpbiBwYWFyIFNla3VuZGVuJyxcbiAgICAgICAgICAgIHNzIDogJyVkIFNla3VuZGVuJyxcbiAgICAgICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXG4gICAgICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoIDogJyVkIFN0dW5kZW4nLFxuICAgICAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVDaDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtY2guanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var months = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ], weekdays = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n\n    var dv = moment.defineLocale('dv', {\n        months : months,\n        monthsShort : months,\n        weekdays : weekdays,\n        weekdaysShort : weekdays,\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'D/M/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            ss : 'd% ',\n            m : '',\n            mm : ' %d',\n            h : '',\n            hh : ' %d',\n            d : '',\n            dd : ' %d',\n            M : '',\n            MM : ' %d',\n            y : '',\n            yy : ' %d'\n        },\n        preparse: function (string) {\n            return string.replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/,/g, '');\n        },\n        week : {\n            dow : 7,  // Sunday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return dv;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kdi5qcz9hYzhiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzID0gW1xuICAgICAgICAn3pberN6C3qreh96m3oPeqScsXG4gICAgICAgICfeit6s3oTesN6D3qreh96m3oPeqScsXG4gICAgICAgICfeid6n3oPeqN6X3qonLFxuICAgICAgICAn3oferd6V3rDeg96p3o3eqicsXG4gICAgICAgICfeid6tJyxcbiAgICAgICAgJ96W3qvegt6wJyxcbiAgICAgICAgJ96W3qrejd6m3ofeqCcsXG4gICAgICAgICfeh96v3o7ept6Q3rDek96qJyxcbiAgICAgICAgJ96Q3qzeld6w3pPerN6J3rDehN6m3oPeqicsXG4gICAgICAgICfeh96u3obesN6T3q/ehN6m3oPeqicsXG4gICAgICAgICfegt6u3ojerN6J3rDehN6m3oPeqicsXG4gICAgICAgICfekd6o3pDerN6J3rDehN6m3oPeqidcbiAgICBdLCB3ZWVrZGF5cyA9IFtcbiAgICAgICAgJ96H3qfei96o3ofesN6M3qYnLFxuICAgICAgICAn3oDer96J3qYnLFxuICAgICAgICAn3ofept6C3rDejt6n3oPepicsXG4gICAgICAgICfehN6q3ovepicsXG4gICAgICAgICfehN6q3oPep96Q3rDeit6m3ozeqCcsXG4gICAgICAgICfegN6q3obeqt6D3qonLFxuICAgICAgICAn3oDert6C3qjegN6o3oPeqidcbiAgICBdO1xuXG4gICAgdmFyIGR2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZHYnLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHMsXG4gICAgICAgIHdlZWtkYXlzIDogd2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiB3ZWVrZGF5cyxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn3ofep96L3qhf3oDer96J3qZf3ofept6C3rBf3oTeqt6L3qZf3oTeqt6D3qdf3oDeqt6G3qpf3oDert6C3qgnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuXG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdEL00vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv3onehnzeid6KLyxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuICfeid6KJyA9PT0gaW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn3onehic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn3oneiic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb3oneqN6H3qbei96qXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1veid6n3ovept6J3qddIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb3ofeqN6H3rDelN6sXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb3orep96H3qjejN6q3ojeqF0gZGRkZCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn3ozerN6D3q3ejt6m3ofeqCAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ96G3qreg96o3oLesCAlcycsXG4gICAgICAgICAgICBzIDogJ96Q3qjeht6q3oLesN6M3qreht6u3oXerN6H3rAnLFxuICAgICAgICAgICAgc3MgOiAnZCUg3pDeqN6G3qregt6w3ozeqicsXG4gICAgICAgICAgICBtIDogJ96J3qjegt6o3pPerN6H3rAnLFxuICAgICAgICAgICAgbW0gOiAn3oneqN6C3qjek96qICVkJyxcbiAgICAgICAgICAgIGggOiAn3o7ept6R3qjeh96o3oPerN6H3rAnLFxuICAgICAgICAgICAgaGggOiAn3o7ept6R3qjeh96o3oPeqiAlZCcsXG4gICAgICAgICAgICBkIDogJ96L3qreiN6m3oDerN6H3rAnLFxuICAgICAgICAgICAgZGQgOiAn3oveqt6I3qbekN6wICVkJyxcbiAgICAgICAgICAgIE0gOiAn3onept6A3qzeh96wJyxcbiAgICAgICAgICAgIE1NIDogJ96J3qbekN6wICVkJyxcbiAgICAgICAgICAgIHkgOiAn3ofept6A3qbeg96s3ofesCcsXG4gICAgICAgICAgICB5eSA6ICfeh96m3oDept6D3qogJWQnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLC9nLCAn2IwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDcsICAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkdjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZHYuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n\n    var el = moment.defineLocale('el', {\n        monthsNominativeEl : '___________'.split('_'),\n        monthsGenitiveEl : '___________'.split('_'),\n        months : function (momentToFormat, format) {\n            if (!momentToFormat) {\n                return this._monthsNominativeEl;\n            } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'\n                return this._monthsGenitiveEl[momentToFormat.month()];\n            } else {\n                return this._monthsNominativeEl[momentToFormat.month()];\n            }\n        },\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? '' : '';\n            } else {\n                return isLower ? '' : '';\n            }\n        },\n        isPM : function (input) {\n            return ((input + '').toLowerCase()[0] === '');\n        },\n        meridiemParse : /[]\\.??\\.?/i,\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendarEl : {\n            sameDay : '[ {}] LT',\n            nextDay : '[ {}] LT',\n            nextWeek : 'dddd [{}] LT',\n            lastDay : '[ {}] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 6:\n                        return '[ ] dddd [{}] LT';\n                    default:\n                        return '[ ] dddd [{}] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        calendar : function (key, mom) {\n            var output = this._calendarEl[key],\n                hours = mom && mom.hours();\n            if (isFunction(output)) {\n                output = output.apply(mom);\n            }\n            return output.replace('{}', (hours % 12 === 1 ? '' : ''));\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal: '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4st is the first week of the year.\n        }\n    });\n\n    return el;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbC5qcz8wODVhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOztBQUU1QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0dBQWdHO0FBQzdHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG5cbiAgICB2YXIgZWwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlbCcsIHtcbiAgICAgICAgbW9udGhzTm9taW5hdGl2ZUVsIDogJ86ZzrHOvc6/z4XOrM+BzrnOv8+CX86mzrXOss+Bzr/Phc6sz4HOuc6/z4JfzpzOrM+Bz4TOuc6/z4JfzpHPgM+Bzq/Ou865zr/Pgl/OnM6szrnOv8+CX86Zzr/Pjc69zrnOv8+CX86Zzr/Pjc67zrnOv8+CX86Rz43Os86/z4XPg8+Ezr/Pgl/Oo861z4DPhM6tzrzOss+BzrnOv8+CX86fzrrPhM+OzrLPgc65zr/Pgl/Onc6/zq3OvM6yz4HOuc6/z4JfzpTOtc66zq3OvM6yz4HOuc6/z4InLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc0dlbml0aXZlRWwgOiAnzpnOsc69zr/Phc6xz4HOr86/z4VfzqbOtc6yz4HOv8+FzrHPgc6vzr/PhV/OnM6xz4HPhM6vzr/PhV/Okc+Az4HOuc67zq/Ov8+FX86czrHOkM6/z4VfzpnOv8+Fzr3Or86/z4VfzpnOv8+FzrvOr86/z4VfzpHPhc6zzr/Pjc+Dz4TOv8+FX86jzrXPgM+EzrXOvM6yz4HOr86/z4Vfzp/Ous+Ez4nOss+Bzq/Ov8+FX86dzr/Otc68zrLPgc6vzr/PhV/OlM61zrrOtc68zrLPgc6vzr/PhScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzIDogZnVuY3Rpb24gKG1vbWVudFRvRm9ybWF0LCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50VG9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzTm9taW5hdGl2ZUVsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJyAmJiAvRC8udGVzdChmb3JtYXQuc3Vic3RyaW5nKDAsIGZvcm1hdC5pbmRleE9mKCdNTU1NJykpKSkgeyAvLyBpZiB0aGVyZSBpcyBhIGRheSBudW1iZXIgYmVmb3JlICdNTU1NJ1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNHZW5pdGl2ZUVsW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzTm9taW5hdGl2ZUVsW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb250aHNTaG9ydCA6ICfOmc6xzr1fzqbOtc6yX86czrHPgV/Okc+Az4FfzpzOsc+KX86Zzr/Phc69X86Zzr/Phc67X86Rz4XOs1/Oo861z4Bfzp/Ous+EX86dzr/OtV/OlM61zronLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ86az4XPgc65zrHOus6uX86UzrXPhc+Ezq3Pgc6xX86kz4HOr8+EzrdfzqTOtc+EzqzPgc+EzrdfzqDOrc68z4DPhM63X86gzrHPgc6xz4POus61z4XOrl/Oo86szrLOss6xz4TOvycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfOms+Fz4FfzpTOtc+FX86kz4HOuV/OpM61z4RfzqDOtc68X86gzrHPgV/Oo86xzrInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ86az4VfzpTOtV/OpM+BX86kzrVfzqDOtV/OoM6xX86jzrEnLnNwbGl0KCdfJyksXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ868zrwnIDogJ86czpwnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICfPgM68JyA6ICfOoM6cJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKVswXSA9PT0gJ868Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2UgOiAvW86gzpxdXFwuP86cP1xcLj8vaSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdoOm1tIEEnLFxuICAgICAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIGg6bW0gQScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIGg6bW0gQSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXJFbCA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW86jzq7OvM61z4HOsSB7fV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbzpHPjc+BzrnOvyB7fV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbe31dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW86nzrjOtc+CIHt9XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbz4TOvyDPgM+Bzr/Ot86zzr/Pjc68zrXOvc6/XSBkZGRkIFt7fV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbz4TOt869IM+Az4HOv863zrPOv8+NzrzOtc69zrddIGRkZGQgW3t9XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDogZnVuY3Rpb24gKGtleSwgbW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJFbFtrZXldLFxuICAgICAgICAgICAgICAgIGhvdXJzID0gbW9tICYmIG1vbS5ob3VycygpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5hcHBseShtb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5yZXBsYWNlKCd7fScsIChob3VycyAlIDEyID09PSAxID8gJ8+Dz4TOtycgOiAnz4PPhM65z4InKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfPg861ICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgz4DPgc65zr0nLFxuICAgICAgICAgICAgcyA6ICfOu86vzrPOsSDOtM61z4XPhM61z4HPjM67zrXPgM+EzrEnLFxuICAgICAgICAgICAgc3MgOiAnJWQgzrTOtc+Fz4TOtc+Bz4zOu861z4DPhM6xJyxcbiAgICAgICAgICAgIG0gOiAnzq3Ovc6xIM67zrXPgM+Ez4wnLFxuICAgICAgICAgICAgbW0gOiAnJWQgzrvOtc+Az4TOrCcsXG4gICAgICAgICAgICBoIDogJ868zq/OsSDPjs+BzrEnLFxuICAgICAgICAgICAgaGggOiAnJWQgz47Pgc61z4InLFxuICAgICAgICAgICAgZCA6ICfOvM6vzrEgzrzOrc+BzrEnLFxuICAgICAgICAgICAgZGQgOiAnJWQgzrzOrc+BzrXPgicsXG4gICAgICAgICAgICBNIDogJ86tzr3Osc+CIM68zq7Ovc6xz4InLFxuICAgICAgICAgICAgTU0gOiAnJWQgzrzOrs69zrXPgicsXG4gICAgICAgICAgICB5IDogJ86tzr3Osc+CIM+Hz4HPjM69zr/PgicsXG4gICAgICAgICAgICB5eSA6ICclZCDPh8+Bz4zOvc65zrEnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfc63LyxcbiAgICAgICAgb3JkaW5hbDogJyVkzrcnLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0c3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZWwuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var enAu = moment.defineLocale('en-au', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            ss : '%d seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return enAu;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1hdS5qcz80YTNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZW5BdSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWF1Jywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGFnbycsXG4gICAgICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgICAgICAgICBtIDogJ2EgbWludXRlJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgICAgaCA6ICdhbiBob3VyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgICAgIGQgOiAnYSBkYXknLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgICAgICBNIDogJ2EgbW9udGgnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgICAgIHkgOiAnYSB5ZWFyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVuQXU7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var enCa = moment.defineLocale('en-ca', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'YYYY-MM-DD',\n            LL : 'MMMM D, YYYY',\n            LLL : 'MMMM D, YYYY h:mm A',\n            LLLL : 'dddd, MMMM D, YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            ss : '%d seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    return enCa;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1jYS5qcz80ZWFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlbkNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZW4tY2EnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdoOm1tIEEnLFxuICAgICAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXG4gICAgICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEwgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcbiAgICAgICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgICAgIG0gOiAnYSBtaW51dGUnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgICAgICBoIDogJ2FuIGhvdXInLFxuICAgICAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICAgICAgZCA6ICdhIGRheScsXG4gICAgICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgICAgIE0gOiAnYSBtb250aCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICAgICAgeSA6ICdhIHllYXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVuQ2E7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWNhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var enGb = moment.defineLocale('en-gb', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            ss : '%d seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return enGb;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1nYi5qcz84NGZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZW5HYiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWdiJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcbiAgICAgICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgICAgIG0gOiAnYSBtaW51dGUnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgICAgICBoIDogJ2FuIGhvdXInLFxuICAgICAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICAgICAgZCA6ICdhIGRheScsXG4gICAgICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgICAgIE0gOiAnYSBtb250aCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICAgICAgeSA6ICdhIHllYXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW5HYjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tZ2IuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var enIe = moment.defineLocale('en-ie', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            ss : '%d seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return enIe;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qcz8wMGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZW5JZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWllJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQtTU0tWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBhZ28nLFxuICAgICAgICAgICAgcyA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICAgICAgbSA6ICdhIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAnYW4gaG91cicsXG4gICAgICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgICAgICBkIDogJ2EgZGF5JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICAgICAgTSA6ICdhIG1vbnRoJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgICAgICB5IDogJ2EgeWVhcicsXG4gICAgICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0fG5kfHJkfHRoKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbkllO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var enIl = moment.defineLocale('en-il', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    return enIl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pbC5qcz80MTk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZW5JbCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWlsJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcbiAgICAgICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgICAgICBtIDogJ2EgbWludXRlJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgICAgaCA6ICdhbiBob3VyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgICAgIGQgOiAnYSBkYXknLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgICAgICBNIDogJ2EgbW9udGgnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgICAgIHkgOiAnYSB5ZWFyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbklsO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pbC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var enNz = moment.defineLocale('en-nz', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            ss : '%d seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return enNz;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1uei5qcz83NzIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZW5OeiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLW56Jywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGFnbycsXG4gICAgICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgICAgICAgICBtIDogJ2EgbWludXRlJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgICAgaCA6ICdhbiBob3VyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgICAgIGQgOiAnYSBkYXknLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgICAgICBNIDogJ2EgbW9udGgnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgICAgIHkgOiAnYSB5ZWFyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVuTno7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40\n");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var eo = moment.defineLocale('eo', {\n        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),\n        weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),\n        weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),\n        weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'D[-a de] MMMM, YYYY',\n            LLL : 'D[-a de] MMMM, YYYY HH:mm',\n            LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'\n        },\n        meridiemParse: /[ap]\\.t\\.m/i,\n        isPM: function (input) {\n            return input.charAt(0).toLowerCase() === 'p';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? 'p.t.m.' : 'P.T.M.';\n            } else {\n                return isLower ? 'a.t.m.' : 'A.T.M.';\n            }\n        },\n        calendar : {\n            sameDay : '[Hodia je] LT',\n            nextDay : '[Morga je] LT',\n            nextWeek : 'dddd [je] LT',\n            lastDay : '[Hiera je] LT',\n            lastWeek : '[pasinta] dddd [je] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'post %s',\n            past : 'anta %s',\n            s : 'sekundoj',\n            ss : '%d sekundoj',\n            m : 'minuto',\n            mm : '%d minutoj',\n            h : 'horo',\n            hh : '%d horoj',\n            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo\n            dd : '%d tagoj',\n            M : 'monato',\n            MM : '%d monatoj',\n            y : 'jaro',\n            yy : '%d jaroj'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}a/,\n        ordinal : '%da',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return eo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lby5qcz8zNWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZW8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlbycsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcm9fZmVicnVhcm9fbWFydG9fYXByaWxvX21ham9fanVuaW9fanVsaW9fYcWtZ3VzdG9fc2VwdGVtYnJvX29rdG9icm9fbm92ZW1icm9fZGVjZW1icm8nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWpfanVuX2p1bF9hxa1nX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnZGltYW7EiW9fbHVuZG9fbWFyZG9fbWVya3JlZG9fxLVhxa1kb192ZW5kcmVkb19zYWJhdG8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnZGltX2x1bl9tYXJkX21lcmtfxLVhxa1fdmVuX3NhYicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnZGlfbHVfbWFfbWVfxLVhX3ZlX3NhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEwgOiAnRFstYSBkZV0gTU1NTSwgWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRFstYSBkZV0gTU1NTSwgWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIFtsYV0gRFstYSBkZV0gTU1NTSwgWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL1thcF1cXC50XFwubS9pLFxuICAgICAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA9PT0gJ3AnO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwLnQubS4nIDogJ1AuVC5NLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2EudC5tLicgOiAnQS5ULk0uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tIb2RpYcWtIGplXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tNb3JnYcWtIGplXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtqZV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbSGllcmHFrSBqZV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW3Bhc2ludGFdIGRkZGQgW2plXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAncG9zdCAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2FudGHFrSAlcycsXG4gICAgICAgICAgICBzIDogJ3Nla3VuZG9qJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla3VuZG9qJyxcbiAgICAgICAgICAgIG0gOiAnbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0b2onLFxuICAgICAgICAgICAgaCA6ICdob3JvJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvcm9qJyxcbiAgICAgICAgICAgIGQgOiAndGFnbycsLy9uZSAnZGl1cm5vJywgxIlhciBlc3RhcyB1eml0YSBwb3IgcHJva3NpbXVtb1xuICAgICAgICAgICAgZGQgOiAnJWQgdGFnb2onLFxuICAgICAgICAgICAgTSA6ICdtb25hdG8nLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9uYXRvaicsXG4gICAgICAgICAgICB5IDogJ2phcm8nLFxuICAgICAgICAgICAgeXkgOiAnJWQgamFyb2onXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfWEvLFxuICAgICAgICBvcmRpbmFsIDogJyVkYScsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVvO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lby5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),\n        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');\n\n    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];\n    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\\.?|feb\\.?|mar\\.?|abr\\.?|may\\.?|jun\\.?|jul\\.?|ago\\.?|sep\\.?|oct\\.?|nov\\.?|dic\\.?)/i;\n\n    var es = moment.defineLocale('es', {\n        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),\n        monthsShort : function (m, format) {\n            if (!m) {\n                return monthsShortDot;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShort[m.month()];\n            } else {\n                return monthsShortDot[m.month()];\n            }\n        },\n        monthsRegex : monthsRegex,\n        monthsShortRegex : monthsRegex,\n        monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,\n        monthsShortStrictRegex : /^(ene\\.?|feb\\.?|mar\\.?|abr\\.?|may\\.?|jun\\.?|jul\\.?|ago\\.?|sep\\.?|oct\\.?|nov\\.?|dic\\.?)/i,\n        monthsParse : monthsParse,\n        longMonthsParse : monthsParse,\n        shortMonthsParse : monthsParse,\n        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),\n        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),\n        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY H:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextDay : function () {\n                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastDay : function () {\n                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastWeek : function () {\n                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'en %s',\n            past : 'hace %s',\n            s : 'unos segundos',\n            ss : '%d segundos',\n            m : 'un minuto',\n            mm : '%d minutos',\n            h : 'una hora',\n            hh : '%d horas',\n            d : 'un da',\n            dd : '%d das',\n            M : 'un mes',\n            MM : '%d meses',\n            y : 'un ao',\n            yy : '%d aos'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return es;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy5qcz8yZDNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtb250aHNTaG9ydERvdCA9ICdlbmUuX2ZlYi5fbWFyLl9hYnIuX21heS5fanVuLl9qdWwuX2Fnby5fc2VwLl9vY3QuX25vdi5fZGljLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgPSAnZW5lX2ZlYl9tYXJfYWJyX21heV9qdW5fanVsX2Fnb19zZXBfb2N0X25vdl9kaWMnLnNwbGl0KCdfJyk7XG5cbiAgICB2YXIgbW9udGhzUGFyc2UgPSBbL15lbmUvaSwgL15mZWIvaSwgL15tYXIvaSwgL15hYnIvaSwgL15tYXkvaSwgL15qdW4vaSwgL15qdWwvaSwgL15hZ28vaSwgL15zZXAvaSwgL15vY3QvaSwgL15ub3YvaSwgL15kaWMvaV07XG4gICAgdmFyIG1vbnRoc1JlZ2V4ID0gL14oZW5lcm98ZmVicmVyb3xtYXJ6b3xhYnJpbHxtYXlvfGp1bmlvfGp1bGlvfGFnb3N0b3xzZXB0aWVtYnJlfG9jdHVicmV8bm92aWVtYnJlfGRpY2llbWJyZXxlbmVcXC4/fGZlYlxcLj98bWFyXFwuP3xhYnJcXC4/fG1heVxcLj98anVuXFwuP3xqdWxcXC4/fGFnb1xcLj98c2VwXFwuP3xvY3RcXC4/fG5vdlxcLj98ZGljXFwuPykvaTtcblxuICAgIHZhciBlcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VzJywge1xuICAgICAgICBtb250aHMgOiAnZW5lcm9fZmVicmVyb19tYXJ6b19hYnJpbF9tYXlvX2p1bmlvX2p1bGlvX2Fnb3N0b19zZXB0aWVtYnJlX29jdHVicmVfbm92aWVtYnJlX2RpY2llbWJyZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnREb3Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdFttLm1vbnRoKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb250aHNSZWdleCA6IG1vbnRoc1JlZ2V4LFxuICAgICAgICBtb250aHNTaG9ydFJlZ2V4IDogbW9udGhzUmVnZXgsXG4gICAgICAgIG1vbnRoc1N0cmljdFJlZ2V4IDogL14oZW5lcm98ZmVicmVyb3xtYXJ6b3xhYnJpbHxtYXlvfGp1bmlvfGp1bGlvfGFnb3N0b3xzZXB0aWVtYnJlfG9jdHVicmV8bm92aWVtYnJlfGRpY2llbWJyZSkvaSxcbiAgICAgICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IC9eKGVuZVxcLj98ZmViXFwuP3xtYXJcXC4/fGFiclxcLj98bWF5XFwuP3xqdW5cXC4/fGp1bFxcLj98YWdvXFwuP3xzZXBcXC4/fG9jdFxcLj98bm92XFwuP3xkaWNcXC4/KS9pLFxuICAgICAgICBtb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxuICAgICAgICBsb25nTW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcbiAgICAgICAgc2hvcnRNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdkb21pbmdvX2x1bmVzX21hcnRlc19tacOpcmNvbGVzX2p1ZXZlc192aWVybmVzX3PDoWJhZG8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnZG9tLl9sdW4uX21hci5fbWnDqS5fanVlLl92aWUuX3PDoWIuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdkb19sdV9tYV9taV9qdV92aV9zw6EnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbaG95IGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbbWHDsWFuYSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RkZGQgW2EgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbYXllciBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzYWRvIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdlbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2hhY2UgJXMnLFxuICAgICAgICAgICAgcyA6ICd1bm9zIHNlZ3VuZG9zJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlZ3VuZG9zJyxcbiAgICAgICAgICAgIG0gOiAndW4gbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxuICAgICAgICAgICAgaCA6ICd1bmEgaG9yYScsXG4gICAgICAgICAgICBoaCA6ICclZCBob3JhcycsXG4gICAgICAgICAgICBkIDogJ3VuIGTDrWEnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZMOtYXMnLFxuICAgICAgICAgICAgTSA6ICd1biBtZXMnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxuICAgICAgICAgICAgeSA6ICd1biBhw7FvJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGHDsW9zJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlcztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),\n        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');\n\n    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];\n    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\\.?|feb\\.?|mar\\.?|abr\\.?|may\\.?|jun\\.?|jul\\.?|ago\\.?|sep\\.?|oct\\.?|nov\\.?|dic\\.?)/i;\n\n    var esDo = moment.defineLocale('es-do', {\n        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),\n        monthsShort : function (m, format) {\n            if (!m) {\n                return monthsShortDot;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShort[m.month()];\n            } else {\n                return monthsShortDot[m.month()];\n            }\n        },\n        monthsRegex: monthsRegex,\n        monthsShortRegex: monthsRegex,\n        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,\n        monthsShortStrictRegex: /^(ene\\.?|feb\\.?|mar\\.?|abr\\.?|may\\.?|jun\\.?|jul\\.?|ago\\.?|sep\\.?|oct\\.?|nov\\.?|dic\\.?)/i,\n        monthsParse: monthsParse,\n        longMonthsParse: monthsParse,\n        shortMonthsParse: monthsParse,\n        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),\n        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),\n        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY h:mm A',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextDay : function () {\n                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastDay : function () {\n                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastWeek : function () {\n                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'en %s',\n            past : 'hace %s',\n            s : 'unos segundos',\n            ss : '%d segundos',\n            m : 'un minuto',\n            mm : '%d minutos',\n            h : 'una hora',\n            hh : '%d horas',\n            d : 'un da',\n            dd : '%d das',\n            M : 'un mes',\n            MM : '%d meses',\n            y : 'un ao',\n            yy : '%d aos'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return esDo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy1kby5qcz9lY2MxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtb250aHNTaG9ydERvdCA9ICdlbmUuX2ZlYi5fbWFyLl9hYnIuX21heS5fanVuLl9qdWwuX2Fnby5fc2VwLl9vY3QuX25vdi5fZGljLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgPSAnZW5lX2ZlYl9tYXJfYWJyX21heV9qdW5fanVsX2Fnb19zZXBfb2N0X25vdl9kaWMnLnNwbGl0KCdfJyk7XG5cbiAgICB2YXIgbW9udGhzUGFyc2UgPSBbL15lbmUvaSwgL15mZWIvaSwgL15tYXIvaSwgL15hYnIvaSwgL15tYXkvaSwgL15qdW4vaSwgL15qdWwvaSwgL15hZ28vaSwgL15zZXAvaSwgL15vY3QvaSwgL15ub3YvaSwgL15kaWMvaV07XG4gICAgdmFyIG1vbnRoc1JlZ2V4ID0gL14oZW5lcm98ZmVicmVyb3xtYXJ6b3xhYnJpbHxtYXlvfGp1bmlvfGp1bGlvfGFnb3N0b3xzZXB0aWVtYnJlfG9jdHVicmV8bm92aWVtYnJlfGRpY2llbWJyZXxlbmVcXC4/fGZlYlxcLj98bWFyXFwuP3xhYnJcXC4/fG1heVxcLj98anVuXFwuP3xqdWxcXC4/fGFnb1xcLj98c2VwXFwuP3xvY3RcXC4/fG5vdlxcLj98ZGljXFwuPykvaTtcblxuICAgIHZhciBlc0RvID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZXMtZG8nLCB7XG4gICAgICAgIG1vbnRocyA6ICdlbmVyb19mZWJyZXJvX21hcnpvX2FicmlsX21heW9fanVuaW9fanVsaW9fYWdvc3RvX3NlcHRpZW1icmVfb2N0dWJyZV9ub3ZpZW1icmVfZGljaWVtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLy1NTU0tLy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90W20ubW9udGgoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoc1JlZ2V4OiBtb250aHNSZWdleCxcbiAgICAgICAgbW9udGhzU2hvcnRSZWdleDogbW9udGhzUmVnZXgsXG4gICAgICAgIG1vbnRoc1N0cmljdFJlZ2V4OiAvXihlbmVyb3xmZWJyZXJvfG1hcnpvfGFicmlsfG1heW98anVuaW98anVsaW98YWdvc3RvfHNlcHRpZW1icmV8b2N0dWJyZXxub3ZpZW1icmV8ZGljaWVtYnJlKS9pLFxuICAgICAgICBtb250aHNTaG9ydFN0cmljdFJlZ2V4OiAvXihlbmVcXC4/fGZlYlxcLj98bWFyXFwuP3xhYnJcXC4/fG1heVxcLj98anVuXFwuP3xqdWxcXC4/fGFnb1xcLj98c2VwXFwuP3xvY3RcXC4/fG5vdlxcLj98ZGljXFwuPykvaSxcbiAgICAgICAgbW9udGhzUGFyc2U6IG1vbnRoc1BhcnNlLFxuICAgICAgICBsb25nTW9udGhzUGFyc2U6IG1vbnRoc1BhcnNlLFxuICAgICAgICBzaG9ydE1vbnRoc1BhcnNlOiBtb250aHNQYXJzZSxcbiAgICAgICAgd2Vla2RheXMgOiAnZG9taW5nb19sdW5lc19tYXJ0ZXNfbWnDqXJjb2xlc19qdWV2ZXNfdmllcm5lc19zw6FiYWRvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ2RvbS5fbHVuLl9tYXIuX21pw6kuX2p1ZS5fdmllLl9zw6FiLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnZG9fbHVfbWFfbWlfanVfdmlfc8OhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ2g6bW0gQScsXG4gICAgICAgICAgICBMVFMgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIFtkZV0gTU1NTSBbZGVdIFlZWVkgaDptbSBBJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbaG95IGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbbWHDsWFuYSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RkZGQgW2EgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbYXllciBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzYWRvIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdlbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2hhY2UgJXMnLFxuICAgICAgICAgICAgcyA6ICd1bm9zIHNlZ3VuZG9zJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlZ3VuZG9zJyxcbiAgICAgICAgICAgIG0gOiAndW4gbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxuICAgICAgICAgICAgaCA6ICd1bmEgaG9yYScsXG4gICAgICAgICAgICBoaCA6ICclZCBob3JhcycsXG4gICAgICAgICAgICBkIDogJ3VuIGTDrWEnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZMOtYXMnLFxuICAgICAgICAgICAgTSA6ICd1biBtZXMnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxuICAgICAgICAgICAgeSA6ICd1biBhw7FvJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGHDsW9zJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlc0RvO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy1kby5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),\n        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');\n\n    var esUs = moment.defineLocale('es-us', {\n        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),\n        monthsShort : function (m, format) {\n            if (!m) {\n                return monthsShortDot;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShort[m.month()];\n            } else {\n                return monthsShortDot[m.month()];\n            }\n        },\n        monthsParseExact : true,\n        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),\n        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),\n        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'MM/DD/YYYY',\n            LL : 'MMMM [de] D [de] YYYY',\n            LLL : 'MMMM [de] D [de] YYYY h:mm A',\n            LLLL : 'dddd, MMMM [de] D [de] YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextDay : function () {\n                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastDay : function () {\n                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastWeek : function () {\n                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'en %s',\n            past : 'hace %s',\n            s : 'unos segundos',\n            ss : '%d segundos',\n            m : 'un minuto',\n            mm : '%d minutos',\n            h : 'una hora',\n            hh : '%d horas',\n            d : 'un da',\n            dd : '%d das',\n            M : 'un mes',\n            MM : '%d meses',\n            y : 'un ao',\n            yy : '%d aos'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return esUs;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy11cy5qcz8yMGQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzU2hvcnREb3QgPSAnZW5lLl9mZWIuX21hci5fYWJyLl9tYXkuX2p1bi5fanVsLl9hZ28uX3NlcC5fb2N0Ll9ub3YuX2RpYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0ID0gJ2VuZV9mZWJfbWFyX2Ficl9tYXlfanVuX2p1bF9hZ29fc2VwX29jdF9ub3ZfZGljJy5zcGxpdCgnXycpO1xuXG4gICAgdmFyIGVzVXMgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlcy11cycsIHtcbiAgICAgICAgbW9udGhzIDogJ2VuZXJvX2ZlYnJlcm9fbWFyem9fYWJyaWxfbWF5b19qdW5pb19qdWxpb19hZ29zdG9fc2VwdGllbWJyZV9vY3R1YnJlX25vdmllbWJyZV9kaWNpZW1icmUnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0sIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90O1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFttLm1vbnRoKCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnREb3RbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ2RvbWluZ29fbHVuZXNfbWFydGVzX21pw6lyY29sZXNfanVldmVzX3ZpZXJuZXNfc8OhYmFkbycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdkb20uX2x1bi5fbWFyLl9tacOpLl9qdWUuX3ZpZS5fc8OhYi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ2RvX2x1X21hX21pX2p1X3ZpX3PDoScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdoOm1tIEEnLFxuICAgICAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXG4gICAgICAgICAgICBMIDogJ01NL0REL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnTU1NTSBbZGVdIEQgW2RlXSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdNTU1NIFtkZV0gRCBbZGVdIFlZWVkgaDptbSBBJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBbZGVdIEQgW2RlXSBZWVlZIGg6bW0gQSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW2hveSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW21hw7FhbmEgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZGRkIFthIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW2F5ZXIgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbZWxdIGRkZGQgW3Bhc2FkbyBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZW4gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdoYWNlICVzJyxcbiAgICAgICAgICAgIHMgOiAndW5vcyBzZWd1bmRvcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWd1bmRvcycsXG4gICAgICAgICAgICBtIDogJ3VuIG1pbnV0bycsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcbiAgICAgICAgICAgIGggOiAndW5hIGhvcmEnLFxuICAgICAgICAgICAgaGggOiAnJWQgaG9yYXMnLFxuICAgICAgICAgICAgZCA6ICd1biBkw61hJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGTDrWFzJyxcbiAgICAgICAgICAgIE0gOiAndW4gbWVzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1lc2VzJyxcbiAgICAgICAgICAgIHkgOiAndW4gYcOxbycsXG4gICAgICAgICAgICB5eSA6ICclZCBhw7FvcydcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcbiAgICAgICAgb3JkaW5hbCA6ICclZMK6JyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXNVcztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtdXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],\n            'ss': [number + 'sekundi', number + 'sekundit'],\n            'm' : ['he minuti', 'ks minut'],\n            'mm': [number + ' minuti', number + ' minutit'],\n            'h' : ['he tunni', 'tund aega', 'ks tund'],\n            'hh': [number + ' tunni', number + ' tundi'],\n            'd' : ['he peva', 'ks pev'],\n            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],\n            'MM': [number + ' kuu', number + ' kuud'],\n            'y' : ['he aasta', 'aasta', 'ks aasta'],\n            'yy': [number + ' aasta', number + ' aastat']\n        };\n        if (withoutSuffix) {\n            return format[key][2] ? format[key][2] : format[key][1];\n        }\n        return isFuture ? format[key][0] : format[key][1];\n    }\n\n    var et = moment.defineLocale('et', {\n        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),\n        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),\n        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),\n        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),\n        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),\n        longDateFormat : {\n            LT   : 'H:mm',\n            LTS : 'H:mm:ss',\n            L    : 'DD.MM.YYYY',\n            LL   : 'D. MMMM YYYY',\n            LLL  : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[Tna,] LT',\n            nextDay  : '[Homme,] LT',\n            nextWeek : '[Jrgmine] dddd LT',\n            lastDay  : '[Eile,] LT',\n            lastWeek : '[Eelmine] dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s prast',\n            past   : '%s tagasi',\n            s      : processRelativeTime,\n            ss     : processRelativeTime,\n            m      : processRelativeTime,\n            mm     : processRelativeTime,\n            h      : processRelativeTime,\n            hh     : processRelativeTime,\n            d      : processRelativeTime,\n            dd     : '%d peva',\n            M      : processRelativeTime,\n            MM     : processRelativeTime,\n            y      : processRelativeTime,\n            yy     : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return et;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qcz81ZTU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB7XG4gICAgICAgICAgICAncycgOiBbJ23DtW5lIHNla3VuZGknLCAnbcO1bmkgc2VrdW5kJywgJ3BhYXIgc2VrdW5kaXQnXSxcbiAgICAgICAgICAgICdzcyc6IFtudW1iZXIgKyAnc2VrdW5kaScsIG51bWJlciArICdzZWt1bmRpdCddLFxuICAgICAgICAgICAgJ20nIDogWyfDvGhlIG1pbnV0aScsICfDvGtzIG1pbnV0J10sXG4gICAgICAgICAgICAnbW0nOiBbbnVtYmVyICsgJyBtaW51dGknLCBudW1iZXIgKyAnIG1pbnV0aXQnXSxcbiAgICAgICAgICAgICdoJyA6IFsnw7xoZSB0dW5uaScsICd0dW5kIGFlZ2EnLCAnw7xrcyB0dW5kJ10sXG4gICAgICAgICAgICAnaGgnOiBbbnVtYmVyICsgJyB0dW5uaScsIG51bWJlciArICcgdHVuZGknXSxcbiAgICAgICAgICAgICdkJyA6IFsnw7xoZSBww6RldmEnLCAnw7xrcyBww6RldiddLFxuICAgICAgICAgICAgJ00nIDogWydrdXUgYWphJywgJ2t1dSBhZWdhJywgJ8O8a3Mga3V1J10sXG4gICAgICAgICAgICAnTU0nOiBbbnVtYmVyICsgJyBrdXUnLCBudW1iZXIgKyAnIGt1dWQnXSxcbiAgICAgICAgICAgICd5JyA6IFsnw7xoZSBhYXN0YScsICdhYXN0YScsICfDvGtzIGFhc3RhJ10sXG4gICAgICAgICAgICAneXknOiBbbnVtYmVyICsgJyBhYXN0YScsIG51bWJlciArICcgYWFzdGF0J11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRba2V5XVsyXSA/IGZvcm1hdFtrZXldWzJdIDogZm9ybWF0W2tleV1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcbiAgICB9XG5cbiAgICB2YXIgZXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdldCcsIHtcbiAgICAgICAgbW9udGhzICAgICAgICA6ICdqYWFudWFyX3ZlZWJydWFyX23DpHJ0c19hcHJpbGxfbWFpX2p1dW5pX2p1dWxpX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0b29iZXJfbm92ZW1iZXJfZGV0c2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCAgIDogJ2phYW5fdmVlYnJfbcOkcnRzX2Fwcl9tYWlfanV1bmlfanV1bGlfYXVnX3NlcHRfb2t0X25vdl9kZXRzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyAgICAgIDogJ3DDvGhhcMOkZXZfZXNtYXNww6Rldl90ZWlzaXDDpGV2X2tvbG1hcMOkZXZfbmVsamFww6Rldl9yZWVkZV9sYXVww6Rldicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdQX0VfVF9LX05fUl9MJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiAgIDogJ1BfRV9UX0tfTl9SX0wnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgICA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgICAgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCAgIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSAgOiAnW1TDpG5hLF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSAgOiAnW0hvbW1lLF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnW0rDpHJnbWluZV0gZGRkZCBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdbRWlsZSxdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tFZWxtaW5lXSBkZGRkIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyBww6RyYXN0JyxcbiAgICAgICAgICAgIHBhc3QgICA6ICclcyB0YWdhc2knLFxuICAgICAgICAgICAgcyAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHNzICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGggICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoaCAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGRkICAgICA6ICclZCBww6RldmEnLFxuICAgICAgICAgICAgTSAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICB5ICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV0O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n");

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var eu = moment.defineLocale('eu', {\n        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),\n        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),\n        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),\n        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'YYYY[ko] MMMM[ren] D[a]',\n            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',\n            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',\n            l : 'YYYY-M-D',\n            ll : 'YYYY[ko] MMM D[a]',\n            lll : 'YYYY[ko] MMM D[a] HH:mm',\n            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'\n        },\n        calendar : {\n            sameDay : '[gaur] LT[etan]',\n            nextDay : '[bihar] LT[etan]',\n            nextWeek : 'dddd LT[etan]',\n            lastDay : '[atzo] LT[etan]',\n            lastWeek : '[aurreko] dddd LT[etan]',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s barru',\n            past : 'duela %s',\n            s : 'segundo batzuk',\n            ss : '%d segundo',\n            m : 'minutu bat',\n            mm : '%d minutu',\n            h : 'ordu bat',\n            hh : '%d ordu',\n            d : 'egun bat',\n            dd : '%d egun',\n            M : 'hilabete bat',\n            MM : '%d hilabete',\n            y : 'urte bat',\n            yy : '%d urte'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return eu;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldS5qcz9iMmEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBldSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2V1Jywge1xuICAgICAgICBtb250aHMgOiAndXJ0YXJyaWxhX290c2FpbGFfbWFydHhvYV9hcGlyaWxhX21haWF0emFfZWthaW5hX3V6dGFpbGFfYWJ1enR1YV9pcmFpbGFfdXJyaWFfYXphcm9hX2FiZW5kdWEnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ3VydC5fb3RzLl9tYXIuX2FwaS5fbWFpLl9la2EuX3V6dC5fYWJ1Ll9pcmEuX3Vyci5fYXphLl9hYmUuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAnaWdhbmRlYV9hc3RlbGVoZW5hX2FzdGVhcnRlYV9hc3RlYXprZW5hX29zdGVndW5hX29zdGlyYWxhX2xhcnVuYmF0YScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdpZy5fYWwuX2FyLl9hei5fb2cuX29sLl9sci4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ2lnX2FsX2FyX2F6X29nX29sX2xyJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEwgOiAnWVlZWVtrb10gTU1NTVtyZW5dIERbYV0nLFxuICAgICAgICAgICAgTExMIDogJ1lZWVlba29dIE1NTU1bcmVuXSBEW2FdIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgWVlZWVtrb10gTU1NTVtyZW5dIERbYV0gSEg6bW0nLFxuICAgICAgICAgICAgbCA6ICdZWVlZLU0tRCcsXG4gICAgICAgICAgICBsbCA6ICdZWVlZW2tvXSBNTU0gRFthXScsXG4gICAgICAgICAgICBsbGwgOiAnWVlZWVtrb10gTU1NIERbYV0gSEg6bW0nLFxuICAgICAgICAgICAgbGxsbCA6ICdkZGQsIFlZWVlba29dIE1NTSBEW2FdIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW2dhdXJdIExUW2V0YW5dJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW2JpaGFyXSBMVFtldGFuXScsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIExUW2V0YW5dJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW2F0em9dIExUW2V0YW5dJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1thdXJyZWtvXSBkZGRkIExUW2V0YW5dJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyBiYXJydScsXG4gICAgICAgICAgICBwYXN0IDogJ2R1ZWxhICVzJyxcbiAgICAgICAgICAgIHMgOiAnc2VndW5kbyBiYXR6dWsnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2VndW5kbycsXG4gICAgICAgICAgICBtIDogJ21pbnV0dSBiYXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXR1JyxcbiAgICAgICAgICAgIGggOiAnb3JkdSBiYXQnLFxuICAgICAgICAgICAgaGggOiAnJWQgb3JkdScsXG4gICAgICAgICAgICBkIDogJ2VndW4gYmF0JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGVndW4nLFxuICAgICAgICAgICAgTSA6ICdoaWxhYmV0ZSBiYXQnLFxuICAgICAgICAgICAgTU0gOiAnJWQgaGlsYWJldGUnLFxuICAgICAgICAgICAgeSA6ICd1cnRlIGJhdCcsXG4gICAgICAgICAgICB5eSA6ICclZCB1cnRlJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV1O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46\n");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var fa = moment.defineLocale('fa', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '\\u200c__\\u200c__\\u200c__'.split('_'),\n        weekdaysShort : '\\u200c__\\u200c__\\u200c__'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /  |  /,\n        isPM: function (input) {\n            return /  /.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '  ';\n            } else {\n                return '  ';\n            }\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : 'dddd [] [] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            ss : ' d%',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[-]/g, function (match) {\n                return numberMap[match];\n            }).replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12 // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return fa;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mYS5qcz9kYTk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn27EnLFxuICAgICAgICAnMic6ICfbsicsXG4gICAgICAgICczJzogJ9uzJyxcbiAgICAgICAgJzQnOiAn27QnLFxuICAgICAgICAnNSc6ICfbtScsXG4gICAgICAgICc2JzogJ9u2JyxcbiAgICAgICAgJzcnOiAn27cnLFxuICAgICAgICAnOCc6ICfbuCcsXG4gICAgICAgICc5JzogJ9u5JyxcbiAgICAgICAgJzAnOiAn27AnXG4gICAgfSwgbnVtYmVyTWFwID0ge1xuICAgICAgICAn27EnOiAnMScsXG4gICAgICAgICfbsic6ICcyJyxcbiAgICAgICAgJ9uzJzogJzMnLFxuICAgICAgICAn27QnOiAnNCcsXG4gICAgICAgICfbtSc6ICc1JyxcbiAgICAgICAgJ9u2JzogJzYnLFxuICAgICAgICAn27cnOiAnNycsXG4gICAgICAgICfbuCc6ICc4JyxcbiAgICAgICAgJ9u5JzogJzknLFxuICAgICAgICAn27AnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIGZhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZmEnLCB7XG4gICAgICAgIG1vbnRocyA6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfbjNqpXFx1MjAwY9i02YbYqNmHX9iv2YjYtNmG2KjZh1/Ys9mHXFx1MjAwY9i02YbYqNmHX9qG2YfYp9ix2LTZhtio2Ydf2b7ZhtisXFx1MjAwY9i02YbYqNmHX9is2YXYudmHX9i02YbYqNmHJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9uM2qlcXHUyMDBj2LTZhtio2Ydf2K/ZiNi02YbYqNmHX9iz2YdcXHUyMDBj2LTZhtio2Ydf2obZh9in2LHYtNmG2KjZh1/ZvtmG2KxcXHUyMDBj2LTZhtio2Ydf2KzZhdi52Ydf2LTZhtio2YcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9uMX9ivX9izX9qGX9m+X9isX9i0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/Zgtio2YQg2KfYsiDYuNmH2LF82KjYudivINin2LIg2LjZh9ixLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL9io2LnYryDYp9iyINi42YfYsS8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn2YLYqNmEINin2LIg2LjZh9ixJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfYqNi52K8g2KfYsiDYuNmH2LEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW9in2YXYsdmI2LIg2LPYp9i52KpdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW9mB2LHYr9inINiz2KfYudiqXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvYs9in2LnYql0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb2K/bjNix2YjYsiDYs9in2LnYql0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBb2b7bjNi0XSBb2LPYp9i52KpdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfYr9ixICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg2b7bjNi0JyxcbiAgICAgICAgICAgIHMgOiAn2obZhtivINir2KfZhtuM2YcnLFxuICAgICAgICAgICAgc3MgOiAn2KvYp9mG24zZhyBkJScsXG4gICAgICAgICAgICBtIDogJ9uM2qkg2K/ZgtuM2YLZhycsXG4gICAgICAgICAgICBtbSA6ICclZCDYr9mC24zZgtmHJyxcbiAgICAgICAgICAgIGggOiAn24zaqSDYs9in2LnYqicsXG4gICAgICAgICAgICBoaCA6ICclZCDYs9in2LnYqicsXG4gICAgICAgICAgICBkIDogJ9uM2qkg2LHZiNiyJyxcbiAgICAgICAgICAgIGRkIDogJyVkINix2YjYsicsXG4gICAgICAgICAgICBNIDogJ9uM2qkg2YXYp9mHJyxcbiAgICAgICAgICAgIE1NIDogJyVkINmF2KfZhycsXG4gICAgICAgICAgICB5IDogJ9uM2qkg2LPYp9mEJyxcbiAgICAgICAgICAgIHl5IDogJyVkINiz2KfZhCdcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW9uwLdu5XS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL9iML2csICcsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvLC9nLCAn2IwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ92YUvLFxuICAgICAgICBvcmRpbmFsIDogJyVk2YUnLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDEyIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZhO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mYS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),\n        numbersFuture = [\n            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',\n            numbersPast[7], numbersPast[8], numbersPast[9]\n        ];\n    function translate(number, withoutSuffix, key, isFuture) {\n        var result = '';\n        switch (key) {\n            case 's':\n                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';\n            case 'ss':\n                return isFuture ? 'sekunnin' : 'sekuntia';\n            case 'm':\n                return isFuture ? 'minuutin' : 'minuutti';\n            case 'mm':\n                result = isFuture ? 'minuutin' : 'minuuttia';\n                break;\n            case 'h':\n                return isFuture ? 'tunnin' : 'tunti';\n            case 'hh':\n                result = isFuture ? 'tunnin' : 'tuntia';\n                break;\n            case 'd':\n                return isFuture ? 'pivn' : 'piv';\n            case 'dd':\n                result = isFuture ? 'pivn' : 'piv';\n                break;\n            case 'M':\n                return isFuture ? 'kuukauden' : 'kuukausi';\n            case 'MM':\n                result = isFuture ? 'kuukauden' : 'kuukautta';\n                break;\n            case 'y':\n                return isFuture ? 'vuoden' : 'vuosi';\n            case 'yy':\n                result = isFuture ? 'vuoden' : 'vuotta';\n                break;\n        }\n        result = verbalNumber(number, isFuture) + ' ' + result;\n        return result;\n    }\n    function verbalNumber(number, isFuture) {\n        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;\n    }\n\n    var fi = moment.defineLocale('fi', {\n        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),\n        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),\n        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),\n        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),\n        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD.MM.YYYY',\n            LL : 'Do MMMM[ta] YYYY',\n            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',\n            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',\n            l : 'D.M.YYYY',\n            ll : 'Do MMM YYYY',\n            lll : 'Do MMM YYYY, [klo] HH.mm',\n            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'\n        },\n        calendar : {\n            sameDay : '[tnn] [klo] LT',\n            nextDay : '[huomenna] [klo] LT',\n            nextWeek : 'dddd [klo] LT',\n            lastDay : '[eilen] [klo] LT',\n            lastWeek : '[viime] dddd[na] [klo] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s pst',\n            past : '%s sitten',\n            s : translate,\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : translate,\n            hh : translate,\n            d : translate,\n            dd : translate,\n            M : translate,\n            MM : translate,\n            y : translate,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return fi;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9maS5qcz85ZDJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbnVtYmVyc1Bhc3QgPSAnbm9sbGEgeWtzaSBrYWtzaSBrb2xtZSBuZWxqw6Qgdmlpc2kga3V1c2kgc2VpdHNlbcOkbiBrYWhkZWtzYW4geWhkZWtzw6RuJy5zcGxpdCgnICcpLFxuICAgICAgICBudW1iZXJzRnV0dXJlID0gW1xuICAgICAgICAgICAgJ25vbGxhJywgJ3loZGVuJywgJ2thaGRlbicsICdrb2xtZW4nLCAnbmVsasOkbicsICd2aWlkZW4nLCAna3V1ZGVuJyxcbiAgICAgICAgICAgIG51bWJlcnNQYXN0WzddLCBudW1iZXJzUGFzdFs4XSwgbnVtYmVyc1Bhc3RbOV1cbiAgICAgICAgXTtcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdtdXV0YW1hbiBzZWt1bm5pbicgOiAnbXV1dGFtYSBzZWt1bnRpJztcbiAgICAgICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAnc2VrdW5uaW4nIDogJ3Nla3VudGlhJztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdtaW51dXRpbicgOiAnbWludXV0dGknO1xuICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ21pbnV1dGluJyA6ICdtaW51dXR0aWEnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ3R1bm5pbicgOiAndHVudGknO1xuICAgICAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ3R1bm5pbicgOiAndHVudGlhJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdww6RpdsOkbicgOiAncMOkaXbDpCc7XG4gICAgICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAncMOkaXbDpG4nIDogJ3DDpGl2w6TDpCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAna3V1a2F1ZGVuJyA6ICdrdXVrYXVzaSc7XG4gICAgICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAna3V1a2F1ZGVuJyA6ICdrdXVrYXV0dGEnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ3Z1b2RlbicgOiAndnVvc2knO1xuICAgICAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ3Z1b2RlbicgOiAndnVvdHRhJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2ZXJiYWxOdW1iZXIobnVtYmVyLCBpc0Z1dHVyZSkgKyAnICcgKyByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZlcmJhbE51bWJlcihudW1iZXIsIGlzRnV0dXJlKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIgPCAxMCA/IChpc0Z1dHVyZSA/IG51bWJlcnNGdXR1cmVbbnVtYmVyXSA6IG51bWJlcnNQYXN0W251bWJlcl0pIDogbnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmaSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZpJywge1xuICAgICAgICBtb250aHMgOiAndGFtbWlrdXVfaGVsbWlrdXVfbWFhbGlza3V1X2h1aHRpa3V1X3RvdWtva3V1X2tlc8Oka3V1X2hlaW7DpGt1dV9lbG9rdXVfc3l5c2t1dV9sb2tha3V1X21hcnJhc2t1dV9qb3VsdWt1dScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAndGFtbWlfaGVsbWlfbWFhbGlzX2h1aHRpX3RvdWtvX2tlc8OkX2hlaW7DpF9lbG9fc3l5c19sb2thX21hcnJhc19qb3VsdScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnc3VubnVudGFpX21hYW5hbnRhaV90aWlzdGFpX2tlc2tpdmlpa2tvX3RvcnN0YWlfcGVyamFudGFpX2xhdWFudGFpJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3N1X21hX3RpX2tlX3RvX3BlX2xhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdzdV9tYV90aV9rZV90b19wZV9sYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISC5tbScsXG4gICAgICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0RvIE1NTU1bdGFdIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0RvIE1NTU1bdGFdIFlZWVksIFtrbG9dIEhILm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRG8gTU1NTVt0YV0gWVlZWSwgW2tsb10gSEgubW0nLFxuICAgICAgICAgICAgbCA6ICdELk0uWVlZWScsXG4gICAgICAgICAgICBsbCA6ICdEbyBNTU0gWVlZWScsXG4gICAgICAgICAgICBsbGwgOiAnRG8gTU1NIFlZWVksIFtrbG9dIEhILm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnZGRkLCBEbyBNTU0gWVlZWSwgW2tsb10gSEgubW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbdMOkbsOkw6RuXSBba2xvXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1todW9tZW5uYV0gW2tsb10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBba2xvXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tlaWxlbl0gW2tsb10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW3ZpaW1lXSBkZGRkW25hXSBba2xvXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMgcMOkw6RzdMOkJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgc2l0dGVuJyxcbiAgICAgICAgICAgIHMgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBzcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9maS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48\n");

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var fo = moment.defineLocale('fo', {\n        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),\n        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),\n        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D. MMMM, YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ dag kl.] LT',\n            nextDay : '[ morgin kl.] LT',\n            nextWeek : 'dddd [kl.] LT',\n            lastDay : '[ gjr kl.] LT',\n            lastWeek : '[sstu] dddd [kl] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'um %s',\n            past : '%s sani',\n            s : 'f sekund',\n            ss : '%d sekundir',\n            m : 'ein minutt',\n            mm : '%d minuttir',\n            h : 'ein tmi',\n            hh : '%d tmar',\n            d : 'ein dagur',\n            dd : '%d dagar',\n            M : 'ein mnai',\n            MM : '%d mnair',\n            y : 'eitt r',\n            yy : '%d r'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return fo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mby5qcz8zOTUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBmbyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZvJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFyc19hcHLDrWxfbWFpX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWlfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzdW5udWRhZ3VyX23DoW5hZGFndXJfdMO9c2RhZ3VyX21pa3VkYWd1cl9ow7NzZGFndXJfZnLDrWdnamFkYWd1cl9sZXlnYXJkYWd1cicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzdW5fbcOhbl90w71zX21pa19ow7NzX2Zyw61fbGV5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdzdV9tw6FfdMO9X21pX2jDs19mcl9sZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSwgWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vDjSBkYWcga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vDjSBtb3JnaW4ga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtrbC5dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW8ONIGdqw6FyIGtsLl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW3PDrcOwc3R1XSBkZGRkIFtrbF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3VtICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgc8Otw7BhbmknLFxuICAgICAgICAgICAgcyA6ICdmw6Egc2VrdW5kJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla3VuZGlyJyxcbiAgICAgICAgICAgIG0gOiAnZWluIG1pbnV0dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHRpcicsXG4gICAgICAgICAgICBoIDogJ2VpbiB0w61taScsXG4gICAgICAgICAgICBoaCA6ICclZCB0w61tYXInLFxuICAgICAgICAgICAgZCA6ICdlaW4gZGFndXInLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnYXInLFxuICAgICAgICAgICAgTSA6ICdlaW4gbcOhbmHDsGknLFxuICAgICAgICAgICAgTU0gOiAnJWQgbcOhbmHDsGlyJyxcbiAgICAgICAgICAgIHkgOiAnZWl0dCDDoXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgw6FyJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mby5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n");

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var fr = moment.defineLocale('fr', {\n        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Aujourdhui ] LT',\n            nextDay : '[Demain ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[Hier ] LT',\n            lastWeek : 'dddd [dernier ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dans %s',\n            past : 'il y a %s',\n            s : 'quelques secondes',\n            ss : '%d secondes',\n            m : 'une minute',\n            mm : '%d minutes',\n            h : 'une heure',\n            hh : '%d heures',\n            d : 'un jour',\n            dd : '%d jours',\n            M : 'un mois',\n            MM : '%d mois',\n            y : 'un an',\n            yy : '%d ans'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(er|)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                // TODO: Return 'e' when day of month > 1. Move this case inside\n                // block for masculine words below.\n                // See https://github.com/moment/moment/issues/3375\n                case 'D':\n                    return number + (number === 1 ? 'er' : '');\n\n                // Words with masculine grammatical gender: mois, trimestre, jour\n                default:\n                case 'M':\n                case 'Q':\n                case 'DDD':\n                case 'd':\n                    return number + (number === 1 ? 'er' : 'e');\n\n                // Words with feminine grammatical gender: semaine\n                case 'w':\n                case 'W':\n                    return number + (number === 1 ? 're' : 'e');\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return fr;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qcz9iNzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZnIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmcicsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnZpZXJfZsOpdnJpZXJfbWFyc19hdnJpbF9tYWlfanVpbl9qdWlsbGV0X2Fvw7t0X3NlcHRlbWJyZV9vY3RvYnJlX25vdmVtYnJlX2TDqWNlbWJyZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFudi5fZsOpdnIuX21hcnNfYXZyLl9tYWlfanVpbl9qdWlsLl9hb8O7dF9zZXB0Ll9vY3QuX25vdi5fZMOpYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdkaW1hbmNoZV9sdW5kaV9tYXJkaV9tZXJjcmVkaV9qZXVkaV92ZW5kcmVkaV9zYW1lZGknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnZGltLl9sdW4uX21hci5fbWVyLl9qZXUuX3Zlbi5fc2FtLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnZGlfbHVfbWFfbWVfamVfdmVfc2EnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW0F1am91cmTigJlodWkgw6BdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW0RlbWFpbiDDoF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbw6BdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0hpZXIgw6BdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2Rlcm5pZXIgw6BdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdkYW5zICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnaWwgeSBhICVzJyxcbiAgICAgICAgICAgIHMgOiAncXVlbHF1ZXMgc2Vjb25kZXMnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2Vjb25kZXMnLFxuICAgICAgICAgICAgbSA6ICd1bmUgbWludXRlJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgICAgaCA6ICd1bmUgaGV1cmUnLFxuICAgICAgICAgICAgaGggOiAnJWQgaGV1cmVzJyxcbiAgICAgICAgICAgIGQgOiAndW4gam91cicsXG4gICAgICAgICAgICBkZCA6ICclZCBqb3VycycsXG4gICAgICAgICAgICBNIDogJ3VuIG1vaXMnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9pcycsXG4gICAgICAgICAgICB5IDogJ3VuIGFuJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGFucydcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGVyfCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJldHVybiAnZScgd2hlbiBkYXkgb2YgbW9udGggPiAxLiBNb3ZlIHRoaXMgY2FzZSBpbnNpZGVcbiAgICAgICAgICAgICAgICAvLyBibG9jayBmb3IgbWFzY3VsaW5lIHdvcmRzIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMzM3NVxuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdlcicgOiAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBXb3JkcyB3aXRoIG1hc2N1bGluZSBncmFtbWF0aWNhbCBnZW5kZXI6IG1vaXMsIHRyaW1lc3RyZSwgam91clxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAnZXInIDogJ2UnKTtcblxuICAgICAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggZmVtaW5pbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBzZW1haW5lXG4gICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ3JlJyA6ICdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZyO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50\n");

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var frCa = moment.defineLocale('fr-ca', {\n        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Aujourdhui ] LT',\n            nextDay : '[Demain ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[Hier ] LT',\n            lastWeek : 'dddd [dernier ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dans %s',\n            past : 'il y a %s',\n            s : 'quelques secondes',\n            ss : '%d secondes',\n            m : 'une minute',\n            mm : '%d minutes',\n            h : 'une heure',\n            hh : '%d heures',\n            d : 'un jour',\n            dd : '%d jours',\n            M : 'un mois',\n            MM : '%d mois',\n            y : 'un an',\n            yy : '%d ans'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(er|e)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                // Words with masculine grammatical gender: mois, trimestre, jour\n                default:\n                case 'M':\n                case 'Q':\n                case 'D':\n                case 'DDD':\n                case 'd':\n                    return number + (number === 1 ? 'er' : 'e');\n\n                // Words with feminine grammatical gender: semaine\n                case 'w':\n                case 'W':\n                    return number + (number === 1 ? 're' : 'e');\n            }\n        }\n    });\n\n    return frCa;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jYS5qcz82ZDc0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBmckNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnItY2EnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW52aWVyX2bDqXZyaWVyX21hcnNfYXZyaWxfbWFpX2p1aW5fanVpbGxldF9hb8O7dF9zZXB0ZW1icmVfb2N0b2JyZV9ub3ZlbWJyZV9kw6ljZW1icmUnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbnYuX2bDqXZyLl9tYXJzX2F2ci5fbWFpX2p1aW5fanVpbC5fYW/Du3Rfc2VwdC5fb2N0Ll9ub3YuX2TDqWMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAnZGltYW5jaGVfbHVuZGlfbWFyZGlfbWVyY3JlZGlfamV1ZGlfdmVuZHJlZGlfc2FtZWRpJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ2RpbS5fbHVuLl9tYXIuX21lci5famV1Ll92ZW4uX3NhbS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ2RpX2x1X21hX21lX2plX3ZlX3NhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tBdWpvdXJk4oCZaHVpIMOgXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tEZW1haW4gw6BdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW8OgXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tIaWVyIMOgXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtkZXJuaWVyIMOgXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZGFucyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2lsIHkgYSAlcycsXG4gICAgICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlY29uZGVzJyxcbiAgICAgICAgICAgIG0gOiAndW5lIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAndW5lIGhldXJlJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhldXJlcycsXG4gICAgICAgICAgICBkIDogJ3VuIGpvdXInLFxuICAgICAgICAgICAgZGQgOiAnJWQgam91cnMnLFxuICAgICAgICAgICAgTSA6ICd1biBtb2lzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vaXMnLFxuICAgICAgICAgICAgeSA6ICd1biBhbicsXG4gICAgICAgICAgICB5eSA6ICclZCBhbnMnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShlcnxlKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBtYXNjdWxpbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBtb2lzLCB0cmltZXN0cmUsIGpvdXJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ2VyJyA6ICdlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBXb3JkcyB3aXRoIGZlbWluaW5lIGdyYW1tYXRpY2FsIGdlbmRlcjogc2VtYWluZVxuICAgICAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdyZScgOiAnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnJDYTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2EuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51\n");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var frCh = moment.defineLocale('fr-ch', {\n        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Aujourdhui ] LT',\n            nextDay : '[Demain ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[Hier ] LT',\n            lastWeek : 'dddd [dernier ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dans %s',\n            past : 'il y a %s',\n            s : 'quelques secondes',\n            ss : '%d secondes',\n            m : 'une minute',\n            mm : '%d minutes',\n            h : 'une heure',\n            hh : '%d heures',\n            d : 'un jour',\n            dd : '%d jours',\n            M : 'un mois',\n            MM : '%d mois',\n            y : 'un an',\n            yy : '%d ans'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(er|e)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                // Words with masculine grammatical gender: mois, trimestre, jour\n                default:\n                case 'M':\n                case 'Q':\n                case 'D':\n                case 'DDD':\n                case 'd':\n                    return number + (number === 1 ? 'er' : 'e');\n\n                // Words with feminine grammatical gender: semaine\n                case 'w':\n                case 'W':\n                    return number + (number === 1 ? 're' : 'e');\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return frCh;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jaC5qcz81NGFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZnJDaCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZyLWNoJywge1xuICAgICAgICBtb250aHMgOiAnamFudmllcl9mw6l2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW/Du3Rfc2VwdGVtYnJlX29jdG9icmVfbm92ZW1icmVfZMOpY2VtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW52Ll9mw6l2ci5fbWFyc19hdnIuX21haV9qdWluX2p1aWwuX2Fvw7t0X3NlcHQuX29jdC5fbm92Ll9kw6ljLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ2RpbWFuY2hlX2x1bmRpX21hcmRpX21lcmNyZWRpX2pldWRpX3ZlbmRyZWRpX3NhbWVkaScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdkaW0uX2x1bi5fbWFyLl9tZXIuX2pldS5fdmVuLl9zYW0uJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdkaV9sdV9tYV9tZV9qZV92ZV9zYScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbQXVqb3VyZOKAmWh1aSDDoF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbRGVtYWluIMOgXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvDoF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbSGllciDDoF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbZGVybmllciDDoF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2RhbnMgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdpbCB5IGEgJXMnLFxuICAgICAgICAgICAgcyA6ICdxdWVscXVlcyBzZWNvbmRlcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWNvbmRlcycsXG4gICAgICAgICAgICBtIDogJ3VuZSBtaW51dGUnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgICAgICBoIDogJ3VuZSBoZXVyZScsXG4gICAgICAgICAgICBoaCA6ICclZCBoZXVyZXMnLFxuICAgICAgICAgICAgZCA6ICd1biBqb3VyJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGpvdXJzJyxcbiAgICAgICAgICAgIE0gOiAndW4gbW9pcycsXG4gICAgICAgICAgICBNTSA6ICclZCBtb2lzJyxcbiAgICAgICAgICAgIHkgOiAndW4gYW4nLFxuICAgICAgICAgICAgeXkgOiAnJWQgYW5zJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oZXJ8ZSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggbWFzY3VsaW5lIGdyYW1tYXRpY2FsIGdlbmRlcjogbW9pcywgdHJpbWVzdHJlLCBqb3VyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdlcicgOiAnZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBmZW1pbmluZSBncmFtbWF0aWNhbCBnZW5kZXI6IHNlbWFpbmVcbiAgICAgICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAncmUnIDogJ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnJDaDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2guanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52\n");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),\n        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');\n\n    var fy = moment.defineLocale('fy', {\n        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),\n        monthsShort : function (m, format) {\n            if (!m) {\n                return monthsShortWithDots;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShortWithoutDots[m.month()];\n            } else {\n                return monthsShortWithDots[m.month()];\n            }\n        },\n        monthsParseExact : true,\n        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),\n        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),\n        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[hjoed om] LT',\n            nextDay: '[moarn om] LT',\n            nextWeek: 'dddd [om] LT',\n            lastDay: '[juster om] LT',\n            lastWeek: '[frne] dddd [om] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'oer %s',\n            past : '%s lyn',\n            s : 'in pear sekonden',\n            ss : '%d sekonden',\n            m : 'ien mint',\n            mm : '%d minuten',\n            h : 'ien oere',\n            hh : '%d oeren',\n            d : 'ien dei',\n            dd : '%d dagen',\n            M : 'ien moanne',\n            MM : '%d moannen',\n            y : 'ien jier',\n            yy : '%d jierren'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return fy;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9meS5qcz84M2IyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzU2hvcnRXaXRoRG90cyA9ICdqYW4uX2ZlYi5fbXJ0Ll9hcHIuX21haV9qdW4uX2p1bC5fYXVnLl9zZXAuX29rdC5fbm92Ll9kZXMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydFdpdGhvdXREb3RzID0gJ2phbl9mZWJfbXJ0X2Fwcl9tYWlfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVzJy5zcGxpdCgnXycpO1xuXG4gICAgdmFyIGZ5ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnknLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW5uZXdhcmlzX2ZlYnJld2FyaXNfbWFhcnRfYXByaWxfbWFhaWVfanVueV9qdWx5X2F1Z3VzdHVzX3NlcHRpbWJlcl9va3RvYmVyX25vdmltYmVyX2Rlc2ltYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhvdXREb3RzW20ubW9udGgoKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzW20ubW9udGgoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzbmVpbl9tb2FuZGVpX3RpaXNkZWlfd29hbnNkZWlfdG9uZ2Vyc2RlaV9mcmVlZF9zbmVvbicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzaS5fbW8uX3RpLl93by5fdG8uX2ZyLl9zby4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1NpX01vX1RpX1dvX1RvX0ZyX1NvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELU1NLVlZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW2hqb2VkIG9tXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW21vYXJuIG9tXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW29tXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW2p1c3RlciBvbV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdbw7RmcsO7bmVdIGRkZGQgW29tXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdvZXIgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBseW4nLFxuICAgICAgICAgICAgcyA6ICdpbiBwZWFyIHNla29uZGVuJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla29uZGVuJyxcbiAgICAgICAgICAgIG0gOiAnaWVuIG1pbsO6dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVuJyxcbiAgICAgICAgICAgIGggOiAnaWVuIG9lcmUnLFxuICAgICAgICAgICAgaGggOiAnJWQgb2VyZW4nLFxuICAgICAgICAgICAgZCA6ICdpZW4gZGVpJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZ2VuJyxcbiAgICAgICAgICAgIE0gOiAnaWVuIG1vYW5uZScsXG4gICAgICAgICAgICBNTSA6ICclZCBtb2FubmVuJyxcbiAgICAgICAgICAgIHkgOiAnaWVuIGppZXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgamllcnJlbidcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0ZXxkZSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICgobnVtYmVyID09PSAxIHx8IG51bWJlciA9PT0gOCB8fCBudW1iZXIgPj0gMjApID8gJ3N0ZScgOiAnZGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnk7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2Z5LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var months = [\n        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'\n    ];\n\n    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];\n\n    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];\n\n    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];\n\n    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];\n\n    var gd = moment.defineLocale('gd', {\n        months : months,\n        monthsShort : monthsShort,\n        monthsParseExact : true,\n        weekdays : weekdays,\n        weekdaysShort : weekdaysShort,\n        weekdaysMin : weekdaysMin,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[An-diugh aig] LT',\n            nextDay : '[A-mireach aig] LT',\n            nextWeek : 'dddd [aig] LT',\n            lastDay : '[An-d aig] LT',\n            lastWeek : 'dddd [seo chaidh] [aig] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'ann an %s',\n            past : 'bho chionn %s',\n            s : 'beagan diogan',\n            ss : '%d diogan',\n            m : 'mionaid',\n            mm : '%d mionaidean',\n            h : 'uair',\n            hh : '%d uairean',\n            d : 'latha',\n            dd : '%d latha',\n            M : 'mos',\n            MM : '%d mosan',\n            y : 'bliadhna',\n            yy : '%d bliadhna'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}(d|na|mh)/,\n        ordinal : function (number) {\n            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return gd;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nZC5qcz85Y2IzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG1vbnRocyA9IFtcbiAgICAgICAgJ0FtIEZhb2lsbGVhY2gnLCAnQW4gR2VhcnJhbicsICdBbSBNw6BydCcsICdBbiBHaWJsZWFuJywgJ0FuIEPDqGl0ZWFuJywgJ0FuIHQtw5JnbWhpb3MnLCAnQW4gdC1JdWNoYXInLCAnQW4gTMO5bmFzdGFsJywgJ0FuIHQtU3VsdGFpbicsICdBbiBEw6BtaGFpcicsICdBbiB0LVNhbWhhaW4nLCAnQW4gRMO5YmhsYWNoZCdcbiAgICBdO1xuXG4gICAgdmFyIG1vbnRoc1Nob3J0ID0gWydGYW9pJywgJ0dlYXInLCAnTcOgcnQnLCAnR2libCcsICdDw6hpdCcsICfDkmdtaCcsICdJdWNoJywgJ0zDuW4nLCAnU3VsdCcsICdEw6BtaCcsICdTYW1oJywgJ0TDuWJoJ107XG5cbiAgICB2YXIgd2Vla2RheXMgPSBbJ0RpZMOybWhuYWljaCcsICdEaWx1YWluJywgJ0RpbcOgaXJ0JywgJ0RpY2lhZGFpbicsICdEaWFyZGFvaW4nLCAnRGloYW9pbmUnLCAnRGlzYXRoYWlybmUnXTtcblxuICAgIHZhciB3ZWVrZGF5c1Nob3J0ID0gWydEaWQnLCAnRGlsJywgJ0RpbScsICdEaWMnLCAnRGlhJywgJ0RpaCcsICdEaXMnXTtcblxuICAgIHZhciB3ZWVrZGF5c01pbiA9IFsnRMOyJywgJ0x1JywgJ03DoCcsICdDaScsICdBcicsICdIYScsICdTYSddO1xuXG4gICAgdmFyIGdkID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZ2QnLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogd2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiB3ZWVrZGF5c1Nob3J0LFxuICAgICAgICB3ZWVrZGF5c01pbiA6IHdlZWtkYXlzTWluLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbQW4tZGl1Z2ggYWlnXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tBLW3DoGlyZWFjaCBhaWddIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2FpZ10gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbQW4tZMOoIGFpZ10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbc2VvIGNoYWlkaF0gW2FpZ10gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2FubiBhbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2JobyBjaGlvbm4gJXMnLFxuICAgICAgICAgICAgcyA6ICdiZWFnYW4gZGlvZ2FuJyxcbiAgICAgICAgICAgIHNzIDogJyVkIGRpb2dhbicsXG4gICAgICAgICAgICBtIDogJ21pb25haWQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWlvbmFpZGVhbicsXG4gICAgICAgICAgICBoIDogJ3VhaXInLFxuICAgICAgICAgICAgaGggOiAnJWQgdWFpcmVhbicsXG4gICAgICAgICAgICBkIDogJ2xhdGhhJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGxhdGhhJyxcbiAgICAgICAgICAgIE0gOiAnbcOsb3MnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbcOsb3NhbicsXG4gICAgICAgICAgICB5IDogJ2JsaWFkaG5hJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGJsaWFkaG5hJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9KGR8bmF8bWgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBudW1iZXIgPT09IDEgPyAnZCcgOiBudW1iZXIgJSAxMCA9PT0gMiA/ICduYScgOiAnbWgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ2Q7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dkLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54\n");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var gl = moment.defineLocale('gl', {\n        months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),\n        monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),\n        monthsParseExact: true,\n        weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),\n        weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),\n        weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY H:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextDay : function () {\n                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';\n            },\n            lastDay : function () {\n                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';\n            },\n            lastWeek : function () {\n                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : function (str) {\n                if (str.indexOf('un') === 0) {\n                    return 'n' + str;\n                }\n                return 'en ' + str;\n            },\n            past : 'hai %s',\n            s : 'uns segundos',\n            ss : '%d segundos',\n            m : 'un minuto',\n            mm : '%d minutos',\n            h : 'unha hora',\n            hh : '%d horas',\n            d : 'un da',\n            dd : '%d das',\n            M : 'un mes',\n            MM : '%d meses',\n            y : 'un ano',\n            yy : '%d anos'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return gl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nbC5qcz8xNmU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZ2wgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdnbCcsIHtcbiAgICAgICAgbW9udGhzIDogJ3hhbmVpcm9fZmVicmVpcm9fbWFyem9fYWJyaWxfbWFpb194dcOxb194dWxsb19hZ29zdG9fc2V0ZW1icm9fb3V0dWJyb19ub3ZlbWJyb19kZWNlbWJybycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAneGFuLl9mZWIuX21hci5fYWJyLl9tYWkuX3h1w7EuX3h1bC5fYWdvLl9zZXQuX291dC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdkb21pbmdvX2x1bnNfbWFydGVzX23DqXJjb3Jlc194b3Zlc192ZW5yZXNfc8OhYmFkbycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdkb20uX2x1bi5fbWFyLl9tw6lyLl94b3YuX3Zlbi5fc8OhYi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ2RvX2x1X21hX23DqV94b192ZV9zw6EnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbaG94ZSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhcycgOiAnw6EnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW21hw7HDoSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhcycgOiAnw6EnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RkZGQgWycgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6FzJyA6ICdhJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tvbnRlICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6EnIDogJ2EnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tvXSBkZGRkIFtwYXNhZG8gJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICfDoXMnIDogJ2EnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCd1bicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbicgKyBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnZW4gJyArIHN0cjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXN0IDogJ2hhaSAlcycsXG4gICAgICAgICAgICBzIDogJ3VucyBzZWd1bmRvcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWd1bmRvcycsXG4gICAgICAgICAgICBtIDogJ3VuIG1pbnV0bycsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcbiAgICAgICAgICAgIGggOiAndW5oYSBob3JhJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvcmFzJyxcbiAgICAgICAgICAgIGQgOiAndW4gZMOtYScsXG4gICAgICAgICAgICBkZCA6ICclZCBkw61hcycsXG4gICAgICAgICAgICBNIDogJ3VuIG1lcycsXG4gICAgICAgICAgICBNTSA6ICclZCBtZXNlcycsXG4gICAgICAgICAgICB5IDogJ3VuIGFubycsXG4gICAgICAgICAgICB5eSA6ICclZCBhbm9zJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBnbDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2wuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55\n");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            's': ['thodde secondanim', 'thodde second'],\n            'ss': [number + ' secondanim', number + ' second'],\n            'm': ['eka mintan', 'ek minute'],\n            'mm': [number + ' mintanim', number + ' mintam'],\n            'h': ['eka horan', 'ek hor'],\n            'hh': [number + ' horanim', number + ' horam'],\n            'd': ['eka disan', 'ek dis'],\n            'dd': [number + ' disanim', number + ' dis'],\n            'M': ['eka mhoinean', 'ek mhoino'],\n            'MM': [number + ' mhoineanim', number + ' mhoine'],\n            'y': ['eka vorsan', 'ek voros'],\n            'yy': [number + ' vorsanim', number + ' vorsam']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var gomLatn = moment.defineLocale('gom-latn', {\n        months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),\n        monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\\'var'.split('_'),\n        weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),\n        weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'A h:mm [vazta]',\n            LTS : 'A h:mm:ss [vazta]',\n            L : 'DD-MM-YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY A h:mm [vazta]',\n            LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',\n            llll: 'ddd, D MMM YYYY, A h:mm [vazta]'\n        },\n        calendar : {\n            sameDay: '[Aiz] LT',\n            nextDay: '[Faleam] LT',\n            nextWeek: '[Ieta to] dddd[,] LT',\n            lastDay: '[Kal] LT',\n            lastWeek: '[Fatlo] dddd[,] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s adim',\n            s : processRelativeTime,\n            ss : processRelativeTime,\n            m : processRelativeTime,\n            mm : processRelativeTime,\n            h : processRelativeTime,\n            hh : processRelativeTime,\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}(er)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                // the ordinal 'er' only applies to day of the month\n                case 'D':\n                    return number + 'er';\n                default:\n                case 'M':\n                case 'Q':\n                case 'DDD':\n                case 'd':\n                case 'w':\n                case 'W':\n                    return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        },\n        meridiemParse: /rati|sokalli|donparam|sanje/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'rati') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === 'sokalli') {\n                return hour;\n            } else if (meridiem === 'donparam') {\n                return hour > 12 ? hour : hour + 12;\n            } else if (meridiem === 'sanje') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return 'rati';\n            } else if (hour < 12) {\n                return 'sokalli';\n            } else if (hour < 16) {\n                return 'donparam';\n            } else if (hour < 20) {\n                return 'sanje';\n            } else {\n                return 'rati';\n            }\n        }\n    });\n\n    return gomLatn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nb20tbGF0bi5qcz9mYjZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjU2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ3MnOiBbJ3Rob2RkZSBzZWNvbmRhbmltJywgJ3Rob2RkZSBzZWNvbmQnXSxcbiAgICAgICAgICAgICdzcyc6IFtudW1iZXIgKyAnIHNlY29uZGFuaW0nLCBudW1iZXIgKyAnIHNlY29uZCddLFxuICAgICAgICAgICAgJ20nOiBbJ2VrYSBtaW50YW4nLCAnZWsgbWludXRlJ10sXG4gICAgICAgICAgICAnbW0nOiBbbnVtYmVyICsgJyBtaW50YW5pbScsIG51bWJlciArICcgbWludGFtJ10sXG4gICAgICAgICAgICAnaCc6IFsnZWthIGhvcmFuJywgJ2VrIGhvciddLFxuICAgICAgICAgICAgJ2hoJzogW251bWJlciArICcgaG9yYW5pbScsIG51bWJlciArICcgaG9yYW0nXSxcbiAgICAgICAgICAgICdkJzogWydla2EgZGlzYW4nLCAnZWsgZGlzJ10sXG4gICAgICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBkaXNhbmltJywgbnVtYmVyICsgJyBkaXMnXSxcbiAgICAgICAgICAgICdNJzogWydla2EgbWhvaW5lYW4nLCAnZWsgbWhvaW5vJ10sXG4gICAgICAgICAgICAnTU0nOiBbbnVtYmVyICsgJyBtaG9pbmVhbmltJywgbnVtYmVyICsgJyBtaG9pbmUnXSxcbiAgICAgICAgICAgICd5JzogWydla2Egdm9yc2FuJywgJ2VrIHZvcm9zJ10sXG4gICAgICAgICAgICAneXknOiBbbnVtYmVyICsgJyB2b3JzYW5pbScsIG51bWJlciArICcgdm9yc2FtJ11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xuICAgIH1cblxuICAgIHZhciBnb21MYXRuID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZ29tLWxhdG4nLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW5lcl9GZWJyZXJfTWFyc19BYnJpbF9NYWlfSnVuX0p1bGFpX0Fnb3N0X1NldGVtYnJfT3R1YnJfTm92ZW1icl9EZXplbWJyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW4uX0ZlYi5fTWFyc19BYnIuX01haV9KdW5fSnVsLl9BZ28uX1NldC5fT3R1Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdBaXRhcl9Tb21hcl9Nb25nbGxhcl9CdWR2YXJfQnJlc3Rhcl9TdWtyYXJfU29uXFwndmFyJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0FpdC5fU29tLl9Nb24uX0J1ZC5fQnJlLl9TdWsuX1Nvbi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0FpX1NtX01vX0J1X0JyX1N1X1NuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0EgaDptbSBbdmF6dGFdJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3MgW3ZhenRhXScsXG4gICAgICAgICAgICBMIDogJ0RELU1NLVlZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEEgaDptbSBbdmF6dGFdJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTVthY2hlYV0gRG8sIFlZWVksIEEgaDptbSBbdmF6dGFdJyxcbiAgICAgICAgICAgIGxsbGw6ICdkZGQsIEQgTU1NIFlZWVksIEEgaDptbSBbdmF6dGFdJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbQWl6XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW0ZhbGVhbV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdbSWV0YSB0b10gZGRkZFssXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0thbF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdbRmF0bG9dIGRkZGRbLF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBhZGltJyxcbiAgICAgICAgICAgIHMgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgc3MgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHl5IDogcHJvY2Vzc1JlbGF0aXZlVGltZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9KGVyKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9yZGluYWwgJ2VyJyBvbmx5IGFwcGxpZXMgdG8gZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ2VyJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL3JhdGl8c29rYWxsaXxkb25wYXJhbXxzYW5qZS8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdyYXRpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc29rYWxsaScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdkb25wYXJhbScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+IDEyID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdzYW5qZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmF0aSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc29rYWxsaSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG9ucGFyYW0nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NhbmplJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyYXRpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdvbUxhdG47XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dvbS1sYXRuLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///56\n");

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n            '1': '',\n            '2': '',\n            '3': '',\n            '4': '',\n            '5': '',\n            '6': '',\n            '7': '',\n            '8': '',\n            '9': '',\n            '0': ''\n        },\n        numberMap = {\n            '': '1',\n            '': '2',\n            '': '3',\n            '': '4',\n            '': '5',\n            '': '6',\n            '': '7',\n            '': '8',\n            '': '9',\n            '': '0'\n        };\n\n    var gu = moment.defineLocale('gu', {\n        months: '___________'.split('_'),\n        monthsShort: '._.__.___._._._._._.'.split('_'),\n        monthsParseExact: true,\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        longDateFormat: {\n            LT: 'A h:mm ',\n            LTS: 'A h:mm:ss ',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY, A h:mm ',\n            LLLL: 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar: {\n            sameDay: '[] LT',\n            nextDay: '[] LT',\n            nextWeek: 'dddd, LT',\n            lastDay: '[] LT',\n            lastWeek: '[] dddd, LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: '%s ',\n            past: '%s ',\n            s: ' ',\n            ss: '%d ',\n            m: ' ',\n            mm: '%d ',\n            h: ' ',\n            hh: '%d ',\n            d: ' ',\n            dd: '%d ',\n            M: ' ',\n            MM: '%d ',\n            y: ' ',\n            yy: '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists\n        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.\n        meridiemParse: /|||/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem: function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week: {\n            dow: 0, // Sunday is the first day of the week.\n            doy: 6 // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return gu;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qcz9hZWRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAgICAgJzEnOiAn4KunJyxcbiAgICAgICAgICAgICcyJzogJ+CrqCcsXG4gICAgICAgICAgICAnMyc6ICfgq6knLFxuICAgICAgICAgICAgJzQnOiAn4KuqJyxcbiAgICAgICAgICAgICc1JzogJ+CrqycsXG4gICAgICAgICAgICAnNic6ICfgq6wnLFxuICAgICAgICAgICAgJzcnOiAn4KutJyxcbiAgICAgICAgICAgICc4JzogJ+CrricsXG4gICAgICAgICAgICAnOSc6ICfgq68nLFxuICAgICAgICAgICAgJzAnOiAn4KumJ1xuICAgICAgICB9LFxuICAgICAgICBudW1iZXJNYXAgPSB7XG4gICAgICAgICAgICAn4KunJzogJzEnLFxuICAgICAgICAgICAgJ+CrqCc6ICcyJyxcbiAgICAgICAgICAgICfgq6knOiAnMycsXG4gICAgICAgICAgICAn4KuqJzogJzQnLFxuICAgICAgICAgICAgJ+Crqyc6ICc1JyxcbiAgICAgICAgICAgICfgq6wnOiAnNicsXG4gICAgICAgICAgICAn4KutJzogJzcnLFxuICAgICAgICAgICAgJ+Crric6ICc4JyxcbiAgICAgICAgICAgICfgq68nOiAnOScsXG4gICAgICAgICAgICAn4KumJzogJzAnXG4gICAgICAgIH07XG5cbiAgICB2YXIgZ3UgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdndScsIHtcbiAgICAgICAgbW9udGhzOiAn4Kqc4Kq+4Kqo4KuN4Kqv4KuB4KqG4Kqw4KuAX+Cqq+Crh+CqrOCrjeCqsOCrgeCqhuCqsOCrgF/gqq7gqr7gqrDgq43gqppf4KqP4Kqq4KuN4Kqw4Kq/4KqyX+CqruCrh1/gqpzgq4Lgqqhf4Kqc4KuB4Kqy4Kq+4KqIX+CqkeCql+CquOCrjeCqn1/gqrjgqqrgq43gqp/gq4fgqq7gq43gqqzgqrBf4KqR4KqV4KuN4Kqf4KuN4Kqs4KqwX+CqqOCqteCrh+CqruCrjeCqrOCqsF/gqqHgqr/gqrjgq4fgqq7gq43gqqzgqrAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0OiAn4Kqc4Kq+4Kqo4KuN4Kqv4KuBLl/gqqvgq4fgqqzgq43gqrDgq4EuX+CqruCqvuCqsOCrjeCqml/gqo/gqqrgq43gqrDgqr8uX+CqruCrh1/gqpzgq4Lgqqhf4Kqc4KuB4Kqy4Kq+Ll/gqpHgqpcuX+CquOCqquCrjeCqn+Crhy5f4KqR4KqV4KuN4Kqf4KuNLl/gqqjgqrXgq4cuX+CqoeCqv+CquOCrhy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzOiAn4Kqw4Kq14Kq/4Kq14Kq+4KqwX+CquOCri+CqruCqteCqvuCqsF/gqq7gqoLgqpfgqrPgqrXgqr7gqrBf4Kqs4KuB4Kqn4KuN4Kq14Kq+4KqwX+Cql+CrgeCqsOCrgeCqteCqvuCqsF/gqrbgq4HgqpXgq43gqrDgqrXgqr7gqrBf4Kq24Kqo4Kq/4Kq14Kq+4KqwJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiAn4Kqw4Kq14Kq/X+CquOCri+Cqrl/gqq7gqoLgqpfgqrNf4Kqs4KuB4Kqn4KuNX+Cql+CrgeCqsOCrgV/gqrbgq4HgqpXgq43gqrBf4Kq24Kqo4Kq/Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbjogJ+CqsF/gqrjgq4tf4Kqu4KqCX+CqrOCrgV/gqpfgq4Ff4Kq24KuBX+Cqticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnQSBoOm1tIOCqteCqvuCql+CrjeCqr+CrhycsXG4gICAgICAgICAgICBMVFM6ICdBIGg6bW06c3Mg4Kq14Kq+4KqX4KuN4Kqv4KuHJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgqrXgqr7gqpfgq43gqq/gq4cnLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0g4Kq14Kq+4KqX4KuN4Kqv4KuHJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhcjoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vgqobgqpxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb4KqV4Kq+4Kqy4KuHXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQsIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb4KqX4KqH4KqV4Kq+4Kqy4KuHXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1vgqqrgqr7gqpvgqrLgqr5dIGRkZGQsIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiB7XG4gICAgICAgICAgICBmdXR1cmU6ICclcyDgqq7gqr4nLFxuICAgICAgICAgICAgcGFzdDogJyVzIOCqquCrh+CqueCqsuCqvicsXG4gICAgICAgICAgICBzOiAn4KqF4Kqu4KuB4KqVIOCqquCqs+CriycsXG4gICAgICAgICAgICBzczogJyVkIOCquOCrh+CqleCqguCqoScsXG4gICAgICAgICAgICBtOiAn4KqP4KqVIOCqruCqv+CqqOCqv+CqnycsXG4gICAgICAgICAgICBtbTogJyVkIOCqruCqv+CqqOCqv+CqnycsXG4gICAgICAgICAgICBoOiAn4KqP4KqVIOCqleCqsuCqvuCqlScsXG4gICAgICAgICAgICBoaDogJyVkIOCqleCqsuCqvuCqlScsXG4gICAgICAgICAgICBkOiAn4KqP4KqVIOCqpuCqv+CqteCquCcsXG4gICAgICAgICAgICBkZDogJyVkIOCqpuCqv+CqteCquCcsXG4gICAgICAgICAgICBNOiAn4KqP4KqVIOCqruCqueCqv+CqqOCriycsXG4gICAgICAgICAgICBNTTogJyVkIOCqruCqueCqv+CqqOCriycsXG4gICAgICAgICAgICB5OiAn4KqP4KqVIOCqteCqsOCrjeCqtycsXG4gICAgICAgICAgICB5eTogJyVkIOCqteCqsOCrjeCqtydcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Crp+CrqOCrqeCrquCrq+CrrOCrreCrruCrr+Crpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR3VqYXJhdGkgbm90YXRpb24gZm9yIG1lcmlkaWVtcyBhcmUgcXVpdGUgZnV6enkgaW4gcHJhY3RpY2UuIFdoaWxlIHRoZXJlIGV4aXN0c1xuICAgICAgICAvLyBhIHJpZ2lkIG5vdGlvbiBvZiBhICdQYWhhcicgaXQgaXMgbm90IHVzZWQgYXMgcmlnaWRseSBpbiBtb2Rlcm4gR3VqYXJhdGkuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/gqrDgqr7gqqR84Kqs4Kqq4KuL4KqwfOCquOCqteCqvuCqsHzgqrjgqr7gqoLgqpwvLFxuICAgICAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgqrDgqr7gqqQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqrjgqrXgqr7gqrAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4Kqs4Kqq4KuL4KqwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqrjgqr7gqoLgqpwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Kqw4Kq+4KqkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgqrjgqrXgqr7gqrAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CqrOCqquCri+CqsCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Kq44Kq+4KqC4KqcJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgqrDgqr7gqqQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95OiA2IC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGd1O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57\n");

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var he = moment.defineLocale('he', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D []MMMM YYYY',\n            LLL : 'D []MMMM YYYY HH:mm',\n            LLLL : 'dddd, D []MMMM YYYY HH:mm',\n            l : 'D/M/YYYY',\n            ll : 'D MMM YYYY',\n            lll : 'D MMM YYYY HH:mm',\n            llll : 'ddd, D MMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ]LT',\n            nextDay : '[ ]LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ]LT',\n            lastWeek : '[] dddd [ ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : ' ',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : function (number) {\n                if (number === 2) {\n                    return '';\n                }\n                return number + ' ';\n            },\n            d : '',\n            dd : function (number) {\n                if (number === 2) {\n                    return '';\n                }\n                return number + ' ';\n            },\n            M : '',\n            MM : function (number) {\n                if (number === 2) {\n                    return '';\n                }\n                return number + ' ';\n            },\n            y : '',\n            yy : function (number) {\n                if (number === 2) {\n                    return '';\n                } else if (number % 10 === 0 && number !== 10) {\n                    return number + ' ';\n                }\n                return number + ' ';\n            }\n        },\n        meridiemParse: /\"|\"| | | ||/i,\n        isPM : function (input) {\n            return /^(\"| |)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 5) {\n                return ' ';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 12) {\n                return isLower ? '\"' : ' ';\n            } else if (hour < 18) {\n                return isLower ? '\"' : ' ';\n            } else {\n                return '';\n            }\n        }\n    });\n\n    return he;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oZS5qcz8zNzNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgaGUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdoZScsIHtcbiAgICAgICAgbW9udGhzIDogJ9eZ16DXldeQ16hf16TXkdeo15XXkNeoX9ee16jXpV/XkNek16jXmdecX9ee15DXmV/XmdeV16DXmV/XmdeV15zXmV/XkNeV15LXldeh15hf16HXpNeY157XkdeoX9eQ15XXp9eY15XXkdeoX9eg15XXkdee15HXqF/Xk9em157XkdeoJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfXmdeg15XXs1/XpNeR16jXs1/Xnteo16Vf15DXpNeo17Nf157XkNeZX9eZ15XXoNeZX9eZ15XXnNeZX9eQ15XXktezX9eh16TXmNezX9eQ15XXp9ezX9eg15XXkdezX9eT16bXntezJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfXqNeQ16nXldefX9ep16DXmV/Xqdec15nXqdeZX9eo15HXmdei15lf15fXnteZ16nXmV/XqdeZ16nXmV/XqdeR16onLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn15DXs1/XkdezX9eS17Nf15PXs1/XlNezX9eV17Nf16nXsycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn15Bf15Ff15Jf15Nf15Rf15Vf16knLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIFvXkV1NTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgW9eRXU1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgW9eRXU1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBsIDogJ0QvTS9ZWVlZJyxcbiAgICAgICAgICAgIGxsIDogJ0QgTU1NIFlZWVknLFxuICAgICAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgbGxsbCA6ICdkZGQsIEQgTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb15TXmdeV150g15HWvl1MVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vXnteX16gg15HWvl1MVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvXkdep16LXlF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb15DXqtee15XXnCDXkda+XUxUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vXkdeZ15XXnV0gZGRkZCBb15TXkNeX16jXldefINeR16nXoteUXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn15HXoteV15MgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfXnNek16DXmSAlcycsXG4gICAgICAgICAgICBzIDogJ9ee16HXpNeoINep16DXmdeV16onLFxuICAgICAgICAgICAgc3MgOiAnJWQg16nXoNeZ15XXqicsXG4gICAgICAgICAgICBtIDogJ9eT16fXlCcsXG4gICAgICAgICAgICBtbSA6ICclZCDXk9en15XXqicsXG4gICAgICAgICAgICBoIDogJ9ep16LXlCcsXG4gICAgICAgICAgICBoaCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAn16nXoteq15nXmdedJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg16nXoteV16onO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGQgOiAn15nXldedJyxcbiAgICAgICAgICAgIGRkIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICfXmdeV157XmdeZ150nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXmdee15nXnSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTSA6ICfXl9eV15PXqScsXG4gICAgICAgICAgICBNTSA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAn15fXldeT16nXmdeZ150nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXl9eV15PXqdeZ150nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHkgOiAn16nXoNeUJyxcbiAgICAgICAgICAgIHl5IDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICfXqdeg16rXmdeZ150nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyICUgMTAgPT09IDAgJiYgbnVtYmVyICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXqdeg15QnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXqdeg15nXnSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/XkNeX15RcItemfNec16TXoNeUXCLXpnzXkNeX16jXmSDXlNem15TXqNeZ15nXnXzXnNek16DXmSDXlNem15TXqNeZ15nXnXzXnNek16DXldeqINeR15XXp9eofNeR15HXlden16h815HXoteo15EvaSxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eKNeQ15fXlFwi16Z815DXl9eo15kg15TXpteU16jXmdeZ151815HXoteo15EpJC8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCA1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfXnNek16DXldeqINeR15XXp9eoJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfXkdeR15XXp9eoJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAn15zXpNeg15RcItemJyA6ICfXnNek16DXmSDXlNem15TXqNeZ15nXnSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ9eQ15fXlFwi16YnIDogJ9eQ15fXqNeZINeU16bXlNeo15nXmdedJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfXkdei16jXkSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoZTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGUuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58\n");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var hi = moment.defineLocale('hi', {\n        months : '___________'.split('_'),\n        monthsShort : '._.__.___._._._._._.'.split('_'),\n        monthsParseExact: true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '  ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        // Hindi notation for meridiems are quite fuzzy in practice. While there exists\n        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return hi;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oaS5qcz8xMTMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfgpacnLFxuICAgICAgICAnMic6ICfgpagnLFxuICAgICAgICAnMyc6ICfgpaknLFxuICAgICAgICAnNCc6ICfgpaonLFxuICAgICAgICAnNSc6ICfgpasnLFxuICAgICAgICAnNic6ICfgpawnLFxuICAgICAgICAnNyc6ICfgpa0nLFxuICAgICAgICAnOCc6ICfgpa4nLFxuICAgICAgICAnOSc6ICfgpa8nLFxuICAgICAgICAnMCc6ICfgpaYnXG4gICAgfSxcbiAgICBudW1iZXJNYXAgPSB7XG4gICAgICAgICfgpacnOiAnMScsXG4gICAgICAgICfgpagnOiAnMicsXG4gICAgICAgICfgpaknOiAnMycsXG4gICAgICAgICfgpaonOiAnNCcsXG4gICAgICAgICfgpasnOiAnNScsXG4gICAgICAgICfgpawnOiAnNicsXG4gICAgICAgICfgpa0nOiAnNycsXG4gICAgICAgICfgpa4nOiAnOCcsXG4gICAgICAgICfgpa8nOiAnOScsXG4gICAgICAgICfgpaYnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIGhpID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaGknLCB7XG4gICAgICAgIG1vbnRocyA6ICfgpJzgpKjgpLXgpLDgpYBf4KSr4KS84KSw4KS14KSw4KWAX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpYjgpLJf4KSu4KSIX+CknOClguCkqF/gpJzgpYHgpLLgpL7gpIhf4KSF4KSX4KS44KWN4KSkX+CkuOCkv+CkpOCkruCljeCkrOCksF/gpIXgpJXgpY3gpJ/gpYLgpKzgpLBf4KSo4KS14KSu4KWN4KSs4KSwX+CkpuCkv+CkuOCkruCljeCkrOCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4KSc4KSoLl/gpKvgpLzgpLAuX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpYguX+CkruCkiF/gpJzgpYLgpKhf4KSc4KWB4KSyLl/gpIXgpJcuX+CkuOCkv+CkpC5f4KSF4KSV4KWN4KSf4KWCLl/gpKjgpLUuX+CkpuCkv+CkuC4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ+CksOCkteCkv+CkteCkvuCksF/gpLjgpYvgpK7gpLXgpL7gpLBf4KSu4KSC4KSX4KSy4KS14KS+4KSwX+CkrOClgeCkp+CkteCkvuCksF/gpJfgpYHgpLDgpYLgpLXgpL7gpLBf4KS24KWB4KSV4KWN4KSw4KS14KS+4KSwX+CktuCkqOCkv+CkteCkvuCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgpLDgpLXgpL9f4KS44KWL4KSuX+CkruCkguCkl+Cksl/gpKzgpYHgpKdf4KSX4KWB4KSw4KWCX+CktuClgeCkleCljeCksF/gpLbgpKjgpL8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+CksF/gpLjgpYtf4KSu4KSCX+CkrOClgV/gpJfgpYFf4KS24KWBX+Ckticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0g4KSs4KSc4KWHJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4KSs4KSc4KWHJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgpKzgpJzgpYcnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCkrOCknOClhydcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgpIbgpJxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CkleCksl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KSV4KSyXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4KSq4KS/4KSb4KSy4KWHXSBkZGRkLCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg4KSu4KWH4KSCJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg4KSq4KS54KSy4KWHJyxcbiAgICAgICAgICAgIHMgOiAn4KSV4KWB4KSbIOCkueClgCDgpJXgpY3gpLfgpKMnLFxuICAgICAgICAgICAgc3MgOiAnJWQg4KS44KWH4KSV4KSC4KShJyxcbiAgICAgICAgICAgIG0gOiAn4KSP4KSVIOCkruCkv+CkqOCknycsXG4gICAgICAgICAgICBtbSA6ICclZCDgpK7gpL/gpKjgpJ8nLFxuICAgICAgICAgICAgaCA6ICfgpI/gpJUg4KSY4KSC4KSf4KS+JyxcbiAgICAgICAgICAgIGhoIDogJyVkIOCkmOCkguCkn+ClhycsXG4gICAgICAgICAgICBkIDogJ+Ckj+CklSDgpKbgpL/gpKgnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4KSm4KS/4KSoJyxcbiAgICAgICAgICAgIE0gOiAn4KSP4KSVIOCkruCkueClgOCkqOClhycsXG4gICAgICAgICAgICBNTSA6ICclZCDgpK7gpLngpYDgpKjgpYcnLFxuICAgICAgICAgICAgeSA6ICfgpI/gpJUg4KS14KSw4KWN4KS3JyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCkteCksOCljeCktydcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Clp+ClqOClqeClquClq+ClrOClreClruClr+Clpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSGluZGkgbm90YXRpb24gZm9yIG1lcmlkaWVtcyBhcmUgcXVpdGUgZnV6enkgaW4gcHJhY3RpY2UuIFdoaWxlIHRoZXJlIGV4aXN0c1xuICAgICAgICAvLyBhIHJpZ2lkIG5vdGlvbiBvZiBhICdQYWhhcicgaXQgaXMgbm90IHVzZWQgYXMgcmlnaWRseSBpbiBtb2Rlcm4gSGluZGkuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/gpLDgpL7gpKR84KS44KWB4KSs4KS5fOCkpuCli+CkquCkueCksHzgpLbgpL7gpK4vLFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4KSw4KS+4KSkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KS44KWB4KSs4KS5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkpuCli+CkquCkueCksCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KS24KS+4KSuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CkuOClgeCkrOCkuSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSm4KWL4KSq4KS54KSwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLbgpL7gpK4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhpO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oaS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59\n");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function translate(number, withoutSuffix, key) {\n        var result = number + ' ';\n        switch (key) {\n            case 'ss':\n                if (number === 1) {\n                    result += 'sekunda';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'sekunde';\n                } else {\n                    result += 'sekundi';\n                }\n                return result;\n            case 'm':\n                return withoutSuffix ? 'jedna minuta' : 'jedne minute';\n            case 'mm':\n                if (number === 1) {\n                    result += 'minuta';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'minute';\n                } else {\n                    result += 'minuta';\n                }\n                return result;\n            case 'h':\n                return withoutSuffix ? 'jedan sat' : 'jednog sata';\n            case 'hh':\n                if (number === 1) {\n                    result += 'sat';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'sata';\n                } else {\n                    result += 'sati';\n                }\n                return result;\n            case 'dd':\n                if (number === 1) {\n                    result += 'dan';\n                } else {\n                    result += 'dana';\n                }\n                return result;\n            case 'MM':\n                if (number === 1) {\n                    result += 'mjesec';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'mjeseca';\n                } else {\n                    result += 'mjeseci';\n                }\n                return result;\n            case 'yy':\n                if (number === 1) {\n                    result += 'godina';\n                } else if (number === 2 || number === 3 || number === 4) {\n                    result += 'godine';\n                } else {\n                    result += 'godina';\n                }\n                return result;\n        }\n    }\n\n    var hr = moment.defineLocale('hr', {\n        months : {\n            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),\n            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')\n        },\n        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),\n        monthsParseExact: true,\n        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[danas u] LT',\n            nextDay  : '[sutra u] LT',\n            nextWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[u] [nedjelju] [u] LT';\n                    case 3:\n                        return '[u] [srijedu] [u] LT';\n                    case 6:\n                        return '[u] [subotu] [u] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[juer u] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                    case 3:\n                        return '[prolu] dddd [u] LT';\n                    case 6:\n                        return '[prole] [subote] [u] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[proli] dddd [u] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'prije %s',\n            s      : 'par sekundi',\n            ss     : translate,\n            m      : translate,\n            mm     : translate,\n            h      : translate,\n            hh     : translate,\n            d      : 'dan',\n            dd     : translate,\n            M      : 'mjesec',\n            MM     : translate,\n            y      : 'godinu',\n            yy     : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return hr;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oci5qcz81NzhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdzcyc6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3Nla3VuZGEnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzZWt1bmRlJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3Nla3VuZGknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnamVkbmEgbWludXRhJyA6ICdqZWRuZSBtaW51dGUnO1xuICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGEnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRhJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2plZGFuIHNhdCcgOiAnamVkbm9nIHNhdGEnO1xuICAgICAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXRhJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdGknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdkYW4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZGFuYSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlYyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2EnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWplc2VjaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlICd5eSc6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluYSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluZSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaHInLCB7XG4gICAgICAgIG1vbnRocyA6IHtcbiAgICAgICAgICAgIGZvcm1hdDogJ3NpamXEjW5qYV92ZWxqYcSNZV9vxb51amthX3RyYXZuamFfc3ZpYm5qYV9saXBuamFfc3JwbmphX2tvbG92b3phX3J1am5hX2xpc3RvcGFkYV9zdHVkZW5vZ2FfcHJvc2luY2EnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBzdGFuZGFsb25lOiAnc2lqZcSNYW5qX3ZlbGphxI1hX2/FvnVqYWtfdHJhdmFual9zdmliYW5qX2xpcGFual9zcnBhbmpfa29sb3Zvel9ydWphbl9saXN0b3BhZF9zdHVkZW5pX3Byb3NpbmFjJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ3Npai5fdmVsai5fb8W+dS5fdHJhLl9zdmkuX2xpcC5fc3JwLl9rb2wuX3J1ai5fbGlzLl9zdHUuX3Byby4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ25lZGplbGphX3BvbmVkamVsamFrX3V0b3Jha19zcmlqZWRhX8SNZXR2cnRha19wZXRha19zdWJvdGEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVkLl9wb24uX3V0by5fc3JpLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ25lX3BvX3V0X3NyX8SNZV9wZV9zdScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSAgOiAnW2RhbmFzIHVdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgIDogJ1tzdXRyYSB1XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGplbGp1XSBbdV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3JpamVkdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3N1Ym90dV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWVyIHVdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Byb8WhbHVdIGRkZGQgW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsaV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxuICAgICAgICAgICAgcGFzdCAgIDogJ3ByaWplICVzJyxcbiAgICAgICAgICAgIHMgICAgICA6ICdwYXIgc2VrdW5kaScsXG4gICAgICAgICAgICBzcyAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtICAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoICAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkICAgICAgOiAnZGFuJyxcbiAgICAgICAgICAgIGRkICAgICA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gICAgICA6ICdtamVzZWMnLFxuICAgICAgICAgICAgTU0gICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeSAgICAgIDogJ2dvZGludScsXG4gICAgICAgICAgICB5eSAgICAgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBocjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHIuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60\n");

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');\n    function translate(number, withoutSuffix, key, isFuture) {\n        var num = number;\n        switch (key) {\n            case 's':\n                return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';\n            case 'ss':\n                return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';\n            case 'm':\n                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');\n            case 'mm':\n                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');\n            case 'h':\n                return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');\n            case 'hh':\n                return num + (isFuture || withoutSuffix ? ' ra' : ' rja');\n            case 'd':\n                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');\n            case 'dd':\n                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');\n            case 'M':\n                return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');\n            case 'MM':\n                return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');\n            case 'y':\n                return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');\n            case 'yy':\n                return num + (isFuture || withoutSuffix ? ' v' : ' ve');\n        }\n        return '';\n    }\n    function week(isFuture) {\n        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';\n    }\n\n    var hu = moment.defineLocale('hu', {\n        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),\n        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),\n        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),\n        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),\n        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'YYYY.MM.DD.',\n            LL : 'YYYY. MMMM D.',\n            LLL : 'YYYY. MMMM D. H:mm',\n            LLLL : 'YYYY. MMMM D., dddd H:mm'\n        },\n        meridiemParse: /de|du/i,\n        isPM: function (input) {\n            return input.charAt(1).toLowerCase() === 'u';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 12) {\n                return isLower === true ? 'de' : 'DE';\n            } else {\n                return isLower === true ? 'du' : 'DU';\n            }\n        },\n        calendar : {\n            sameDay : '[ma] LT[-kor]',\n            nextDay : '[holnap] LT[-kor]',\n            nextWeek : function () {\n                return week.call(this, true);\n            },\n            lastDay : '[tegnap] LT[-kor]',\n            lastWeek : function () {\n                return week.call(this, false);\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s mlva',\n            past : '%s',\n            s : translate,\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : translate,\n            hh : translate,\n            d : translate,\n            dd : translate,\n            M : translate,\n            MM : translate,\n            y : translate,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return hu;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9odS5qcz9jNjc3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjYxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgd2Vla0VuZGluZ3MgPSAndmFzw6FybmFwIGjDqXRmxZFuIGtlZGRlbiBzemVyZMOhbiBjc8O8dMO2cnTDtmvDtm4gcMOpbnRla2VuIHN6b21iYXRvbicuc3BsaXQoJyAnKTtcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBudW0gPSBudW1iZXI7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXgpID8gJ27DqWjDoW55IG3DoXNvZHBlcmMnIDogJ27DqWjDoW55IG3DoXNvZHBlcmNlJztcbiAgICAgICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXgpID8gJyBtw6Fzb2RwZXJjJyA6ICcgbcOhc29kcGVyY2UnO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdlZ3knICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIHBlcmMnIDogJyBwZXJjZScpO1xuICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgcGVyYycgOiAnIHBlcmNlJyk7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw7NyYScgOiAnIMOzcsOhamEnKTtcbiAgICAgICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIMOzcmEnIDogJyDDs3LDoWphJyk7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgbmFwJyA6ICcgbmFwamEnKTtcbiAgICAgICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIG5hcCcgOiAnIG5hcGphJyk7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgaMOzbmFwJyA6ICcgaMOzbmFwamEnKTtcbiAgICAgICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIGjDs25hcCcgOiAnIGjDs25hcGphJyk7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw6l2JyA6ICcgw6l2ZScpO1xuICAgICAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw6l2JyA6ICcgw6l2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Vlayhpc0Z1dHVyZSkge1xuICAgICAgICByZXR1cm4gKGlzRnV0dXJlID8gJycgOiAnW23Dumx0XSAnKSArICdbJyArIHdlZWtFbmRpbmdzW3RoaXMuZGF5KCldICsgJ10gTFRbLWtvcl0nO1xuICAgIH1cblxuICAgIHZhciBodSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2h1Jywge1xuICAgICAgICBtb250aHMgOiAnamFudcOhcl9mZWJydcOhcl9tw6FyY2l1c1/DoXByaWxpc19tw6FqdXNfasO6bml1c19qw7psaXVzX2F1Z3VzenR1c19zemVwdGVtYmVyX29rdMOzYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX23DoXJjX8OhcHJfbcOhal9qw7puX2rDumxfYXVnX3N6ZXB0X29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICd2YXPDoXJuYXBfaMOpdGbFkV9rZWRkX3N6ZXJkYV9jc8O8dMO2cnTDtmtfcMOpbnRla19zem9tYmF0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3Zhc19ow6l0X2tlZGRfc3plX2Nzw7x0X3DDqW5fc3pvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICd2X2hfa19zemVfY3NfcF9zem8nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ1lZWVkuTU0uREQuJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVkuIE1NTU0gRC4nLFxuICAgICAgICAgICAgTExMIDogJ1lZWVkuIE1NTU0gRC4gSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ1lZWVkuIE1NTU0gRC4sIGRkZGQgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL2RlfGR1L2ksXG4gICAgICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAndSc7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID09PSB0cnVlID8gJ2RlJyA6ICdERSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID09PSB0cnVlID8gJ2R1JyA6ICdEVSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbbWFdIExUWy1rb3JdJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW2hvbG5hcF0gTFRbLWtvcl0nLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlZWsuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1t0ZWduYXBdIExUWy1rb3JdJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3ZWVrLmNhbGwodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyBtw7psdmEnLFxuICAgICAgICAgICAgcGFzdCA6ICclcycsXG4gICAgICAgICAgICBzIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgc3MgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeXkgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBodTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61\n");

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var hyAm = moment.defineLocale('hy-am', {\n        months : {\n            format: '___________'.split('_'),\n            standalone: '___________'.split('_')\n        },\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: '[] LT',\n            nextDay: '[] LT',\n            lastDay: '[] LT',\n            nextWeek: function () {\n                return 'dddd [ ] LT';\n            },\n            lastWeek: function () {\n                return '[] dddd [ ] LT';\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '  ',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        meridiemParse: /|||/,\n        isPM: function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}|\\d{1,2}-(|)/,\n        ordinal: function (number, period) {\n            switch (period) {\n                case 'DDD':\n                case 'w':\n                case 'W':\n                case 'DDDo':\n                    if (number === 1) {\n                        return number + '-';\n                    }\n                    return number + '-';\n                default:\n                    return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return hyAm;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oeS1hbS5qcz8xYWI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJLElBQUksSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGh5QW0gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdoeS1hbScsIHtcbiAgICAgICAgbW9udGhzIDoge1xuICAgICAgICAgICAgZm9ybWF0OiAn1bDVuNaC1bbVvtWh1oDVq1/Wg9Wl1b/WgNW+1aHWgNWrX9W01aHWgNW/1atf1aHVutaA1avVrNWrX9W01aHVtdWr1b3Vq1/VsNW41oLVttWr1b3Vq1/VsNW41oLVrNWr1b3Vq1/WhdWj1bjVvdW/1bjVvdWrX9W91aXVutW/1aXVtNWi1aXWgNWrX9Ww1bjVr9W/1aXVtNWi1aXWgNWrX9W21bjVtdWl1bTVotWl1oDVq1/VpNWl1a/Vv9Wl1bTVotWl1oDVqycuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgIHN0YW5kYWxvbmU6ICfVsNW41oLVttW+1aHWgF/Wg9Wl1b/WgNW+1aHWgF/VtNWh1oDVv1/VodW61oDVq9WsX9W01aHVtdWr1b1f1bDVuNaC1bbVq9W9X9Ww1bjWgtWs1avVvV/WhdWj1bjVvdW/1bjVvV/VvdWl1brVv9Wl1bTVotWl1oBf1bDVuNWv1b/VpdW01aLVpdaAX9W21bjVtdWl1bTVotWl1oBf1aTVpdWv1b/VpdW01aLVpdaAJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9Ww1bbVvl/Wg9W/1oBf1bTWgNW/X9Wh1brWgF/VtNW11b1f1bDVttW9X9Ww1azVvV/WhdWj1b1f1b3VutW/X9Ww1a/Vv1/VttW01aJf1aTVr9W/Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfVr9Wr1oDVodWv1atf1aXWgNWv1bjWgtW31aHVotWp1atf1aXWgNWl1oTVt9Wh1aLVqdWrX9W51bjWgNWl1oTVt9Wh1aLVqdWrX9Ww1avVttWj1bfVodWi1anVq1/VuNaC1oDVotWh1alf1bfVodWi1aHVqScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfVr9aA1a9f1aXWgNWvX9Wl1oDWhF/VudaA1oRf1bDVttWjX9W41oLWgNWiX9W31aLVqScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn1a/WgNWvX9Wl1oDVr1/VpdaA1oRf1bnWgNaEX9Ww1bbVo1/VuNaC1oDVol/Vt9Wi1aknLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWSDVqS4nLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINWpLiwgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSDVqS4sIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb1aHVtdW91oXWgF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vVvtWh1bLVqF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1vVpdaA1aXVr10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RkZGQgW9aF1oDVqCDVqtWh1bTVqF0gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdb1aHVttaB1aHVrl0gZGRkZCBb1oXWgNWoINWq1aHVtNWoXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg1bDVpdW/1bgnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDVodW81aHVuycsXG4gICAgICAgICAgICBzIDogJ9W01asg1oTVodW21asg1b7VodW11oDVr9W11aHVticsXG4gICAgICAgICAgICBzcyA6ICclZCDVvtWh1bXWgNWv1bXVodW2JyxcbiAgICAgICAgICAgIG0gOiAn1oDVuNW61aUnLFxuICAgICAgICAgICAgbW0gOiAnJWQg1oDVuNW61aUnLFxuICAgICAgICAgICAgaCA6ICfVqtWh1bQnLFxuICAgICAgICAgICAgaGggOiAnJWQg1arVodW0JyxcbiAgICAgICAgICAgIGQgOiAn1oXWgCcsXG4gICAgICAgICAgICBkZCA6ICclZCDWhdaAJyxcbiAgICAgICAgICAgIE0gOiAn1aHVtNWr1b0nLFxuICAgICAgICAgICAgTU0gOiAnJWQg1aHVtNWr1b0nLFxuICAgICAgICAgICAgeSA6ICfVv9Wh1oDVqycsXG4gICAgICAgICAgICB5eSA6ICclZCDVv9Wh1oDVqydcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL9Wj1avVt9Wl1oDVvtWhfNWh1bzVodW+1bjVv9W+1aF81oHVpdaA1aXVr9W+1aF81aXWgNWl1a/VuNW11aHVti8sXG4gICAgICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eKNaB1aXWgNWl1a/VvtWhfNWl1oDVpdWv1bjVtdWh1bYpJC8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn1aPVq9W31aXWgNW+1aEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9Wh1bzVodW+1bjVv9W+1aEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9aB1aXWgNWl1a/VvtWhJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfVpdaA1aXVr9W41bXVodW2JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9fFxcZHsxLDJ9LSjVq9W2fNaA1aQpLyxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnREREbyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdWr1bYnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdaA1aQnO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGh5QW07XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62\n");

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var id = moment.defineLocale('id', {\n        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),\n        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),\n        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),\n        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /pagi|siang|sore|malam/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'pagi') {\n                return hour;\n            } else if (meridiem === 'siang') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'sore' || meridiem === 'malam') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'pagi';\n            } else if (hours < 15) {\n                return 'siang';\n            } else if (hours < 19) {\n                return 'sore';\n            } else {\n                return 'malam';\n            }\n        },\n        calendar : {\n            sameDay : '[Hari ini pukul] LT',\n            nextDay : '[Besok pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kemarin pukul] LT',\n            lastWeek : 'dddd [lalu pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dalam %s',\n            past : '%s yang lalu',\n            s : 'beberapa detik',\n            ss : '%d detik',\n            m : 'semenit',\n            mm : '%d menit',\n            h : 'sejam',\n            hh : '%d jam',\n            d : 'sehari',\n            dd : '%d hari',\n            M : 'sebulan',\n            MM : '%d bulan',\n            y : 'setahun',\n            yy : '%d tahun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return id;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pZC5qcz9jOTE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBpZCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2lkJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYXJldF9BcHJpbF9NZWlfSnVuaV9KdWxpX0FndXN0dXNfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NZWlfSnVuX0p1bF9BZ3RfU2VwX09rdF9Ob3ZfRGVzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdNaW5nZ3VfU2VuaW5fU2VsYXNhX1JhYnVfS2FtaXNfSnVtYXRfU2FidHUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnTWluX1Nlbl9TZWxfUmFiX0thbV9KdW1fU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdNZ19Tbl9TbF9SYl9LbV9KbV9TYicuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISC5tbScsXG4gICAgICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL3BhZ2l8c2lhbmd8c29yZXxtYWxhbS8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdwYWdpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NpYW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdzb3JlJyB8fCBtZXJpZGllbSA9PT0gJ21hbGFtJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGFnaSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NpYW5nJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc29yZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbWFsYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW0hhcmkgaW5pIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tCZXNvayBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbcHVrdWxdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0tlbWFyaW4gcHVrdWxdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xhbHUgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdkYWxhbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHlhbmcgbGFsdScsXG4gICAgICAgICAgICBzIDogJ2JlYmVyYXBhIGRldGlrJyxcbiAgICAgICAgICAgIHNzIDogJyVkIGRldGlrJyxcbiAgICAgICAgICAgIG0gOiAnc2VtZW5pdCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtZW5pdCcsXG4gICAgICAgICAgICBoIDogJ3NlamFtJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGphbScsXG4gICAgICAgICAgICBkIDogJ3NlaGFyaScsXG4gICAgICAgICAgICBkZCA6ICclZCBoYXJpJyxcbiAgICAgICAgICAgIE0gOiAnc2VidWxhbicsXG4gICAgICAgICAgICBNTSA6ICclZCBidWxhbicsXG4gICAgICAgICAgICB5IDogJ3NldGFodW4nLFxuICAgICAgICAgICAgeXkgOiAnJWQgdGFodW4nXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlkO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pZC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63\n");

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function plural(n) {\n        if (n % 100 === 11) {\n            return true;\n        } else if (n % 10 === 1) {\n            return false;\n        }\n        return true;\n    }\n    function translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n            case 's':\n                return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';\n            case 'ss':\n                if (plural(number)) {\n                    return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');\n                }\n                return result + 'seknda';\n            case 'm':\n                return withoutSuffix ? 'mnta' : 'mntu';\n            case 'mm':\n                if (plural(number)) {\n                    return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');\n                } else if (withoutSuffix) {\n                    return result + 'mnta';\n                }\n                return result + 'mntu';\n            case 'hh':\n                if (plural(number)) {\n                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');\n                }\n                return result + 'klukkustund';\n            case 'd':\n                if (withoutSuffix) {\n                    return 'dagur';\n                }\n                return isFuture ? 'dag' : 'degi';\n            case 'dd':\n                if (plural(number)) {\n                    if (withoutSuffix) {\n                        return result + 'dagar';\n                    }\n                    return result + (isFuture ? 'daga' : 'dgum');\n                } else if (withoutSuffix) {\n                    return result + 'dagur';\n                }\n                return result + (isFuture ? 'dag' : 'degi');\n            case 'M':\n                if (withoutSuffix) {\n                    return 'mnuur';\n                }\n                return isFuture ? 'mnu' : 'mnui';\n            case 'MM':\n                if (plural(number)) {\n                    if (withoutSuffix) {\n                        return result + 'mnuir';\n                    }\n                    return result + (isFuture ? 'mnui' : 'mnuum');\n                } else if (withoutSuffix) {\n                    return result + 'mnuur';\n                }\n                return result + (isFuture ? 'mnu' : 'mnui');\n            case 'y':\n                return withoutSuffix || isFuture ? 'r' : 'ri';\n            case 'yy':\n                if (plural(number)) {\n                    return result + (withoutSuffix || isFuture ? 'r' : 'rum');\n                }\n                return result + (withoutSuffix || isFuture ? 'r' : 'ri');\n        }\n    }\n\n    var is = moment.defineLocale('is', {\n        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),\n        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),\n        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),\n        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY [kl.] H:mm',\n            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'\n        },\n        calendar : {\n            sameDay : '[ dag kl.] LT',\n            nextDay : '[ morgun kl.] LT',\n            nextWeek : 'dddd [kl.] LT',\n            lastDay : '[ gr kl.] LT',\n            lastWeek : '[sasta] dddd [kl.] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'eftir %s',\n            past : 'fyrir %s san',\n            s : translate,\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : 'klukkustund',\n            hh : translate,\n            d : translate,\n            dd : translate,\n            M : translate,\n            MM : translate,\n            y : translate,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return is;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pcy5qcz9iYTk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwbHVyYWwobikge1xuICAgICAgICBpZiAobiAlIDEwMCA9PT0gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG4gJSAxMCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdub2trcmFyIHNla8O6bmR1cicgOiAnbm9ra3J1bSBzZWvDum5kdW0nO1xuICAgICAgICAgICAgY2FzZSAnc3MnOlxuICAgICAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnc2Vrw7puZHVyJyA6ICdzZWvDum5kdW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdzZWvDum5kYSc7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtw61uw7p0YScgOiAnbcOtbsO6dHUnO1xuICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbcOtbsO6dHVyJyA6ICdtw61uw7p0dW0nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw61uw7p0YSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcOtbsO6dHUnO1xuICAgICAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAna2x1a2t1c3R1bmRpcicgOiAna2x1a2t1c3R1bmR1bScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2tsdWtrdXN0dW5kJztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZGFndXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAnZGFnJyA6ICdkZWdpJztcbiAgICAgICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgICAgICAgICBpZiAocGx1cmFsKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZGFnYXInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnZGFnYScgOiAnZMO2Z3VtJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZGFndXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGlzRnV0dXJlID8gJ2RhZycgOiAnZGVnaScpO1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtw6FudcOwdXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAnbcOhbnXDsCcgOiAnbcOhbnXDsGknO1xuICAgICAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw6FudcOwaXInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnbcOhbnXDsGknIDogJ23DoW51w7B1bScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ23DoW51w7B1cic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnbcOhbnXDsCcgOiAnbcOhbnXDsGknKTtcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ8OhcicgOiAnw6FyaSc7XG4gICAgICAgICAgICBjYXNlICd5eSc6XG4gICAgICAgICAgICAgICAgaWYgKHBsdXJhbChudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICfDoXInIDogJ8OhcnVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICfDoXInIDogJ8OhcmknKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2lzJywge1xuICAgICAgICBtb250aHMgOiAnamFuw7phcl9mZWJyw7phcl9tYXJzX2FwcsOtbF9tYcOtX2rDum7DrV9qw7psw61fw6Fnw7pzdF9zZXB0ZW1iZXJfb2t0w7NiZXJfbsOzdmVtYmVyX2Rlc2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWHDrV9qw7puX2rDumxfw6Fnw7pfc2VwX29rdF9uw7N2X2Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnc3VubnVkYWd1cl9tw6FudWRhZ3VyX8O+cmnDsGp1ZGFndXJfbWnDsHZpa3VkYWd1cl9maW1tdHVkYWd1cl9mw7ZzdHVkYWd1cl9sYXVnYXJkYWd1cicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzdW5fbcOhbl/DvnJpX21pw7BfZmltX2bDtnNfbGF1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nw6Ffw55yX01pX0ZpX0bDtl9MYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBba2wuXSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIFtrbC5dIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbw60gZGFnIGtsLl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbw6EgbW9yZ3VuIGtsLl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBba2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vDrSBnw6ZyIGtsLl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW3PDrcOwYXN0YV0gZGRkZCBba2wuXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZWZ0aXIgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdmeXJpciAlcyBzw63DsGFuJyxcbiAgICAgICAgICAgIHMgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBzcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiAna2x1a2t1c3R1bmQnLFxuICAgICAgICAgICAgaGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeXkgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpcztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXMuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64\n");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var it = moment.defineLocale('it', {\n        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),\n        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),\n        weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),\n        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),\n        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Oggi alle] LT',\n            nextDay: '[Domani alle] LT',\n            nextWeek: 'dddd [alle] LT',\n            lastDay: '[Ieri alle] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[la scorsa] dddd [alle] LT';\n                    default:\n                        return '[lo scorso] dddd [alle] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : function (s) {\n                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;\n            },\n            past : '%s fa',\n            s : 'alcuni secondi',\n            ss : '%d secondi',\n            m : 'un minuto',\n            mm : '%d minuti',\n            h : 'un\\'ora',\n            hh : '%d ore',\n            d : 'un giorno',\n            dd : '%d giorni',\n            M : 'un mese',\n            MM : '%d mesi',\n            y : 'un anno',\n            yy : '%d anni'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal: '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return it;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pdC5qcz8xNGE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgaXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdpdCcsIHtcbiAgICAgICAgbW9udGhzIDogJ2dlbm5haW9fZmViYnJhaW9fbWFyem9fYXByaWxlX21hZ2dpb19naXVnbm9fbHVnbGlvX2Fnb3N0b19zZXR0ZW1icmVfb3R0b2JyZV9ub3ZlbWJyZV9kaWNlbWJyZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnZ2VuX2ZlYl9tYXJfYXByX21hZ19naXVfbHVnX2Fnb19zZXRfb3R0X25vdl9kaWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ2RvbWVuaWNhX2x1bmVkw6xfbWFydGVkw6xfbWVyY29sZWTDrF9naW92ZWTDrF92ZW5lcmTDrF9zYWJhdG8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnZG9tX2x1bl9tYXJfbWVyX2dpb192ZW5fc2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdkb19sdV9tYV9tZV9naV92ZV9zYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tPZ2dpIGFsbGVdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbRG9tYW5pIGFsbGVdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbYWxsZV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tJZXJpIGFsbGVdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2xhIHNjb3JzYV0gZGRkZCBbYWxsZV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbG8gc2NvcnNvXSBkZGRkIFthbGxlXSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCgvXlswLTldLiskLykudGVzdChzKSA/ICd0cmEnIDogJ2luJykgKyAnICcgKyBzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgZmEnLFxuICAgICAgICAgICAgcyA6ICdhbGN1bmkgc2Vjb25kaScsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWNvbmRpJyxcbiAgICAgICAgICAgIG0gOiAndW4gbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0aScsXG4gICAgICAgICAgICBoIDogJ3VuXFwnb3JhJyxcbiAgICAgICAgICAgIGhoIDogJyVkIG9yZScsXG4gICAgICAgICAgICBkIDogJ3VuIGdpb3JubycsXG4gICAgICAgICAgICBkZCA6ICclZCBnaW9ybmknLFxuICAgICAgICAgICAgTSA6ICd1biBtZXNlJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1lc2knLFxuICAgICAgICAgICAgeSA6ICd1biBhbm5vJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGFubmknXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXG4gICAgICAgIG9yZGluYWw6ICclZMK6JyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXQ7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///65\n");

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ja = moment.defineLocale('ja', {\n        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYYMD',\n            LLL : 'YYYYMD HH:mm',\n            LLLL : 'YYYYMD dddd HH:mm',\n            l : 'YYYY/MM/DD',\n            ll : 'YYYYMD',\n            lll : 'YYYYMD HH:mm',\n            llll : 'YYYYMD(ddd) HH:mm'\n        },\n        meridiemParse: /|/i,\n        isPM : function (input) {\n            return input === '';\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : function (now) {\n                if (now.week() < this.week()) {\n                    return '[]dddd LT';\n                } else {\n                    return 'dddd LT';\n                }\n            },\n            lastDay : '[] LT',\n            lastWeek : function (now) {\n                if (this.week() < now.week()) {\n                    return '[]dddd LT';\n                } else {\n                    return 'dddd LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : function (number, period) {\n            switch (period) {\n                case 'd':\n                case 'D':\n                case 'DDD':\n                    return number + '';\n                default:\n                    return number;\n            }\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            ss : '%d',\n            m : '1',\n            mm : '%d',\n            h : '1',\n            hh : '%d',\n            d : '1',\n            dd : '%d',\n            M : '1',\n            MM : '%d',\n            y : '1',\n            yy : '%d'\n        }\n    });\n\n    return ja;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qcz8zOTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBqYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2phJywge1xuICAgICAgICBtb250aHMgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfml6Xmm5zml6Vf5pyI5puc5pelX+eBq+abnOaXpV/msLTmm5zml6Vf5pyo5puc5pelX+mHkeabnOaXpV/lnJ/mm5zml6UnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn5pelX+aciF/ngatf5rC0X+acqF/ph5Ff5ZyfJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfml6Vf5pyIX+eBq1/msLRf5pyoX+mHkV/lnJ8nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS9NTS9ERCcsXG4gICAgICAgICAgICBMTCA6ICdZWVlZ5bm0TeaciETml6UnLFxuICAgICAgICAgICAgTExMIDogJ1lZWVnlubRN5pyIROaXpSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ1lZWVnlubRN5pyIROaXpSBkZGRkIEhIOm1tJyxcbiAgICAgICAgICAgIGwgOiAnWVlZWS9NTS9ERCcsXG4gICAgICAgICAgICBsbCA6ICdZWVlZ5bm0TeaciETml6UnLFxuICAgICAgICAgICAgbGxsIDogJ1lZWVnlubRN5pyIROaXpSBISDptbScsXG4gICAgICAgICAgICBsbGxsIDogJ1lZWVnlubRN5pyIROaXpShkZGQpIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv5Y2I5YmNfOWNiOW+jC9pLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfljYjlvownO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+WNiOWJjSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5Y2I5b6MJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vku4rml6VdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+aYjuaXpV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdy53ZWVrKCkgPCB0aGlzLndlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vmnaXpgLFdZGRkZCBMVCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkZGRkIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheSA6ICdb5pio5pelXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uIChub3cpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ZWVrKCkgPCBub3cud2VlaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW+WFiOmAsV1kZGRkIExUJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RkZGQgTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ95pelLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aXpSc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVz5b6MJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPliY0nLFxuICAgICAgICAgICAgcyA6ICfmlbDnp5InLFxuICAgICAgICAgICAgc3MgOiAnJWTnp5InLFxuICAgICAgICAgICAgbSA6ICcx5YiGJyxcbiAgICAgICAgICAgIG1tIDogJyVk5YiGJyxcbiAgICAgICAgICAgIGggOiAnMeaZgumWkycsXG4gICAgICAgICAgICBoaCA6ICclZOaZgumWkycsXG4gICAgICAgICAgICBkIDogJzHml6UnLFxuICAgICAgICAgICAgZGQgOiAnJWTml6UnLFxuICAgICAgICAgICAgTSA6ICcx44O25pyIJyxcbiAgICAgICAgICAgIE1NIDogJyVk44O25pyIJyxcbiAgICAgICAgICAgIHkgOiAnMeW5tCcsXG4gICAgICAgICAgICB5eSA6ICclZOW5tCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGphO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66\n");

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var jv = moment.defineLocale('jv', {\n        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),\n        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),\n        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),\n        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /enjing|siyang|sonten|ndalu/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'enjing') {\n                return hour;\n            } else if (meridiem === 'siyang') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'enjing';\n            } else if (hours < 15) {\n                return 'siyang';\n            } else if (hours < 19) {\n                return 'sonten';\n            } else {\n                return 'ndalu';\n            }\n        },\n        calendar : {\n            sameDay : '[Dinten puniko pukul] LT',\n            nextDay : '[Mbenjang pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kala wingi pukul] LT',\n            lastWeek : 'dddd [kepengker pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'wonten ing %s',\n            past : '%s ingkang kepengker',\n            s : 'sawetawis detik',\n            ss : '%d detik',\n            m : 'setunggal menit',\n            mm : '%d menit',\n            h : 'setunggal jam',\n            hh : '%d jam',\n            d : 'sedinten',\n            dd : '%d dinten',\n            M : 'sewulan',\n            MM : '%d wulan',\n            y : 'setaun',\n            yy : '%d taun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return jv;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qdi5qcz8yNzA4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBqdiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2p2Jywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYXJldF9BcHJpbF9NZWlfSnVuaV9KdWxpX0FndXN0dXNfU2VwdGVtYmVyX09rdG9iZXJfTm9wZW1iZXJfRGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NZWlfSnVuX0p1bF9BZ3NfU2VwX09rdF9Ob3BfRGVzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdNaW5nZ3VfU2VuZW5fU2Vsb3NvX1JlYnVfS2VtaXNfSmVtdXdhaF9TZXB0dScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdNaW5fU2VuX1NlbF9SZWJfS2VtX0plbV9TZXAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ01nX1NuX1NsX1JiX0ttX0ptX1NwJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hILm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISC5tbS5zcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvZW5qaW5nfHNpeWFuZ3xzb250ZW58bmRhbHUvLFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAnZW5qaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NpeWFuZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc29udGVuJyB8fCBtZXJpZGllbSA9PT0gJ25kYWx1Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZW5qaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc2l5YW5nJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc29udGVuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZGFsdSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbRGludGVuIHB1bmlrbyBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbTWJlbmphbmcgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tLYWxhIHdpbmdpIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtrZXBlbmdrZXIgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICd3b250ZW4gaW5nICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgaW5na2FuZyBrZXBlbmdrZXInLFxuICAgICAgICAgICAgcyA6ICdzYXdldGF3aXMgZGV0aWsnLFxuICAgICAgICAgICAgc3MgOiAnJWQgZGV0aWsnLFxuICAgICAgICAgICAgbSA6ICdzZXR1bmdnYWwgbWVuaXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWVuaXQnLFxuICAgICAgICAgICAgaCA6ICdzZXR1bmdnYWwgamFtJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGphbScsXG4gICAgICAgICAgICBkIDogJ3NlZGludGVuJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRpbnRlbicsXG4gICAgICAgICAgICBNIDogJ3Nld3VsYW4nLFxuICAgICAgICAgICAgTU0gOiAnJWQgd3VsYW4nLFxuICAgICAgICAgICAgeSA6ICdzZXRhdW4nLFxuICAgICAgICAgICAgeXkgOiAnJWQgdGF1bidcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ganY7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///67\n");

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ka = moment.defineLocale('ka', {\n        months : {\n            standalone: '___________'.split('_'),\n            format: '___________'.split('_')\n        },\n        monthsShort : '___________'.split('_'),\n        weekdays : {\n            standalone: '______'.split('_'),\n            format: '______'.split('_'),\n            isFormat: /(|)/\n        },\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[] LT[-]',\n            nextDay : '[] LT[-]',\n            lastDay : '[] LT[-]',\n            nextWeek : '[] dddd LT[-]',\n            lastWeek : '[] dddd LT-',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : function (s) {\n                return (/(|||)/).test(s) ?\n                    s.replace(/$/, '') :\n                    s + '';\n            },\n            past : function (s) {\n                if ((/(||||)/).test(s)) {\n                    return s.replace(/(|)$/, ' ');\n                }\n                if ((//).test(s)) {\n                    return s.replace(/$/, ' ');\n                }\n            },\n            s : ' ',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /0|1-|-\\d{1,2}|\\d{1,2}-/,\n        ordinal : function (number) {\n            if (number === 0) {\n                return number;\n            }\n            if (number === 1) {\n                return number + '-';\n            }\n            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {\n                return '-' + number;\n            }\n            return number + '-';\n        },\n        week : {\n            dow : 1,\n            doy : 7\n        }\n    });\n\n    return ka;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rYS5qcz80NjcyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOENBQThDLElBQUksSUFBSSxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBrYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2thJywge1xuICAgICAgICBtb250aHMgOiB7XG4gICAgICAgICAgICBzdGFuZGFsb25lOiAn4YOY4YOQ4YOc4YOV4YOQ4YOg4YOYX+GDl+GDlOGDkeGDlOGDoOGDleGDkOGDmuGDmF/hg5vhg5Dhg6Dhg6Lhg5hf4YOQ4YOe4YOg4YOY4YOa4YOYX+GDm+GDkOGDmOGDoeGDmF/hg5jhg5Xhg5zhg5jhg6Hhg5hf4YOY4YOV4YOa4YOY4YOh4YOYX+GDkOGDkuGDleGDmOGDoeGDouGDnV/hg6Hhg5Thg6Xhg6Lhg5Thg5vhg5Hhg5Thg6Dhg5hf4YOd4YOl4YOi4YOd4YOb4YOR4YOU4YOg4YOYX+GDnOGDneGDlOGDm+GDkeGDlOGDoOGDmF/hg5Phg5Thg5nhg5Thg5vhg5Hhg5Thg6Dhg5gnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBmb3JtYXQ6ICfhg5jhg5Dhg5zhg5Xhg5Dhg6Dhg6Ff4YOX4YOU4YOR4YOU4YOg4YOV4YOQ4YOa4YOhX+GDm+GDkOGDoOGDouGDoV/hg5Dhg57hg6Dhg5jhg5rhg5jhg6Ff4YOb4YOQ4YOY4YOh4YOhX+GDmOGDleGDnOGDmOGDoeGDoV/hg5jhg5Xhg5rhg5jhg6Hhg6Ff4YOQ4YOS4YOV4YOY4YOh4YOi4YOhX+GDoeGDlOGDpeGDouGDlOGDm+GDkeGDlOGDoOGDoV/hg53hg6Xhg6Lhg53hg5vhg5Hhg5Thg6Dhg6Ff4YOc4YOd4YOU4YOb4YOR4YOU4YOg4YOhX+GDk+GDlOGDmeGDlOGDm+GDkeGDlOGDoOGDoScuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBtb250aHNTaG9ydCA6ICfhg5jhg5Dhg5xf4YOX4YOU4YORX+GDm+GDkOGDoF/hg5Dhg57hg6Bf4YOb4YOQ4YOYX+GDmOGDleGDnF/hg5jhg5Xhg5pf4YOQ4YOS4YOVX+GDoeGDlOGDpV/hg53hg6Xhg6Jf4YOc4YOd4YOUX+GDk+GDlOGDmScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiB7XG4gICAgICAgICAgICBzdGFuZGFsb25lOiAn4YOZ4YOV4YOY4YOg4YOQX+GDneGDoOGDqOGDkOGDkeGDkOGDl+GDmF/hg6Hhg5Dhg5vhg6jhg5Dhg5Hhg5Dhg5fhg5hf4YOd4YOX4YOu4YOo4YOQ4YOR4YOQ4YOX4YOYX+GDruGDo+GDl+GDqOGDkOGDkeGDkOGDl+GDmF/hg57hg5Dhg6Dhg5Dhg6Hhg5nhg5Thg5Xhg5hf4YOo4YOQ4YOR4YOQ4YOX4YOYJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgZm9ybWF0OiAn4YOZ4YOV4YOY4YOg4YOQ4YOhX+GDneGDoOGDqOGDkOGDkeGDkOGDl+GDoV/hg6Hhg5Dhg5vhg6jhg5Dhg5Hhg5Dhg5fhg6Ff4YOd4YOX4YOu4YOo4YOQ4YOR4YOQ4YOX4YOhX+GDruGDo+GDl+GDqOGDkOGDkeGDkOGDl+GDoV/hg57hg5Dhg6Dhg5Dhg6Hhg5nhg5Thg5Xhg6Ff4YOo4YOQ4YOR4YOQ4YOX4YOhJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgaXNGb3JtYXQ6IC8o4YOs4YOY4YOc4YOQfOGDqOGDlOGDm+GDk+GDlOGDkikvXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4YOZ4YOV4YOYX+GDneGDoOGDqF/hg6Hhg5Dhg5tf4YOd4YOX4YOuX+GDruGDo+GDl1/hg57hg5Dhg6Bf4YOo4YOQ4YORJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfhg5nhg5Vf4YOd4YOgX+GDoeGDkF/hg53hg5df4YOu4YOjX+GDnuGDkF/hg6jhg5AnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4YOT4YOm4YOU4YOhXSBMVFst4YOW4YOUXScsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vhg67hg5Xhg5Dhg5pdIExUWy3hg5bhg5RdJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+GDkuGDo+GDqOGDmOGDnF0gTFRbLeGDluGDlF0nLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnW+GDqOGDlOGDm+GDk+GDlOGDkl0gZGRkZCBMVFst4YOW4YOUXScsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4YOs4YOY4YOc4YOQXSBkZGRkIExULeGDluGDlCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoLyjhg6zhg5Dhg5vhg5h84YOs4YOj4YOX4YOYfOGDoeGDkOGDkOGDl+GDmHzhg6zhg5Thg5rhg5gpLykudGVzdChzKSA/XG4gICAgICAgICAgICAgICAgICAgIHMucmVwbGFjZSgv4YOYJC8sICfhg6jhg5gnKSA6XG4gICAgICAgICAgICAgICAgICAgIHMgKyAn4YOo4YOYJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXN0IDogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKC8o4YOs4YOQ4YOb4YOYfOGDrOGDo+GDl+GDmHzhg6Hhg5Dhg5Dhg5fhg5h84YOT4YOm4YOUfOGDl+GDleGDlCkvKS50ZXN0KHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoLyjhg5h84YOUKSQvLCAn4YOY4YOhIOGDrOGDmOGDnCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKC/hg6zhg5Thg5rhg5gvKS50ZXN0KHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL+GDrOGDlOGDmuGDmCQvLCAn4YOs4YOa4YOY4YOhIOGDrOGDmOGDnCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzIDogJ+GDoOGDkOGDm+GDk+GDlOGDnOGDmOGDm+GDlCDhg6zhg5Dhg5vhg5gnLFxuICAgICAgICAgICAgc3MgOiAnJWQg4YOs4YOQ4YOb4YOYJyxcbiAgICAgICAgICAgIG0gOiAn4YOs4YOj4YOX4YOYJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOGDrOGDo+GDl+GDmCcsXG4gICAgICAgICAgICBoIDogJ+GDoeGDkOGDkOGDl+GDmCcsXG4gICAgICAgICAgICBoaCA6ICclZCDhg6Hhg5Dhg5Dhg5fhg5gnLFxuICAgICAgICAgICAgZCA6ICfhg5Phg6bhg5QnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4YOT4YOm4YOUJyxcbiAgICAgICAgICAgIE0gOiAn4YOX4YOV4YOUJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOGDl+GDleGDlCcsXG4gICAgICAgICAgICB5IDogJ+GDrOGDlOGDmuGDmCcsXG4gICAgICAgICAgICB5eSA6ICclZCDhg6zhg5Thg5rhg5gnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC8wfDEt4YOa4YOYfOGDm+GDlC1cXGR7MSwyfXxcXGR7MSwyfS3hg5QvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct4YOa4YOYJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobnVtYmVyIDwgMjApIHx8IChudW1iZXIgPD0gMTAwICYmIChudW1iZXIgJSAyMCA9PT0gMCkpIHx8IChudW1iZXIgJSAxMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfhg5vhg5QtJyArIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLeGDlCc7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLFxuICAgICAgICAgICAgZG95IDogN1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga2E7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2thLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68\n");

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var suffixes = {\n        0: '-',\n        1: '-',\n        2: '-',\n        3: '-',\n        4: '-',\n        5: '-',\n        6: '-',\n        7: '-',\n        8: '-',\n        9: '-',\n        10: '-',\n        20: '-',\n        30: '-',\n        40: '-',\n        50: '-',\n        60: '-',\n        70: '-',\n        80: '-',\n        90: '-',\n        100: '-'\n    };\n\n    var kk = moment.defineLocale('kk', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : '[ ] dddd [] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(|)/,\n        ordinal : function (number) {\n            var a = number % 10,\n                b = number >= 100 ? 100 : null;\n            return number + (suffixes[number] || suffixes[a] || suffixes[b]);\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return kk;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ray5qcz84ZmViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3VmZml4ZXMgPSB7XG4gICAgICAgIDA6ICct0YjRlicsXG4gICAgICAgIDE6ICct0YjRlicsXG4gICAgICAgIDI6ICct0YjRlicsXG4gICAgICAgIDM6ICct0YjRlicsXG4gICAgICAgIDQ6ICct0YjRlicsXG4gICAgICAgIDU6ICct0YjRlicsXG4gICAgICAgIDY6ICct0YjRiycsXG4gICAgICAgIDc6ICct0YjRlicsXG4gICAgICAgIDg6ICct0YjRlicsXG4gICAgICAgIDk6ICct0YjRiycsXG4gICAgICAgIDEwOiAnLdGI0YsnLFxuICAgICAgICAyMDogJy3RiNGLJyxcbiAgICAgICAgMzA6ICct0YjRiycsXG4gICAgICAgIDQwOiAnLdGI0YsnLFxuICAgICAgICA1MDogJy3RiNGWJyxcbiAgICAgICAgNjA6ICct0YjRiycsXG4gICAgICAgIDcwOiAnLdGI0ZYnLFxuICAgICAgICA4MDogJy3RiNGWJyxcbiAgICAgICAgOTA6ICct0YjRiycsXG4gICAgICAgIDEwMDogJy3RiNGWJ1xuICAgIH07XG5cbiAgICB2YXIga2sgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdraycsIHtcbiAgICAgICAgbW9udGhzIDogJ9Kb0LDSo9GC0LDRgF/QsNKb0L/QsNC9X9C90LDRg9GA0YvQt1/RgdOZ0YPRltGAX9C80LDQvNGL0YBf0LzQsNGD0YHRi9C8X9GI0ZbQu9C00LVf0YLQsNC80YvQt1/Sm9GL0YDQutKv0LnQtdC6X9Kb0LDQt9Cw0L1f0pvQsNGA0LDRiNCwX9C20LXQu9GC0L7Sm9GB0LDQvScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn0pvQsNKjX9Cw0pvQv1/QvdCw0YNf0YHTmdGDX9C80LDQvF/QvNCw0YNf0YjRltC7X9GC0LDQvF/Sm9GL0YBf0pvQsNC3X9Kb0LDRgF/QttC10LsnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ9C20LXQutGB0LXQvdCx0ZZf0LTSr9C50YHQtdC90LHRll/RgdC10LnRgdC10L3QsdGWX9GB05nRgNGB0LXQvdCx0ZZf0LHQtdC50YHQtdC90LHRll/QttKx0LzQsF/RgdC10L3QsdGWJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9C20LXQul/QtNKv0Llf0YHQtdC5X9GB05nRgF/QsdC10Llf0LbSsdC8X9GB0LXQvScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0LbQul/QtNC5X9GB0Llf0YHRgF/QsdC5X9C20Lxf0YHQvScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW9CR0q/Qs9GW0L0g0YHQsNKT0LDRgl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb0JXRgNGC0LXSoyDRgdCw0pPQsNGCXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvRgdCw0pPQsNGCXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vQmtC10YjQtSDRgdCw0pPQsNGCXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb06jRgtC60LXQvSDQsNC/0YLQsNC90YvSo10gZGRkZCBb0YHQsNKT0LDRgl0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzINGW0YjRltC90LTQtScsXG4gICAgICAgICAgICBwYXN0IDogJyVzINCx0rHRgNGL0L0nLFxuICAgICAgICAgICAgcyA6ICfQsdGW0YDQvdC10YjQtSDRgdC10LrRg9C90LQnLFxuICAgICAgICAgICAgc3MgOiAnJWQg0YHQtdC60YPQvdC0JyxcbiAgICAgICAgICAgIG0gOiAn0LHRltGAINC80LjQvdGD0YInLFxuICAgICAgICAgICAgbW0gOiAnJWQg0LzQuNC90YPRgicsXG4gICAgICAgICAgICBoIDogJ9Cx0ZbRgCDRgdCw0pPQsNGCJyxcbiAgICAgICAgICAgIGhoIDogJyVkINGB0LDSk9Cw0YInLFxuICAgICAgICAgICAgZCA6ICfQsdGW0YAg0LrSr9C9JyxcbiAgICAgICAgICAgIGRkIDogJyVkINC60q/QvScsXG4gICAgICAgICAgICBNIDogJ9Cx0ZbRgCDQsNC5JyxcbiAgICAgICAgICAgIE1NIDogJyVkINCw0LknLFxuICAgICAgICAgICAgeSA6ICfQsdGW0YAg0LbRi9C7JyxcbiAgICAgICAgICAgIHl5IDogJyVkINC20YvQuydcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjRiNGWfNGI0YspLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgYiA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1tudW1iZXJdIHx8IHN1ZmZpeGVzW2FdIHx8IHN1ZmZpeGVzW2JdKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga2s7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2trLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69\n");

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var km = moment.defineLocale('km', {\n        months: '___________'.split(\n            '_'\n        ),\n        monthsShort: '___________'.split(\n            '_'\n        ),\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        weekdaysParseExact: true,\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd, D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM: function (input) {\n            return input === '';\n        },\n        meridiem: function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar: {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: 'dddd [] LT',\n            lastDay: '[ ] LT',\n            lastWeek: 'dddd [] [] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: '%s',\n            past: '%s',\n            s: '',\n            ss: '%d ',\n            m: '',\n            mm: '%d ',\n            h: '',\n            hh: '%d ',\n            d: '',\n            dd: '%d ',\n            M: '',\n            MM: '%d ',\n            y: '',\n            yy: '%d '\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4 // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return km;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbS5qcz9lNjNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfhn6EnLFxuICAgICAgICAnMic6ICfhn6InLFxuICAgICAgICAnMyc6ICfhn6MnLFxuICAgICAgICAnNCc6ICfhn6QnLFxuICAgICAgICAnNSc6ICfhn6UnLFxuICAgICAgICAnNic6ICfhn6YnLFxuICAgICAgICAnNyc6ICfhn6cnLFxuICAgICAgICAnOCc6ICfhn6gnLFxuICAgICAgICAnOSc6ICfhn6knLFxuICAgICAgICAnMCc6ICfhn6AnXG4gICAgfSwgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4Z+hJzogJzEnLFxuICAgICAgICAn4Z+iJzogJzInLFxuICAgICAgICAn4Z+jJzogJzMnLFxuICAgICAgICAn4Z+kJzogJzQnLFxuICAgICAgICAn4Z+lJzogJzUnLFxuICAgICAgICAn4Z+mJzogJzYnLFxuICAgICAgICAn4Z+nJzogJzcnLFxuICAgICAgICAn4Z+oJzogJzgnLFxuICAgICAgICAn4Z+pJzogJzknLFxuICAgICAgICAn4Z+gJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBrbSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ttJywge1xuICAgICAgICBtb250aHM6ICfhnpjhnoDhnprhnrZf4Z6A4Z674Z6Y4Z+S4Z6X4Z+IX+GemOGeuOGek+Getl/hnpjhn4Hhnp/hnrZf4Z6n4Z6f4Z6X4Z62X+GemOGet+GekOGeu+Gek+Getl/hnoDhnoDhn5LhnoDhnorhnrZf4Z6f4Z644Z6g4Z62X+GegOGeieGfkuGeieGetl/hno/hnrvhnpvhnrZf4Z6c4Z634Z6F4Z+S4Z6G4Z634Z6A4Z62X+GekuGfkuGek+GevCcuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfhnpjhnoDhnprhnrZf4Z6A4Z674Z6Y4Z+S4Z6X4Z+IX+GemOGeuOGek+Getl/hnpjhn4Hhnp/hnrZf4Z6n4Z6f4Z6X4Z62X+GemOGet+GekOGeu+Gek+Getl/hnoDhnoDhn5LhnoDhnorhnrZf4Z6f4Z644Z6g4Z62X+GegOGeieGfkuGeieGetl/hno/hnrvhnpvhnrZf4Z6c4Z634Z6F4Z+S4Z6G4Z634Z6A4Z62X+GekuGfkuGek+GevCcuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgd2Vla2RheXM6ICfhnqLhnrbhnpHhnrfhno/hn5Lhnplf4Z6F4Z+Q4Z6T4Z+S4Z6RX+GeouGehOGfkuGeguGetuGeml/hnpbhnrvhnpJf4Z6W4Z+S4Z6a4Z6g4Z6f4Z+S4Z6U4Z6P4Z634Z+NX+Gen+Geu+GegOGfkuGeml/hnp/hn4Xhnprhn40nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICfhnqLhnrZf4Z6FX+Geol/hnpZf4Z6W4Z+S4Z6aX+Gen+Geu1/hnp8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAn4Z6i4Z62X+GehV/hnqJf4Z6WX+GeluGfkuGeml/hnp/hnrtf4Z6fJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3Q6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUzogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv4Z6W4Z+S4Z6a4Z654Z6AfOGem+GfkuGehOGetuGehS8sXG4gICAgICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09PSAn4Z6b4Z+S4Z6E4Z624Z6FJztcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+GeluGfkuGemuGeueGegCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Z6b4Z+S4Z6E4Z624Z6FJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXI6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb4Z6Q4Z+S4Z6E4Z+D4Z6T4Z+B4Z+HIOGemOGfieGfhOGehF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vhnp/hn5LhnqLhn4LhnoAg4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW+GemOGfieGfhOGehF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1vhnpjhn5Lhnp/hnrfhnpvhnpjhnrfhnokg4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW+Gen+GelOGfkuGej+GetuGeoOGfjeGemOGeu+Gek10gW+GemOGfieGfhOGehF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWU6IHtcbiAgICAgICAgICAgIGZ1dHVyZTogJyVz4Z6R4Z+A4Z6PJyxcbiAgICAgICAgICAgIHBhc3Q6ICclc+GemOGeu+GekycsXG4gICAgICAgICAgICBzOiAn4Z6U4Z+J4Z674Z6T4Z+S4Z6Y4Z624Z6T4Z6c4Z634Z6T4Z624Z6R4Z64JyxcbiAgICAgICAgICAgIHNzOiAnJWQg4Z6c4Z634Z6T4Z624Z6R4Z64JyxcbiAgICAgICAgICAgIG06ICfhnpjhnr3hnpnhnpPhnrbhnpHhnrgnLFxuICAgICAgICAgICAgbW06ICclZCDhnpPhnrbhnpHhnrgnLFxuICAgICAgICAgICAgaDogJ+GemOGeveGemeGemOGfieGfhOGehCcsXG4gICAgICAgICAgICBoaDogJyVkIOGemOGfieGfhOGehCcsXG4gICAgICAgICAgICBkOiAn4Z6Y4Z694Z6Z4Z6Q4Z+S4Z6E4Z+DJyxcbiAgICAgICAgICAgIGRkOiAnJWQg4Z6Q4Z+S4Z6E4Z+DJyxcbiAgICAgICAgICAgIE06ICfhnpjhnr3hnpnhnoHhn4InLFxuICAgICAgICAgICAgTU06ICclZCDhnoHhn4InLFxuICAgICAgICAgICAgeTogJ+GemOGeveGemeGehuGfkuGek+GetuGfhicsXG4gICAgICAgICAgICB5eTogJyVkIOGehuGfkuGek+GetuGfhidcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC/hnpHhnrhcXGR7MSwyfS8sXG4gICAgICAgIG9yZGluYWwgOiAn4Z6R4Z64JWQnLFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4Z+h4Z+i4Z+j4Z+k4Z+l4Z+m4Z+n4Z+o4Z+p4Z+gXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95OiA0IC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGttO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///70\n");

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var kn = moment.defineLocale('kn', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        monthsParseExact: true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm',\n            LTS : 'A h:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}()/,\n        ordinal : function (number) {\n            return number + '';\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return kn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbi5qcz84MDQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI3MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4LOnJyxcbiAgICAgICAgJzInOiAn4LOoJyxcbiAgICAgICAgJzMnOiAn4LOpJyxcbiAgICAgICAgJzQnOiAn4LOqJyxcbiAgICAgICAgJzUnOiAn4LOrJyxcbiAgICAgICAgJzYnOiAn4LOsJyxcbiAgICAgICAgJzcnOiAn4LOtJyxcbiAgICAgICAgJzgnOiAn4LOuJyxcbiAgICAgICAgJzknOiAn4LOvJyxcbiAgICAgICAgJzAnOiAn4LOmJ1xuICAgIH0sXG4gICAgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4LOnJzogJzEnLFxuICAgICAgICAn4LOoJzogJzInLFxuICAgICAgICAn4LOpJzogJzMnLFxuICAgICAgICAn4LOqJzogJzQnLFxuICAgICAgICAn4LOrJzogJzUnLFxuICAgICAgICAn4LOsJzogJzYnLFxuICAgICAgICAn4LOtJzogJzcnLFxuICAgICAgICAn4LOuJzogJzgnLFxuICAgICAgICAn4LOvJzogJzknLFxuICAgICAgICAn4LOmJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBrbiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2tuJywge1xuICAgICAgICBtb250aHMgOiAn4LKc4LKo4LK14LKw4LK/X+Cyq+CzhuCyrOCzjeCysOCyteCysOCyv1/gsq7gsr7gsrDgs43gsprgs41f4LKP4LKq4LON4LKw4LK/4LKy4LONX+CyruCzhuCzlV/gspzgs4Lgsqjgs41f4LKc4LOB4LKy4LOG4LOWX+CyhuCyl+CyuOCzjeCyn+CzjV/gsrjgs4bgsqrgs43gsp/gs4bgsoLgsqzgsrDgs41f4LKF4LKV4LON4LKf4LOG4LOC4LOV4LKs4LKw4LONX+CyqOCyteCzhuCyguCyrOCysOCzjV/gsqHgsr/gsrjgs4bgsoLgsqzgsrDgs40nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+CynOCyqF/gsqvgs4bgsqzgs43gsrBf4LKu4LK+4LKw4LON4LKa4LONX+Cyj+CyquCzjeCysOCyv+CysuCzjV/gsq7gs4bgs5Vf4LKc4LOC4LKo4LONX+CynOCzgeCysuCzhuCzll/gsobgspfgsrjgs43gsp/gs41f4LK44LOG4LKq4LON4LKf4LOG4LKCX+CyheCyleCzjeCyn+CzhuCzguCzlV/gsqjgsrXgs4bgsoJf4LKh4LK/4LK44LOG4LKCJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICfgsq3gsr7gsqjgs4HgsrXgsr7gsrBf4LK44LOG4LOC4LOV4LKu4LK14LK+4LKwX+CyruCyguCyl+Cys+CyteCyvuCysF/gsqzgs4HgsqfgsrXgsr7gsrBf4LKX4LOB4LKw4LOB4LK14LK+4LKwX+CytuCzgeCyleCzjeCysOCyteCyvuCysF/gsrbgsqjgsr/gsrXgsr7gsrAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4LKt4LK+4LKo4LOBX+CyuOCzhuCzguCzleCyrl/gsq7gsoLgspfgsrNf4LKs4LOB4LKnX+Cyl+CzgeCysOCzgV/gsrbgs4HgspXgs43gsrBf4LK24LKo4LK/Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfgsq3gsr5f4LK44LOG4LOC4LOVX+CyruCygl/gsqzgs4Ff4LKX4LOBX+CytuCzgV/gsrYnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnQSBoOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgsofgsoLgsqbgs4FdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CyqOCyvuCys+Czhl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4LKo4LK/4LKo4LON4LKo4LOGXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4LKV4LOG4LOC4LKo4LOG4LKvXSBkZGRkLCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg4LKo4LKC4LKk4LKwJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg4LK54LK/4LKC4LKm4LOGJyxcbiAgICAgICAgICAgIHMgOiAn4LKV4LOG4LKy4LK14LOBIOCyleCzjeCyt+Cyo+Cyl+Cys+CzgScsXG4gICAgICAgICAgICBzcyA6ICclZCDgsrjgs4bgspXgs4bgsoLgsqHgs4HgspfgsrPgs4EnLFxuICAgICAgICAgICAgbSA6ICfgspLgsoLgsqbgs4Eg4LKo4LK/4LKu4LK/4LK3JyxcbiAgICAgICAgICAgIG1tIDogJyVkIOCyqOCyv+CyruCyv+CytycsXG4gICAgICAgICAgICBoIDogJ+CykuCyguCypuCzgSDgspfgsoLgsp/gs4YnLFxuICAgICAgICAgICAgaGggOiAnJWQg4LKX4LKC4LKf4LOGJyxcbiAgICAgICAgICAgIGQgOiAn4LKS4LKC4LKm4LOBIOCypuCyv+CyqCcsXG4gICAgICAgICAgICBkZCA6ICclZCDgsqbgsr/gsqgnLFxuICAgICAgICAgICAgTSA6ICfgspLgsoLgsqbgs4Eg4LKk4LK/4LKC4LKX4LKz4LOBJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOCypOCyv+CyguCyl+Cys+CzgScsXG4gICAgICAgICAgICB5IDogJ+CykuCyguCypuCzgSDgsrXgsrDgs43gsrcnLFxuICAgICAgICAgICAgeXkgOiAnJWQg4LK14LKw4LON4LK3J1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4LOn4LOo4LOp4LOq4LOr4LOs4LOt4LOu4LOv4LOmXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv4LKw4LK+4LKk4LON4LKw4LK/fOCyrOCzhuCys+Cyv+Cyl+CzjeCyl+Czhnzgsq7gsqfgs43gsq/gsr7gsrngs43gsqh84LK44LKC4LKc4LOGLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CysOCyvuCypOCzjeCysOCyvycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA8IDQgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CyrOCzhuCys+Cyv+Cyl+CzjeCyl+CzhicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgsq7gsqfgs43gsq/gsr7gsrngs43gsqgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CyuOCyguCynOCzhicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LKw4LK+4LKk4LON4LKw4LK/JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgsqzgs4bgsrPgsr/gspfgs43gspfgs4YnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CyruCyp+CzjeCyr+CyvuCyueCzjeCyqCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LK44LKC4LKc4LOGJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgsrDgsr7gsqTgs43gsrDgsr8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0o4LKo4LOG4LOVKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+CyqOCzhuCzlSc7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGtuO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbi5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///71\n");

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ko = moment.defineLocale('ko', {\n        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm',\n            LTS : 'A h:mm:ss',\n            L : 'YYYY.MM.DD.',\n            LL : 'YYYY MMMM D',\n            LLL : 'YYYY MMMM D A h:mm',\n            LLLL : 'YYYY MMMM D dddd A h:mm',\n            l : 'YYYY.MM.DD.',\n            ll : 'YYYY MMMM D',\n            lll : 'YYYY MMMM D A h:mm',\n            llll : 'YYYY MMMM D dddd A h:mm'\n        },\n        calendar : {\n            sameDay : ' LT',\n            nextDay : ' LT',\n            nextWeek : 'dddd LT',\n            lastDay : ' LT',\n            lastWeek : ' dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d',\n            m : '1',\n            mm : '%d',\n            h : ' ',\n            hh : '%d',\n            d : '',\n            dd : '%d',\n            M : ' ',\n            MM : '%d',\n            y : ' ',\n            yy : '%d'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}(||)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                case 'd':\n                case 'D':\n                case 'DDD':\n                    return number + '';\n                case 'M':\n                    return number + '';\n                case 'w':\n                case 'W':\n                    return number + '';\n                default:\n                    return number;\n            }\n        },\n        meridiemParse : /|/,\n        isPM : function (token) {\n            return token === '';\n        },\n        meridiem : function (hour, minute, isUpper) {\n            return hour < 12 ? '' : '';\n        }\n    });\n\n    return ko;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rby5qcz83ODEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIga28gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdrbycsIHtcbiAgICAgICAgbW9udGhzIDogJzHsm5RfMuyblF8z7JuUXzTsm5RfNeyblF827JuUXzfsm5RfOOyblF857JuUXzEw7JuUXzEx7JuUXzEy7JuUJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICcx7JuUXzLsm5RfM+yblF807JuUXzXsm5RfNuyblF837JuUXzjsm5RfOeyblF8xMOyblF8xMeyblF8xMuyblCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn7J287JqU7J28X+yblOyalOydvF/tmZTsmpTsnbxf7IiY7JqU7J28X+uqqeyalOydvF/quIjsmpTsnbxf7Yag7JqU7J28Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+ydvF/sm5Rf7ZmUX+yImF/rqqlf6riIX+2GoCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn7J28X+yblF/tmZRf7IiYX+uqqV/quIhf7YagJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0EgaDptbScsXG4gICAgICAgICAgICBMVFMgOiAnQSBoOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS5NTS5ERC4nLFxuICAgICAgICAgICAgTEwgOiAnWVlZWeuFhCBNTU1NIETsnbwnLFxuICAgICAgICAgICAgTExMIDogJ1lZWVnrhYQgTU1NTSBE7J28IEEgaDptbScsXG4gICAgICAgICAgICBMTExMIDogJ1lZWVnrhYQgTU1NTSBE7J28IGRkZGQgQSBoOm1tJyxcbiAgICAgICAgICAgIGwgOiAnWVlZWS5NTS5ERC4nLFxuICAgICAgICAgICAgbGwgOiAnWVlZWeuFhCBNTU1NIETsnbwnLFxuICAgICAgICAgICAgbGxsIDogJ1lZWVnrhYQgTU1NTSBE7J28IEEgaDptbScsXG4gICAgICAgICAgICBsbGxsIDogJ1lZWVnrhYQgTU1NTSBE7J28IGRkZGQgQSBoOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAn7Jik64qYIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAn64K07J28IExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICfslrTsoJwgTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAn7KeA64Kc7KO8IGRkZGQgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIO2bhCcsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOyghCcsXG4gICAgICAgICAgICBzIDogJ+uqhyDstIgnLFxuICAgICAgICAgICAgc3MgOiAnJWTstIgnLFxuICAgICAgICAgICAgbSA6ICcx67aEJyxcbiAgICAgICAgICAgIG1tIDogJyVk67aEJyxcbiAgICAgICAgICAgIGggOiAn7ZWcIOyLnOqwhCcsXG4gICAgICAgICAgICBoaCA6ICclZOyLnOqwhCcsXG4gICAgICAgICAgICBkIDogJ+2VmOujqCcsXG4gICAgICAgICAgICBkZCA6ICclZOydvCcsXG4gICAgICAgICAgICBNIDogJ+2VnCDri6wnLFxuICAgICAgICAgICAgTU0gOiAnJWTri6wnLFxuICAgICAgICAgICAgeSA6ICfsnbwg64WEJyxcbiAgICAgICAgICAgIHl5IDogJyVk64WEJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9KOydvHzsm5R87KO8KS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfsnbwnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+yblCc7XG4gICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn7KO8JztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlIDogL+yYpOyghHzsmKTtm4QvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPT09ICfsmKTtm4QnO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzVXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgMTIgPyAn7Jik7KCEJyA6ICfsmKTtm4QnO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga287XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tvLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72\n");

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var suffixes = {\n        0: '-',\n        1: '-',\n        2: '-',\n        3: '-',\n        4: '-',\n        5: '-',\n        6: '-',\n        7: '-',\n        8: '-',\n        9: '-',\n        10: '-',\n        20: '-',\n        30: '-',\n        40: '-',\n        50: '-',\n        60: '-',\n        70: '-',\n        80: '-',\n        90: '-',\n        100: '-'\n    };\n\n    var ky = moment.defineLocale('ky', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : '[ ] dddd [] [] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(|||)/,\n        ordinal : function (number) {\n            var a = number % 10,\n                b = number >= 100 ? 100 : null;\n            return number + (suffixes[number] || suffixes[a] || suffixes[b]);\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ky;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9reS5qcz9lOWM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3VmZml4ZXMgPSB7XG4gICAgICAgIDA6ICct0YfSrycsXG4gICAgICAgIDE6ICct0YfQuCcsXG4gICAgICAgIDI6ICct0YfQuCcsXG4gICAgICAgIDM6ICct0YfSrycsXG4gICAgICAgIDQ6ICct0YfSrycsXG4gICAgICAgIDU6ICct0YfQuCcsXG4gICAgICAgIDY6ICct0YfRiycsXG4gICAgICAgIDc6ICct0YfQuCcsXG4gICAgICAgIDg6ICct0YfQuCcsXG4gICAgICAgIDk6ICct0YfRgycsXG4gICAgICAgIDEwOiAnLdGH0YMnLFxuICAgICAgICAyMDogJy3Rh9GLJyxcbiAgICAgICAgMzA6ICct0YfRgycsXG4gICAgICAgIDQwOiAnLdGH0YsnLFxuICAgICAgICA1MDogJy3Rh9KvJyxcbiAgICAgICAgNjA6ICct0YfRiycsXG4gICAgICAgIDcwOiAnLdGH0LgnLFxuICAgICAgICA4MDogJy3Rh9C4JyxcbiAgICAgICAgOTA6ICct0YfRgycsXG4gICAgICAgIDEwMDogJy3Rh9KvJ1xuICAgIH07XG5cbiAgICB2YXIga3kgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdreScsIHtcbiAgICAgICAgbW9udGhzIDogJ9GP0L3QstCw0YDRjF/RhNC10LLRgNCw0LvRjF/QvNCw0YDRgl/QsNC/0YDQtdC70Yxf0LzQsNC5X9C40Y7QvdGMX9C40Y7Qu9GMX9Cw0LLQs9GD0YHRgl/RgdC10L3RgtGP0LHRgNGMX9C+0LrRgtGP0LHRgNGMX9C90L7Rj9Cx0YDRjF/QtNC10LrQsNCx0YDRjCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn0Y/QvdCyX9GE0LXQsl/QvNCw0YDRgl/QsNC/0YBf0LzQsNC5X9C40Y7QvdGMX9C40Y7Qu9GMX9Cw0LLQs1/RgdC10L1f0L7QutGCX9C90L7Rj1/QtNC10LonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ9CW0LXQutGI0LXQvNCx0Lhf0JTSr9C50YjTqdC80LHSr1/QqNC10LnRiNC10LzQsdC4X9Co0LDRgNGI0LXQvNCx0Lhf0JHQtdC50YjQtdC80LHQuF/QltGD0LzQsF/QmNGI0LXQvNCx0LgnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn0JbQtdC6X9CU0q/QuV/QqNC10Llf0KjQsNGAX9CR0LXQuV/QltGD0Lxf0JjRiNC1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfQltC6X9CU0Llf0KjQuV/QqNGAX9CR0Llf0JbQvF/QmNGIJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb0JHSr9Cz0q/QvSDRgdCw0LDRgl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb0K3RgNGC0LXSoyDRgdCw0LDRgl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0YHQsNCw0YJdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW9Ca0LXRh9C1INGB0LDQsNGCXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb06jRgtC60LXQvSDQsNC/0YLQsNC90YvQvV0gZGRkZCBb0LrSr9C90q9dIFvRgdCw0LDRgl0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzINC40YfQuNC90LTQtScsXG4gICAgICAgICAgICBwYXN0IDogJyVzINC80YPRgNGD0L0nLFxuICAgICAgICAgICAgcyA6ICfQsdC40YDQvdC10YfQtSDRgdC10LrRg9C90LQnLFxuICAgICAgICAgICAgc3MgOiAnJWQg0YHQtdC60YPQvdC0JyxcbiAgICAgICAgICAgIG0gOiAn0LHQuNGAINC80q/QvdOp0YInLFxuICAgICAgICAgICAgbW0gOiAnJWQg0LzSr9C906nRgicsXG4gICAgICAgICAgICBoIDogJ9Cx0LjRgCDRgdCw0LDRgicsXG4gICAgICAgICAgICBoaCA6ICclZCDRgdCw0LDRgicsXG4gICAgICAgICAgICBkIDogJ9Cx0LjRgCDQutKv0L0nLFxuICAgICAgICAgICAgZGQgOiAnJWQg0LrSr9C9JyxcbiAgICAgICAgICAgIE0gOiAn0LHQuNGAINCw0LknLFxuICAgICAgICAgICAgTU0gOiAnJWQg0LDQuScsXG4gICAgICAgICAgICB5IDogJ9Cx0LjRgCDQttGL0LsnLFxuICAgICAgICAgICAgeXkgOiAnJWQg0LbRi9C7J1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNGH0Lh80YfRi3zRh9KvfNGH0YMpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgYiA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1tudW1iZXJdIHx8IHN1ZmZpeGVzW2FdIHx8IHN1ZmZpeGVzW2JdKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga3k7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2t5LmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///73\n");

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eng Minutt', 'enger Minutt'],\n            'h': ['eng Stonn', 'enger Stonn'],\n            'd': ['een Dag', 'engem Dag'],\n            'M': ['ee Mount', 'engem Mount'],\n            'y': ['ee Joer', 'engem Joer']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n    function processFutureTime(string) {\n        var number = string.substr(0, string.indexOf(' '));\n        if (eifelerRegelAppliesToNumber(number)) {\n            return 'a ' + string;\n        }\n        return 'an ' + string;\n    }\n    function processPastTime(string) {\n        var number = string.substr(0, string.indexOf(' '));\n        if (eifelerRegelAppliesToNumber(number)) {\n            return 'viru ' + string;\n        }\n        return 'virun ' + string;\n    }\n    /**\n     * Returns true if the word before the given number loses the '-n' ending.\n     * e.g. 'an 10 Deeg' but 'a 5 Deeg'\n     *\n     * @param number {integer}\n     * @returns {boolean}\n     */\n    function eifelerRegelAppliesToNumber(number) {\n        number = parseInt(number, 10);\n        if (isNaN(number)) {\n            return false;\n        }\n        if (number < 0) {\n            // Negative Number --> always true\n            return true;\n        } else if (number < 10) {\n            // Only 1 digit\n            if (4 <= number && number <= 7) {\n                return true;\n            }\n            return false;\n        } else if (number < 100) {\n            // 2 digits\n            var lastDigit = number % 10, firstDigit = number / 10;\n            if (lastDigit === 0) {\n                return eifelerRegelAppliesToNumber(firstDigit);\n            }\n            return eifelerRegelAppliesToNumber(lastDigit);\n        } else if (number < 10000) {\n            // 3 or 4 digits --> recursively check first digit\n            while (number >= 10) {\n                number = number / 10;\n            }\n            return eifelerRegelAppliesToNumber(number);\n        } else {\n            // Anything larger than 4 digits: recursively check first n-3 digits\n            number = number / 1000;\n            return eifelerRegelAppliesToNumber(number);\n        }\n    }\n\n    var lb = moment.defineLocale('lb', {\n        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),\n        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),\n        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat: {\n            LT: 'H:mm [Auer]',\n            LTS: 'H:mm:ss [Auer]',\n            L: 'DD.MM.YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm [Auer]',\n            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'\n        },\n        calendar: {\n            sameDay: '[Haut um] LT',\n            sameElse: 'L',\n            nextDay: '[Muer um] LT',\n            nextWeek: 'dddd [um] LT',\n            lastDay: '[Gschter um] LT',\n            lastWeek: function () {\n                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule\n                switch (this.day()) {\n                    case 2:\n                    case 4:\n                        return '[Leschten] dddd [um] LT';\n                    default:\n                        return '[Leschte] dddd [um] LT';\n                }\n            }\n        },\n        relativeTime : {\n            future : processFutureTime,\n            past : processPastTime,\n            s : 'e puer Sekonnen',\n            ss : '%d Sekonnen',\n            m : processRelativeTime,\n            mm : '%d Minutten',\n            h : processRelativeTime,\n            hh : '%d Stonnen',\n            d : processRelativeTime,\n            dd : '%d Deeg',\n            M : processRelativeTime,\n            MM : '%d Mint',\n            y : processRelativeTime,\n            yy : '%d Joer'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal: '%d.',\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return lb;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sYi5qcz9jZjc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6Ijc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ20nOiBbJ2VuZyBNaW51dHQnLCAnZW5nZXIgTWludXR0J10sXG4gICAgICAgICAgICAnaCc6IFsnZW5nIFN0b25uJywgJ2VuZ2VyIFN0b25uJ10sXG4gICAgICAgICAgICAnZCc6IFsnZWVuIERhZycsICdlbmdlbSBEYWcnXSxcbiAgICAgICAgICAgICdNJzogWydlZSBNb3VudCcsICdlbmdlbSBNb3VudCddLFxuICAgICAgICAgICAgJ3knOiBbJ2VlIEpvZXInLCAnZW5nZW0gSm9lciddXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0Z1dHVyZVRpbWUoc3RyaW5nKSB7XG4gICAgICAgIHZhciBudW1iZXIgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKCcgJykpO1xuICAgICAgICBpZiAoZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiAnYSAnICsgc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnYW4gJyArIHN0cmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Bhc3RUaW1lKHN0cmluZykge1xuICAgICAgICB2YXIgbnVtYmVyID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZignICcpKTtcbiAgICAgICAgaWYgKGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZpcnUgJyArIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3ZpcnVuICcgKyBzdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd29yZCBiZWZvcmUgdGhlIGdpdmVuIG51bWJlciBsb3NlcyB0aGUgJy1uJyBlbmRpbmcuXG4gICAgICogZS5nLiAnYW4gMTAgRGVlZycgYnV0ICdhIDUgRGVlZydcbiAgICAgKlxuICAgICAqIEBwYXJhbSBudW1iZXIge2ludGVnZXJ9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIsIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gTmVnYXRpdmUgTnVtYmVyIC0tPiBhbHdheXMgdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMTApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgMSBkaWdpdFxuICAgICAgICAgICAgaWYgKDQgPD0gbnVtYmVyICYmIG51bWJlciA8PSA3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMTAwKSB7XG4gICAgICAgICAgICAvLyAyIGRpZ2l0c1xuICAgICAgICAgICAgdmFyIGxhc3REaWdpdCA9IG51bWJlciAlIDEwLCBmaXJzdERpZ2l0ID0gbnVtYmVyIC8gMTA7XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihmaXJzdERpZ2l0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIobGFzdERpZ2l0KTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPCAxMDAwMCkge1xuICAgICAgICAgICAgLy8gMyBvciA0IGRpZ2l0cyAtLT4gcmVjdXJzaXZlbHkgY2hlY2sgZmlyc3QgZGlnaXRcbiAgICAgICAgICAgIHdoaWxlIChudW1iZXIgPj0gMTApIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgPSBudW1iZXIgLyAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGxhcmdlciB0aGFuIDQgZGlnaXRzOiByZWN1cnNpdmVseSBjaGVjayBmaXJzdCBuLTMgZGlnaXRzXG4gICAgICAgICAgICBudW1iZXIgPSBudW1iZXIgLyAxMDAwO1xuICAgICAgICAgICAgcmV0dXJuIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxiID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbGInLCB7XG4gICAgICAgIG1vbnRoczogJ0phbnVhcl9GZWJydWFyX03DpGVyel9BYnLDq2xsX01lZV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydDogJ0phbi5fRmVici5fTXJ6Ll9BYnIuX01lZV9KdW4uX0p1bC5fQXVnLl9TZXB0Ll9Pa3QuX05vdi5fRGV6Licuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzOiAnU29ubmRlZ19Nw6lpbmRlZ19Ew6tuc2NoZGVnX03Dq3R0d29jaF9Eb25uZXNjaGRlZ19GcmVpZGVnX1NhbXNjaGRlZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogJ1NvLl9Nw6kuX0TDqy5fTcOrLl9Eby5fRnIuX1NhLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW46ICdTb19Nw6lfRMOrX03Dq19Eb19Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSDptbSBbQXVlcl0nLFxuICAgICAgICAgICAgTFRTOiAnSDptbTpzcyBbQXVlcl0nLFxuICAgICAgICAgICAgTDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEw6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0gW0F1ZXJdJyxcbiAgICAgICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSBbQXVlcl0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0hhdXQgdW1dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW011ZXIgdW1dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbdW1dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbR8Orc2NodGVyIHVtXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIERpZmZlcmVudCBkYXRlIHN0cmluZyBmb3IgJ0TDq25zY2hkZWcnIChUdWVzZGF5KSBhbmQgJ0Rvbm5lc2NoZGVnJyAoVGh1cnNkYXkpIGR1ZSB0byBwaG9ub2xvZ2ljYWwgcnVsZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW0xlc2NodGVuXSBkZGRkIFt1bV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbTGVzY2h0ZV0gZGRkZCBbdW1dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IHByb2Nlc3NGdXR1cmVUaW1lLFxuICAgICAgICAgICAgcGFzdCA6IHByb2Nlc3NQYXN0VGltZSxcbiAgICAgICAgICAgIHMgOiAnZSBwdWVyIFNla29ubmVuJyxcbiAgICAgICAgICAgIHNzIDogJyVkIFNla29ubmVuJyxcbiAgICAgICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gOiAnJWQgTWludXR0ZW4nLFxuICAgICAgICAgICAgaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoaCA6ICclZCBTdG9ubmVuJyxcbiAgICAgICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZGQgOiAnJWQgRGVlZycsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogJyVkIE3DqWludCcsXG4gICAgICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHl5IDogJyVkIEpvZXInXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWw6ICclZC4nLFxuICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95OiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbGIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74\n");

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var lo = moment.defineLocale('lo', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM: function (input) {\n            return input === '';\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[]dddd[] LT',\n            lastDay : '[] LT',\n            lastWeek : '[]dddd[] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s',\n            s : '',\n            ss : '%d ' ,\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /()\\d{1,2}/,\n        ordinal : function (number) {\n            return '' + number;\n        }\n    });\n\n    return lo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sby5qcz85YzRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGxvID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbG8nLCB7XG4gICAgICAgIG1vbnRocyA6ICfguqHgurHguofguoHguq3guplf4LqB4Lq44Lqh4Lqe4LqyX+C6oeC6teC6meC6sl/gu4DguqHguqrgurJf4Lqe4Lq24LqU4Lqq4Lqw4Lqe4LqyX+C6oeC6tOC6luC6uOC6meC6sl/guoHgu43guqXgurDguoHgurvgupRf4Lqq4Lq04LqH4Lqr4LqyX+C6geC6seC6meC6jeC6sl/gupXgurjguqXgurJf4Lqe4Lqw4LqI4Lq04LqBX+C6l+C6seC6meC6p+C6sicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4Lqh4Lqx4LqH4LqB4Lqt4LqZX+C6geC6uOC6oeC6nuC6sl/guqHgurXgupngurJf4LuA4Lqh4Lqq4LqyX+C6nuC6tuC6lOC6quC6sOC6nuC6sl/guqHgurTgupbgurjgupngurJf4LqB4LuN4Lql4Lqw4LqB4Lq74LqUX+C6quC6tOC6h+C6q+C6sl/guoHgurHgupnguo3gurJf4LqV4Lq44Lql4LqyX+C6nuC6sOC6iOC6tOC6gV/gupfgurHgupnguqfgurInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+C6reC6suC6l+C6tOC6lF/guojgurHguplf4Lqt4Lqx4LqH4LqE4Lqy4LqZX+C6nuC6uOC6lF/gup7gurDguqvgurHgupRf4Lqq4Lq44LqBX+C7gOC6quC6u+C6sicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgupfgurTgupRf4LqI4Lqx4LqZX+C6reC6seC6h+C6hOC6suC6mV/gup7gurjgupRf4Lqe4Lqw4Lqr4Lqx4LqUX+C6quC6uOC6gV/gu4DguqrgurvgurInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+C6l1/guohf4Lqt4LqEX+C6nl/gup7guqtf4Lqq4LqBX+C6qicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ+C6p+C6seC6mWRkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/gupXguq3gupngu4Dguorgurvgu4ngurJ84LqV4Lqt4LqZ4LuB4Lql4LqHLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfgupXguq3gupngu4HguqXguocnO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C6leC6reC6meC7gOC6iuC6u+C7ieC6sic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LqV4Lqt4LqZ4LuB4Lql4LqHJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vguqHgurfgu4ngupngurXgu4ngu4DguqfguqXgurJdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+C6oeC6t+C7ieC6reC6t+C7iOC6meC7gOC6p+C6peC6sl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnW+C6p+C6seC6mV1kZGRkW+C7nOC7ieC6suC7gOC6p+C6peC6sl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4Lqh4Lq34LuJ4Lqn4Lqy4LqZ4LqZ4Lq14LuJ4LuA4Lqn4Lql4LqyXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4Lqn4Lqx4LqZXWRkZGRb4LuB4Lql4LuJ4Lqn4LqZ4Lq14LuJ4LuA4Lqn4Lql4LqyXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn4Lqt4Lq14LqBICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPgupzgu4jgurLgupnguqHgurInLFxuICAgICAgICAgICAgcyA6ICfguprgu43gu4jgu4Dgupfgurvgu4jgurLgu4PgupTguqfgurTgupngurLgupfgurUnLFxuICAgICAgICAgICAgc3MgOiAnJWQg4Lqn4Lq04LqZ4Lqy4LqX4Lq1JyAsXG4gICAgICAgICAgICBtIDogJzEg4LqZ4Lqy4LqX4Lq1JyxcbiAgICAgICAgICAgIG1tIDogJyVkIOC6meC6suC6l+C6tScsXG4gICAgICAgICAgICBoIDogJzEg4LqK4Lq74LuI4Lqn4LuC4Lqh4LqHJyxcbiAgICAgICAgICAgIGhoIDogJyVkIOC6iuC6u+C7iOC6p+C7guC6oeC6hycsXG4gICAgICAgICAgICBkIDogJzEg4Lqh4Lq34LuJJyxcbiAgICAgICAgICAgIGRkIDogJyVkIOC6oeC6t+C7iScsXG4gICAgICAgICAgICBNIDogJzEg4LuA4LqU4Lq34Lqt4LqZJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOC7gOC6lOC6t+C6reC6mScsXG4gICAgICAgICAgICB5IDogJzEg4Lqb4Lq1JyxcbiAgICAgICAgICAgIHl5IDogJyVkIOC6m+C6tSdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogLyjgupfgurXgu4gpXFxkezEsMn0vLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuICfgupfgurXgu4gnICsgbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG87XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xvLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75\n");

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var units = {\n        'ss' : 'sekund_sekundi_sekundes',\n        'm' : 'minut_minuts_minut',\n        'mm': 'minuts_minui_minutes',\n        'h' : 'valanda_valandos_valand',\n        'hh': 'valandos_valand_valandas',\n        'd' : 'diena_dienos_dien',\n        'dd': 'dienos_dien_dienas',\n        'M' : 'mnuo_mnesio_mnes',\n        'MM': 'mnesiai_mnesi_mnesius',\n        'y' : 'metai_met_metus',\n        'yy': 'metai_met_metus'\n    };\n    function translateSeconds(number, withoutSuffix, key, isFuture) {\n        if (withoutSuffix) {\n            return 'kelios sekunds';\n        } else {\n            return isFuture ? 'keli sekundi' : 'kelias sekundes';\n        }\n    }\n    function translateSingular(number, withoutSuffix, key, isFuture) {\n        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);\n    }\n    function special(number) {\n        return number % 10 === 0 || (number > 10 && number < 20);\n    }\n    function forms(key) {\n        return units[key].split('_');\n    }\n    function translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        if (number === 1) {\n            return result + translateSingular(number, withoutSuffix, key[0], isFuture);\n        } else if (withoutSuffix) {\n            return result + (special(number) ? forms(key)[1] : forms(key)[0]);\n        } else {\n            if (isFuture) {\n                return result + forms(key)[1];\n            } else {\n                return result + (special(number) ? forms(key)[1] : forms(key)[2]);\n            }\n        }\n    }\n    var lt = moment.defineLocale('lt', {\n        months : {\n            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),\n            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),\n            isFormat: /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?|MMMM?(\\[[^\\[\\]]*\\]|\\s)+D[oD]?/\n        },\n        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),\n        weekdays : {\n            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),\n            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),\n            isFormat: /dddd HH:mm/\n        },\n        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),\n        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'YYYY [m.] MMMM D [d.]',\n            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',\n            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',\n            l : 'YYYY-MM-DD',\n            ll : 'YYYY [m.] MMMM D [d.]',\n            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',\n            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'\n        },\n        calendar : {\n            sameDay : '[iandien] LT',\n            nextDay : '[Rytoj] LT',\n            nextWeek : 'dddd LT',\n            lastDay : '[Vakar] LT',\n            lastWeek : '[Prajus] dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'po %s',\n            past : 'prie %s',\n            s : translateSeconds,\n            ss : translate,\n            m : translateSingular,\n            mm : translate,\n            h : translateSingular,\n            hh : translate,\n            d : translateSingular,\n            dd : translate,\n            M : translateSingular,\n            MM : translate,\n            y : translateSingular,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-oji/,\n        ordinal : function (number) {\n            return number + '-oji';\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return lt;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdC5qcz9mZmEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6Ijc2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgdW5pdHMgPSB7XG4gICAgICAgICdzcycgOiAnc2VrdW5kxJdfc2VrdW5kxb5pxbNfc2VrdW5kZXMnLFxuICAgICAgICAnbScgOiAnbWludXTEl19taW51dMSXc19taW51dMSZJyxcbiAgICAgICAgJ21tJzogJ21pbnV0xJdzX21pbnXEjWnFs19taW51dGVzJyxcbiAgICAgICAgJ2gnIDogJ3ZhbGFuZGFfdmFsYW5kb3NfdmFsYW5kxIUnLFxuICAgICAgICAnaGgnOiAndmFsYW5kb3NfdmFsYW5kxbNfdmFsYW5kYXMnLFxuICAgICAgICAnZCcgOiAnZGllbmFfZGllbm9zX2RpZW7EhScsXG4gICAgICAgICdkZCc6ICdkaWVub3NfZGllbsWzX2RpZW5hcycsXG4gICAgICAgICdNJyA6ICdtxJdudW9fbcSXbmVzaW9fbcSXbmVzxK8nLFxuICAgICAgICAnTU0nOiAnbcSXbmVzaWFpX23El25lc2nFs19txJduZXNpdXMnLFxuICAgICAgICAneScgOiAnbWV0YWlfbWV0xbNfbWV0dXMnLFxuICAgICAgICAneXknOiAnbWV0YWlfbWV0xbNfbWV0dXMnXG4gICAgfTtcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVTZWNvbmRzKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuICdrZWxpb3Mgc2VrdW5kxJdzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdrZWxpxbMgc2VrdW5kxb5pxbMnIDogJ2tlbGlhcyBzZWt1bmRlcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlU2luZ3VsYXIobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybXMoa2V5KVswXSA6IChpc0Z1dHVyZSA/IGZvcm1zKGtleSlbMV0gOiBmb3JtcyhrZXkpWzJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BlY2lhbChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciAlIDEwID09PSAwIHx8IChudW1iZXIgPiAxMCAmJiBudW1iZXIgPCAyMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1zKGtleSkge1xuICAgICAgICByZXR1cm4gdW5pdHNba2V5XS5zcGxpdCgnXycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyB0cmFuc2xhdGVTaW5ndWxhcihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleVswXSwgaXNGdXR1cmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoc3BlY2lhbChudW1iZXIpID8gZm9ybXMoa2V5KVsxXSA6IGZvcm1zKGtleSlbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1zKGtleSlbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoc3BlY2lhbChudW1iZXIpID8gZm9ybXMoa2V5KVsxXSA6IGZvcm1zKGtleSlbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBsdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2x0Jywge1xuICAgICAgICBtb250aHMgOiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdzYXVzaW9fdmFzYXJpb19rb3ZvX2JhbGFuZMW+aW9fZ2VndcW+xJdzX2JpcsW+ZWxpb19saWVwb3NfcnVncGrFq8SNaW9fcnVnc8SXam9fc3BhbGlvX2xhcGtyacSNaW9fZ3J1b2TFvmlvJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgc3RhbmRhbG9uZTogJ3NhdXNpc192YXNhcmlzX2tvdmFzX2JhbGFuZGlzX2dlZ3XFvsSXX2JpcsW+ZWxpc19saWVwYV9ydWdwasWrdGlzX3J1Z3PEl2ppc19zcGFsaXNfbGFwa3JpdGlzX2dydW9kaXMnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBpc0Zvcm1hdDogL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT98TU1NTT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK0Rbb0RdPy9cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnc2F1X3Zhc19rb3ZfYmFsX2dlZ19iaXJfbGllX3JncF9yZ3Nfc3BhX2xhcF9ncmQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDoge1xuICAgICAgICAgICAgZm9ybWF0OiAnc2VrbWFkaWVuxK9fcGlybWFkaWVuxK9fYW50cmFkaWVuxK9fdHJlxI1pYWRpZW7Er19rZXR2aXJ0YWRpZW7Er19wZW5rdGFkaWVuxK9fxaFlxaF0YWRpZW7Erycuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgIHN0YW5kYWxvbmU6ICdzZWttYWRpZW5pc19waXJtYWRpZW5pc19hbnRyYWRpZW5pc190cmXEjWlhZGllbmlzX2tldHZpcnRhZGllbmlzX3Blbmt0YWRpZW5pc1/FoWXFoXRhZGllbmlzJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgaXNGb3JtYXQ6IC9kZGRkIEhIOm1tL1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1Nla19QaXJfQW50X1RyZV9LZXRfUGVuX8WgZcWhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTX1BfQV9UX0tfUG5fxaAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXG4gICAgICAgICAgICBMTCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0nLFxuICAgICAgICAgICAgTExMIDogJ1lZWVkgW20uXSBNTU1NIEQgW2QuXSwgSEg6bW0gW3ZhbC5dJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBkZGRkLCBISDptbSBbdmFsLl0nLFxuICAgICAgICAgICAgbCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVkgW20uXSBNTU1NIEQgW2QuXScsXG4gICAgICAgICAgICBsbGwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBISDptbSBbdmFsLl0nLFxuICAgICAgICAgICAgbGxsbCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0sIGRkZCwgSEg6bW0gW3ZhbC5dJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW8WgaWFuZGllbl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbUnl0b2pdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbVmFrYXJdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tQcmHEl2p1c8SvXSBkZGRkIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdwbyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ByaWXFoSAlcycsXG4gICAgICAgICAgICBzIDogdHJhbnNsYXRlU2Vjb25kcyxcbiAgICAgICAgICAgIHNzIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbSA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxuICAgICAgICAgICAgbW0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoIDogdHJhbnNsYXRlU2luZ3VsYXIsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiB0cmFuc2xhdGVTaW5ndWxhcixcbiAgICAgICAgICAgIGRkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTSA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogdHJhbnNsYXRlU2luZ3VsYXIsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tb2ppLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLW9qaSc7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGx0O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///76\n");

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var units = {\n        'ss': 'sekundes_sekundm_sekunde_sekundes'.split('_'),\n        'm': 'mintes_mintm_minte_mintes'.split('_'),\n        'mm': 'mintes_mintm_minte_mintes'.split('_'),\n        'h': 'stundas_stundm_stunda_stundas'.split('_'),\n        'hh': 'stundas_stundm_stunda_stundas'.split('_'),\n        'd': 'dienas_dienm_diena_dienas'.split('_'),\n        'dd': 'dienas_dienm_diena_dienas'.split('_'),\n        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),\n        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),\n        'y': 'gada_gadiem_gads_gadi'.split('_'),\n        'yy': 'gada_gadiem_gads_gadi'.split('_')\n    };\n    /**\n     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.\n     */\n    function format(forms, number, withoutSuffix) {\n        if (withoutSuffix) {\n            // E.g. \"21 minte\", \"3 mintes\".\n            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];\n        } else {\n            // E.g. \"21 mintes\" as in \"pc 21 mintes\".\n            // E.g. \"3 mintm\" as in \"pc 3 mintm\".\n            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];\n        }\n    }\n    function relativeTimeWithPlural(number, withoutSuffix, key) {\n        return number + ' ' + format(units[key], number, withoutSuffix);\n    }\n    function relativeTimeWithSingular(number, withoutSuffix, key) {\n        return format(units[key], number, withoutSuffix);\n    }\n    function relativeSeconds(number, withoutSuffix) {\n        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';\n    }\n\n    var lv = moment.defineLocale('lv', {\n        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),\n        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),\n        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),\n        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY.',\n            LL : 'YYYY. [gada] D. MMMM',\n            LLL : 'YYYY. [gada] D. MMMM, HH:mm',\n            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'\n        },\n        calendar : {\n            sameDay : '[odien pulksten] LT',\n            nextDay : '[Rt pulksten] LT',\n            nextWeek : 'dddd [pulksten] LT',\n            lastDay : '[Vakar pulksten] LT',\n            lastWeek : '[Pagju] dddd [pulksten] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'pc %s',\n            past : 'pirms %s',\n            s : relativeSeconds,\n            ss : relativeTimeWithPlural,\n            m : relativeTimeWithSingular,\n            mm : relativeTimeWithPlural,\n            h : relativeTimeWithSingular,\n            hh : relativeTimeWithPlural,\n            d : relativeTimeWithSingular,\n            dd : relativeTimeWithPlural,\n            M : relativeTimeWithSingular,\n            MM : relativeTimeWithPlural,\n            y : relativeTimeWithSingular,\n            yy : relativeTimeWithPlural\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return lv;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdi5qcz84ZjExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHVuaXRzID0ge1xuICAgICAgICAnc3MnOiAnc2VrdW5kZXNfc2VrdW5kxJNtX3Nla3VuZGVfc2VrdW5kZXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdtJzogJ21pbsWrdGVzX21pbsWrdMSTbV9taW7Fq3RlX21pbsWrdGVzJy5zcGxpdCgnXycpLFxuICAgICAgICAnbW0nOiAnbWluxat0ZXNfbWluxat0xJNtX21pbsWrdGVfbWluxat0ZXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdoJzogJ3N0dW5kYXNfc3R1bmTEgW1fc3R1bmRhX3N0dW5kYXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdoaCc6ICdzdHVuZGFzX3N0dW5kxIFtX3N0dW5kYV9zdHVuZGFzJy5zcGxpdCgnXycpLFxuICAgICAgICAnZCc6ICdkaWVuYXNfZGllbsSBbV9kaWVuYV9kaWVuYXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdkZCc6ICdkaWVuYXNfZGllbsSBbV9kaWVuYV9kaWVuYXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdNJzogJ23Ek25lxaFhX23Ek25lxaFpZW1fbcSTbmVzaXNfbcSTbmXFoWknLnNwbGl0KCdfJyksXG4gICAgICAgICdNTSc6ICdtxJNuZcWhYV9txJNuZcWhaWVtX23Ek25lc2lzX23Ek25lxaFpJy5zcGxpdCgnXycpLFxuICAgICAgICAneSc6ICdnYWRhX2dhZGllbV9nYWRzX2dhZGknLnNwbGl0KCdfJyksXG4gICAgICAgICd5eSc6ICdnYWRhX2dhZGllbV9nYWRzX2dhZGknLnNwbGl0KCdfJylcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB3aXRob3V0U3VmZml4IGJvb2xlYW4gdHJ1ZSA9IGEgbGVuZ3RoIG9mIHRpbWU7IGZhbHNlID0gYmVmb3JlL2FmdGVyIGEgcGVyaW9kIG9mIHRpbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0KGZvcm1zLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIEUuZy4gXCIyMSBtaW7Fq3RlXCIsIFwiMyBtaW7Fq3Rlc1wiLlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciAlIDEwID09PSAxICYmIG51bWJlciAlIDEwMCAhPT0gMTEgPyBmb3Jtc1syXSA6IGZvcm1zWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRS5nLiBcIjIxIG1pbsWrdGVzXCIgYXMgaW4gXCJwxJNjIDIxIG1pbsWrdGVzXCIuXG4gICAgICAgICAgICAvLyBFLmcuIFwiMyBtaW7Fq3TEk21cIiBhcyBpbiBcInDEk2MgMyBtaW7Fq3TEk21cIi5cbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgJSAxMCA9PT0gMSAmJiBudW1iZXIgJSAxMDAgIT09IDExID8gZm9ybXNbMF0gOiBmb3Jtc1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBmb3JtYXQodW5pdHNba2V5XSwgbnVtYmVyLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFNpbmd1bGFyKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQodW5pdHNba2V5XSwgbnVtYmVyLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVTZWNvbmRzKG51bWJlciwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdkYcW+YXMgc2VrdW5kZXMnIDogJ2Rhxb7EgW0gc2VrdW5kxJNtJztcbiAgICB9XG5cbiAgICB2YXIgbHYgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdsdicsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnbEgXJpc19mZWJydcSBcmlzX21hcnRzX2FwcsSrbGlzX21haWpzX2rFq25panNfasWrbGlqc19hdWd1c3RzX3NlcHRlbWJyaXNfb2t0b2JyaXNfbm92ZW1icmlzX2RlY2VtYnJpcycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21haV9qxatuX2rFq2xfYXVnX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnc3bEk3RkaWVuYV9waXJtZGllbmFfb3RyZGllbmFfdHJlxaFkaWVuYV9jZXR1cnRkaWVuYV9waWVrdGRpZW5hX3Nlc3RkaWVuYScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdTdl9QX09fVF9DX1BrX1MnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1N2X1BfT19UX0NfUGtfUycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZLicsXG4gICAgICAgICAgICBMTCA6ICdZWVlZLiBbZ2FkYV0gRC4gTU1NTScsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWS4gW2dhZGFdIEQuIE1NTU0sIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWS4gW2dhZGFdIEQuIE1NTU0sIGRkZGQsIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW8Wgb2RpZW4gcHVsa3N0ZW5dIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1LEq3QgcHVsa3N0ZW5dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1bGtzdGVuXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tWYWthciBwdWxrc3Rlbl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW1BhZ8SBanXFocSBXSBkZGRkIFtwdWxrc3Rlbl0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3DEk2MgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdwaXJtcyAlcycsXG4gICAgICAgICAgICBzIDogcmVsYXRpdmVTZWNvbmRzLFxuICAgICAgICAgICAgc3MgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcbiAgICAgICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGggOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXG4gICAgICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBkIDogcmVsYXRpdmVUaW1lV2l0aFNpbmd1bGFyLFxuICAgICAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgTSA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIHkgOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXG4gICAgICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsdjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHYuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77\n");

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var translator = {\n        words: { //Different grammatical cases\n            ss: ['sekund', 'sekunda', 'sekundi'],\n            m: ['jedan minut', 'jednog minuta'],\n            mm: ['minut', 'minuta', 'minuta'],\n            h: ['jedan sat', 'jednog sata'],\n            hh: ['sat', 'sata', 'sati'],\n            dd: ['dan', 'dana', 'dana'],\n            MM: ['mjesec', 'mjeseca', 'mjeseci'],\n            yy: ['godina', 'godine', 'godina']\n        },\n        correctGrammaticalCase: function (number, wordKey) {\n            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n        },\n        translate: function (number, withoutSuffix, key) {\n            var wordKey = translator.words[key];\n            if (key.length === 1) {\n                return withoutSuffix ? wordKey[0] : wordKey[1];\n            } else {\n                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);\n            }\n        }\n    };\n\n    var me = moment.defineLocale('me', {\n        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),\n        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),\n        monthsParseExact : true,\n        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat: {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L: 'DD.MM.YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm',\n            LLLL: 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar: {\n            sameDay: '[danas u] LT',\n            nextDay: '[sjutra u] LT',\n\n            nextWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[u] [nedjelju] [u] LT';\n                    case 3:\n                        return '[u] [srijedu] [u] LT';\n                    case 6:\n                        return '[u] [subotu] [u] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[jue u] LT',\n            lastWeek : function () {\n                var lastWeekDays = [\n                    '[prole] [nedjelje] [u] LT',\n                    '[prolog] [ponedjeljka] [u] LT',\n                    '[prolog] [utorka] [u] LT',\n                    '[prole] [srijede] [u] LT',\n                    '[prolog] [etvrtka] [u] LT',\n                    '[prolog] [petka] [u] LT',\n                    '[prole] [subote] [u] LT'\n                ];\n                return lastWeekDays[this.day()];\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'prije %s',\n            s      : 'nekoliko sekundi',\n            ss     : translator.translate,\n            m      : translator.translate,\n            mm     : translator.translate,\n            h      : translator.translate,\n            hh     : translator.translate,\n            d      : 'dan',\n            dd     : translator.translate,\n            M      : 'mjesec',\n            MM     : translator.translate,\n            y      : 'godinu',\n            yy     : translator.translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return me;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tZS5qcz9iMmYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB0cmFuc2xhdG9yID0ge1xuICAgICAgICB3b3JkczogeyAvL0RpZmZlcmVudCBncmFtbWF0aWNhbCBjYXNlc1xuICAgICAgICAgICAgc3M6IFsnc2VrdW5kJywgJ3Nla3VuZGEnLCAnc2VrdW5kaSddLFxuICAgICAgICAgICAgbTogWydqZWRhbiBtaW51dCcsICdqZWRub2cgbWludXRhJ10sXG4gICAgICAgICAgICBtbTogWydtaW51dCcsICdtaW51dGEnLCAnbWludXRhJ10sXG4gICAgICAgICAgICBoOiBbJ2plZGFuIHNhdCcsICdqZWRub2cgc2F0YSddLFxuICAgICAgICAgICAgaGg6IFsnc2F0JywgJ3NhdGEnLCAnc2F0aSddLFxuICAgICAgICAgICAgZGQ6IFsnZGFuJywgJ2RhbmEnLCAnZGFuYSddLFxuICAgICAgICAgICAgTU06IFsnbWplc2VjJywgJ21qZXNlY2EnLCAnbWplc2VjaSddLFxuICAgICAgICAgICAgeXk6IFsnZ29kaW5hJywgJ2dvZGluZScsICdnb2RpbmEnXVxuICAgICAgICB9LFxuICAgICAgICBjb3JyZWN0R3JhbW1hdGljYWxDYXNlOiBmdW5jdGlvbiAobnVtYmVyLCB3b3JkS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyID09PSAxID8gd29yZEtleVswXSA6IChudW1iZXIgPj0gMiAmJiBudW1iZXIgPD0gNCA/IHdvcmRLZXlbMV0gOiB3b3JkS2V5WzJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB3b3JkS2V5ID0gdHJhbnNsYXRvci53b3Jkc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IHdvcmRLZXlbMF0gOiB3b3JkS2V5WzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgdHJhbnNsYXRvci5jb3JyZWN0R3JhbW1hdGljYWxDYXNlKG51bWJlciwgd29yZEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1lID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbWUnLCB7XG4gICAgICAgIG1vbnRoczogJ2phbnVhcl9mZWJydWFyX21hcnRfYXByaWxfbWFqX2p1bl9qdWxfYXZndXN0X3NlcHRlbWJhcl9va3RvYmFyX25vdmVtYmFyX2RlY2VtYmFyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydDogJ2phbi5fZmViLl9tYXIuX2Fwci5fbWFqX2p1bl9qdWxfYXZnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXM6ICduZWRqZWxqYV9wb25lZGplbGpha191dG9yYWtfc3JpamVkYV/EjWV0dnJ0YWtfcGV0YWtfc3Vib3RhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiAnbmVkLl9wb24uX3V0by5fc3JpLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAnbmVfcG9fdXRfc3JfxI1lX3BlX3N1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDoge1xuICAgICAgICAgICAgTFQ6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXI6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbZGFuYXMgdV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tzanV0cmEgdV0gTFQnLFxuXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbbmVkamVsanVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmlqZWR1XSBbdV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3Vib3R1XSBbdV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBkZGRkIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgIDogJ1tqdcSNZSB1XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFdlZWtEYXlzID0gW1xuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtuZWRqZWxqZV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3BvbmVkamVsamthXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbdXRvcmthXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtzcmlqZWRlXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbxI1ldHZydGthXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcGV0a2FdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RXZWVrRGF5c1t0aGlzLmRheSgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxuICAgICAgICAgICAgcGFzdCAgIDogJ3ByaWplICVzJyxcbiAgICAgICAgICAgIHMgICAgICA6ICduZWtvbGlrbyBzZWt1bmRpJyxcbiAgICAgICAgICAgIHNzICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgbSAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBkICAgICAgOiAnZGFuJyxcbiAgICAgICAgICAgIGRkICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgTSAgICAgIDogJ21qZXNlYycsXG4gICAgICAgICAgICBNTSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxuICAgICAgICAgICAgeXkgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtZTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWUuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78\n");

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var mi = moment.defineLocale('mi', {\n        months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),\n        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),\n        monthsRegex: /(?:['a-z\\u0101\\u014D\\u016B]+\\-?){1,3}/i,\n        monthsStrictRegex: /(?:['a-z\\u0101\\u014D\\u016B]+\\-?){1,3}/i,\n        monthsShortRegex: /(?:['a-z\\u0101\\u014D\\u016B]+\\-?){1,3}/i,\n        monthsShortStrictRegex: /(?:['a-z\\u0101\\u014D\\u016B]+\\-?){1,2}/i,\n        weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),\n        weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),\n        weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY [i] HH:mm',\n            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'\n        },\n        calendar: {\n            sameDay: '[i teie mahana, i] LT',\n            nextDay: '[apopo i] LT',\n            nextWeek: 'dddd [i] LT',\n            lastDay: '[inanahi i] LT',\n            lastWeek: 'dddd [whakamutunga i] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: 'i roto i %s',\n            past: '%s i mua',\n            s: 'te hkona ruarua',\n            ss: '%d hkona',\n            m: 'he meneti',\n            mm: '%d meneti',\n            h: 'te haora',\n            hh: '%d haora',\n            d: 'he ra',\n            dd: '%d ra',\n            M: 'he marama',\n            MM: '%d marama',\n            y: 'he tau',\n            yy: '%d tau'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal: '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return mi;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9taS5qcz84MDQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0EsdURBQXVELElBQUk7QUFDM0QsNkRBQTZELElBQUk7QUFDakUsNERBQTRELElBQUk7QUFDaEUsa0VBQWtFLElBQUk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtaSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21pJywge1xuICAgICAgICBtb250aHM6ICdLb2hpLXTEgXRlX0h1aS10YW5ndXJ1X1BvdXTFqy10ZS1yYW5naV9QYWVuZ2Etd2jEgXdoxIFfSGFyYXR1YV9QaXBpcmlfSMWNbmdvaW5nb2lfSGVyZS10dXJpLWvFjWvEgV9NYWh1cnVfV2hpcmluZ2EtxIEtbnVrdV9XaGlyaW5nYS3EgS1yYW5naV9IYWtpaGVhJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydDogJ0tvaGlfSHVpX1BvdV9QYWVfSGFyYV9QaXBpX0jFjW5nb2lfSGVyZV9NYWh1X1doaS1udV9XaGktcmFfSGFraScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUmVnZXg6IC8oPzpbJ2EtelxcdTAxMDFcXHUwMTREXFx1MDE2Ql0rXFwtPyl7MSwzfS9pLFxuICAgICAgICBtb250aHNTdHJpY3RSZWdleDogLyg/OlsnYS16XFx1MDEwMVxcdTAxNERcXHUwMTZCXStcXC0/KXsxLDN9L2ksXG4gICAgICAgIG1vbnRoc1Nob3J0UmVnZXg6IC8oPzpbJ2EtelxcdTAxMDFcXHUwMTREXFx1MDE2Ql0rXFwtPyl7MSwzfS9pLFxuICAgICAgICBtb250aHNTaG9ydFN0cmljdFJlZ2V4OiAvKD86WydhLXpcXHUwMTAxXFx1MDE0RFxcdTAxNkJdK1xcLT8pezEsMn0vaSxcbiAgICAgICAgd2Vla2RheXM6ICdSxIF0YXB1X01hbmVfVMWrcmVpX1dlbmVyZWlfVMSBaXRlX1BhcmFpcmVfSMSBdGFyZWknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICdUYV9NYV9UxatfV2VfVMSBaV9QYV9IxIEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAnVGFfTWFfVMWrX1dlX1TEgWlfUGFfSMSBJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDoge1xuICAgICAgICAgICAgTFQ6ICdISDptbScsXG4gICAgICAgICAgICBMVFM6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIFtpXSBISDptbScsXG4gICAgICAgICAgICBMTExMOiAnZGRkZCwgRCBNTU1NIFlZWVkgW2ldIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhcjoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tpIHRlaWUgbWFoYW5hLCBpXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW2Fwb3BvIGldIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbaV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tpbmFuYWhpIGldIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbd2hha2FtdXR1bmdhIGldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiB7XG4gICAgICAgICAgICBmdXR1cmU6ICdpIHJvdG8gaSAlcycsXG4gICAgICAgICAgICBwYXN0OiAnJXMgaSBtdWEnLFxuICAgICAgICAgICAgczogJ3RlIGjEk2tvbmEgcnVhcnVhJyxcbiAgICAgICAgICAgIHNzOiAnJWQgaMSTa29uYScsXG4gICAgICAgICAgICBtOiAnaGUgbWVuZXRpJyxcbiAgICAgICAgICAgIG1tOiAnJWQgbWVuZXRpJyxcbiAgICAgICAgICAgIGg6ICd0ZSBoYW9yYScsXG4gICAgICAgICAgICBoaDogJyVkIGhhb3JhJyxcbiAgICAgICAgICAgIGQ6ICdoZSByYScsXG4gICAgICAgICAgICBkZDogJyVkIHJhJyxcbiAgICAgICAgICAgIE06ICdoZSBtYXJhbWEnLFxuICAgICAgICAgICAgTU06ICclZCBtYXJhbWEnLFxuICAgICAgICAgICAgeTogJ2hlIHRhdScsXG4gICAgICAgICAgICB5eTogJyVkIHRhdSdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsOiAnJWTCuicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9taS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///79\n");

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var mk = moment.defineLocale('mk', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : 'e_o_____a'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'D.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd, D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : '[] dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                    case 3:\n                    case 6:\n                        return '[] dddd [] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[] dddd [] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : ' ',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(|||||)/,\n        ordinal : function (number) {\n            var lastDigit = number % 10,\n                last2Digits = number % 100;\n            if (number === 0) {\n                return number + '-';\n            } else if (last2Digits === 0) {\n                return number + '-';\n            } else if (last2Digits > 10 && last2Digits < 20) {\n                return number + '-';\n            } else if (lastDigit === 1) {\n                return number + '-';\n            } else if (lastDigit === 2) {\n                return number + '-';\n            } else if (lastDigit === 7 || lastDigit === 8) {\n                return number + '-';\n            } else {\n                return number + '-';\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return mk;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tay5qcz8wMWJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjgwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbWsgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtaycsIHtcbiAgICAgICAgbW9udGhzIDogJ9GY0LDQvdGD0LDRgNC4X9GE0LXQstGA0YPQsNGA0Lhf0LzQsNGA0YJf0LDQv9GA0LjQu1/QvNCw0Zhf0ZjRg9C90Lhf0ZjRg9C70Lhf0LDQstCz0YPRgdGCX9GB0LXQv9GC0LXQvNCy0YDQuF/QvtC60YLQvtC80LLRgNC4X9C90L7QtdC80LLRgNC4X9C00LXQutC10LzQstGA0LgnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GY0LDQvV/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Zhf0ZjRg9C9X9GY0YPQu1/QsNCy0LNf0YHQtdC/X9C+0LrRgl/QvdC+0LVf0LTQtdC6Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfQvdC10LTQtdC70LBf0L/QvtC90LXQtNC10LvQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTQsF/Rh9C10YLQstGA0YLQvtC6X9C/0LXRgtC+0Lpf0YHQsNCx0L7RgtCwJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9C90LXQtF/Qv9C+0L1f0LLRgtC+X9GB0YDQtV/Rh9C10YJf0L/QtdGCX9GB0LDQsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0L1lX9C/b1/QstGCX9GB0YBf0YfQtV/Qv9C1X9GBYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnRC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vQlNC10L3QtdGBINCy0L5dIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW9Cj0YLRgNC1INCy0L5dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vQktC+XSBkZGRkIFvQstC+XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vQktGH0LXRgNCwINCy0L5dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JjQt9C80LjQvdCw0YLQsNGC0LBdIGRkZGQgW9Cy0L5dIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JjQt9C80LjQvdCw0YLQuNC+0YJdIGRkZGQgW9Cy0L5dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9C/0L7RgdC70LUgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfQv9GA0LXQtCAlcycsXG4gICAgICAgICAgICBzIDogJ9C90LXQutC+0LvQutGDINGB0LXQutGD0L3QtNC4JyxcbiAgICAgICAgICAgIHNzIDogJyVkINGB0LXQutGD0L3QtNC4JyxcbiAgICAgICAgICAgIG0gOiAn0LzQuNC90YPRgtCwJyxcbiAgICAgICAgICAgIG1tIDogJyVkINC80LjQvdGD0YLQuCcsXG4gICAgICAgICAgICBoIDogJ9GH0LDRgScsXG4gICAgICAgICAgICBoaCA6ICclZCDRh9Cw0YHQsCcsXG4gICAgICAgICAgICBkIDogJ9C00LXQvScsXG4gICAgICAgICAgICBkZCA6ICclZCDQtNC10L3QsCcsXG4gICAgICAgICAgICBNIDogJ9C80LXRgdC10YYnLFxuICAgICAgICAgICAgTU0gOiAnJWQg0LzQtdGB0LXRhtC4JyxcbiAgICAgICAgICAgIHkgOiAn0LPQvtC00LjQvdCwJyxcbiAgICAgICAgICAgIHl5IDogJyVkINCz0L7QtNC40L3QuCdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjQtdCyfNC10L180YLQuHzQstC4fNGA0Lh80LzQuCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGxhc3REaWdpdCA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIGxhc3QyRGlnaXRzID0gbnVtYmVyICUgMTAwO1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC10LInO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0MkRpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC10L0nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0MkRpZ2l0cyA+IDEwICYmIGxhc3QyRGlnaXRzIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgtC4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LLQuCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGA0LgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDcgfHwgbGFzdERpZ2l0ID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LzQuCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGC0LgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtaztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWsuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///80\n");

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ml = moment.defineLocale('ml', {\n        months : '___________'.split('_'),\n        monthsShort : '._._._.___._._._._._.'.split('_'),\n        monthsParseExact : true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm -',\n            LTS : 'A h:mm:ss -',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm -',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm -'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        meridiemParse: /|| ||/i,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if ((meridiem === '' && hour >= 4) ||\n                    meridiem === ' ' ||\n                    meridiem === '') {\n                return hour + 12;\n            } else {\n                return hour;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return ' ';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        }\n    });\n\n    return ml;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbC5qcz9hMjhkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI4MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG1sID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbWwnLCB7XG4gICAgICAgIG1vbnRocyA6ICfgtJzgtKjgtYHgtLXgtLDgtL9f4LSr4LWG4LSs4LWN4LSw4LWB4LS14LSw4LS/X+C0ruC0vuC1vOC0muC1jeC0muC1jV/gtI/gtKrgtY3gtLDgtL/gtb1f4LSu4LWH4LSv4LWNX+C0nOC1guC1ul/gtJzgtYLgtLLgtYhf4LST4LSX4LS44LWN4LSx4LWN4LSx4LWNX+C0uOC1huC0quC1jeC0seC1jeC0seC0guC0rOC1vF/gtJLgtJXgtY3gtJ/gtYvgtKzgtbxf4LSo4LS14LSC4LSs4LW8X+C0oeC0v+C0uOC0guC0rOC1vCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4LSc4LSo4LWBLl/gtKvgtYbgtKzgtY3gtLDgtYEuX+C0ruC0vuC1vC5f4LSP4LSq4LWN4LSw4LS/Ll/gtK7gtYfgtK/gtY1f4LSc4LWC4LW6X+C0nOC1guC0suC1iC5f4LST4LSXLl/gtLjgtYbgtKrgtY3gtLHgtY3gtLEuX+C0kuC0leC1jeC0n+C1iy5f4LSo4LS14LSCLl/gtKHgtL/gtLjgtIIuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAn4LSe4LS+4LSv4LSx4LS+4LS04LWN4LSaX+C0pOC0v+C0meC1jeC0leC0s+C0vuC0tOC1jeC0ml/gtJrgtYrgtLXgtY3gtLXgtL7gtLTgtY3gtJpf4LSs4LWB4LSn4LSo4LS+4LS04LWN4LSaX+C0teC1jeC0r+C0vuC0tOC0vuC0tOC1jeC0ml/gtLXgtYbgtLPgtY3gtLPgtL/gtK/gtL7gtLTgtY3gtJpf4LS24LSo4LS/4LSv4LS+4LS04LWN4LSaJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+C0nuC0vuC0r+C1vF/gtKTgtL/gtJngtY3gtJXgtb5f4LSa4LWK4LS14LWN4LS1X+C0rOC1geC0p+C1u1/gtLXgtY3gtK/gtL7gtLTgtIJf4LS14LWG4LSz4LWN4LSz4LS/X+C0tuC0qOC0vycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn4LSe4LS+X+C0pOC0v1/gtJrgtYpf4LSs4LWBX+C0teC1jeC0r+C0vl/gtLXgtYZf4LS2Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0EgaDptbSAt4LSo4LWBJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3MgLeC0qOC1gScsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0gLeC0qOC1gScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0gLeC0qOC1gSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgtIfgtKjgtY3gtKjgtY1dIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+C0qOC0vuC0s+C1hl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4LSH4LSo4LWN4LSo4LSy4LWGXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4LSV4LS04LS/4LSe4LWN4LSeXSBkZGRkLCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg4LSV4LS04LS/4LSe4LWN4LSe4LWNJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg4LSu4LWB4LW74LSq4LWNJyxcbiAgICAgICAgICAgIHMgOiAn4LSF4LW94LSqIOC0qOC0v+C0ruC0v+C0t+C0meC1jeC0meC1vicsXG4gICAgICAgICAgICBzcyA6ICclZCDgtLjgtYbgtJXgtY3gtJXgtbvgtKHgtY0nLFxuICAgICAgICAgICAgbSA6ICfgtJLgtLDgtYEg4LSu4LS/4LSo4LS/4LSx4LWN4LSx4LWNJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOC0ruC0v+C0qOC0v+C0seC1jeC0seC1jScsXG4gICAgICAgICAgICBoIDogJ+C0kuC0sOC1gSDgtK7gtKPgtL/gtJXgtY3gtJXgtYLgtbwnLFxuICAgICAgICAgICAgaGggOiAnJWQg4LSu4LSj4LS/4LSV4LWN4LSV4LWC4LW8JyxcbiAgICAgICAgICAgIGQgOiAn4LSS4LSw4LWBIOC0puC0v+C0teC0uOC0gicsXG4gICAgICAgICAgICBkZCA6ICclZCDgtKbgtL/gtLXgtLjgtIInLFxuICAgICAgICAgICAgTSA6ICfgtJLgtLDgtYEg4LSu4LS+4LS44LSCJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOC0ruC0vuC0uOC0gicsXG4gICAgICAgICAgICB5IDogJ+C0kuC0sOC1gSDgtLXgtbzgtLfgtIInLFxuICAgICAgICAgICAgeXkgOiAnJWQg4LS14LW84LS34LSCJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv4LSw4LS+4LSk4LWN4LSw4LS/fOC0sOC0vuC0teC0v+C0suC1hnzgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNfOC0teC1iOC0leC1geC0qOC1jeC0qOC1h+C0sOC0gnzgtLDgtL7gtKTgtY3gtLDgtL8vaSxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobWVyaWRpZW0gPT09ICfgtLDgtL7gtKTgtY3gtLDgtL8nICYmIGhvdXIgPj0gNCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNJyB8fFxuICAgICAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+C0teC1iOC0leC1geC0qOC1jeC0qOC1h+C0sOC0gicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C0sOC0vuC0pOC1jeC0sOC0vyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LSw4LS+4LS14LS/4LSy4LWGJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgtLXgtYjgtJXgtYHgtKjgtY3gtKjgtYfgtLDgtIInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C0sOC0vuC0pOC1jeC0sOC0vyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtbDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWwuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81\n");

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function translate(number, withoutSuffix, key, isFuture) {\n        switch (key) {\n            case 's':\n                return withoutSuffix ? ' ' : ' ';\n            case 'ss':\n                return number + (withoutSuffix ? ' ' : ' ');\n            case 'm':\n            case 'mm':\n                return number + (withoutSuffix ? ' ' : ' ');\n            case 'h':\n            case 'hh':\n                return number + (withoutSuffix ? ' ' : ' ');\n            case 'd':\n            case 'dd':\n                return number + (withoutSuffix ? ' ' : ' ');\n            case 'M':\n            case 'MM':\n                return number + (withoutSuffix ? ' ' : ' ');\n            case 'y':\n            case 'yy':\n                return number + (withoutSuffix ? ' ' : ' ');\n            default:\n                return number;\n        }\n    }\n\n    var mn = moment.defineLocale('mn', {\n        months : ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),\n        monthsShort : '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),\n        monthsParseExact : true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'YYYY  MMMM D',\n            LLL : 'YYYY  MMMM D HH:mm',\n            LLLL : 'dddd, YYYY  MMMM D HH:mm'\n        },\n        meridiemParse: /|/i,\n        isPM : function (input) {\n            return input === '';\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[] dddd LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : translate,\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : translate,\n            hh : translate,\n            d : translate,\n            dd : translate,\n            M : translate,\n            MM : translate,\n            y : translate,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2} /,\n        ordinal : function (number, period) {\n            switch (period) {\n                case 'd':\n                case 'D':\n                case 'DDD':\n                    return number + ' ';\n                default:\n                    return number;\n            }\n        }\n    });\n\n    return mn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbi5qcz8wYWExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9GF0Y3QtNGF0Y3QvSDRgdC10LrRg9C90LQnIDogJ9GF0Y3QtNGF0Y3QvSDRgdC10LrRg9C90LTRi9C9JztcbiAgICAgICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKHdpdGhvdXRTdWZmaXggPyAnINGB0LXQutGD0L3QtCcgOiAnINGB0LXQutGD0L3QtNGL0L0nKTtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAod2l0aG91dFN1ZmZpeCA/ICcg0LzQuNC90YPRgicgOiAnINC80LjQvdGD0YLRi9C9Jyk7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKHdpdGhvdXRTdWZmaXggPyAnINGG0LDQsycgOiAnINGG0LDQs9C40LnQvScpO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICh3aXRob3V0U3VmZml4ID8gJyDTqdC006nRgCcgOiAnINOp0LTRgNC40LnQvScpO1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICh3aXRob3V0U3VmZml4ID8gJyDRgdCw0YAnIDogJyDRgdCw0YDRi9C9Jyk7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIGNhc2UgJ3l5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKHdpdGhvdXRTdWZmaXggPyAnINC20LjQuycgOiAnINC20LjQu9C40LnQvScpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1uID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbW4nLCB7XG4gICAgICAgIG1vbnRocyA6ICfQndGN0LPQtNKv0LPRjdGN0YAg0YHQsNGAX9Cl0L7RkdGA0LTRg9Cz0LDQsNGAINGB0LDRgF/Qk9GD0YDQsNCy0LTRg9Cz0LDQsNGAINGB0LDRgF/QlNOp0YDTqdCy0LTSr9Cz0Y3RjdGAINGB0LDRgF/QotCw0LLQtNGD0LPQsNCw0YAg0YHQsNGAX9CX0YPRgNCz0LDQtNGD0LPQsNCw0YAg0YHQsNGAX9CU0L7Qu9C00YPQs9Cw0LDRgCDRgdCw0YBf0J3QsNC50LzQtNGD0LPQsNCw0YAg0YHQsNGAX9CV0YHQtNKv0LPRjdGN0YAg0YHQsNGAX9CQ0YDQsNCy0LTRg9Cz0LDQsNGAINGB0LDRgF/QkNGA0LLQsNC9INC90Y3Qs9C00q/Qs9GN0Y3RgCDRgdCw0YBf0JDRgNCy0LDQvSDRhdC+0ZHRgNC00YPQs9Cw0LDRgCDRgdCw0YAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJzEg0YHQsNGAXzIg0YHQsNGAXzMg0YHQsNGAXzQg0YHQsNGAXzUg0YHQsNGAXzYg0YHQsNGAXzcg0YHQsNGAXzgg0YHQsNGAXzkg0YHQsNGAXzEwINGB0LDRgF8xMSDRgdCw0YBfMTIg0YHQsNGAJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAn0J3Rj9C8X9CU0LDQstCw0LBf0JzRj9Cz0LzQsNGAX9Cb0YXQsNCz0LLQsF/Qn9Kv0YDRjdCyX9CR0LDQsNGB0LDQvV/QkdGP0LzQsdCwJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9Cd0Y/QvF/QlNCw0LJf0JzRj9CzX9Cb0YXQsF/Qn9Kv0YBf0JHQsNCwX9CR0Y/QvCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0J3Rj1/QlNCwX9Cc0Y9f0JvRhV/Qn9KvX9CR0LBf0JHRjycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVkg0L7QvdGLIE1NTU3Ri9C9IEQnLFxuICAgICAgICAgICAgTExMIDogJ1lZWVkg0L7QvdGLIE1NTU3Ri9C9IEQgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBZWVlZINC+0L3RiyBNTU1N0YvQvSBEIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv0q7TqHzSrtClL2ksXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PT0gJ9Ku0KUnO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9Ku06gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9Ku0KUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW9Oo0L3TqdOp0LTTqdGAXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vQnNCw0YDQs9Cw0LDRiF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnW9CY0YDRjdGFXSBkZGRkIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW9Oo0YfQuNCz0LTTqdGAXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb06jQvdCz06nRgNGB06nQvV0gZGRkZCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg0LTQsNGA0LDQsCcsXG4gICAgICAgICAgICBwYXN0IDogJyVzINOp0LzQvdOpJyxcbiAgICAgICAgICAgIHMgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBzcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0g06nQtNOp0YAvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnINOp0LTTqdGAJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbW47XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21uLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///82\n");

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    function relativeTimeMr(number, withoutSuffix, string, isFuture)\n    {\n        var output = '';\n        if (withoutSuffix) {\n            switch (string) {\n                case 's': output = ' '; break;\n                case 'ss': output = '%d '; break;\n                case 'm': output = ' '; break;\n                case 'mm': output = '%d '; break;\n                case 'h': output = ' '; break;\n                case 'hh': output = '%d '; break;\n                case 'd': output = ' '; break;\n                case 'dd': output = '%d '; break;\n                case 'M': output = ' '; break;\n                case 'MM': output = '%d '; break;\n                case 'y': output = ' '; break;\n                case 'yy': output = '%d '; break;\n            }\n        }\n        else {\n            switch (string) {\n                case 's': output = ' '; break;\n                case 'ss': output = '%d '; break;\n                case 'm': output = ' '; break;\n                case 'mm': output = '%d '; break;\n                case 'h': output = ' '; break;\n                case 'hh': output = '%d '; break;\n                case 'd': output = ' '; break;\n                case 'dd': output = '%d '; break;\n                case 'M': output = ' '; break;\n                case 'MM': output = '%d '; break;\n                case 'y': output = ' '; break;\n                case 'yy': output = '%d '; break;\n            }\n        }\n        return output.replace(/%d/i, number);\n    }\n\n    var mr = moment.defineLocale('mr', {\n        months : '___________'.split('_'),\n        monthsShort: '._._._._._._._._._._._.'.split('_'),\n        monthsParseExact : true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek: '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future: '%s',\n            past: '%s',\n            s: relativeTimeMr,\n            ss: relativeTimeMr,\n            m: relativeTimeMr,\n            mm: relativeTimeMr,\n            h: relativeTimeMr,\n            hh: relativeTimeMr,\n            d: relativeTimeMr,\n            dd: relativeTimeMr,\n            M: relativeTimeMr,\n            MM: relativeTimeMr,\n            y: relativeTimeMr,\n            yy: relativeTimeMr\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem: function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return mr;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tci5qcz9lNmYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCwrQ0FBK0M7QUFDL0MsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRCw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLCtDQUErQztBQUMvQyw2Q0FBNkM7QUFDN0MsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGlEQUFpRDtBQUNqRCxnREFBZ0Q7QUFDaEQsaURBQWlEO0FBQ2pELDhDQUE4QztBQUM5QywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLGdEQUFnRDtBQUNoRCxpREFBaUQ7QUFDakQsa0RBQWtEO0FBQ2xELCtDQUErQztBQUMvQyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzeW1ib2xNYXAgPSB7XG4gICAgICAgICcxJzogJ+ClpycsXG4gICAgICAgICcyJzogJ+ClqCcsXG4gICAgICAgICczJzogJ+ClqScsXG4gICAgICAgICc0JzogJ+ClqicsXG4gICAgICAgICc1JzogJ+ClqycsXG4gICAgICAgICc2JzogJ+ClrCcsXG4gICAgICAgICc3JzogJ+ClrScsXG4gICAgICAgICc4JzogJ+ClricsXG4gICAgICAgICc5JzogJ+ClrycsXG4gICAgICAgICcwJzogJ+ClpidcbiAgICB9LFxuICAgIG51bWJlck1hcCA9IHtcbiAgICAgICAgJ+Clpyc6ICcxJyxcbiAgICAgICAgJ+ClqCc6ICcyJyxcbiAgICAgICAgJ+ClqSc6ICczJyxcbiAgICAgICAgJ+Clqic6ICc0JyxcbiAgICAgICAgJ+Clqyc6ICc1JyxcbiAgICAgICAgJ+ClrCc6ICc2JyxcbiAgICAgICAgJ+ClrSc6ICc3JyxcbiAgICAgICAgJ+Clric6ICc4JyxcbiAgICAgICAgJ+Clryc6ICc5JyxcbiAgICAgICAgJ+Clpic6ICcwJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWVNcihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpXG4gICAge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOiBvdXRwdXQgPSAn4KSV4KS+4KS54KWAIOCkuOClh+CkleCkguCkpic7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NzJzogb3V0cHV0ID0gJyVkIOCkuOClh+CkleCkguCkpic7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ20nOiBvdXRwdXQgPSAn4KSP4KSVIOCkruCkv+CkqOCkv+Cknyc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21tJzogb3V0cHV0ID0gJyVkIOCkruCkv+CkqOCkv+Ckn+Clhyc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOiBvdXRwdXQgPSAn4KSP4KSVIOCkpOCkvuCkuCc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hoJzogb3V0cHV0ID0gJyVkIOCkpOCkvuCkuCc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOiBvdXRwdXQgPSAn4KSP4KSVIOCkpuCkv+CkteCkuCc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RkJzogb3V0cHV0ID0gJyVkIOCkpuCkv+CkteCkuCc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOiBvdXRwdXQgPSAn4KSP4KSVIOCkruCkueCkv+CkqOCkvic7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ01NJzogb3V0cHV0ID0gJyVkIOCkruCkueCkv+CkqOClhyc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3knOiBvdXRwdXQgPSAn4KSP4KSVIOCkteCksOCljeCktyc7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3l5Jzogb3V0cHV0ID0gJyVkIOCkteCksOCljeCkt+Clhyc7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzogb3V0cHV0ID0gJ+CkleCkvuCkueClgCDgpLjgpYfgpJXgpILgpKbgpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcyc6IG91dHB1dCA9ICclZCDgpLjgpYfgpJXgpILgpKbgpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpK7gpL/gpKjgpL/gpJ/gpL4nOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtbSc6IG91dHB1dCA9ICclZCDgpK7gpL/gpKjgpL/gpJ/gpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpKTgpL7gpLjgpL4nOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoaCc6IG91dHB1dCA9ICclZCDgpKTgpL7gpLjgpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpKbgpL/gpLXgpLjgpL4nOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZCc6IG91dHB1dCA9ICclZCDgpKbgpL/gpLXgpLjgpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdNJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpK7gpLngpL/gpKjgpY3gpK/gpL4nOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdNTSc6IG91dHB1dCA9ICclZCDgpK7gpLngpL/gpKjgpY3gpK/gpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd5Jzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpLXgpLDgpY3gpLfgpL4nOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd5eSc6IG91dHB1dCA9ICclZCDgpLXgpLDgpY3gpLfgpL7gpIInOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIG1yID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXInLCB7XG4gICAgICAgIG1vbnRocyA6ICfgpJzgpL7gpKjgpYfgpLXgpL7gpLDgpYBf4KSr4KWH4KSs4KWN4KSw4KWB4KS14KS+4KSw4KWAX+CkruCkvuCksOCljeCkml/gpI/gpKrgpY3gpLDgpL/gpLJf4KSu4KWHX+CknOClguCkqF/gpJzgpYHgpLLgpYhf4KSR4KSX4KS44KWN4KSfX+CkuOCkquCljeCkn+Clh+CkguCkrOCksF/gpJHgpJXgpY3gpJ/gpYvgpKzgpLBf4KSo4KWL4KS14KWN4KS54KWH4KSC4KSs4KSwX+CkoeCkv+CkuOClh+CkguCkrOCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfgpJzgpL7gpKjgpYcuX+Ckq+Clh+CkrOCljeCksOClgS5f4KSu4KS+4KSw4KWN4KSaLl/gpI/gpKrgpY3gpLDgpL8uX+CkruClhy5f4KSc4KWC4KSoLl/gpJzgpYHgpLLgpYguX+CkkeCkly5f4KS44KSq4KWN4KSf4KWH4KSCLl/gpJHgpJXgpY3gpJ/gpYsuX+CkqOCli+CkteCljeCkueClh+Ckgi5f4KSh4KS/4KS44KWH4KSCLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ+CksOCkteCkv+CkteCkvuCksF/gpLjgpYvgpK7gpLXgpL7gpLBf4KSu4KSC4KSX4KSz4KS14KS+4KSwX+CkrOClgeCkp+CkteCkvuCksF/gpJfgpYHgpLDgpYLgpLXgpL7gpLBf4KS24KWB4KSV4KWN4KSw4KS14KS+4KSwX+CktuCkqOCkv+CkteCkvuCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgpLDgpLXgpL9f4KS44KWL4KSuX+CkruCkguCkl+Cks1/gpKzgpYHgpKdf4KSX4KWB4KSw4KWCX+CktuClgeCkleCljeCksF/gpLbgpKjgpL8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+CksF/gpLjgpYtf4KSu4KSCX+CkrOClgV/gpJfgpYFf4KS24KWBX+Ckticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0g4KS14KS+4KSc4KSk4KS+JyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4KS14KS+4KSc4KSk4KS+JyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgpLXgpL7gpJzgpKTgpL4nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCkteCkvuCknOCkpOCkvidcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgpIbgpJxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CkieCkpuCljeCkr+Ckvl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KSV4KS+4KSyXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1vgpK7gpL7gpJfgpYDgpLJdIGRkZGQsIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZTogJyVz4KSu4KSn4KWN4KSv4KWHJyxcbiAgICAgICAgICAgIHBhc3Q6ICclc+CkquClguCksOCljeCkteClgCcsXG4gICAgICAgICAgICBzOiByZWxhdGl2ZVRpbWVNcixcbiAgICAgICAgICAgIHNzOiByZWxhdGl2ZVRpbWVNcixcbiAgICAgICAgICAgIG06IHJlbGF0aXZlVGltZU1yLFxuICAgICAgICAgICAgbW06IHJlbGF0aXZlVGltZU1yLFxuICAgICAgICAgICAgaDogcmVsYXRpdmVUaW1lTXIsXG4gICAgICAgICAgICBoaDogcmVsYXRpdmVUaW1lTXIsXG4gICAgICAgICAgICBkOiByZWxhdGl2ZVRpbWVNcixcbiAgICAgICAgICAgIGRkOiByZWxhdGl2ZVRpbWVNcixcbiAgICAgICAgICAgIE06IHJlbGF0aXZlVGltZU1yLFxuICAgICAgICAgICAgTU06IHJlbGF0aXZlVGltZU1yLFxuICAgICAgICAgICAgeTogcmVsYXRpdmVUaW1lTXIsXG4gICAgICAgICAgICB5eTogcmVsYXRpdmVUaW1lTXJcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Clp+ClqOClqeClquClq+ClrOClreClruClr+Clpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+CksOCkvuCkpOCljeCksOClgHzgpLjgpJXgpL7gpLPgpYB84KSm4KWB4KSq4KS+4KSw4KWAfOCkuOCkvuCkr+CkguCkleCkvuCks+ClgC8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgpLDgpL7gpKTgpY3gpLDgpYAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpJXgpL7gpLPgpYAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSm4KWB4KSq4KS+4KSw4KWAJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpL7gpK/gpILgpJXgpL7gpLPgpYAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSk4KWN4KSw4KWAJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLjgpJXgpL7gpLPgpYAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CkpuClgeCkquCkvuCksOClgCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KS44KS+4KSv4KSC4KSV4KS+4KSz4KWAJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKTgpY3gpLDgpYAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtcjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXIuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83\n");

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ms = moment.defineLocale('ms', {\n        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),\n        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),\n        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),\n        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),\n        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /pagi|tengahari|petang|malam/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'pagi') {\n                return hour;\n            } else if (meridiem === 'tengahari') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'petang' || meridiem === 'malam') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'pagi';\n            } else if (hours < 15) {\n                return 'tengahari';\n            } else if (hours < 19) {\n                return 'petang';\n            } else {\n                return 'malam';\n            }\n        },\n        calendar : {\n            sameDay : '[Hari ini pukul] LT',\n            nextDay : '[Esok pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kelmarin pukul] LT',\n            lastWeek : 'dddd [lepas pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dalam %s',\n            past : '%s yang lepas',\n            s : 'beberapa saat',\n            ss : '%d saat',\n            m : 'seminit',\n            mm : '%d minit',\n            h : 'sejam',\n            hh : '%d jam',\n            d : 'sehari',\n            dd : '%d hari',\n            M : 'sebulan',\n            MM : '%d bulan',\n            y : 'setahun',\n            yy : '%d tahun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ms;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy5qcz9hMjg2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21zJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYWNfQXByaWxfTWVpX0p1bl9KdWxhaV9PZ29zX1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0Rpc2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hY19BcHJfTWVpX0p1bl9KdWxfT2dzX1NlcF9Pa3RfTm92X0Rpcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnQWhhZF9Jc25pbl9TZWxhc2FfUmFidV9LaGFtaXNfSnVtYWF0X1NhYnR1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0FoZF9Jc25fU2VsX1JhYl9LaGFfSnVtX1NhYicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnQWhfSXNfU2xfUmJfS21fSm1fU2InLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEgubW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC9wYWdpfHRlbmdhaGFyaXxwZXRhbmd8bWFsYW0vLFxuICAgICAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdwYWdpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3RlbmdhaGFyaScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAncGV0YW5nJyB8fCBtZXJpZGllbSA9PT0gJ21hbGFtJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGFnaSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RlbmdhaGFyaSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3BldGFuZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbWFsYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW0hhcmkgaW5pIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tFc29rIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbS2VsbWFyaW4gcHVrdWxdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xlcGFzIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZGFsYW0gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyB5YW5nIGxlcGFzJyxcbiAgICAgICAgICAgIHMgOiAnYmViZXJhcGEgc2FhdCcsXG4gICAgICAgICAgICBzcyA6ICclZCBzYWF0JyxcbiAgICAgICAgICAgIG0gOiAnc2VtaW5pdCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW5pdCcsXG4gICAgICAgICAgICBoIDogJ3NlamFtJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGphbScsXG4gICAgICAgICAgICBkIDogJ3NlaGFyaScsXG4gICAgICAgICAgICBkZCA6ICclZCBoYXJpJyxcbiAgICAgICAgICAgIE0gOiAnc2VidWxhbicsXG4gICAgICAgICAgICBNTSA6ICclZCBidWxhbicsXG4gICAgICAgICAgICB5IDogJ3NldGFodW4nLFxuICAgICAgICAgICAgeXkgOiAnJWQgdGFodW4nXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1zO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n");

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var msMy = moment.defineLocale('ms-my', {\n        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),\n        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),\n        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),\n        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),\n        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /pagi|tengahari|petang|malam/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'pagi') {\n                return hour;\n            } else if (meridiem === 'tengahari') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'petang' || meridiem === 'malam') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'pagi';\n            } else if (hours < 15) {\n                return 'tengahari';\n            } else if (hours < 19) {\n                return 'petang';\n            } else {\n                return 'malam';\n            }\n        },\n        calendar : {\n            sameDay : '[Hari ini pukul] LT',\n            nextDay : '[Esok pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kelmarin pukul] LT',\n            lastWeek : 'dddd [lepas pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dalam %s',\n            past : '%s yang lepas',\n            s : 'beberapa saat',\n            ss : '%d saat',\n            m : 'seminit',\n            mm : '%d minit',\n            h : 'sejam',\n            hh : '%d jam',\n            d : 'sehari',\n            dd : '%d hari',\n            M : 'sebulan',\n            MM : '%d bulan',\n            y : 'setahun',\n            yy : '%d tahun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return msMy;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy1teS5qcz8xYmVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtc015ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXMtbXknLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJpX0ZlYnJ1YXJpX01hY19BcHJpbF9NZWlfSnVuX0p1bGFpX09nb3NfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGlzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFjX0Fwcl9NZWlfSnVuX0p1bF9PZ3NfU2VwX09rdF9Ob3ZfRGlzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdBaGFkX0lzbmluX1NlbGFzYV9SYWJ1X0toYW1pc19KdW1hYXRfU2FidHUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnQWhkX0lzbl9TZWxfUmFiX0toYV9KdW1fU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdBaF9Jc19TbF9SYl9LbV9KbV9TYicuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISC5tbScsXG4gICAgICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL3BhZ2l8dGVuZ2FoYXJpfHBldGFuZ3xtYWxhbS8sXG4gICAgICAgIG1lcmlkaWVtSG91cjogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ3BhZ2knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAndGVuZ2FoYXJpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdwZXRhbmcnIHx8IG1lcmlkaWVtID09PSAnbWFsYW0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwYWdpJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndGVuZ2FoYXJpJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGV0YW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtYWxhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbSGFyaSBpbmkgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW0Vzb2sgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tLZWxtYXJpbiBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbbGVwYXMgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdkYWxhbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHlhbmcgbGVwYXMnLFxuICAgICAgICAgICAgcyA6ICdiZWJlcmFwYSBzYWF0JyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNhYXQnLFxuICAgICAgICAgICAgbSA6ICdzZW1pbml0JyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbml0JyxcbiAgICAgICAgICAgIGggOiAnc2VqYW0nLFxuICAgICAgICAgICAgaGggOiAnJWQgamFtJyxcbiAgICAgICAgICAgIGQgOiAnc2VoYXJpJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGhhcmknLFxuICAgICAgICAgICAgTSA6ICdzZWJ1bGFuJyxcbiAgICAgICAgICAgIE1NIDogJyVkIGJ1bGFuJyxcbiAgICAgICAgICAgIHkgOiAnc2V0YWh1bicsXG4gICAgICAgICAgICB5eSA6ICclZCB0YWh1bidcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbXNNeTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXMtbXkuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///85\n");

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var mt = moment.defineLocale('mt', {\n        months : 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),\n        monthsShort : 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),\n        weekdays : 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),\n        weekdaysShort : 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),\n        weekdaysMin : 'a_Tn_Tl_Er_a_i_Si'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Illum fil-]LT',\n            nextDay : '[Gada fil-]LT',\n            nextWeek : 'dddd [fil-]LT',\n            lastDay : '[Il-biera fil-]LT',\n            lastWeek : 'dddd [li gadda] [fil-]LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'f %s',\n            past : '%s ilu',\n            s : 'ftit sekondi',\n            ss : '%d sekondi',\n            m : 'minuta',\n            mm : '%d minuti',\n            h : 'siega',\n            hh : '%d siegat',\n            d : 'urnata',\n            dd : '%d ranet',\n            M : 'xahar',\n            MM : '%d xhur',\n            y : 'sena',\n            yy : '%d sni'\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal: '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return mt;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tdC5qcz9hMDJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ210Jywge1xuICAgICAgICBtb250aHMgOiAnSmFubmFyX0ZyYXJfTWFyenVfQXByaWxfTWVqanVfxKB1bmp1X0x1bGp1X0F3d2lzc3VfU2V0dGVtYnJ1X090dHVicnVfTm92ZW1icnVfRGnEi2VtYnJ1Jy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRnJhX01hcl9BcHJfTWVqX8SgdW5fTHVsX0F3d19TZXRfT3R0X05vdl9EacSLJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdJbC3EpmFkZF9JdC1UbmVqbl9JdC1UbGlldGFfTC1FcmJnxKdhX0lsLcSmYW1pc19JbC3EoGltZ8SnYV9Jcy1TaWJ0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ8SmYWRfVG5lX1RsaV9FcmJfxKZhbV/EoGltX1NpYicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnxKZhX1RuX1RsX0VyX8SmYV/EoGlfU2knLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tJbGx1bSBmaWwtXUxUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW0fEp2FkYSBmaWwtXUxUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2ZpbC1dTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbSWwtYmllcmHEpyBmaWwtXUxUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xpIGfEp2FkZGFdIFtmaWwtXUxUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdm4oCZICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgaWx1JyxcbiAgICAgICAgICAgIHMgOiAnZnRpdCBzZWtvbmRpJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla29uZGknLFxuICAgICAgICAgICAgbSA6ICdtaW51dGEnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRpJyxcbiAgICAgICAgICAgIGggOiAnc2llZ8SnYScsXG4gICAgICAgICAgICBoaCA6ICclZCBzaWVnxKdhdCcsXG4gICAgICAgICAgICBkIDogJ8ShdXJuYXRhJyxcbiAgICAgICAgICAgIGRkIDogJyVkIMShcmFuZXQnLFxuICAgICAgICAgICAgTSA6ICd4YWhhcicsXG4gICAgICAgICAgICBNTSA6ICclZCB4aHVyJyxcbiAgICAgICAgICAgIHkgOiAnc2VuYScsXG4gICAgICAgICAgICB5eSA6ICclZCBzbmknXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXG4gICAgICAgIG9yZGluYWw6ICclZMK6JyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbXQ7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL210LmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///86\n");

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var my = moment.defineLocale('my', {\n        months: '___________'.split('_'),\n        monthsShort: '___________'.split('_'),\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[.] LT []',\n            nextDay: '[] LT []',\n            nextWeek: 'dddd LT []',\n            lastDay: '[.] LT []',\n            lastWeek: '[] dddd LT []',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: ' %s ',\n            past: ' %s ',\n            s: '.',\n            ss : '%d ',\n            m: '',\n            mm: '%d ',\n            h: '',\n            hh: '%d ',\n            d: '',\n            dd: '%d ',\n            M: '',\n            MM: '%d ',\n            y: '',\n            yy: '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4 // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return my;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9teS5qcz8xN2VkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6Ijg3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfhgYEnLFxuICAgICAgICAnMic6ICfhgYInLFxuICAgICAgICAnMyc6ICfhgYMnLFxuICAgICAgICAnNCc6ICfhgYQnLFxuICAgICAgICAnNSc6ICfhgYUnLFxuICAgICAgICAnNic6ICfhgYYnLFxuICAgICAgICAnNyc6ICfhgYcnLFxuICAgICAgICAnOCc6ICfhgYgnLFxuICAgICAgICAnOSc6ICfhgYknLFxuICAgICAgICAnMCc6ICfhgYAnXG4gICAgfSwgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4YGBJzogJzEnLFxuICAgICAgICAn4YGCJzogJzInLFxuICAgICAgICAn4YGDJzogJzMnLFxuICAgICAgICAn4YGEJzogJzQnLFxuICAgICAgICAn4YGFJzogJzUnLFxuICAgICAgICAn4YGGJzogJzYnLFxuICAgICAgICAn4YGHJzogJzcnLFxuICAgICAgICAn4YGIJzogJzgnLFxuICAgICAgICAn4YGJJzogJzknLFxuICAgICAgICAn4YGAJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBteSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ215Jywge1xuICAgICAgICBtb250aHM6ICfhgIfhgJThgLrhgJThgJ3hgKvhgJvhgK5f4YCW4YCx4YCW4YCx4YCs4YC64YCd4YCr4YCb4YCuX+GAmeGAkOGAul/hgKfhgJXhgLzhgK5f4YCZ4YCxX+GAh+GAveGAlOGAul/hgIfhgLDhgJzhgK3hgK/hgIThgLpf4YCe4YC84YCC4YCv4YCQ4YC6X+GAheGAgOGAuuGAkOGAhOGAuuGAmOGArF/hgKHhgLHhgKzhgIDhgLrhgJDhgK3hgK/hgJjhgKxf4YCU4YCt4YCv4YCd4YCE4YC64YCY4YCsX+GAkuGAruGAh+GAhOGAuuGAmOGArCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfhgIfhgJThgLpf4YCW4YCxX+GAmeGAkOGAul/hgJXhgLzhgK5f4YCZ4YCxX+GAh+GAveGAlOGAul/hgJzhgK3hgK/hgIThgLpf4YCe4YC8X+GAheGAgOGAul/hgKHhgLHhgKzhgIDhgLpf4YCU4YCt4YCvX+GAkuGAricuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXM6ICfhgJDhgJThgIThgLrhgLnhgILhgJThgL3hgLFf4YCQ4YCU4YCE4YC64YC54YCc4YCsX+GAoeGAhOGAuuGAueGAguGAq1/hgJfhgK/hgJLhgLnhgJPhgJ/hgLDhgLhf4YCA4YC84YCs4YCe4YCV4YCQ4YCx4YC4X+GAnuGAseGArOGAgOGAvOGArF/hgIXhgJThgLEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICfhgJThgL3hgLFf4YCc4YCsX+GAguGAq1/hgJ/hgLDhgLhf4YCA4YC84YCsX+GAnuGAseGArF/hgJThgLEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAn4YCU4YC94YCxX+GAnOGArF/hgILhgKtf4YCf4YCw4YC4X+GAgOGAvOGArF/hgJ7hgLHhgKxf4YCU4YCxJy5zcGxpdCgnXycpLFxuXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUzogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW+GAmuGAlOGAsS5dIExUIFvhgJnhgL7hgKxdJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb4YCZ4YCU4YCA4YC64YCW4YC84YCU4YC6XSBMVCBb4YCZ4YC+4YCsXScsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgTFQgW+GAmeGAvuGArF0nLFxuICAgICAgICAgICAgbGFzdERheTogJ1vhgJnhgJThgLEu4YCAXSBMVCBb4YCZ4YC+4YCsXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1vhgJXhgLzhgK7hgLjhgIHhgLLhgLfhgJ7hgLHhgKxdIGRkZGQgTFQgW+GAmeGAvuGArF0nLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWU6IHtcbiAgICAgICAgICAgIGZ1dHVyZTogJ+GAnOGArOGAmeGAiuGAuuGAtyAlcyDhgJnhgL7hgKwnLFxuICAgICAgICAgICAgcGFzdDogJ+GAnOGAveGAlOGAuuGAgeGAsuGAt+GAnuGAseGArCAlcyDhgIAnLFxuICAgICAgICAgICAgczogJ+GAheGAgOGAueGAgOGAlOGAui7hgKHhgJThgIrhgLrhgLjhgIThgJrhgLonLFxuICAgICAgICAgICAgc3MgOiAnJWQg4YCF4YCA4YC54YCA4YCU4YC34YC6JyxcbiAgICAgICAgICAgIG06ICfhgJDhgIXhgLrhgJnhgK3hgJThgIXhgLonLFxuICAgICAgICAgICAgbW06ICclZCDhgJnhgK3hgJThgIXhgLonLFxuICAgICAgICAgICAgaDogJ+GAkOGAheGAuuGAlOGArOGAm+GAricsXG4gICAgICAgICAgICBoaDogJyVkIOGAlOGArOGAm+GAricsXG4gICAgICAgICAgICBkOiAn4YCQ4YCF4YC64YCb4YCA4YC6JyxcbiAgICAgICAgICAgIGRkOiAnJWQg4YCb4YCA4YC6JyxcbiAgICAgICAgICAgIE06ICfhgJDhgIXhgLrhgJwnLFxuICAgICAgICAgICAgTU06ICclZCDhgJwnLFxuICAgICAgICAgICAgeTogJ+GAkOGAheGAuuGAlOGAvuGAheGAuicsXG4gICAgICAgICAgICB5eTogJyVkIOGAlOGAvuGAheGAuidcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+GBgeGBguGBg+GBhOGBheGBhuGBh+GBiOGBieGBgF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgd2Vlazoge1xuICAgICAgICAgICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveTogNCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBteTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXkuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///87\n");

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var nb = moment.defineLocale('nb', {\n        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),\n        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY [kl.] HH:mm',\n            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'\n        },\n        calendar : {\n            sameDay: '[i dag kl.] LT',\n            nextDay: '[i morgen kl.] LT',\n            nextWeek: 'dddd [kl.] LT',\n            lastDay: '[i gr kl.] LT',\n            lastWeek: '[forrige] dddd [kl.] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : '%s siden',\n            s : 'noen sekunder',\n            ss : '%d sekunder',\n            m : 'ett minutt',\n            mm : '%d minutter',\n            h : 'en time',\n            hh : '%d timer',\n            d : 'en dag',\n            dd : '%d dager',\n            M : 'en mned',\n            MM : '%d mneder',\n            y : 'ett r',\n            yy : '%d r'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return nb;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uYi5qcz8xNjVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6Ijg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbmIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCduYicsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnNfYXByaWxfbWFpX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbi5fZmViLl9tYXJzX2FwcmlsX21haV9qdW5pX2p1bGlfYXVnLl9zZXAuX29rdC5fbm92Ll9kZXMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAnc8O4bmRhZ19tYW5kYWdfdGlyc2RhZ19vbnNkYWdfdG9yc2RhZ19mcmVkYWdfbMO4cmRhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzw7guX21hLl90aS5fb24uX3RvLl9mci5fbMO4Licuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnc8O4X21hX3RpX29uX3RvX2ZyX2zDuCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tpIGRhZyBrbC5dIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbaSBtb3JnZW4ga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2tsLl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tpIGfDpXIga2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tmb3JyaWdlXSBkZGRkIFtrbC5dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29tICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgc2lkZW4nLFxuICAgICAgICAgICAgcyA6ICdub2VuIHNla3VuZGVyJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla3VuZGVyJyxcbiAgICAgICAgICAgIG0gOiAnZXR0IG1pbnV0dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHRlcicsXG4gICAgICAgICAgICBoIDogJ2VuIHRpbWUnLFxuICAgICAgICAgICAgaGggOiAnJWQgdGltZXInLFxuICAgICAgICAgICAgZCA6ICdlbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnZXInLFxuICAgICAgICAgICAgTSA6ICdlbiBtw6VuZWQnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbcOlbmVkZXInLFxuICAgICAgICAgICAgeSA6ICdldHQgw6VyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIMOlcidcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuYjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmIuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///88\n");

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var ne = moment.defineLocale('ne', {\n        months : '___________'.split('_'),\n        monthsShort : '._.__.___._._._._._.'.split('_'),\n        monthsParseExact : true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '._._._._._._.'.split('_'),\n        weekdaysMin : '._._._._._._.'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 3) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 16) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[] dddd[,] LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd[,] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ne;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uZS5qcz9mZTY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4KWnJyxcbiAgICAgICAgJzInOiAn4KWoJyxcbiAgICAgICAgJzMnOiAn4KWpJyxcbiAgICAgICAgJzQnOiAn4KWqJyxcbiAgICAgICAgJzUnOiAn4KWrJyxcbiAgICAgICAgJzYnOiAn4KWsJyxcbiAgICAgICAgJzcnOiAn4KWtJyxcbiAgICAgICAgJzgnOiAn4KWuJyxcbiAgICAgICAgJzknOiAn4KWvJyxcbiAgICAgICAgJzAnOiAn4KWmJ1xuICAgIH0sXG4gICAgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4KWnJzogJzEnLFxuICAgICAgICAn4KWoJzogJzInLFxuICAgICAgICAn4KWpJzogJzMnLFxuICAgICAgICAn4KWqJzogJzQnLFxuICAgICAgICAn4KWrJzogJzUnLFxuICAgICAgICAn4KWsJzogJzYnLFxuICAgICAgICAn4KWtJzogJzcnLFxuICAgICAgICAn4KWuJzogJzgnLFxuICAgICAgICAn4KWvJzogJzknLFxuICAgICAgICAn4KWmJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBuZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25lJywge1xuICAgICAgICBtb250aHMgOiAn4KSc4KSo4KS14KSw4KWAX+Ckq+Clh+CkrOCljeCksOClgeCkteCksOClgF/gpK7gpL7gpLDgpY3gpJpf4KSF4KSq4KWN4KSw4KS/4KSyX+CkruCkiF/gpJzgpYHgpKhf4KSc4KWB4KSy4KS+4KSIX+CkheCkl+Ckt+CljeCkn1/gpLjgpYfgpKrgpY3gpJ/gpYfgpK7gpY3gpKzgpLBf4KSF4KSV4KWN4KSf4KWL4KSs4KSwX+CkqOCli+CkreClh+CkruCljeCkrOCksF/gpKHgpL/gpLjgpYfgpK7gpY3gpKzgpLAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+CknOCkqC5f4KSr4KWH4KSs4KWN4KSw4KWBLl/gpK7gpL7gpLDgpY3gpJpf4KSF4KSq4KWN4KSw4KS/Ll/gpK7gpIhf4KSc4KWB4KSoX+CknOClgeCksuCkvuCkiC5f4KSF4KSXLl/gpLjgpYfgpKrgpY3gpJ8uX+CkheCkleCljeCkn+Cliy5f4KSo4KWL4KSt4KWHLl/gpKHgpL/gpLjgpYcuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAn4KSG4KSH4KSk4KSs4KS+4KSwX+CkuOCli+CkruCkrOCkvuCksF/gpK7gpJngpY3gpJfgpLLgpKzgpL7gpLBf4KSs4KWB4KSn4KSs4KS+4KSwX+CkrOCkv+CkueCkv+CkrOCkvuCksF/gpLbgpYHgpJXgpY3gpLDgpKzgpL7gpLBf4KS24KSo4KS/4KSs4KS+4KSwJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+CkhuCkh+CkpC5f4KS44KWL4KSuLl/gpK7gpJngpY3gpJfgpLIuX+CkrOClgeCkpy5f4KSs4KS/4KS54KS/Ll/gpLbgpYHgpJXgpY3gpLAuX+CktuCkqOCkvy4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+Ckhi5f4KS44KWLLl/gpK7gpIIuX+CkrOClgS5f4KSs4KS/Ll/gpLbgpYEuX+Ckti4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnQeCkleCliyBoOm1tIOCkrOCknOClhycsXG4gICAgICAgICAgICBMVFMgOiAnQeCkleCliyBoOm1tOnNzIOCkrOCknOClhycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBB4KSV4KWLIGg6bW0g4KSs4KSc4KWHJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEHgpJXgpYsgaDptbSDgpKzgpJzgpYcnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgpafgpajgpangpargpavgpazgpa3gpa7gpa/gpaZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/gpLDgpL7gpKTgpL984KSs4KS/4KS54KS+4KSofOCkpuCkv+CkieCkgeCkuOCli3zgpLjgpL7gpIHgpJ0vLFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4KSw4KS+4KSk4KS/Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSs4KS/4KS54KS+4KSoJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkpuCkv+CkieCkgeCkuOCliycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KS44KS+4KSB4KSdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKTgpL8nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CkrOCkv+CkueCkvuCkqCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSm4KS/4KSJ4KSB4KS44KWLJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLjgpL7gpIHgpJ0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpOCkvyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4KSG4KScXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgpK3gpYvgpLLgpL9dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vgpIbgpIngpIHgpKbgpYtdIGRkZGRbLF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KS54KS/4KSc4KWLXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4KSX4KSP4KSV4KWLXSBkZGRkWyxdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclc+CkruCkvicsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOCkheCkl+CkvuCkoeCkvycsXG4gICAgICAgICAgICBzIDogJ+CkleClh+CkueClgCDgpJXgpY3gpLfgpKMnLFxuICAgICAgICAgICAgc3MgOiAnJWQg4KS44KWH4KSV4KWH4KSj4KWN4KShJyxcbiAgICAgICAgICAgIG0gOiAn4KSP4KSVIOCkruCkv+CkqOClh+CknycsXG4gICAgICAgICAgICBtbSA6ICclZCDgpK7gpL/gpKjgpYfgpJ8nLFxuICAgICAgICAgICAgaCA6ICfgpI/gpJUg4KSY4KSj4KWN4KSf4KS+JyxcbiAgICAgICAgICAgIGhoIDogJyVkIOCkmOCko+CljeCkn+CkvicsXG4gICAgICAgICAgICBkIDogJ+Ckj+CklSDgpKbgpL/gpKgnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4KSm4KS/4KSoJyxcbiAgICAgICAgICAgIE0gOiAn4KSP4KSVIOCkruCkueCkv+CkqOCkvicsXG4gICAgICAgICAgICBNTSA6ICclZCDgpK7gpLngpL/gpKjgpL4nLFxuICAgICAgICAgICAgeSA6ICfgpI/gpJUg4KSs4KSw4KWN4KS3JyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCkrOCksOCljeCktydcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmU7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25lLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n");

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');\n\n    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];\n    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\\.?|feb\\.?|mrt\\.?|apr\\.?|ju[nl]\\.?|aug\\.?|sep\\.?|okt\\.?|nov\\.?|dec\\.?)/i;\n\n    var nl = moment.defineLocale('nl', {\n        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),\n        monthsShort : function (m, format) {\n            if (!m) {\n                return monthsShortWithDots;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShortWithoutDots[m.month()];\n            } else {\n                return monthsShortWithDots[m.month()];\n            }\n        },\n\n        monthsRegex: monthsRegex,\n        monthsShortRegex: monthsRegex,\n        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,\n        monthsShortStrictRegex: /^(jan\\.?|feb\\.?|mrt\\.?|apr\\.?|mei|ju[nl]\\.?|aug\\.?|sep\\.?|okt\\.?|nov\\.?|dec\\.?)/i,\n\n        monthsParse : monthsParse,\n        longMonthsParse : monthsParse,\n        shortMonthsParse : monthsParse,\n\n        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),\n        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),\n        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[vandaag om] LT',\n            nextDay: '[morgen om] LT',\n            nextWeek: 'dddd [om] LT',\n            lastDay: '[gisteren om] LT',\n            lastWeek: '[afgelopen] dddd [om] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'over %s',\n            past : '%s geleden',\n            s : 'een paar seconden',\n            ss : '%d seconden',\n            m : 'n minuut',\n            mm : '%d minuten',\n            h : 'n uur',\n            hh : '%d uur',\n            d : 'n dag',\n            dd : '%d dagen',\n            M : 'n maand',\n            MM : '%d maanden',\n            y : 'n jaar',\n            yy : '%d jaar'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return nl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC5qcz9kY2FkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtb250aHNTaG9ydFdpdGhEb3RzID0gJ2phbi5fZmViLl9tcnQuX2Fwci5fbWVpX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0V2l0aG91dERvdHMgPSAnamFuX2ZlYl9tcnRfYXByX21laV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyk7XG5cbiAgICB2YXIgbW9udGhzUGFyc2UgPSBbL15qYW4vaSwgL15mZWIvaSwgL15tYWFydHxtcnQuPyQvaSwgL15hcHIvaSwgL15tZWkkL2ksIC9eanVuW2kuXT8kL2ksIC9eanVsW2kuXT8kL2ksIC9eYXVnL2ksIC9ec2VwL2ksIC9eb2t0L2ksIC9ebm92L2ksIC9eZGVjL2ldO1xuICAgIHZhciBtb250aHNSZWdleCA9IC9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8YXByaWx8bWVpfGFwcmlsfGp1W25sXWl8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXJ8amFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xqdVtubF1cXC4/fGF1Z1xcLj98c2VwXFwuP3xva3RcXC4/fG5vdlxcLj98ZGVjXFwuPykvaTtcblxuICAgIHZhciBubCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25sJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyaV9mZWJydWFyaV9tYWFydF9hcHJpbF9tZWlfanVuaV9qdWxpX2F1Z3VzdHVzX3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhvdXREb3RzW20ubW9udGgoKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzW20ubW9udGgoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW9udGhzUmVnZXg6IG1vbnRoc1JlZ2V4LFxuICAgICAgICBtb250aHNTaG9ydFJlZ2V4OiBtb250aHNSZWdleCxcbiAgICAgICAgbW9udGhzU3RyaWN0UmVnZXg6IC9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8bWVpfGp1W25sXWl8YXByaWx8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2ksXG4gICAgICAgIG1vbnRoc1Nob3J0U3RyaWN0UmVnZXg6IC9eKGphblxcLj98ZmViXFwuP3xtcnRcXC4/fGFwclxcLj98bWVpfGp1W25sXVxcLj98YXVnXFwuP3xzZXBcXC4/fG9rdFxcLj98bm92XFwuP3xkZWNcXC4/KS9pLFxuXG4gICAgICAgIG1vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXG4gICAgICAgIGxvbmdNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxuICAgICAgICBzaG9ydE1vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXG5cbiAgICAgICAgd2Vla2RheXMgOiAnem9uZGFnX21hYW5kYWdfZGluc2RhZ193b2Vuc2RhZ19kb25kZXJkYWdfdnJpamRhZ196YXRlcmRhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICd6by5fbWEuX2RpLl93by5fZG8uX3ZyLl96YS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ3pvX21hX2RpX3dvX2RvX3ZyX3phJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELU1NLVlZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW3ZhbmRhYWcgb21dIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbbW9yZ2VuIG9tXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW29tXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW2dpc3RlcmVuIG9tXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1thZmdlbG9wZW5dIGRkZGQgW29tXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdvdmVyICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgZ2VsZWRlbicsXG4gICAgICAgICAgICBzIDogJ2VlbiBwYWFyIHNlY29uZGVuJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlY29uZGVuJyxcbiAgICAgICAgICAgIG0gOiAnw6nDqW4gbWludXV0JyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZW4nLFxuICAgICAgICAgICAgaCA6ICfDqcOpbiB1dXInLFxuICAgICAgICAgICAgaGggOiAnJWQgdXVyJyxcbiAgICAgICAgICAgIGQgOiAnw6nDqW4gZGFnJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZ2VuJyxcbiAgICAgICAgICAgIE0gOiAnw6nDqW4gbWFhbmQnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbWFhbmRlbicsXG4gICAgICAgICAgICB5IDogJ8Opw6luIGphYXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgamFhcidcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0ZXxkZSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICgobnVtYmVyID09PSAxIHx8IG51bWJlciA9PT0gOCB8fCBudW1iZXIgPj0gMjApID8gJ3N0ZScgOiAnZGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmw7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///90\n");

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');\n\n    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];\n    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\\.?|feb\\.?|mrt\\.?|apr\\.?|ju[nl]\\.?|aug\\.?|sep\\.?|okt\\.?|nov\\.?|dec\\.?)/i;\n\n    var nlBe = moment.defineLocale('nl-be', {\n        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),\n        monthsShort : function (m, format) {\n            if (!m) {\n                return monthsShortWithDots;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShortWithoutDots[m.month()];\n            } else {\n                return monthsShortWithDots[m.month()];\n            }\n        },\n\n        monthsRegex: monthsRegex,\n        monthsShortRegex: monthsRegex,\n        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,\n        monthsShortStrictRegex: /^(jan\\.?|feb\\.?|mrt\\.?|apr\\.?|mei|ju[nl]\\.?|aug\\.?|sep\\.?|okt\\.?|nov\\.?|dec\\.?)/i,\n\n        monthsParse : monthsParse,\n        longMonthsParse : monthsParse,\n        shortMonthsParse : monthsParse,\n\n        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),\n        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),\n        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[vandaag om] LT',\n            nextDay: '[morgen om] LT',\n            nextWeek: 'dddd [om] LT',\n            lastDay: '[gisteren om] LT',\n            lastWeek: '[afgelopen] dddd [om] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'over %s',\n            past : '%s geleden',\n            s : 'een paar seconden',\n            ss : '%d seconden',\n            m : 'n minuut',\n            mm : '%d minuten',\n            h : 'n uur',\n            hh : '%d uur',\n            d : 'n dag',\n            dd : '%d dagen',\n            M : 'n maand',\n            MM : '%d maanden',\n            y : 'n jaar',\n            yy : '%d jaar'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return nlBe;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qcz8wNjlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtb250aHNTaG9ydFdpdGhEb3RzID0gJ2phbi5fZmViLl9tcnQuX2Fwci5fbWVpX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0V2l0aG91dERvdHMgPSAnamFuX2ZlYl9tcnRfYXByX21laV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyk7XG5cbiAgICB2YXIgbW9udGhzUGFyc2UgPSBbL15qYW4vaSwgL15mZWIvaSwgL15tYWFydHxtcnQuPyQvaSwgL15hcHIvaSwgL15tZWkkL2ksIC9eanVuW2kuXT8kL2ksIC9eanVsW2kuXT8kL2ksIC9eYXVnL2ksIC9ec2VwL2ksIC9eb2t0L2ksIC9ebm92L2ksIC9eZGVjL2ldO1xuICAgIHZhciBtb250aHNSZWdleCA9IC9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8YXByaWx8bWVpfGFwcmlsfGp1W25sXWl8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXJ8amFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xqdVtubF1cXC4/fGF1Z1xcLj98c2VwXFwuP3xva3RcXC4/fG5vdlxcLj98ZGVjXFwuPykvaTtcblxuICAgIHZhciBubEJlID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbmwtYmUnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW51YXJpX2ZlYnJ1YXJpX21hYXJ0X2FwcmlsX21laV9qdW5pX2p1bGlfYXVndXN0dXNfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0sIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aG91dERvdHNbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHNbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb250aHNSZWdleDogbW9udGhzUmVnZXgsXG4gICAgICAgIG1vbnRoc1Nob3J0UmVnZXg6IG1vbnRoc1JlZ2V4LFxuICAgICAgICBtb250aHNTdHJpY3RSZWdleDogL14oamFudWFyaXxmZWJydWFyaXxtYWFydHxtZWl8anVbbmxdaXxhcHJpbHxhdWd1c3R1c3xzZXB0ZW1iZXJ8b2t0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaSxcbiAgICAgICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleDogL14oamFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xtZWl8anVbbmxdXFwuP3xhdWdcXC4/fHNlcFxcLj98b2t0XFwuP3xub3ZcXC4/fGRlY1xcLj8pL2ksXG5cbiAgICAgICAgbW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcbiAgICAgICAgbG9uZ01vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXG4gICAgICAgIHNob3J0TW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcblxuICAgICAgICB3ZWVrZGF5cyA6ICd6b25kYWdfbWFhbmRhZ19kaW5zZGFnX3dvZW5zZGFnX2RvbmRlcmRhZ192cmlqZGFnX3phdGVyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3pvLl9tYS5fZGkuX3dvLl9kby5fdnIuX3phLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnem9fbWFfZGlfd29fZG9fdnJfemEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbdmFuZGFhZyBvbV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1ttb3JnZW4gb21dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbb21dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbZ2lzdGVyZW4gb21dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW2FmZ2Vsb3Blbl0gZGRkZCBbb21dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ292ZXIgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBnZWxlZGVuJyxcbiAgICAgICAgICAgIHMgOiAnZWVuIHBhYXIgc2Vjb25kZW4nLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2Vjb25kZW4nLFxuICAgICAgICAgICAgbSA6ICfDqcOpbiBtaW51dXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlbicsXG4gICAgICAgICAgICBoIDogJ8Opw6luIHV1cicsXG4gICAgICAgICAgICBoaCA6ICclZCB1dXInLFxuICAgICAgICAgICAgZCA6ICfDqcOpbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnZW4nLFxuICAgICAgICAgICAgTSA6ICfDqcOpbiBtYWFuZCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtYWFuZGVuJyxcbiAgICAgICAgICAgIHkgOiAnw6nDqW4gamFhcicsXG4gICAgICAgICAgICB5eSA6ICclZCBqYWFyJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3RlfGRlKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKChudW1iZXIgPT09IDEgfHwgbnVtYmVyID09PSA4IHx8IG51bWJlciA+PSAyMCkgPyAnc3RlJyA6ICdkZScpO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBubEJlO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///91\n");

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var nn = moment.defineLocale('nn', {\n        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),\n        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),\n        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY [kl.] H:mm',\n            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'\n        },\n        calendar : {\n            sameDay: '[I dag klokka] LT',\n            nextDay: '[I morgon klokka] LT',\n            nextWeek: 'dddd [klokka] LT',\n            lastDay: '[I gr klokka] LT',\n            lastWeek: '[Fregande] dddd [klokka] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : '%s sidan',\n            s : 'nokre sekund',\n            ss : '%d sekund',\n            m : 'eit minutt',\n            mm : '%d minutt',\n            h : 'ein time',\n            hh : '%d timar',\n            d : 'ein dag',\n            dd : '%d dagar',\n            M : 'ein mnad',\n            MM : '%d mnader',\n            y : 'eit r',\n            yy : '%d r'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return nn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubi5qcz8wYmI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBubiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25uJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFyc19hcHJpbF9tYWlfanVuaV9qdWxpX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZXNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21haV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZXMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ3N1bmRhZ19tw6VuZGFnX3R5c2RhZ19vbnNkYWdfdG9yc2RhZ19mcmVkYWdfbGF1cmRhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzdW5fbcOlbl90eXNfb25zX3Rvcl9mcmVfbGF1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdzdV9tw6VfdHlfb25fdG9fZnJfbMO4Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgW2tsLl0gSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSSBkYWcga2xva2thXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW0kgbW9yZ29uIGtsb2trYV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtrbG9ra2FdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbSSBnw6VyIGtsb2trYV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdbRsO4cmVnw6VhbmRlXSBkZGRkIFtrbG9ra2FdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29tICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgc2lkYW4nLFxuICAgICAgICAgICAgcyA6ICdub2tyZSBzZWt1bmQnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc2VrdW5kJyxcbiAgICAgICAgICAgIG0gOiAnZWl0IG1pbnV0dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHQnLFxuICAgICAgICAgICAgaCA6ICdlaW4gdGltZScsXG4gICAgICAgICAgICBoaCA6ICclZCB0aW1hcicsXG4gICAgICAgICAgICBkIDogJ2VpbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnYXInLFxuICAgICAgICAgICAgTSA6ICdlaW4gbcOlbmFkJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG3DpW5hZGVyJyxcbiAgICAgICAgICAgIHkgOiAnZWl0IMOlcicsXG4gICAgICAgICAgICB5eSA6ICclZCDDpXInXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm47XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25uLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///92\n");

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var paIn = moment.defineLocale('pa-in', {\n        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists\n        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return paIn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wYS1pbi5qcz9hNWZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfgqacnLFxuICAgICAgICAnMic6ICfgqagnLFxuICAgICAgICAnMyc6ICfgqaknLFxuICAgICAgICAnNCc6ICfgqaonLFxuICAgICAgICAnNSc6ICfgqasnLFxuICAgICAgICAnNic6ICfgqawnLFxuICAgICAgICAnNyc6ICfgqa0nLFxuICAgICAgICAnOCc6ICfgqa4nLFxuICAgICAgICAnOSc6ICfgqa8nLFxuICAgICAgICAnMCc6ICfgqaYnXG4gICAgfSxcbiAgICBudW1iZXJNYXAgPSB7XG4gICAgICAgICfgqacnOiAnMScsXG4gICAgICAgICfgqagnOiAnMicsXG4gICAgICAgICfgqaknOiAnMycsXG4gICAgICAgICfgqaonOiAnNCcsXG4gICAgICAgICfgqasnOiAnNScsXG4gICAgICAgICfgqawnOiAnNicsXG4gICAgICAgICfgqa0nOiAnNycsXG4gICAgICAgICfgqa4nOiAnOCcsXG4gICAgICAgICfgqa8nOiAnOScsXG4gICAgICAgICfgqaYnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIHBhSW4gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdwYS1pbicsIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG1vbnRocyBuYW1lIGFzIHBlciBOYW5ha3NoYWhpIENhbGVuZGVyIGJ1dCB0aGV5IGFyZSBub3QgdXNlZCBhcyByaWdpZGx5IGluIG1vZGVybiBQdW5qYWJpLlxuICAgICAgICBtb250aHMgOiAn4Kic4Kio4Ki14Kiw4KmAX+Coq+CovOCosOCoteCosOCpgF/gqK7gqL7gqLDgqJpf4KiF4Kiq4KmN4Kiw4KmI4KiyX+CoruCoiF/gqJzgqYLgqKhf4Kic4KmB4Kiy4Ki+4KiIX+CoheCol+CouOCopF/gqLjgqKTgqbDgqKzgqLBf4KiF4KiV4Kik4KmC4Kis4KiwX+CoqOCoteCpsOCorOCosF/gqKbgqLjgqbDgqKzgqLAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+ConOCoqOCoteCosOCpgF/gqKvgqLzgqLDgqLXgqLDgqYBf4Kiu4Ki+4Kiw4KiaX+CoheCoquCpjeCosOCpiOCosl/gqK7gqIhf4Kic4KmC4KioX+ConOCpgeCosuCovuCoiF/gqIXgqJfgqLjgqKRf4Ki44Kik4Kmw4Kis4KiwX+CoheColeCopOCpguCorOCosF/gqKjgqLXgqbDgqKzgqLBf4Kim4Ki44Kmw4Kis4KiwJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfgqJDgqKTgqLXgqL7gqLBf4Ki44KmL4Kiu4Ki14Ki+4KiwX+CoruCpsOCol+CosuCoteCovuCosF/gqKzgqYHgqKfgqLXgqL7gqLBf4Ki14KmA4Kiw4Ki14Ki+4KiwX+CouOCovOCpgeCpseColeCosOCoteCovuCosF/gqLjgqLzgqKjgqYDgqJrgqLDgqLXgqL7gqLAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4KiQ4KikX+CouOCpi+Corl/gqK7gqbDgqJfgqLJf4Kis4KmB4KinX+CoteCpgOCosF/gqLjgqLzgqYHgqJXgqLBf4Ki44Ki84Kio4KmAJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfgqJDgqKRf4Ki44KmL4KiuX+CoruCpsOCol+Cosl/gqKzgqYHgqKdf4Ki14KmA4KiwX+CouOCovOCpgeColeCosF/gqLjgqLzgqKjgqYAnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnQSBoOm1tIOCoteConOCphycsXG4gICAgICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIOCoteConOCphycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0g4Ki14Kic4KmHJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSDgqLXgqJzgqYcnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4KiF4KicXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgqJXgqLJdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+ColeCosl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+CoquCov+Com+CosuCph10gZGRkZCwgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIOCoteCov+CpseComicsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOCoquCov+Com+CosuCphycsXG4gICAgICAgICAgICBzIDogJ+ColeCpgeConSDgqLjgqJXgqL/gqbDgqJ8nLFxuICAgICAgICAgICAgc3MgOiAnJWQg4Ki44KiV4Ki/4Kmw4KifJyxcbiAgICAgICAgICAgIG0gOiAn4KiH4KiVIOCoruCov+CpsOConycsXG4gICAgICAgICAgICBtbSA6ICclZCDgqK7gqL/gqbDgqJ8nLFxuICAgICAgICAgICAgaCA6ICfgqIfgqbHgqJUg4KiY4Kmw4Kif4Ki+JyxcbiAgICAgICAgICAgIGhoIDogJyVkIOComOCpsOCon+CphycsXG4gICAgICAgICAgICBkIDogJ+Coh+CpseColSDgqKbgqL/gqKgnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4Kim4Ki/4KioJyxcbiAgICAgICAgICAgIE0gOiAn4KiH4Kmx4KiVIOCoruCoueCpgOCoqOCovicsXG4gICAgICAgICAgICBNTSA6ICclZCDgqK7gqLngqYDgqKjgqYcnLFxuICAgICAgICAgICAgeSA6ICfgqIfgqbHgqJUg4Ki44Ki+4KiyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCouOCovuCosidcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Cpp+CpqOCpqeCpquCpq+CprOCpreCpruCpr+Cppl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHVuamFiaSBub3RhdGlvbiBmb3IgbWVyaWRpZW1zIGFyZSBxdWl0ZSBmdXp6eSBpbiBwcmFjdGljZS4gV2hpbGUgdGhlcmUgZXhpc3RzXG4gICAgICAgIC8vIGEgcmlnaWQgbm90aW9uIG9mIGEgJ1BhaGFyJyBpdCBpcyBub3QgdXNlZCBhcyByaWdpZGx5IGluIG1vZGVybiBQdW5qYWJpLlxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv4Kiw4Ki+4KikfOCouOCoteCph+CosHzgqKbgqYHgqKrgqLngqL/gqLB84Ki44Ki84Ki+4KiuLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CosOCovuCopCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA8IDQgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CouOCoteCph+CosCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqKbgqYHgqKrgqLngqL/gqLAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CouOCovOCovuCoricpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Kiw4Ki+4KikJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgqLjgqLXgqYfgqLAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CopuCpgeCoquCoueCov+CosCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Ki44Ki84Ki+4KiuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgqLDgqL7gqKQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwYUluO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wYS1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///93\n");

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),\n        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');\n    function plural(n) {\n        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);\n    }\n    function translate(number, withoutSuffix, key) {\n        var result = number + ' ';\n        switch (key) {\n            case 'ss':\n                return result + (plural(number) ? 'sekundy' : 'sekund');\n            case 'm':\n                return withoutSuffix ? 'minuta' : 'minut';\n            case 'mm':\n                return result + (plural(number) ? 'minuty' : 'minut');\n            case 'h':\n                return withoutSuffix  ? 'godzina'  : 'godzin';\n            case 'hh':\n                return result + (plural(number) ? 'godziny' : 'godzin');\n            case 'MM':\n                return result + (plural(number) ? 'miesice' : 'miesicy');\n            case 'yy':\n                return result + (plural(number) ? 'lata' : 'lat');\n        }\n    }\n\n    var pl = moment.defineLocale('pl', {\n        months : function (momentToFormat, format) {\n            if (!momentToFormat) {\n                return monthsNominative;\n            } else if (format === '') {\n                // Hack: if format empty we know this is used to generate\n                // RegExp by moment. Give then back both valid forms of months\n                // in RegExp ready format.\n                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';\n            } else if (/D MMMM/.test(format)) {\n                return monthsSubjective[momentToFormat.month()];\n            } else {\n                return monthsNominative[momentToFormat.month()];\n            }\n        },\n        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),\n        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),\n        weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),\n        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Dzi o] LT',\n            nextDay: '[Jutro o] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[W niedziel o] LT';\n\n                    case 2:\n                        return '[We wtorek o] LT';\n\n                    case 3:\n                        return '[W rod o] LT';\n\n                    case 6:\n                        return '[W sobot o] LT';\n\n                    default:\n                        return '[W] dddd [o] LT';\n                }\n            },\n            lastDay: '[Wczoraj o] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[W zesz niedziel o] LT';\n                    case 3:\n                        return '[W zesz rod o] LT';\n                    case 6:\n                        return '[W zesz sobot o] LT';\n                    default:\n                        return '[W zeszy] dddd [o] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past : '%s temu',\n            s : 'kilka sekund',\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : translate,\n            hh : translate,\n            d : '1 dzie',\n            dd : '%d dni',\n            M : 'miesic',\n            MM : translate,\n            y : 'rok',\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return pl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wbC5qcz9lY2I1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6Ijk0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzTm9taW5hdGl2ZSA9ICdzdHljemXFhF9sdXR5X21hcnplY19rd2llY2llxYRfbWFqX2N6ZXJ3aWVjX2xpcGllY19zaWVycGllxYRfd3J6ZXNpZcWEX3Bhxbpkemllcm5pa19saXN0b3BhZF9ncnVkemllxYQnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1N1YmplY3RpdmUgPSAnc3R5Y3puaWFfbHV0ZWdvX21hcmNhX2t3aWV0bmlhX21hamFfY3plcndjYV9saXBjYV9zaWVycG5pYV93cnplxZtuaWFfcGHFumR6aWVybmlrYV9saXN0b3BhZGFfZ3J1ZG5pYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBwbHVyYWwobikge1xuICAgICAgICByZXR1cm4gKG4gJSAxMCA8IDUpICYmIChuICUgMTAgPiAxKSAmJiAoKH5+KG4gLyAxMCkgJSAxMCkgIT09IDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ3Nla3VuZHknIDogJ3Nla3VuZCcpO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnbWludXRhJyA6ICdtaW51dMSZJztcbiAgICAgICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pbnV0eScgOiAnbWludXQnKTtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ICA/ICdnb2R6aW5hJyAgOiAnZ29kemluxJknO1xuICAgICAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnZ29kemlueScgOiAnZ29kemluJyk7XG4gICAgICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtaWVzacSFY2UnIDogJ21pZXNpxJljeScpO1xuICAgICAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbGF0YScgOiAnbGF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdwbCcsIHtcbiAgICAgICAgbW9udGhzIDogZnVuY3Rpb24gKG1vbWVudFRvRm9ybWF0LCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50VG9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzTm9taW5hdGl2ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIEhhY2s6IGlmIGZvcm1hdCBlbXB0eSB3ZSBrbm93IHRoaXMgaXMgdXNlZCB0byBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIFJlZ0V4cCBieSBtb21lbnQuIEdpdmUgdGhlbiBiYWNrIGJvdGggdmFsaWQgZm9ybXMgb2YgbW9udGhzXG4gICAgICAgICAgICAgICAgLy8gaW4gUmVnRXhwIHJlYWR5IGZvcm1hdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgbW9udGhzU3ViamVjdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXSArICd8JyArIG1vbnRoc05vbWluYXRpdmVbbW9tZW50VG9Gb3JtYXQubW9udGgoKV0gKyAnKSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9EIE1NTU0vLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTdWJqZWN0aXZlW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzTm9taW5hdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnc3R5X2x1dF9tYXJfa3dpX21hal9jemVfbGlwX3NpZV93cnpfcGHFul9saXNfZ3J1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICduaWVkemllbGFfcG9uaWVkemlhxYJla193dG9yZWtfxZtyb2RhX2N6d2FydGVrX3BpxIV0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ25kel9wb25fd3RfxZtyX2N6d19wdF9zb2InLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ05kX1BuX1d0X8Wacl9Del9QdF9Tbycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbRHppxZsgb10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tKdXRybyBvXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIG5pZWR6aWVsxJkgb10gTFQnO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1dlIHd0b3JlayBvXSBMVCc7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbVyDFm3JvZMSZIG9dIExUJztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHNvYm90xJkgb10gTFQnO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXXSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbV2N6b3JhaiBvXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgsSFIG5pZWR6aWVsxJkgb10gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgsSFIMWbcm9kxJkgb10gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgsSFIHNvYm90xJkgb10gTFQnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbVyB6ZXN6xYJ5XSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgdGVtdScsXG4gICAgICAgICAgICBzIDogJ2tpbGthIHNla3VuZCcsXG4gICAgICAgICAgICBzcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiAnMSBkemllxYQnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZG5pJyxcbiAgICAgICAgICAgIE0gOiAnbWllc2nEhWMnLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogJ3JvaycsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBsO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wbC5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94\n");

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var pt = moment.defineLocale('pt', {\n        months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),\n        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),\n        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),\n        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),\n        weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY HH:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Hoje s] LT',\n            nextDay: '[Amanh s] LT',\n            nextWeek: 'dddd [s] LT',\n            lastDay: '[Ontem s] LT',\n            lastWeek: function () {\n                return (this.day() === 0 || this.day() === 6) ?\n                    '[ltimo] dddd [s] LT' : // Saturday + Sunday\n                    '[ltima] dddd [s] LT'; // Monday - Friday\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'em %s',\n            past : 'h %s',\n            s : 'segundos',\n            ss : '%d segundos',\n            m : 'um minuto',\n            mm : '%d minutos',\n            h : 'uma hora',\n            hh : '%d horas',\n            d : 'um dia',\n            dd : '%d dias',\n            M : 'um ms',\n            MM : '%d meses',\n            y : 'um ano',\n            yy : '%d anos'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return pt;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC5qcz82Njg0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI5NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHB0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgncHQnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW5laXJvX2ZldmVyZWlyb19tYXLDp29fYWJyaWxfbWFpb19qdW5ob19qdWxob19hZ29zdG9fc2V0ZW1icm9fb3V0dWJyb19ub3ZlbWJyb19kZXplbWJybycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2Zldl9tYXJfYWJyX21haV9qdW5fanVsX2Fnb19zZXRfb3V0X25vdl9kZXonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0RvbWluZ29fU2VndW5kYS1mZWlyYV9UZXLDp2EtZmVpcmFfUXVhcnRhLWZlaXJhX1F1aW50YS1mZWlyYV9TZXh0YS1mZWlyYV9Tw6FiYWRvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0RvbV9TZWdfVGVyX1F1YV9RdWlfU2V4X1PDoWInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RvXzLCql8zwqpfNMKqXzXCql82wqpfU8OhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIFtkZV0gTU1NTSBbZGVdIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tIb2plIMOgc10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tBbWFuaMOjIMOgc10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvDoHNdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbT250ZW0gw6BzXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5kYXkoKSA9PT0gMCB8fCB0aGlzLmRheSgpID09PSA2KSA/XG4gICAgICAgICAgICAgICAgICAgICdbw5psdGltb10gZGRkZCBbw6BzXSBMVCcgOiAvLyBTYXR1cmRheSArIFN1bmRheVxuICAgICAgICAgICAgICAgICAgICAnW8OabHRpbWFdIGRkZGQgW8Ogc10gTFQnOyAvLyBNb25kYXkgLSBGcmlkYXlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdlbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2jDoSAlcycsXG4gICAgICAgICAgICBzIDogJ3NlZ3VuZG9zJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlZ3VuZG9zJyxcbiAgICAgICAgICAgIG0gOiAndW0gbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxuICAgICAgICAgICAgaCA6ICd1bWEgaG9yYScsXG4gICAgICAgICAgICBoaCA6ICclZCBob3JhcycsXG4gICAgICAgICAgICBkIDogJ3VtIGRpYScsXG4gICAgICAgICAgICBkZCA6ICclZCBkaWFzJyxcbiAgICAgICAgICAgIE0gOiAndW0gbcOqcycsXG4gICAgICAgICAgICBNTSA6ICclZCBtZXNlcycsXG4gICAgICAgICAgICB5IDogJ3VtIGFubycsXG4gICAgICAgICAgICB5eSA6ICclZCBhbm9zJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn3Cui8sXG4gICAgICAgIG9yZGluYWwgOiAnJWTCuicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHB0O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///95\n");

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ptBr = moment.defineLocale('pt-br', {\n        months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),\n        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),\n        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),\n        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),\n        weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'\n        },\n        calendar : {\n            sameDay: '[Hoje s] LT',\n            nextDay: '[Amanh s] LT',\n            nextWeek: 'dddd [s] LT',\n            lastDay: '[Ontem s] LT',\n            lastWeek: function () {\n                return (this.day() === 0 || this.day() === 6) ?\n                    '[ltimo] dddd [s] LT' : // Saturday + Sunday\n                    '[ltima] dddd [s] LT'; // Monday - Friday\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'em %s',\n            past : 'h %s',\n            s : 'poucos segundos',\n            ss : '%d segundos',\n            m : 'um minuto',\n            mm : '%d minutos',\n            h : 'uma hora',\n            hh : '%d horas',\n            d : 'um dia',\n            dd : '%d dias',\n            M : 'um ms',\n            MM : '%d meses',\n            y : 'um ano',\n            yy : '%d anos'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : '%d'\n    });\n\n    return ptBr;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC1ici5qcz8wMjgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBwdEJyID0gbW9tZW50LmRlZmluZUxvY2FsZSgncHQtYnInLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW5laXJvX2ZldmVyZWlyb19tYXLDp29fYWJyaWxfbWFpb19qdW5ob19qdWxob19hZ29zdG9fc2V0ZW1icm9fb3V0dWJyb19ub3ZlbWJyb19kZXplbWJybycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2Zldl9tYXJfYWJyX21haV9qdW5fanVsX2Fnb19zZXRfb3V0X25vdl9kZXonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0RvbWluZ29fU2VndW5kYS1mZWlyYV9UZXLDp2EtZmVpcmFfUXVhcnRhLWZlaXJhX1F1aW50YS1mZWlyYV9TZXh0YS1mZWlyYV9Tw6FiYWRvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0RvbV9TZWdfVGVyX1F1YV9RdWlfU2V4X1PDoWInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RvXzLCql8zwqpfNMKqXzXCql82wqpfU8OhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVkgW8Ogc10gSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIFtkZV0gTU1NTSBbZGVdIFlZWVkgW8Ogc10gSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tIb2plIMOgc10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tBbWFuaMOjIMOgc10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvDoHNdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbT250ZW0gw6BzXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5kYXkoKSA9PT0gMCB8fCB0aGlzLmRheSgpID09PSA2KSA/XG4gICAgICAgICAgICAgICAgICAgICdbw5psdGltb10gZGRkZCBbw6BzXSBMVCcgOiAvLyBTYXR1cmRheSArIFN1bmRheVxuICAgICAgICAgICAgICAgICAgICAnW8OabHRpbWFdIGRkZGQgW8Ogc10gTFQnOyAvLyBNb25kYXkgLSBGcmlkYXlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdlbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2jDoSAlcycsXG4gICAgICAgICAgICBzIDogJ3BvdWNvcyBzZWd1bmRvcycsXG4gICAgICAgICAgICBzcyA6ICclZCBzZWd1bmRvcycsXG4gICAgICAgICAgICBtIDogJ3VtIG1pbnV0bycsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcbiAgICAgICAgICAgIGggOiAndW1hIGhvcmEnLFxuICAgICAgICAgICAgaGggOiAnJWQgaG9yYXMnLFxuICAgICAgICAgICAgZCA6ICd1bSBkaWEnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGlhcycsXG4gICAgICAgICAgICBNIDogJ3VtIG3DqnMnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxuICAgICAgICAgICAgeSA6ICd1bSBhbm8nLFxuICAgICAgICAgICAgeXkgOiAnJWQgYW5vcydcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHRCcjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQtYnIuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///96\n");

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n                'ss': 'secunde',\n                'mm': 'minute',\n                'hh': 'ore',\n                'dd': 'zile',\n                'MM': 'luni',\n                'yy': 'ani'\n            },\n            separator = ' ';\n        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {\n            separator = ' de ';\n        }\n        return number + separator + format[key];\n    }\n\n    var ro = moment.defineLocale('ro', {\n        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),\n        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),\n        monthsParseExact: true,\n        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),\n        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),\n        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd, D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay: '[azi la] LT',\n            nextDay: '[mine la] LT',\n            nextWeek: 'dddd [la] LT',\n            lastDay: '[ieri la] LT',\n            lastWeek: '[fosta] dddd [la] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'peste %s',\n            past : '%s n urm',\n            s : 'cteva secunde',\n            ss : relativeTimeWithPlural,\n            m : 'un minut',\n            mm : relativeTimeWithPlural,\n            h : 'o or',\n            hh : relativeTimeWithPlural,\n            d : 'o zi',\n            dd : relativeTimeWithPlural,\n            M : 'o lun',\n            MM : relativeTimeWithPlural,\n            y : 'un an',\n            yy : relativeTimeWithPlural\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ro;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9yby5qcz9jMTNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHtcbiAgICAgICAgICAgICAgICAnc3MnOiAnc2VjdW5kZScsXG4gICAgICAgICAgICAgICAgJ21tJzogJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ2hoJzogJ29yZScsXG4gICAgICAgICAgICAgICAgJ2RkJzogJ3ppbGUnLFxuICAgICAgICAgICAgICAgICdNTSc6ICdsdW5pJyxcbiAgICAgICAgICAgICAgICAneXknOiAnYW5pJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcGFyYXRvciA9ICcgJztcbiAgICAgICAgaWYgKG51bWJlciAlIDEwMCA+PSAyMCB8fCAobnVtYmVyID49IDEwMCAmJiBudW1iZXIgJSAxMDAgPT09IDApKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSAnIGRlICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bWJlciArIHNlcGFyYXRvciArIGZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBybyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3JvJywge1xuICAgICAgICBtb250aHMgOiAnaWFudWFyaWVfZmVicnVhcmllX21hcnRpZV9hcHJpbGllX21haV9pdW5pZV9pdWxpZV9hdWd1c3Rfc2VwdGVtYnJpZV9vY3RvbWJyaWVfbm9pZW1icmllX2RlY2VtYnJpZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnaWFuLl9mZWJyLl9tYXJ0Ll9hcHIuX21haV9pdW4uX2l1bC5fYXVnLl9zZXB0Ll9vY3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAnZHVtaW5pY8SDX2x1bmlfbWFyyJtpX21pZXJjdXJpX2pvaV92aW5lcmlfc8OibWLEg3TEgycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdEdW1fTHVuX01hcl9NaWVfSm9pX1Zpbl9Tw6JtJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdEdV9MdV9NYV9NaV9Kb19WaV9Tw6InLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbYXppIGxhXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW23DomluZSBsYV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtsYV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tpZXJpIGxhXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tmb3N0YV0gZGRkZCBbbGFdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3Blc3RlICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgw65uIHVybcSDJyxcbiAgICAgICAgICAgIHMgOiAnY8OidGV2YSBzZWN1bmRlJyxcbiAgICAgICAgICAgIHNzIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIG0gOiAndW4gbWludXQnLFxuICAgICAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgaCA6ICdvIG9yxIMnLFxuICAgICAgICAgICAgaGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgZCA6ICdvIHppJyxcbiAgICAgICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIE0gOiAnbyBsdW7EgycsXG4gICAgICAgICAgICBNTSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICB5IDogJ3VuIGFuJyxcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBybztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcm8uanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97\n");

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function plural(word, num) {\n        var forms = word.split('_');\n        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n    }\n    function relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n            'ss': withoutSuffix ? '__' : '__',\n            'mm': withoutSuffix ? '__' : '__',\n            'hh': '__',\n            'dd': '__',\n            'MM': '__',\n            'yy': '__'\n        };\n        if (key === 'm') {\n            return withoutSuffix ? '' : '';\n        }\n        else {\n            return number + ' ' + plural(format[key], +number);\n        }\n    }\n    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];\n\n    // http://new.gramota.ru/spravka/rules/139-prop :  103\n    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637\n    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753\n    var ru = moment.defineLocale('ru', {\n        months : {\n            format: '___________'.split('_'),\n            standalone: '___________'.split('_')\n        },\n        monthsShort : {\n            //  CLDR  \".\"  \".\",        ?\n            format: '._._._.____._._._._.'.split('_'),\n            standalone: '._.__.____._._._._.'.split('_')\n        },\n        weekdays : {\n            standalone: '______'.split('_'),\n            format: '______'.split('_'),\n            isFormat: /\\[ ?[] ?(?:||)? ?\\] ?dddd/\n        },\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        monthsParse : monthsParse,\n        longMonthsParse : monthsParse,\n        shortMonthsParse : monthsParse,\n\n        //    ,   ,  ,  4 ,      \n        monthsRegex: /^([]|\\.?|[]|?\\.?|?|\\.?|[]|\\.?|[]|[]|\\.?|[]|\\.?|?|\\.?|[]|?\\.?|[]|\\.?|[]|?\\.?|[]|\\.?)/i,\n\n        //  \n        monthsShortRegex: /^([]|\\.?|[]|?\\.?|?|\\.?|[]|\\.?|[]|[]|\\.?|[]|\\.?|?|\\.?|[]|?\\.?|[]|\\.?|[]|?\\.?|[]|\\.?)/i,\n\n        //    \n        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,\n\n        // ,     \n        monthsShortStrictRegex: /^(\\.|?\\.|[.]|\\.|[]|[.]|[.]|\\.|?\\.|\\.|?\\.|\\.)/i,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., H:mm',\n            LLLL : 'dddd, D MMMM YYYY ., H:mm'\n        },\n        calendar : {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            lastDay: '[ ] LT',\n            nextWeek: function (now) {\n                if (now.week() !== this.week()) {\n                    switch (this.day()) {\n                        case 0:\n                            return '[ ] dddd [] LT';\n                        case 1:\n                        case 2:\n                        case 4:\n                            return '[ ] dddd [] LT';\n                        case 3:\n                        case 5:\n                        case 6:\n                            return '[ ] dddd [] LT';\n                    }\n                } else {\n                    if (this.day() === 2) {\n                        return '[] dddd [] LT';\n                    } else {\n                        return '[] dddd [] LT';\n                    }\n                }\n            },\n            lastWeek: function (now) {\n                if (now.week() !== this.week()) {\n                    switch (this.day()) {\n                        case 0:\n                            return '[ ] dddd [] LT';\n                        case 1:\n                        case 2:\n                        case 4:\n                            return '[ ] dddd [] LT';\n                        case 3:\n                        case 5:\n                        case 6:\n                            return '[ ] dddd [] LT';\n                    }\n                } else {\n                    if (this.day() === 2) {\n                        return '[] dddd [] LT';\n                    } else {\n                        return '[] dddd [] LT';\n                    }\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            ss : relativeTimeWithPlural,\n            m : relativeTimeWithPlural,\n            mm : relativeTimeWithPlural,\n            h : '',\n            hh : relativeTimeWithPlural,\n            d : '',\n            dd : relativeTimeWithPlural,\n            M : '',\n            MM : relativeTimeWithPlural,\n            y : '',\n            yy : relativeTimeWithPlural\n        },\n        meridiemParse: /|||/i,\n        isPM : function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(||)/,\n        ordinal: function (number, period) {\n            switch (period) {\n                case 'M':\n                case 'd':\n                case 'DDD':\n                    return number + '-';\n                case 'D':\n                    return number + '-';\n                case 'w':\n                case 'W':\n                    return number + '-';\n                default:\n                    return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return ru;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ydS5qcz9iYTVhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiI5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcGx1cmFsKHdvcmQsIG51bSkge1xuICAgICAgICB2YXIgZm9ybXMgPSB3b3JkLnNwbGl0KCdfJyk7XG4gICAgICAgIHJldHVybiBudW0gJSAxMCA9PT0gMSAmJiBudW0gJSAxMDAgIT09IDExID8gZm9ybXNbMF0gOiAobnVtICUgMTAgPj0gMiAmJiBudW0gJSAxMCA8PSA0ICYmIChudW0gJSAxMDAgPCAxMCB8fCBudW0gJSAxMDAgPj0gMjApID8gZm9ybXNbMV0gOiBmb3Jtc1syXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHtcbiAgICAgICAgICAgICdzcyc6IHdpdGhvdXRTdWZmaXggPyAn0YHQtdC60YPQvdC00LBf0YHQtdC60YPQvdC00Ytf0YHQtdC60YPQvdC0JyA6ICfRgdC10LrRg9C90LTRg1/RgdC10LrRg9C90LTRi1/RgdC10LrRg9C90LQnLFxuICAgICAgICAgICAgJ21tJzogd2l0aG91dFN1ZmZpeCA/ICfQvNC40L3Rg9GC0LBf0LzQuNC90YPRgtGLX9C80LjQvdGD0YInIDogJ9C80LjQvdGD0YLRg1/QvNC40L3Rg9GC0Ytf0LzQuNC90YPRgicsXG4gICAgICAgICAgICAnaGgnOiAn0YfQsNGBX9GH0LDRgdCwX9GH0LDRgdC+0LInLFxuICAgICAgICAgICAgJ2RkJzogJ9C00LXQvdGMX9C00L3Rj1/QtNC90LXQuScsXG4gICAgICAgICAgICAnTU0nOiAn0LzQtdGB0Y/Rhl/QvNC10YHRj9GG0LBf0LzQtdGB0Y/RhtC10LInLFxuICAgICAgICAgICAgJ3l5JzogJ9Cz0L7QtF/Qs9C+0LTQsF/Qu9C10YInXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXkgPT09ICdtJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0LzQuNC90YPRgtCwJyA6ICfQvNC40L3Rg9GC0YMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHBsdXJhbChmb3JtYXRba2V5XSwgK251bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1vbnRoc1BhcnNlID0gWy9e0Y/QvdCyL2ksIC9e0YTQtdCyL2ksIC9e0LzQsNGAL2ksIC9e0LDQv9GAL2ksIC9e0LzQsFvQudGPXS9pLCAvXtC40Y7QvS9pLCAvXtC40Y7Quy9pLCAvXtCw0LLQsy9pLCAvXtGB0LXQvS9pLCAvXtC+0LrRgi9pLCAvXtC90L7Rjy9pLCAvXtC00LXQui9pXTtcblxuICAgIC8vIGh0dHA6Ly9uZXcuZ3JhbW90YS5ydS9zcHJhdmthL3J1bGVzLzEzOS1wcm9wIDogwqcgMTAzXG4gICAgLy8g0KHQvtC60YDQsNGJ0LXQvdC40Y8g0LzQtdGB0Y/RhtC10LI6IGh0dHA6Ly9uZXcuZ3JhbW90YS5ydS9zcHJhdmthL2J1cm8vc2VhcmNoLWFuc3dlcj9zPTI0MjYzN1xuICAgIC8vIENMRFIgZGF0YTogICAgICAgICAgaHR0cDovL3d3dy51bmljb2RlLm9yZy9jbGRyL2NoYXJ0cy8yOC9zdW1tYXJ5L3J1Lmh0bWwjMTc1M1xuICAgIHZhciBydSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3J1Jywge1xuICAgICAgICBtb250aHMgOiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICfRj9C90LLQsNGA0Y9f0YTQtdCy0YDQsNC70Y9f0LzQsNGA0YLQsF/QsNC/0YDQtdC70Y9f0LzQsNGPX9C40Y7QvdGPX9C40Y7Qu9GPX9Cw0LLQs9GD0YHRgtCwX9GB0LXQvdGC0Y/QsdGA0Y9f0L7QutGC0Y/QsdGA0Y9f0L3QvtGP0LHRgNGPX9C00LXQutCw0LHRgNGPJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgc3RhbmRhbG9uZTogJ9GP0L3QstCw0YDRjF/RhNC10LLRgNCw0LvRjF/QvNCw0YDRgl/QsNC/0YDQtdC70Yxf0LzQsNC5X9C40Y7QvdGMX9C40Y7Qu9GMX9Cw0LLQs9GD0YHRgl/RgdC10L3RgtGP0LHRgNGMX9C+0LrRgtGP0LHRgNGMX9C90L7Rj9Cx0YDRjF/QtNC10LrQsNCx0YDRjCcuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBtb250aHNTaG9ydCA6IHtcbiAgICAgICAgICAgIC8vINC/0L4gQ0xEUiDQuNC80LXQvdC90L4gXCLQuNGO0LsuXCIg0LggXCLQuNGO0L0uXCIsINC90L4g0LrQsNC60L7QuSDRgdC80YvRgdC7INC80LXQvdGP0YLRjCDQsdGD0LrQstGDINC90LAg0YLQvtGH0LrRgyA/XG4gICAgICAgICAgICBmb3JtYXQ6ICfRj9C90LIuX9GE0LXQstGALl/QvNCw0YAuX9Cw0L/RgC5f0LzQsNGPX9C40Y7QvdGPX9C40Y7Qu9GPX9Cw0LLQsy5f0YHQtdC90YIuX9C+0LrRgi5f0L3QvtGP0LEuX9C00LXQui4nLnNwbGl0KCdfJyksXG4gICAgICAgICAgICBzdGFuZGFsb25lOiAn0Y/QvdCyLl/RhNC10LLRgC5f0LzQsNGA0YJf0LDQv9GALl/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCzLl/RgdC10L3Rgi5f0L7QutGCLl/QvdC+0Y/QsS5f0LTQtdC6Licuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrZGF5cyA6IHtcbiAgICAgICAgICAgIHN0YW5kYWxvbmU6ICfQstC+0YHQutGA0LXRgdC10L3RjNC1X9C/0L7QvdC10LTQtdC70YzQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTQsF/Rh9C10YLQstC10YDQs1/Qv9GP0YLQvdC40YbQsF/RgdGD0LHQsdC+0YLQsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgIGZvcm1hdDogJ9Cy0L7RgdC60YDQtdGB0LXQvdGM0LVf0L/QvtC90LXQtNC10LvRjNC90LjQul/QstGC0L7RgNC90LjQul/RgdGA0LXQtNGDX9GH0LXRgtCy0LXRgNCzX9C/0Y/RgtC90LjRhtGDX9GB0YPQsdCx0L7RgtGDJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgaXNGb3JtYXQ6IC9cXFsgP1vQktCyXSA/KD860L/RgNC+0YjQu9GD0Y580YHQu9C10LTRg9GO0YnRg9GOfNGN0YLRgyk/ID9cXF0gP2RkZGQvXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn0LLRgV/Qv9C9X9Cy0YJf0YHRgF/Rh9GCX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0LLRgV/Qv9C9X9Cy0YJf0YHRgF/Rh9GCX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcbiAgICAgICAgbG9uZ01vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXG4gICAgICAgIHNob3J0TW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcblxuICAgICAgICAvLyDQv9C+0LvQvdGL0LUg0L3QsNC30LLQsNC90LjRjyDRgSDQv9Cw0LTQtdC20LDQvNC4LCDQv9C+INGC0YDQuCDQsdGD0LrQstGLLCDQtNC70Y8g0L3QtdC60L7RgtC+0YDRi9GFLCDQv9C+IDQg0LHRg9C60LLRiywg0YHQvtC60YDQsNGJ0LXQvdC40Y8g0YEg0YLQvtGH0LrQvtC5INC4INCx0LXQtyDRgtC+0YfQutC4XG4gICAgICAgIG1vbnRoc1JlZ2V4OiAvXijRj9C90LLQsNGAW9GM0Y9dfNGP0L3QslxcLj980YTQtdCy0YDQsNC7W9GM0Y9dfNGE0LXQstGAP1xcLj980LzQsNGA0YLQsD980LzQsNGAXFwuP3zQsNC/0YDQtdC7W9GM0Y9dfNCw0L/RgFxcLj980LzQsFvQudGPXXzQuNGO0L1b0YzRj1180LjRjtC9XFwuP3zQuNGO0Ltb0YzRj1180LjRjtC7XFwuP3zQsNCy0LPRg9GB0YLQsD980LDQstCzXFwuP3zRgdC10L3RgtGP0LHRgFvRjNGPXXzRgdC10L3Rgj9cXC4/fNC+0LrRgtGP0LHRgFvRjNGPXXzQvtC60YJcXC4/fNC90L7Rj9Cx0YBb0YzRj1180L3QvtGP0LE/XFwuP3zQtNC10LrQsNCx0YBb0YzRj1180LTQtdC6XFwuPykvaSxcblxuICAgICAgICAvLyDQutC+0L/QuNGPINC/0YDQtdC00YvQtNGD0YnQtdCz0L5cbiAgICAgICAgbW9udGhzU2hvcnRSZWdleDogL14o0Y/QvdCy0LDRgFvRjNGPXXzRj9C90LJcXC4/fNGE0LXQstGA0LDQu1vRjNGPXXzRhNC10LLRgD9cXC4/fNC80LDRgNGC0LA/fNC80LDRgFxcLj980LDQv9GA0LXQu1vRjNGPXXzQsNC/0YBcXC4/fNC80LBb0LnRj1180LjRjtC9W9GM0Y9dfNC40Y7QvVxcLj980LjRjtC7W9GM0Y9dfNC40Y7Qu1xcLj980LDQstCz0YPRgdGC0LA/fNCw0LLQs1xcLj980YHQtdC90YLRj9Cx0YBb0YzRj1180YHQtdC90YI/XFwuP3zQvtC60YLRj9Cx0YBb0YzRj1180L7QutGCXFwuP3zQvdC+0Y/QsdGAW9GM0Y9dfNC90L7Rj9CxP1xcLj980LTQtdC60LDQsdGAW9GM0Y9dfNC00LXQulxcLj8pL2ksXG5cbiAgICAgICAgLy8g0L/QvtC70L3Ri9C1INC90LDQt9Cy0LDQvdC40Y8g0YEg0L/QsNC00LXQttCw0LzQuFxuICAgICAgICBtb250aHNTdHJpY3RSZWdleDogL14o0Y/QvdCy0LDRgFvRj9GMXXzRhNC10LLRgNCw0Ltb0Y/RjF180LzQsNGA0YLQsD980LDQv9GA0LXQu1vRj9GMXXzQvNCwW9GP0LldfNC40Y7QvVvRj9GMXXzQuNGO0Ltb0Y/RjF180LDQstCz0YPRgdGC0LA/fNGB0LXQvdGC0Y/QsdGAW9GP0YxdfNC+0LrRgtGP0LHRgFvRj9GMXXzQvdC+0Y/QsdGAW9GP0YxdfNC00LXQutCw0LHRgFvRj9GMXSkvaSxcblxuICAgICAgICAvLyDQktGL0YDQsNC20LXQvdC40LUsINC60L7RgtC+0YDQvtC1INGB0L7QvtGC0LLQtdGB0YLQstGD0LXRgiDRgtC+0LvRjNC60L4g0YHQvtC60YDQsNGJ0ZHQvdC90YvQvCDRhNC+0YDQvNCw0LxcbiAgICAgICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleDogL14o0Y/QvdCyXFwufNGE0LXQstGAP1xcLnzQvNCw0YBb0YIuXXzQsNC/0YBcXC580LzQsFvRj9C5XXzQuNGO0L1b0YzRjy5dfNC40Y7Qu1vRjNGPLl180LDQstCzXFwufNGB0LXQvdGCP1xcLnzQvtC60YJcXC580L3QvtGP0LE/XFwufNC00LXQulxcLikvaSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWSDQsy4nLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINCzLiwgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZINCzLiwgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9Ch0LXQs9C+0LTQvdGPINCyXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW9CX0LDQstGC0YDQsCDQsl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1vQktGH0LXRgNCwINCyXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKG5vdykge1xuICAgICAgICAgICAgICAgIGlmIChub3cud2VlaygpICE9PSB0aGlzLndlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDRgdC70LXQtNGD0Y7RidC10LVdIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0YHQu9C10LTRg9GO0YnQuNC5XSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINGB0LvQtdC00YPRjtGJ0YPRjl0gZGRkZCBb0LJdIExUJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRheSgpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQktC+XSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JJdIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uIChub3cpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93LndlZWsoKSAhPT0gdGhpcy53ZWVrKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0L/RgNC+0YjQu9C+0LVdIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0L/RgNC+0YjQu9GL0LldIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0L/RgNC+0YjQu9GD0Y5dIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXkoKSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JLQvl0gZGRkZCBb0LJdIExUJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSXSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9GH0LXRgNC10LcgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDQvdCw0LfQsNC0JyxcbiAgICAgICAgICAgIHMgOiAn0L3QtdGB0LrQvtC70YzQutC+INGB0LXQutGD0L3QtCcsXG4gICAgICAgICAgICBzcyA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBtIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGggOiAn0YfQsNGBJyxcbiAgICAgICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGQgOiAn0LTQtdC90YwnLFxuICAgICAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgTSA6ICfQvNC10YHRj9GGJyxcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIHkgOiAn0LPQvtC0JyxcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0Lh80YPRgtGA0LB80LTQvdGPfNCy0LXRh9C10YDQsC9pLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9C10YDQsCkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9C4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRg9GC0YDQsCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0LTQvdGPJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfQstC10YfQtdGA0LAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNC5fNCz0L580Y8pLyxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC5JztcbiAgICAgICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LPQvic7XG4gICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGPJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBydTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcnUuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98\n");

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var months = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n    var days = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n\n    var sd = moment.defineLocale('sd', {\n        months : months,\n        monthsShort : months,\n        weekdays : days,\n        weekdaysShort : days,\n        weekdaysMin : days,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            }\n            return '';\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd [  ] LT',\n            lastDay : '[] LT',\n            lastWeek : '[ ] dddd [] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/,/g, '');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return sd;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZC5qcz83ZDZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6Ijk5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzID0gW1xuICAgICAgICAn2KzZhtmI2LHZiicsXG4gICAgICAgICfZgdmK2KjYsdmI2LHZiicsXG4gICAgICAgICfZhdin2LHahicsXG4gICAgICAgICfYp9m+2LHZitmEJyxcbiAgICAgICAgJ9mF2KbZiicsXG4gICAgICAgICfYrNmI2YYnLFxuICAgICAgICAn2KzZiNmE2KfYodmQJyxcbiAgICAgICAgJ9ii2q/Ys9m9JyxcbiAgICAgICAgJ9iz2YrZvtm92YXYqNixJyxcbiAgICAgICAgJ9ii2qrZvdmI2KjYsScsXG4gICAgICAgICfZhtmI2YXYqNixJyxcbiAgICAgICAgJ9qK2LPZhdio2LEnXG4gICAgXTtcbiAgICB2YXIgZGF5cyA9IFtcbiAgICAgICAgJ9ii2obYsScsXG4gICAgICAgICfYs9mI2YXYsScsXG4gICAgICAgICfYp9qx2KfYsdmIJyxcbiAgICAgICAgJ9in2LHYqNi5JyxcbiAgICAgICAgJ9iu2YXZitizJyxcbiAgICAgICAgJ9is2YXYuScsXG4gICAgICAgICfah9mG2ofYsSdcbiAgICBdO1xuXG4gICAgdmFyIHNkID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc2QnLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHMsXG4gICAgICAgIHdlZWtkYXlzIDogZGF5cyxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6IGRheXMsXG4gICAgICAgIHdlZWtkYXlzTWluIDogZGF5cyxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGTYjCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL9i12KjYrXzYtNin2YUvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ9i02KfZhScgPT09IGlucHV0O1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9i12KjYrSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ9i02KfZhSc7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb2KfahF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb2LPagNin2rvZil0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb2Kfas9mK2YYg2YfZgdiq2Yog2KrZil0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb2qrYp9mE2YfZh10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW9qv2LLYsdmK2YQg2YfZgdiq2YpdIGRkZGQgW9iq2YpdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDZvtmI2KEnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDYp9qzJyxcbiAgICAgICAgICAgIHMgOiAn2obZhtivINiz2YraqtmG2oonLFxuICAgICAgICAgICAgc3MgOiAnJWQg2LPZitqq2YbaiicsXG4gICAgICAgICAgICBtIDogJ9mH2qog2YXZhtm9JyxcbiAgICAgICAgICAgIG1tIDogJyVkINmF2YbZvScsXG4gICAgICAgICAgICBoIDogJ9mH2qog2qrZhNin2qonLFxuICAgICAgICAgICAgaGggOiAnJWQg2qrZhNin2qonLFxuICAgICAgICAgICAgZCA6ICfZh9qqINqP2YrZhtmH2YYnLFxuICAgICAgICAgICAgZGQgOiAnJWQg2o/ZitmG2YfZhicsXG4gICAgICAgICAgICBNIDogJ9mH2qog2YXZh9mK2YbZiCcsXG4gICAgICAgICAgICBNTSA6ICclZCDZhdmH2YrZhtinJyxcbiAgICAgICAgICAgIHkgOiAn2YfaqiDYs9in2YQnLFxuICAgICAgICAgICAgeXkgOiAnJWQg2LPYp9mEJ1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC/YjC9nLCAnLCcpO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLywvZywgJ9iMJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNkO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZC5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///99\n");

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var se = moment.defineLocale('se', {\n        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),\n        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),\n        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),\n        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),\n        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'MMMM D. [b.] YYYY',\n            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',\n            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'\n        },\n        calendar : {\n            sameDay: '[otne ti] LT',\n            nextDay: '[ihttin ti] LT',\n            nextWeek: 'dddd [ti] LT',\n            lastDay: '[ikte ti] LT',\n            lastWeek: '[ovddit] dddd [ti] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '%s geaes',\n            past : 'mait %s',\n            s : 'moadde sekunddat',\n            ss: '%d sekunddat',\n            m : 'okta minuhta',\n            mm : '%d minuhtat',\n            h : 'okta diimmu',\n            hh : '%d diimmut',\n            d : 'okta beaivi',\n            dd : '%d beaivvit',\n            M : 'okta mnnu',\n            MM : '%d mnut',\n            y : 'okta jahki',\n            yy : '%d jagit'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return se;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZS5qcz9lNGU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc2UgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzZScsIHtcbiAgICAgICAgbW9udGhzIDogJ2/EkcSRYWphZ2Vtw6FubnVfZ3VvdnZhbcOhbm51X25qdWvEjWFtw6FubnVfY3VvxYtvbcOhbm51X21pZXNzZW3DoW5udV9nZWFzc2Vtw6FubnVfc3VvaWRuZW3DoW5udV9ib3JnZW3DoW5udV/EjWFrxI1hbcOhbm51X2dvbGdnb3Rtw6FubnVfc2vDoWJtYW3DoW5udV9qdW92bGFtw6FubnUnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2/EkcSRal9ndW92X25qdWtfY3VvX21pZXNfZ2Vhc19zdW9pX2JvcmdfxI1ha8SNX2dvbGdfc2vDoWJfanVvdicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnc290bmFiZWFpdmlfdnVvc3PDoXJnYV9tYcWLxYtlYsOhcmdhX2dhc2thdmFoa2t1X2R1b3Jhc3RhdF9iZWFyamFkYXRfbMOhdnZhcmRhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzb3RuX3Z1b3NfbWHFi19nYXNrX2R1b3JfYmVhcl9sw6F2Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdzX3ZfbV9nX2RfYl9MJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnTU1NTSBELiBbYi5dIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ01NTU0gRC4gW2IuXSBZWVlZIFt0aS5dIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELiBbYi5dIFlZWVkgW3RpLl0gSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tvdG5lIHRpXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW2lodHRpbiB0aV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt0aV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tpa3RlIHRpXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tvdmRkaXRdIGRkZGQgW3RpXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyBnZWHFvmVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnbWHFi2l0ICVzJyxcbiAgICAgICAgICAgIHMgOiAnbW9hZGRlIHNla3VuZGRhdCcsXG4gICAgICAgICAgICBzczogJyVkIHNla3VuZGRhdCcsXG4gICAgICAgICAgICBtIDogJ29rdGEgbWludWh0YScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51aHRhdCcsXG4gICAgICAgICAgICBoIDogJ29rdGEgZGlpbW11JyxcbiAgICAgICAgICAgIGhoIDogJyVkIGRpaW1tdXQnLFxuICAgICAgICAgICAgZCA6ICdva3RhIGJlYWl2aScsXG4gICAgICAgICAgICBkZCA6ICclZCBiZWFpdnZpdCcsXG4gICAgICAgICAgICBNIDogJ29rdGEgbcOhbm51JyxcbiAgICAgICAgICAgIE1NIDogJyVkIG3DoW51dCcsXG4gICAgICAgICAgICB5IDogJ29rdGEgamFoa2knLFxuICAgICAgICAgICAgeXkgOiAnJWQgamFnaXQnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2U7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n");

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    /*jshint -W100*/\n    var si = moment.defineLocale('si', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'a h:mm',\n            LTS : 'a h:mm:ss',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYY MMMM D',\n            LLL : 'YYYY MMMM D, a h:mm',\n            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'\n        },\n        calendar : {\n            sameDay : '[] LT[]',\n            nextDay : '[] LT[]',\n            nextWeek : 'dddd LT[]',\n            lastDay : '[] LT[]',\n            lastWeek : '[] dddd LT[]',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s ',\n            s : ' ',\n            ss : ' %d',\n            m : '',\n            mm : ' %d',\n            h : '',\n            hh : ' %d',\n            d : '',\n            dd : ' %d',\n            M : '',\n            MM : ' %d',\n            y : '',\n            yy : ' %d'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2} /,\n        ordinal : function (number) {\n            return number + ' ';\n        },\n        meridiemParse : / | |.|../,\n        isPM : function (input) {\n            return input === '..' || input === ' ';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? '..' : ' ';\n            } else {\n                return isLower ? '..' : ' ';\n            }\n        }\n    });\n\n    return si;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zaS5qcz8yZTBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEwMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgLypqc2hpbnQgLVcxMDAqL1xuICAgIHZhciBzaSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NpJywge1xuICAgICAgICBtb250aHMgOiAn4Lai4Lax4LeA4LeP4La74LeSX+C2tOC3meC2tuC2u+C3gOC3j+C2u+C3kl/gtrjgt4/gtrvgt4rgtq3gt5Rf4LaF4La04LeK4oCN4La74Lea4La94LeKX+C2uOC3kOC2uuC3kl/gtqLgt5bgtrHgt5Jf4Lai4LeW4La94LeSX+C2heC2nOC3neC3g+C3iuC2reC3lF/gt4Pgt5DgtrTgt4rgtq3gt5Dgtrjgt4rgtrbgtrvgt4pf4LaU4Laa4LeK4Lat4Led4La24La74LeKX+C2seC3nOC3gOC3kOC2uOC3iuC2tuC2u+C3il/gtq/gt5ngt4Pgt5Dgtrjgt4rgtrbgtrvgt4onLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+C2ouC2sV/gtrTgt5ngtrZf4La44LeP4La74LeKX+C2heC2tOC3il/gtrjgt5Dgtrrgt5Jf4Lai4LeW4Lax4LeSX+C2ouC3luC2veC3kl/gtoXgtpzgt51f4LeD4LeQ4La04LeKX+C2lOC2muC3il/gtrHgt5zgt4Dgt5Bf4Lav4LeZ4LeD4LeQJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfgtongtrvgt5Lgtq/gt49f4LeD4Laz4LeU4Lav4LePX+C2heC2n+C3hOC2u+C3lOC3gOC3j+C2r+C3j1/gtrbgtq/gt4/gtq/gt49f4La24LeK4oCN4La74LeE4LeD4LeK4La04Lat4LeS4Lax4LeK4Lav4LePX+C3g+C3kuC2muC3lOC2u+C3j+C2r+C3j1/gt4Pgt5ngtrHgt4Pgt5Tgtrvgt4/gtq/gt48nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4LaJ4La74LeSX+C3g+C2s+C3lF/gtoXgtp9f4La24Lav4LePX+C2tuC3iuKAjeC2u+C3hF/gt4Pgt5Lgtprgt5Rf4LeD4LeZ4LaxJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfgtolf4LeDX+C2hV/gtrZf4La24LeK4oCN4La7X+C3g+C3kl/gt4Pgt5knLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnYSBoOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdhIGg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdZWVlZL01NL0REJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVkgTU1NTSBEJyxcbiAgICAgICAgICAgIExMTCA6ICdZWVlZIE1NTU0gRCwgYSBoOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWSBNTU1NIEQgW+C3gOC3kOC2seC3kl0gZGRkZCwgYSBoOm1tOnNzJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW+C2heC2r10gTFRb4LanXScsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgt4Tgt5ngtqddIExUW+C2p10nLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVFvgtqddJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+C2iuC2uuC3ml0gTFRb4LanXScsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4La04LeD4LeU4Lac4LeS4La6XSBkZGRkIExUW+C2p10nLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVz4Laa4LeS4Lax4LeKJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPgtprgtqcg4La04LeZ4La7JyxcbiAgICAgICAgICAgIHMgOiAn4Lat4Lat4LeK4La04La7IOC2muC3kuC3hOC3kuC2tOC2uicsXG4gICAgICAgICAgICBzcyA6ICfgtq3gtq3gt4rgtrTgtrsgJWQnLFxuICAgICAgICAgICAgbSA6ICfgtrjgt5LgtrHgt5Lgtq3gt4rgtq3gt5Tgt4AnLFxuICAgICAgICAgICAgbW0gOiAn4La44LeS4Lax4LeS4Lat4LeK4Lat4LeUICVkJyxcbiAgICAgICAgICAgIGggOiAn4La04LeQ4La6JyxcbiAgICAgICAgICAgIGhoIDogJ+C2tOC3kOC2uiAlZCcsXG4gICAgICAgICAgICBkIDogJ+C2r+C3kuC2seC2uicsXG4gICAgICAgICAgICBkZCA6ICfgtq/gt5LgtrEgJWQnLFxuICAgICAgICAgICAgTSA6ICfgtrjgt4/gt4PgtronLFxuICAgICAgICAgICAgTU0gOiAn4La44LeP4LeDICVkJyxcbiAgICAgICAgICAgIHkgOiAn4LeA4LeD4La7JyxcbiAgICAgICAgICAgIHl5IDogJ+C3gOC3g+C2uyAlZCdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9IOC3gOC3kOC2seC3ki8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDgt4Dgt5DgtrHgt5InO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlIDogL+C2tOC3meC2uyDgt4Dgtrvgt5R84La04LeD4LeKIOC3gOC2u+C3lHzgtrTgt5ku4LeAfOC2tC7gt4AuLyxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09PSAn4La0LuC3gC4nIHx8IGlucHV0ID09PSAn4La04LeD4LeKIOC3gOC2u+C3lCc7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ+C2tC7gt4AuJyA6ICfgtrTgt4Pgt4og4LeA4La74LeUJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAn4La04LeZLuC3gC4nIDogJ+C2tOC3meC2uyDgt4Dgtrvgt5QnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2k7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NpLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///101\n");

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),\n        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');\n    function plural(n) {\n        return (n > 1) && (n < 5);\n    }\n    function translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n            case 's':  // a few seconds / in a few seconds / a few seconds ago\n                return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';\n            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'sekundy' : 'seknd');\n                } else {\n                    return result + 'sekundami';\n                }\n                break;\n            case 'm':  // a minute / in a minute / a minute ago\n                return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');\n            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'minty' : 'mint');\n                } else {\n                    return result + 'mintami';\n                }\n                break;\n            case 'h':  // an hour / in an hour / an hour ago\n                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');\n            case 'hh': // 9 hours / in 9 hours / 9 hours ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'hodiny' : 'hodn');\n                } else {\n                    return result + 'hodinami';\n                }\n                break;\n            case 'd':  // a day / in a day / a day ago\n                return (withoutSuffix || isFuture) ? 'de' : 'dom';\n            case 'dd': // 9 days / in 9 days / 9 days ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'dni' : 'dn');\n                } else {\n                    return result + 'dami';\n                }\n                break;\n            case 'M':  // a month / in a month / a month ago\n                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';\n            case 'MM': // 9 months / in 9 months / 9 months ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'mesiace' : 'mesiacov');\n                } else {\n                    return result + 'mesiacmi';\n                }\n                break;\n            case 'y':  // a year / in a year / a year ago\n                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';\n            case 'yy': // 9 years / in 9 years / 9 years ago\n                if (withoutSuffix || isFuture) {\n                    return result + (plural(number) ? 'roky' : 'rokov');\n                } else {\n                    return result + 'rokmi';\n                }\n                break;\n        }\n    }\n\n    var sk = moment.defineLocale('sk', {\n        months : months,\n        monthsShort : monthsShort,\n        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),\n        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),\n        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),\n        longDateFormat : {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay: '[dnes o] LT',\n            nextDay: '[zajtra o] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[v nedeu o] LT';\n                    case 1:\n                    case 2:\n                        return '[v] dddd [o] LT';\n                    case 3:\n                        return '[v stredu o] LT';\n                    case 4:\n                        return '[vo tvrtok o] LT';\n                    case 5:\n                        return '[v piatok o] LT';\n                    case 6:\n                        return '[v sobotu o] LT';\n                }\n            },\n            lastDay: '[vera o] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[minul nedeu o] LT';\n                    case 1:\n                    case 2:\n                        return '[minul] dddd [o] LT';\n                    case 3:\n                        return '[minul stredu o] LT';\n                    case 4:\n                    case 5:\n                        return '[minul] dddd [o] LT';\n                    case 6:\n                        return '[minul sobotu o] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past : 'pred %s',\n            s : translate,\n            ss : translate,\n            m : translate,\n            mm : translate,\n            h : translate,\n            hh : translate,\n            d : translate,\n            dd : translate,\n            M : translate,\n            MM : translate,\n            y : translate,\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return sk;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zay5qcz8zOTQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzID0gJ2phbnXDoXJfZmVicnXDoXJfbWFyZWNfYXByw61sX23DoWpfasO6bl9qw7psX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0w7NiZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0ID0gJ2phbl9mZWJfbWFyX2Fwcl9tw6FqX2rDum5fasO6bF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIHBsdXJhbChuKSB7XG4gICAgICAgIHJldHVybiAobiA+IDEpICYmIChuIDwgNSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3MnOiAgLy8gYSBmZXcgc2Vjb25kcyAvIGluIGEgZmV3IHNlY29uZHMgLyBhIGZldyBzZWNvbmRzIGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAncMOhciBzZWvDum5kJyA6ICdww6FyIHNla3VuZGFtaSc7XG4gICAgICAgICAgICBjYXNlICdzcyc6IC8vIDkgc2Vjb25kcyAvIGluIDkgc2Vjb25kcyAvIDkgc2Vjb25kcyBhZ29cbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ3Nla3VuZHknIDogJ3Nla8O6bmQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ3Nla3VuZGFtaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbSc6ICAvLyBhIG1pbnV0ZSAvIGluIGEgbWludXRlIC8gYSBtaW51dGUgYWdvXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnbWluw7p0YScgOiAoaXNGdXR1cmUgPyAnbWluw7p0dScgOiAnbWluw7p0b3UnKTtcbiAgICAgICAgICAgIGNhc2UgJ21tJzogLy8gOSBtaW51dGVzIC8gaW4gOSBtaW51dGVzIC8gOSBtaW51dGVzIGFnb1xuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbWluw7p0eScgOiAnbWluw7p0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtaW7DunRhbWknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2gnOiAgLy8gYW4gaG91ciAvIGluIGFuIGhvdXIgLyBhbiBob3VyIGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2hvZGluYScgOiAoaXNGdXR1cmUgPyAnaG9kaW51JyA6ICdob2Rpbm91Jyk7XG4gICAgICAgICAgICBjYXNlICdoaCc6IC8vIDkgaG91cnMgLyBpbiA5IGhvdXJzIC8gOSBob3VycyBhZ29cbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ2hvZGlueScgOiAnaG9kw61uJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdob2RpbmFtaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZCc6ICAvLyBhIGRheSAvIGluIGEgZGF5IC8gYSBkYXkgYWdvXG4gICAgICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdkZcWIJyA6ICdkxYhvbSc7XG4gICAgICAgICAgICBjYXNlICdkZCc6IC8vIDkgZGF5cyAvIGluIDkgZGF5cyAvIDkgZGF5cyBhZ29cbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ2RuaScgOiAnZG7DrScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZMWIYW1pJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNJzogIC8vIGEgbW9udGggLyBpbiBhIG1vbnRoIC8gYSBtb250aCBhZ29cbiAgICAgICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ21lc2lhYycgOiAnbWVzaWFjb20nO1xuICAgICAgICAgICAgY2FzZSAnTU0nOiAvLyA5IG1vbnRocyAvIGluIDkgbW9udGhzIC8gOSBtb250aHMgYWdvXG4gICAgICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtZXNpYWNlJyA6ICdtZXNpYWNvdicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbWVzaWFjbWknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOiAgLy8gYSB5ZWFyIC8gaW4gYSB5ZWFyIC8gYSB5ZWFyIGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAncm9rJyA6ICdyb2tvbSc7XG4gICAgICAgICAgICBjYXNlICd5eSc6IC8vIDkgeWVhcnMgLyBpbiA5IHllYXJzIC8gOSB5ZWFycyBhZ29cbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ3Jva3knIDogJ3Jva292Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdyb2ttaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNrID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc2snLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcbiAgICAgICAgd2Vla2RheXMgOiAnbmVkZcS+YV9wb25kZWxva191dG9yb2tfc3RyZWRhX8WhdHZydG9rX3BpYXRva19zb2JvdGEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVfcG9fdXRfc3RfxaF0X3BpX3NvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICduZV9wb191dF9zdF/FoXRfcGlfc28nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQ6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW2RuZXMgb10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1t6YWp0cmEgb10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBuZWRlxL51IG9dIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Ygc3RyZWR1IG9dIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdm8gxaF0dnJ0b2sgb10gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2IHBpYXRvayBvXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Ygc29ib3R1IG9dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheTogJ1t2xI1lcmEgb10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDuiBuZWRlxL51IG9dIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw7ogc3RyZWR1IG9dIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw7ogc29ib3R1IG9dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdwcmVkICVzJyxcbiAgICAgICAgICAgIHMgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBzcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNrO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zay5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///102\n");

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n            case 's':\n                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';\n            case 'ss':\n                if (number === 1) {\n                    result += withoutSuffix ? 'sekundo' : 'sekundi';\n                } else if (number === 2) {\n                    result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';\n                } else if (number < 5) {\n                    result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';\n                } else {\n                    result += withoutSuffix || isFuture ? 'sekund' : 'sekund';\n                }\n                return result;\n            case 'm':\n                return withoutSuffix ? 'ena minuta' : 'eno minuto';\n            case 'mm':\n                if (number === 1) {\n                    result += withoutSuffix ? 'minuta' : 'minuto';\n                } else if (number === 2) {\n                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';\n                } else if (number < 5) {\n                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';\n                } else {\n                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';\n                }\n                return result;\n            case 'h':\n                return withoutSuffix ? 'ena ura' : 'eno uro';\n            case 'hh':\n                if (number === 1) {\n                    result += withoutSuffix ? 'ura' : 'uro';\n                } else if (number === 2) {\n                    result += withoutSuffix || isFuture ? 'uri' : 'urama';\n                } else if (number < 5) {\n                    result += withoutSuffix || isFuture ? 'ure' : 'urami';\n                } else {\n                    result += withoutSuffix || isFuture ? 'ur' : 'urami';\n                }\n                return result;\n            case 'd':\n                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';\n            case 'dd':\n                if (number === 1) {\n                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';\n                } else if (number === 2) {\n                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';\n                } else {\n                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';\n                }\n                return result;\n            case 'M':\n                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';\n            case 'MM':\n                if (number === 1) {\n                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';\n                } else if (number === 2) {\n                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';\n                } else if (number < 5) {\n                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';\n                } else {\n                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';\n                }\n                return result;\n            case 'y':\n                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';\n            case 'yy':\n                if (number === 1) {\n                    result += withoutSuffix || isFuture ? 'leto' : 'letom';\n                } else if (number === 2) {\n                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';\n                } else if (number < 5) {\n                    result += withoutSuffix || isFuture ? 'leta' : 'leti';\n                } else {\n                    result += withoutSuffix || isFuture ? 'let' : 'leti';\n                }\n                return result;\n        }\n    }\n\n    var sl = moment.defineLocale('sl', {\n        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),\n        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),\n        monthsParseExact: true,\n        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),\n        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),\n        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[danes ob] LT',\n            nextDay  : '[jutri ob] LT',\n\n            nextWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[v] [nedeljo] [ob] LT';\n                    case 3:\n                        return '[v] [sredo] [ob] LT';\n                    case 6:\n                        return '[v] [soboto] [ob] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[v] dddd [ob] LT';\n                }\n            },\n            lastDay  : '[veraj ob] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[prejnjo] [nedeljo] [ob] LT';\n                    case 3:\n                        return '[prejnjo] [sredo] [ob] LT';\n                    case 6:\n                        return '[prejnjo] [soboto] [ob] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[prejnji] dddd [ob] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'ez %s',\n            past   : 'pred %s',\n            s      : processRelativeTime,\n            ss     : processRelativeTime,\n            m      : processRelativeTime,\n            mm     : processRelativeTime,\n            h      : processRelativeTime,\n            hh     : processRelativeTime,\n            d      : processRelativeTime,\n            dd     : processRelativeTime,\n            M      : processRelativeTime,\n            MM     : processRelativeTime,\n            y      : processRelativeTime,\n            yy     : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return sl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zbC5qcz9kYWNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEwMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ25la2FqIHNla3VuZCcgOiAnbmVrYWogc2VrdW5kYW1pJztcbiAgICAgICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4ID8gJ3Nla3VuZG8nIDogJ3Nla3VuZGknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3Nla3VuZGknIDogJ3Nla3VuZGFoJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnc2VrdW5kZScgOiAnc2VrdW5kYWgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3Nla3VuZCcgOiAnc2VrdW5kJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2VuYSBtaW51dGEnIDogJ2VubyBtaW51dG8nO1xuICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggPyAnbWludXRhJyA6ICdtaW51dG8nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21pbnV0aScgOiAnbWludXRhbWEnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtaW51dGUnIDogJ21pbnV0YW1pJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtaW51dCcgOiAnbWludXRhbWknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnZW5hIHVyYScgOiAnZW5vIHVybyc7XG4gICAgICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCA/ICd1cmEnIDogJ3Vybyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAndXJpJyA6ICd1cmFtYSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPCA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3VyZScgOiAndXJhbWknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3VyJyA6ICd1cmFtaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbiBkYW4nIDogJ2VuaW0gZG5lbSc7XG4gICAgICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdkYW4nIDogJ2RuZW0nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2RuaScgOiAnZG5ldm9tYSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnZG5pJyA6ICdkbmV2aSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbiBtZXNlYycgOiAnZW5pbSBtZXNlY2VtJztcbiAgICAgICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21lc2VjJyA6ICdtZXNlY2VtJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlY2EnIDogJ21lc2VjZW1hJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWVzZWNlJyA6ICdtZXNlY2knO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21lc2VjZXYnIDogJ21lc2VjaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbm8gbGV0bycgOiAnZW5pbSBsZXRvbSc7XG4gICAgICAgICAgICBjYXNlICd5eSc6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdsZXRvJyA6ICdsZXRvbSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbGV0aScgOiAnbGV0b21hJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbGV0YScgOiAnbGV0aSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbGV0JyA6ICdsZXRpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NsJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFyZWNfYXByaWxfbWFqX2p1bmlqX2p1bGlqX2F2Z3VzdF9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuLl9mZWIuX21hci5fYXByLl9tYWouX2p1bi5fanVsLl9hdmcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ25lZGVsamFfcG9uZWRlbGpla190b3Jla19zcmVkYV/EjWV0cnRla19wZXRla19zb2JvdGEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVkLl9wb24uX3Rvci5fc3JlLl/EjWV0Ll9wZXQuX3NvYi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ25lX3BvX3RvX3NyX8SNZV9wZV9zbycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSAgOiAnW2RhbmVzIG9iXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5ICA6ICdbanV0cmkgb2JdIExUJyxcblxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZdIFtuZWRlbGpvXSBbb2JdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gW3NyZWRvXSBbb2JdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gW3NvYm90b10gW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZdIGRkZGQgW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgIDogJ1t2xI1lcmFqIG9iXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJlasWhbmpvXSBbbmVkZWxqb10gW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ByZWrFoW5qb10gW3NyZWRvXSBbb2JdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJlasWhbmpvXSBbc29ib3RvXSBbb2JdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJlasWhbmppXSBkZGRkIFtvYl0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnxI1leiAlcycsXG4gICAgICAgICAgICBwYXN0ICAgOiAncHJlZCAlcycsXG4gICAgICAgICAgICBzICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgc3MgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIG0gICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtbSAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgaCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBkICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZGQgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE0gICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNTSAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeSAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHl5ICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzbDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2wuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///103\n");

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var sq = moment.defineLocale('sq', {\n        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),\n        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),\n        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),\n        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),\n        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),\n        weekdaysParseExact : true,\n        meridiemParse: /PD|MD/,\n        isPM: function (input) {\n            return input.charAt(0) === 'M';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            return hours < 12 ? 'PD' : 'MD';\n        },\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Sot n] LT',\n            nextDay : '[Nesr n] LT',\n            nextWeek : 'dddd [n] LT',\n            lastDay : '[Dje n] LT',\n            lastWeek : 'dddd [e kaluar n] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'n %s',\n            past : '%s m par',\n            s : 'disa sekonda',\n            ss : '%d sekonda',\n            m : 'nj minut',\n            mm : '%d minuta',\n            h : 'nj or',\n            hh : '%d or',\n            d : 'nj dit',\n            dd : '%d dit',\n            M : 'nj muaj',\n            MM : '%d muaj',\n            y : 'nj vit',\n            yy : '%d vite'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return sq;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcS5qcz81NzRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzcSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NxJywge1xuICAgICAgICBtb250aHMgOiAnSmFuYXJfU2hrdXJ0X01hcnNfUHJpbGxfTWFqX1FlcnNob3JfS29ycmlrX0d1c2h0X1NodGF0b3JfVGV0b3JfTsOrbnRvcl9EaGpldG9yJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fU2hrX01hcl9QcmlfTWFqX1Flcl9Lb3JfR3VzX1NodF9UZXRfTsOrbl9EaGonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0UgRGllbF9FIEjDq27Dq19FIE1hcnTDq19FIE3Dq3JrdXLDq19FIEVuanRlX0UgUHJlbXRlX0UgU2h0dW7Dqycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdEaWVfSMOrbl9NYXJfTcOrcl9FbmpfUHJlX1NodCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnRF9IX01hX03Dq19FX1BfU2gnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC9QRHxNRC8sXG4gICAgICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgwKSA9PT0gJ00nO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXJzIDwgMTIgPyAnUEQnIDogJ01EJztcbiAgICAgICAgfSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW1NvdCBuw6tdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW05lc8OrciBuw6tdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW27Dq10gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbRGplIG7Dq10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbZSBrYWx1YXIgbsOrXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnbsOrICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgbcOrIHBhcsOrJyxcbiAgICAgICAgICAgIHMgOiAnZGlzYSBzZWtvbmRhJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla29uZGEnLFxuICAgICAgICAgICAgbSA6ICduasOrIG1pbnV0w6snLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRhJyxcbiAgICAgICAgICAgIGggOiAnbmrDqyBvcsOrJyxcbiAgICAgICAgICAgIGhoIDogJyVkIG9yw6snLFxuICAgICAgICAgICAgZCA6ICduasOrIGRpdMOrJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRpdMOrJyxcbiAgICAgICAgICAgIE0gOiAnbmrDqyBtdWFqJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG11YWonLFxuICAgICAgICAgICAgeSA6ICduasOrIHZpdCcsXG4gICAgICAgICAgICB5eSA6ICclZCB2aXRlJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNxO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///104\n");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var translator = {\n        words: { //Different grammatical cases\n            ss: ['sekunda', 'sekunde', 'sekundi'],\n            m: ['jedan minut', 'jedne minute'],\n            mm: ['minut', 'minute', 'minuta'],\n            h: ['jedan sat', 'jednog sata'],\n            hh: ['sat', 'sata', 'sati'],\n            dd: ['dan', 'dana', 'dana'],\n            MM: ['mesec', 'meseca', 'meseci'],\n            yy: ['godina', 'godine', 'godina']\n        },\n        correctGrammaticalCase: function (number, wordKey) {\n            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n        },\n        translate: function (number, withoutSuffix, key) {\n            var wordKey = translator.words[key];\n            if (key.length === 1) {\n                return withoutSuffix ? wordKey[0] : wordKey[1];\n            } else {\n                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);\n            }\n        }\n    };\n\n    var sr = moment.defineLocale('sr', {\n        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),\n        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),\n        monthsParseExact: true,\n        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),\n        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),\n        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat: {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L: 'DD.MM.YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm',\n            LLLL: 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar: {\n            sameDay: '[danas u] LT',\n            nextDay: '[sutra u] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[u] [nedelju] [u] LT';\n                    case 3:\n                        return '[u] [sredu] [u] LT';\n                    case 6:\n                        return '[u] [subotu] [u] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[jue u] LT',\n            lastWeek : function () {\n                var lastWeekDays = [\n                    '[prole] [nedelje] [u] LT',\n                    '[prolog] [ponedeljka] [u] LT',\n                    '[prolog] [utorka] [u] LT',\n                    '[prole] [srede] [u] LT',\n                    '[prolog] [etvrtka] [u] LT',\n                    '[prolog] [petka] [u] LT',\n                    '[prole] [subote] [u] LT'\n                ];\n                return lastWeekDays[this.day()];\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'pre %s',\n            s      : 'nekoliko sekundi',\n            ss     : translator.translate,\n            m      : translator.translate,\n            mm     : translator.translate,\n            h      : translator.translate,\n            hh     : translator.translate,\n            d      : 'dan',\n            dd     : translator.translate,\n            M      : 'mesec',\n            MM     : translator.translate,\n            y      : 'godinu',\n            yy     : translator.translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return sr;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci5qcz83Zjg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB0cmFuc2xhdG9yID0ge1xuICAgICAgICB3b3JkczogeyAvL0RpZmZlcmVudCBncmFtbWF0aWNhbCBjYXNlc1xuICAgICAgICAgICAgc3M6IFsnc2VrdW5kYScsICdzZWt1bmRlJywgJ3Nla3VuZGknXSxcbiAgICAgICAgICAgIG06IFsnamVkYW4gbWludXQnLCAnamVkbmUgbWludXRlJ10sXG4gICAgICAgICAgICBtbTogWydtaW51dCcsICdtaW51dGUnLCAnbWludXRhJ10sXG4gICAgICAgICAgICBoOiBbJ2plZGFuIHNhdCcsICdqZWRub2cgc2F0YSddLFxuICAgICAgICAgICAgaGg6IFsnc2F0JywgJ3NhdGEnLCAnc2F0aSddLFxuICAgICAgICAgICAgZGQ6IFsnZGFuJywgJ2RhbmEnLCAnZGFuYSddLFxuICAgICAgICAgICAgTU06IFsnbWVzZWMnLCAnbWVzZWNhJywgJ21lc2VjaSddLFxuICAgICAgICAgICAgeXk6IFsnZ29kaW5hJywgJ2dvZGluZScsICdnb2RpbmEnXVxuICAgICAgICB9LFxuICAgICAgICBjb3JyZWN0R3JhbW1hdGljYWxDYXNlOiBmdW5jdGlvbiAobnVtYmVyLCB3b3JkS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyID09PSAxID8gd29yZEtleVswXSA6IChudW1iZXIgPj0gMiAmJiBudW1iZXIgPD0gNCA/IHdvcmRLZXlbMV0gOiB3b3JkS2V5WzJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB3b3JkS2V5ID0gdHJhbnNsYXRvci53b3Jkc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IHdvcmRLZXlbMF0gOiB3b3JkS2V5WzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgdHJhbnNsYXRvci5jb3JyZWN0R3JhbW1hdGljYWxDYXNlKG51bWJlciwgd29yZEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc3InLCB7XG4gICAgICAgIG1vbnRoczogJ2phbnVhcl9mZWJydWFyX21hcnRfYXByaWxfbWFqX2p1bl9qdWxfYXZndXN0X3NlcHRlbWJhcl9va3RvYmFyX25vdmVtYmFyX2RlY2VtYmFyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydDogJ2phbi5fZmViLl9tYXIuX2Fwci5fbWFqX2p1bl9qdWxfYXZnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxuICAgICAgICB3ZWVrZGF5czogJ25lZGVsamFfcG9uZWRlbGpha191dG9yYWtfc3JlZGFfxI1ldHZydGFrX3BldGFrX3N1Ym90YScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogJ25lZC5fcG9uLl91dG8uX3NyZS5fxI1ldC5fcGV0Ll9zdWIuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbjogJ25lX3BvX3V0X3NyX8SNZV9wZV9zdScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEw6ICdELiBNTU1NIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW2RhbmFzIHVdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbc3V0cmEgdV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGVsanVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmVkdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3N1Ym90dV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWUgdV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RXZWVrRGF5cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbbmVkZWxqZV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3BvbmVkZWxqa2FdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFt1dG9ya2FdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW3NyZWRlXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbxI1ldHZydGthXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcGV0a2FdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RXZWVrRGF5c1t0aGlzLmRheSgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxuICAgICAgICAgICAgcGFzdCAgIDogJ3ByZSAlcycsXG4gICAgICAgICAgICBzICAgICAgOiAnbmVrb2xpa28gc2VrdW5kaScsXG4gICAgICAgICAgICBzcyAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBoICAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGhoICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgZCAgICAgIDogJ2RhbicsXG4gICAgICAgICAgICBkZCAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gICAgICA6ICdtZXNlYycsXG4gICAgICAgICAgICBNTSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxuICAgICAgICAgICAgeXkgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzcjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///105\n");

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var translator = {\n        words: { //Different grammatical cases\n            ss: ['', '', ''],\n            m: [' ', ' '],\n            mm: ['', '', ''],\n            h: [' ', ' '],\n            hh: ['', '', ''],\n            dd: ['', '', ''],\n            MM: ['', '', ''],\n            yy: ['', '', '']\n        },\n        correctGrammaticalCase: function (number, wordKey) {\n            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n        },\n        translate: function (number, withoutSuffix, key) {\n            var wordKey = translator.words[key];\n            if (key.length === 1) {\n                return withoutSuffix ? wordKey[0] : wordKey[1];\n            } else {\n                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);\n            }\n        }\n    };\n\n    var srCyrl = moment.defineLocale('sr-cyrl', {\n        months: '___________'.split('_'),\n        monthsShort: '._._._.____._._._._.'.split('_'),\n        monthsParseExact: true,\n        weekdays: '______'.split('_'),\n        weekdaysShort: '._._._._._._.'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat: {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L: 'DD.MM.YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm',\n            LLLL: 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar: {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[] [] [] LT';\n                    case 3:\n                        return '[] [] [] LT';\n                    case 6:\n                        return '[] [] [] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                    case 5:\n                        return '[] dddd [] LT';\n                }\n            },\n            lastDay  : '[ ] LT',\n            lastWeek : function () {\n                var lastWeekDays = [\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT'\n                ];\n                return lastWeekDays[this.day()];\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past   : ' %s',\n            s      : ' ',\n            ss     : translator.translate,\n            m      : translator.translate,\n            mm     : translator.translate,\n            h      : translator.translate,\n            hh     : translator.translate,\n            d      : '',\n            dd     : translator.translate,\n            M      : '',\n            MM     : translator.translate,\n            y      : '',\n            yy     : translator.translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return srCyrl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzPzczNWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEwNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHRyYW5zbGF0b3IgPSB7XG4gICAgICAgIHdvcmRzOiB7IC8vRGlmZmVyZW50IGdyYW1tYXRpY2FsIGNhc2VzXG4gICAgICAgICAgICBzczogWyfRgdC10LrRg9C90LTQsCcsICfRgdC10LrRg9C90LTQtScsICfRgdC10LrRg9C90LTQuCddLFxuICAgICAgICAgICAgbTogWyfRmNC10LTQsNC9INC80LjQvdGD0YInLCAn0ZjQtdC00L3QtSDQvNC40L3Rg9GC0LUnXSxcbiAgICAgICAgICAgIG1tOiBbJ9C80LjQvdGD0YInLCAn0LzQuNC90YPRgtC1JywgJ9C80LjQvdGD0YLQsCddLFxuICAgICAgICAgICAgaDogWyfRmNC10LTQsNC9INGB0LDRgicsICfRmNC10LTQvdC+0LMg0YHQsNGC0LAnXSxcbiAgICAgICAgICAgIGhoOiBbJ9GB0LDRgicsICfRgdCw0YLQsCcsICfRgdCw0YLQuCddLFxuICAgICAgICAgICAgZGQ6IFsn0LTQsNC9JywgJ9C00LDQvdCwJywgJ9C00LDQvdCwJ10sXG4gICAgICAgICAgICBNTTogWyfQvNC10YHQtdGGJywgJ9C80LXRgdC10YbQsCcsICfQvNC10YHQtdGG0LgnXSxcbiAgICAgICAgICAgIHl5OiBbJ9Cz0L7QtNC40L3QsCcsICfQs9C+0LTQuNC90LUnLCAn0LPQvtC00LjQvdCwJ11cbiAgICAgICAgfSxcbiAgICAgICAgY29ycmVjdEdyYW1tYXRpY2FsQ2FzZTogZnVuY3Rpb24gKG51bWJlciwgd29yZEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IHdvcmRLZXlbMF0gOiAobnVtYmVyID49IDIgJiYgbnVtYmVyIDw9IDQgPyB3b3JkS2V5WzFdIDogd29yZEtleVsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgICAgICB2YXIgd29yZEtleSA9IHRyYW5zbGF0b3Iud29yZHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyB3b3JkS2V5WzBdIDogd29yZEtleVsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHRyYW5zbGF0b3IuY29ycmVjdEdyYW1tYXRpY2FsQ2FzZShudW1iZXIsIHdvcmRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzckN5cmwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzci1jeXJsJywge1xuICAgICAgICBtb250aHM6ICfRmNCw0L3Rg9Cw0YBf0YTQtdCx0YDRg9Cw0YBf0LzQsNGA0YJf0LDQv9GA0LjQu1/QvNCw0Zhf0ZjRg9C9X9GY0YPQu1/QsNCy0LPRg9GB0YJf0YHQtdC/0YLQtdC80LHQsNGAX9C+0LrRgtC+0LHQsNGAX9C90L7QstC10LzQsdCw0YBf0LTQtdGG0LXQvNCx0LDRgCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfRmNCw0L0uX9GE0LXQsS5f0LzQsNGALl/QsNC/0YAuX9C80LDRmF/RmNGD0L1f0ZjRg9C7X9Cw0LLQsy5f0YHQtdC/Ll/QvtC60YIuX9C90L7Qsi5f0LTQtdGGLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXM6ICfQvdC10LTQtdGZ0LBf0L/QvtC90LXQtNC10ZnQsNC6X9GD0YLQvtGA0LDQul/RgdGA0LXQtNCwX9GH0LXRgtCy0YDRgtCw0Lpf0L/QtdGC0LDQul/RgdGD0LHQvtGC0LAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICfQvdC10LQuX9C/0L7QvS5f0YPRgtC+Ll/RgdGA0LUuX9GH0LXRgi5f0L/QtdGCLl/RgdGD0LEuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbjogJ9C90LVf0L/Qvl/Rg9GCX9GB0YBf0YfQtV/Qv9C1X9GB0YMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEw6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhcjoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vQtNCw0L3QsNGBINGDXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW9GB0YPRgtGA0LAg0YNdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9GDXSBb0L3QtdC00LXRmdGDXSBb0YNdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvRgdGA0LXQtNGDXSBb0YNdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvRgdGD0LHQvtGC0YNdIFvRg10gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vRg10gZGRkZCBb0YNdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheSAgOiAnW9GY0YPRh9C1INGDXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFdlZWtEYXlzID0gW1xuICAgICAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQtV0gW9C90LXQtNC10ZnQtV0gW9GDXSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C+0LNdIFvQv9C+0L3QtdC00LXRmdC60LBdIFvRg10gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQvtCzXSBb0YPRgtC+0YDQutCwXSBb0YNdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70LVdIFvRgdGA0LXQtNC1XSBb0YNdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70L7Qs10gW9GH0LXRgtCy0YDRgtC60LBdIFvRg10gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQvtCzXSBb0L/QtdGC0LrQsF0gW9GDXSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C1XSBb0YHRg9Cx0L7RgtC1XSBb0YNdIExUJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RXZWVrRGF5c1t0aGlzLmRheSgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn0LfQsCAlcycsXG4gICAgICAgICAgICBwYXN0ICAgOiAn0L/RgNC1ICVzJyxcbiAgICAgICAgICAgIHMgICAgICA6ICfQvdC10LrQvtC70LjQutC+INGB0LXQutGD0L3QtNC4JyxcbiAgICAgICAgICAgIHNzICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgbSAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBkICAgICAgOiAn0LTQsNC9JyxcbiAgICAgICAgICAgIGRkICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgTSAgICAgIDogJ9C80LXRgdC10YYnLFxuICAgICAgICAgICAgTU0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICB5ICAgICAgOiAn0LPQvtC00LjQvdGDJyxcbiAgICAgICAgICAgIHl5ICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3JDeXJsO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///106\n");

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ss = moment.defineLocale('ss', {\n        months : \"Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni\".split('_'),\n        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),\n        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),\n        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),\n        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Namuhla nga] LT',\n            nextDay : '[Kusasa nga] LT',\n            nextWeek : 'dddd [nga] LT',\n            lastDay : '[Itolo nga] LT',\n            lastWeek : 'dddd [leliphelile] [nga] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'nga %s',\n            past : 'wenteka nga %s',\n            s : 'emizuzwana lomcane',\n            ss : '%d mzuzwana',\n            m : 'umzuzu',\n            mm : '%d emizuzu',\n            h : 'lihora',\n            hh : '%d emahora',\n            d : 'lilanga',\n            dd : '%d emalanga',\n            M : 'inyanga',\n            MM : '%d tinyanga',\n            y : 'umnyaka',\n            yy : '%d iminyaka'\n        },\n        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'ekuseni';\n            } else if (hours < 15) {\n                return 'emini';\n            } else if (hours < 19) {\n                return 'entsambama';\n            } else {\n                return 'ebusuku';\n            }\n        },\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'ekuseni') {\n                return hour;\n            } else if (meridiem === 'emini') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {\n                if (hour === 0) {\n                    return 0;\n                }\n                return hour + 12;\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return ss;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcy5qcz9lZDBmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEwNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHNzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc3MnLCB7XG4gICAgICAgIG1vbnRocyA6IFwiQmhpbWJpZHZ3YW5lX0luZGxvdmFuYV9JbmRsb3YnbGVua2h1bHVfTWFiYXNhX0lua2h3ZWtod2V0aV9JbmhsYWJhX0tob2x3YW5lX0luZ2NpX0lueW9uaV9JbXBoYWxhX0x3ZXRpX0luZ29uZ29uaVwiLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0JoaV9JbmFfSW51X01hYl9JbmtfSW5oX0tob19JZ2NfSW55X0ltcF9Md2VfSWdvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdMaXNvbnRmb19VbXNvbWJ1bHVrb19MZXNpYmlsaV9MZXNpdHNhdGZ1X0xlc2luZV9MZXNpaGxhbnVfVW1nY2liZWxvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0xpc19VbWJfTHNiX0xlc19Mc2lfTHNoX1VtZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnTGlfVXNfTGJfTHRfTHNfTGhfVWcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbTmFtdWhsYSBuZ2FdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW0t1c2FzYSBuZ2FdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW25nYV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbSXRvbG8gbmdhXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtsZWxpcGhlbGlsZV0gW25nYV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ25nYSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3dlbnRla2EgbmdhICVzJyxcbiAgICAgICAgICAgIHMgOiAnZW1penV6d2FuYSBsb21jYW5lJyxcbiAgICAgICAgICAgIHNzIDogJyVkIG16dXp3YW5hJyxcbiAgICAgICAgICAgIG0gOiAndW16dXp1JyxcbiAgICAgICAgICAgIG1tIDogJyVkIGVtaXp1enUnLFxuICAgICAgICAgICAgaCA6ICdsaWhvcmEnLFxuICAgICAgICAgICAgaGggOiAnJWQgZW1haG9yYScsXG4gICAgICAgICAgICBkIDogJ2xpbGFuZ2EnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZW1hbGFuZ2EnLFxuICAgICAgICAgICAgTSA6ICdpbnlhbmdhJyxcbiAgICAgICAgICAgIE1NIDogJyVkIHRpbnlhbmdhJyxcbiAgICAgICAgICAgIHkgOiAndW1ueWFrYScsXG4gICAgICAgICAgICB5eSA6ICclZCBpbWlueWFrYSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL2VrdXNlbml8ZW1pbml8ZW50c2FtYmFtYXxlYnVzdWt1LyxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdla3VzZW5pJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZW1pbmknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdlbnRzYW1iYW1hJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdlYnVzdWt1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ2VrdXNlbmknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnZW1pbmknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ2VudHNhbWJhbWEnIHx8IG1lcmlkaWVtID09PSAnZWJ1c3VrdScpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LyxcbiAgICAgICAgb3JkaW5hbCA6ICclZCcsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNzO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcy5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///107\n");

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var sv = moment.defineLocale('sv', {\n        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),\n        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),\n        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [kl.] HH:mm',\n            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',\n            lll : 'D MMM YYYY HH:mm',\n            llll : 'ddd D MMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Idag] LT',\n            nextDay: '[Imorgon] LT',\n            lastDay: '[Igr] LT',\n            nextWeek: '[P] dddd LT',\n            lastWeek: '[I] dddd[s] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : 'fr %s sedan',\n            s : 'ngra sekunder',\n            ss : '%d sekunder',\n            m : 'en minut',\n            mm : '%d minuter',\n            h : 'en timme',\n            hh : '%d timmar',\n            d : 'en dag',\n            dd : '%d dagar',\n            M : 'en mnad',\n            MM : '%d mnader',\n            y : 'ett r',\n            yy : '%d r'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(e|a)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'e' :\n                (b === 1) ? 'a' :\n                (b === 2) ? 'a' :\n                (b === 3) ? 'e' : 'e';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return sv;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdi5qcz8xNjlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMDguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzdiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3N2Jywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyaV9mZWJydWFyaV9tYXJzX2FwcmlsX21hal9qdW5pX2p1bGlfYXVndXN0aV9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ3PDtm5kYWdfbcOlbmRhZ190aXNkYWdfb25zZGFnX3RvcnNkYWdfZnJlZGFnX2zDtnJkYWcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnc8O2bl9tw6VuX3Rpc19vbnNfdG9yX2ZyZV9sw7ZyJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdzw7ZfbcOlX3RpX29uX3RvX2ZyX2zDticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBba2wuXSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nLFxuICAgICAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgbGxsbCA6ICdkZGQgRCBNTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0lkYWddIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbSW1vcmdvbl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tJZ8Olcl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdbUMOlXSBkZGRkIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW0ldIGRkZGRbc10gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnb20gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdmw7ZyICVzIHNlZGFuJyxcbiAgICAgICAgICAgIHMgOiAnbsOlZ3JhIHNla3VuZGVyJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNla3VuZGVyJyxcbiAgICAgICAgICAgIG0gOiAnZW4gbWludXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlcicsXG4gICAgICAgICAgICBoIDogJ2VuIHRpbW1lJyxcbiAgICAgICAgICAgIGhoIDogJyVkIHRpbW1hcicsXG4gICAgICAgICAgICBkIDogJ2VuIGRhZycsXG4gICAgICAgICAgICBkZCA6ICclZCBkYWdhcicsXG4gICAgICAgICAgICBNIDogJ2VuIG3DpW5hZCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtw6VuYWRlcicsXG4gICAgICAgICAgICB5IDogJ2V0dCDDpXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgw6VyJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oZXxhKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ2UnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnYScgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICdhJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ2UnIDogJ2UnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3Y7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3N2LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///108\n");

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var sw = moment.defineLocale('sw', {\n        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),\n        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),\n        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),\n        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),\n        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[leo saa] LT',\n            nextDay : '[kesho saa] LT',\n            nextWeek : '[wiki ijayo] dddd [saat] LT',\n            lastDay : '[jana] LT',\n            lastWeek : '[wiki iliyopita] dddd [saat] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s baadaye',\n            past : 'tokea %s',\n            s : 'hivi punde',\n            ss : 'sekunde %d',\n            m : 'dakika moja',\n            mm : 'dakika %d',\n            h : 'saa limoja',\n            hh : 'masaa %d',\n            d : 'siku moja',\n            dd : 'masiku %d',\n            M : 'mwezi mmoja',\n            MM : 'miezi %d',\n            y : 'mwaka mmoja',\n            yy : 'miaka %d'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return sw;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdy5qcz8wZDI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTA5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3cgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzdycsIHtcbiAgICAgICAgbW9udGhzIDogJ0phbnVhcmlfRmVicnVhcmlfTWFjaGlfQXByaWxpX01laV9KdW5pX0p1bGFpX0Fnb3N0aV9TZXB0ZW1iYV9Pa3RvYmFfTm92ZW1iYV9EZXNlbWJhJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hY19BcHJfTWVpX0p1bl9KdWxfQWdvX1NlcF9Pa3RfTm92X0Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnSnVtYXBpbGlfSnVtYXRhdHVfSnVtYW5uZV9KdW1hdGFub19BbGhhbWlzaV9JanVtYWFfSnVtYW1vc2knLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnSnBsX0p0YXRfSm5uZV9KdGFuX0FsaF9Jam1fSm1vcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnSjJfSjNfSjRfSjVfQWxfSWpfSjEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tsZW8gc2FhXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1trZXNobyBzYWFdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1t3aWtpIGlqYXlvXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tqYW5hXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbd2lraSBpbGl5b3BpdGFdIGRkZGQgW3NhYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyBiYWFkYXllJyxcbiAgICAgICAgICAgIHBhc3QgOiAndG9rZWEgJXMnLFxuICAgICAgICAgICAgcyA6ICdoaXZpIHB1bmRlJyxcbiAgICAgICAgICAgIHNzIDogJ3Nla3VuZGUgJWQnLFxuICAgICAgICAgICAgbSA6ICdkYWtpa2EgbW9qYScsXG4gICAgICAgICAgICBtbSA6ICdkYWtpa2EgJWQnLFxuICAgICAgICAgICAgaCA6ICdzYWEgbGltb2phJyxcbiAgICAgICAgICAgIGhoIDogJ21hc2FhICVkJyxcbiAgICAgICAgICAgIGQgOiAnc2lrdSBtb2phJyxcbiAgICAgICAgICAgIGRkIDogJ21hc2lrdSAlZCcsXG4gICAgICAgICAgICBNIDogJ213ZXppIG1tb2phJyxcbiAgICAgICAgICAgIE1NIDogJ21pZXppICVkJyxcbiAgICAgICAgICAgIHkgOiAnbXdha2EgbW1vamEnLFxuICAgICAgICAgICAgeXkgOiAnbWlha2EgJWQnXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN3O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdy5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///109\n");

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var ta = moment.defineLocale('ta', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, HH:mm',\n            LLLL : 'dddd, D MMMM YYYY, HH:mm'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[ ] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '  ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : '  ',\n            hh : '%d  ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : function (number) {\n            return number + '';\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return symbolMap[match];\n            });\n        },\n        // refer http://ta.wikipedia.org/s/1er1\n        meridiemParse: /|||||/,\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 2) {\n                return ' ';\n            } else if (hour < 6) {\n                return ' ';  // \n            } else if (hour < 10) {\n                return ' '; // \n            } else if (hour < 14) {\n                return ' '; // \n            } else if (hour < 18) {\n                return ' '; // \n            } else if (hour < 22) {\n                return ' '; // \n            } else {\n                return ' ';\n            }\n        },\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 2 ? hour : hour + 12;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else {\n                return hour + 12;\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ta;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90YS5qcz9mYmJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQyxhQUFhO0FBQ2IsK0JBQStCO0FBQy9CLGFBQWE7QUFDYixrQ0FBa0M7QUFDbEMsYUFBYTtBQUNiLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2IsK0JBQStCO0FBQy9CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjExMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4K+nJyxcbiAgICAgICAgJzInOiAn4K+oJyxcbiAgICAgICAgJzMnOiAn4K+pJyxcbiAgICAgICAgJzQnOiAn4K+qJyxcbiAgICAgICAgJzUnOiAn4K+rJyxcbiAgICAgICAgJzYnOiAn4K+sJyxcbiAgICAgICAgJzcnOiAn4K+tJyxcbiAgICAgICAgJzgnOiAn4K+uJyxcbiAgICAgICAgJzknOiAn4K+vJyxcbiAgICAgICAgJzAnOiAn4K+mJ1xuICAgIH0sIG51bWJlck1hcCA9IHtcbiAgICAgICAgJ+Cvpyc6ICcxJyxcbiAgICAgICAgJ+CvqCc6ICcyJyxcbiAgICAgICAgJ+CvqSc6ICczJyxcbiAgICAgICAgJ+Cvqic6ICc0JyxcbiAgICAgICAgJ+Cvqyc6ICc1JyxcbiAgICAgICAgJ+CvrCc6ICc2JyxcbiAgICAgICAgJ+CvrSc6ICc3JyxcbiAgICAgICAgJ+Cvric6ICc4JyxcbiAgICAgICAgJ+Cvryc6ICc5JyxcbiAgICAgICAgJ+Cvpic6ICcwJ1xuICAgIH07XG5cbiAgICB2YXIgdGEgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0YScsIHtcbiAgICAgICAgbW9udGhzIDogJ+CunOCuqeCuteCusOCuv1/grqrgrr/grqrgr43grrDgrrXgrrDgrr9f4K6u4K6+4K6w4K+N4K6a4K+NX+Cuj+CuquCvjeCusOCusuCvjV/grq7gr4df4K6c4K+C4K6p4K+NX+CunOCvguCusuCviF/grobgrpXgrrjgr43grp/gr41f4K6a4K+G4K6q4K+N4K6f4K+G4K6u4K+N4K6q4K6w4K+NX+CuheCuleCvjeCun+Cvh+CuvuCuquCusOCvjV/grqjgrrXgrq7gr43grqrgrrDgr41f4K6f4K6/4K6a4K6u4K+N4K6q4K6w4K+NJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfgrpzgrqngrrXgrrDgrr9f4K6q4K6/4K6q4K+N4K6w4K614K6w4K6/X+CuruCuvuCusOCvjeCumuCvjV/gro/grqrgr43grrDgrrLgr41f4K6u4K+HX+CunOCvguCuqeCvjV/grpzgr4LgrrLgr4hf4K6G4K6V4K644K+N4K6f4K+NX+CumuCvhuCuquCvjeCun+CvhuCuruCvjeCuquCusOCvjV/groXgrpXgr43grp/gr4fgrr7grqrgrrDgr41f4K6o4K614K6u4K+N4K6q4K6w4K+NX+Cun+Cuv+CumuCuruCvjeCuquCusOCvjScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn4K6e4K6+4K6v4K6/4K6x4K+N4K6x4K+B4K6V4K+N4K6V4K6/4K604K6u4K+IX+CupOCuv+CumeCvjeCuleCun+CvjeCuleCuv+CutOCuruCviF/grprgr4bgrrXgr43grrXgrr7grq/gr43grpXgrr/grrTgrq7gr4hf4K6q4K+B4K6k4K6p4K+N4K6V4K6/4K604K6u4K+IX+CuteCuv+Cur+CuvuCutOCuleCvjeCuleCuv+CutOCuruCviF/grrXgr4bgrrPgr43grrPgrr/grpXgr43grpXgrr/grrTgrq7gr4hf4K6a4K6p4K6/4K6V4K+N4K6V4K6/4K604K6u4K+IJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+CunuCuvuCur+Cuv+CuseCvgV/grqTgrr/grpngr43grpXgrrPgr41f4K6a4K+G4K614K+N4K614K6+4K6v4K+NX+CuquCvgeCupOCuqeCvjV/grrXgrr/grq/grr7grrTgrqngr41f4K614K+G4K6z4K+N4K6z4K6/X+CumuCuqeCuvycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn4K6e4K6+X+CupOCuv1/grprgr4Zf4K6q4K+BX+CuteCuv1/grrXgr4Zf4K6aJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgrofgrqngr43grrHgr4FdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CuqOCuvuCus+CviF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4K6o4K+H4K6x4K+N4K6x4K+BXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4K6V4K6f4K6o4K+N4K6kIOCuteCuvuCusOCuruCvjV0gZGRkZCwgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIOCuh+CusuCvjScsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOCuruCvgeCuqeCvjScsXG4gICAgICAgICAgICBzIDogJ+CukuCusOCvgSDgrprgrr/grrIg4K614K6/4K6o4K6+4K6f4K6/4K6V4K6z4K+NJyxcbiAgICAgICAgICAgIHNzIDogJyVkIOCuteCuv+CuqOCuvuCun+Cuv+CuleCus+CvjScsXG4gICAgICAgICAgICBtIDogJ+CukuCusOCvgSDgrqjgrr/grq7grr/grp/grq7gr40nLFxuICAgICAgICAgICAgbW0gOiAnJWQg4K6o4K6/4K6u4K6/4K6f4K6Z4K+N4K6V4K6z4K+NJyxcbiAgICAgICAgICAgIGggOiAn4K6S4K6w4K+BIOCuruCuo+CuvyDgrqjgr4fgrrDgrq7gr40nLFxuICAgICAgICAgICAgaGggOiAnJWQg4K6u4K6j4K6/IOCuqOCvh+CusOCuruCvjScsXG4gICAgICAgICAgICBkIDogJ+CukuCusOCvgSDgrqjgrr7grrPgr40nLFxuICAgICAgICAgICAgZGQgOiAnJWQg4K6o4K6+4K6f4K+N4K6V4K6z4K+NJyxcbiAgICAgICAgICAgIE0gOiAn4K6S4K6w4K+BIOCuruCuvuCupOCuruCvjScsXG4gICAgICAgICAgICBNTSA6ICclZCDgrq7grr7grqTgrpngr43grpXgrrPgr40nLFxuICAgICAgICAgICAgeSA6ICfgrpLgrrDgr4Eg4K614K6w4K+B4K6f4K6u4K+NJyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCuhuCuo+CvjeCun+CvgeCuleCus+CvjSdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ94K614K6k4K+BLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn4K614K6k4K+BJztcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Cvp+CvqOCvqeCvquCvq+CvrOCvreCvruCvr+Cvpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmVmZXIgaHR0cDovL3RhLndpa2lwZWRpYS5vcmcvcy8xZXIxXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/grq/grr7grq7grq7gr4184K614K+I4K6V4K6x4K+IfOCuleCuvuCusuCviHzgrqjgrqPgr43grqrgrpXgrrLgr4184K6O4K6x4K+N4K6q4K6+4K6f4K+BfOCuruCuvuCusuCviC8sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcg4K6v4K6+4K6u4K6u4K+NJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyDgrrXgr4jgrpXgrrHgr4gnOyAgLy8g4K614K+I4K6V4K6x4K+IXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnIOCuleCuvuCusuCviCc7IC8vIOCuleCuvuCusuCviFxuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyDgrqjgrqPgr43grqrgrpXgrrLgr40nOyAvLyDgrqjgrqPgr43grqrgrpXgrrLgr41cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcg4K6O4K6x4K+N4K6q4K6+4K6f4K+BJzsgLy8g4K6O4K6x4K+N4K6q4K6+4K6f4K+BXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnIOCuruCuvuCusuCviCc7IC8vIOCuruCuvuCusuCviFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyDgrq/grr7grq7grq7gr40nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4K6v4K6+4K6u4K6u4K+NJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyIDwgMiA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4K614K+I4K6V4K6x4K+IJyB8fCBtZXJpZGllbSA9PT0gJ+CuleCuvuCusuCviCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgrqjgrqPgr43grqrgrpXgrrLgr40nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGEuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///110\n");

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var te = moment.defineLocale('te', {\n        months : '___________'.split('_'),\n        monthsShort : '._.__.____._._._._.'.split('_'),\n        monthsParseExact : true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm',\n            LTS : 'A h:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        dayOfMonthOrdinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return te;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZS5qcz8zNjU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjExMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHRlID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGUnLCB7XG4gICAgICAgIG1vbnRocyA6ICfgsJzgsKjgsLXgsLDgsL9f4LCr4LC/4LCs4LGN4LCw4LC14LCw4LC/X+CwruCwvuCwsOCxjeCwmuCwv1/gsI/gsKrgsY3gsLDgsL/gsLLgsY1f4LCu4LGHX+CwnOCxguCwqOCxjV/gsJzgsYLgsLLgsYbgsZZf4LCG4LCX4LC44LGN4LCf4LGBX+CwuOCxhuCwquCxjeCwn+CxhuCwguCwrOCwsOCxjV/gsIXgsJXgsY3gsJ/gsYvgsKzgsLDgsY1f4LCo4LC14LCC4LCs4LCw4LGNX+CwoeCwv+CwuOCxhuCwguCwrOCwsOCxjScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4LCc4LCoLl/gsKvgsL/gsKzgsY3gsLAuX+CwruCwvuCwsOCxjeCwmuCwv1/gsI/gsKrgsY3gsLDgsL8uX+CwruCxh1/gsJzgsYLgsKjgsY1f4LCc4LGC4LCy4LGG4LGWX+CwhuCwly5f4LC44LGG4LCq4LGNLl/gsIXgsJXgsY3gsJ/gsYsuX+CwqOCwtS5f4LCh4LC/4LC44LGGLicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgICAgIHdlZWtkYXlzIDogJ+CwhuCwpuCwv+CwteCwvuCwsOCwgl/gsLjgsYvgsK7gsLXgsL7gsLDgsIJf4LCu4LCC4LCX4LCz4LC14LC+4LCw4LCCX+CwrOCxgeCwp+CwteCwvuCwsOCwgl/gsJfgsYHgsLDgsYHgsLXgsL7gsLDgsIJf4LC24LGB4LCV4LGN4LCw4LC14LC+4LCw4LCCX+CwtuCwqOCwv+CwteCwvuCwsOCwgicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgsIbgsKbgsL9f4LC44LGL4LCuX+CwruCwguCwl+Cws1/gsKzgsYHgsKdf4LCX4LGB4LCw4LGBX+CwtuCxgeCwleCxjeCwsF/gsLbgsKjgsL8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+Cwhl/gsLjgsYtf4LCu4LCCX+CwrOCxgV/gsJfgsYFf4LC24LGBX+Cwticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0EgaDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW+CwqOCxh+CwoeCxgV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb4LCw4LGH4LCq4LGBXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vgsKjgsL/gsKjgsY3gsKhdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vgsJfgsKRdIGRkZGQsIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDgsLLgsYsnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDgsJXgsY3gsLDgsL/gsKTgsIInLFxuICAgICAgICAgICAgcyA6ICfgsJXgsYrgsKjgsY3gsKjgsL8g4LCV4LGN4LC34LCj4LC+4LCy4LGBJyxcbiAgICAgICAgICAgIHNzIDogJyVkIOCwuOCxhuCwleCwqOCxjeCwsuCxgScsXG4gICAgICAgICAgICBtIDogJ+CwkuCwlSDgsKjgsL/gsK7gsL/gsLfgsIInLFxuICAgICAgICAgICAgbW0gOiAnJWQg4LCo4LC/4LCu4LC/4LC34LC+4LCy4LGBJyxcbiAgICAgICAgICAgIGggOiAn4LCS4LCVIOCwl+CwguCwnycsXG4gICAgICAgICAgICBoaCA6ICclZCDgsJfgsILgsJ/gsLLgsYEnLFxuICAgICAgICAgICAgZCA6ICfgsJLgsJUg4LCw4LGL4LCc4LGBJyxcbiAgICAgICAgICAgIGRkIDogJyVkIOCwsOCxi+CwnOCxgeCwsuCxgScsXG4gICAgICAgICAgICBNIDogJ+CwkuCwlSDgsKjgsYbgsLInLFxuICAgICAgICAgICAgTU0gOiAnJWQg4LCo4LGG4LCy4LCy4LGBJyxcbiAgICAgICAgICAgIHkgOiAn4LCS4LCVIOCwuOCwguCwteCwpOCxjeCwuOCwsOCwgicsXG4gICAgICAgICAgICB5eSA6ICclZCDgsLjgsILgsLXgsKTgsY3gsLjgsLDgsL7gsLLgsYEnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3gsLUvLFxuICAgICAgICBvcmRpbmFsIDogJyVk4LC1JyxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+CwsOCwvuCwpOCxjeCwsOCwv3zgsIngsKbgsK/gsIJ84LCu4LCn4LGN4LCv4LC+4LC54LGN4LCo4LCCfOCwuOCwvuCwr+CwguCwpOCxjeCwsOCwgi8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgsLDgsL7gsKTgsY3gsLDgsL8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgsIngsKbgsK/gsIInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4LCu4LCn4LGN4LCv4LC+4LC54LGN4LCo4LCCJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgsLjgsL7gsK/gsILgsKTgsY3gsLDgsIInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CwsOCwvuCwpOCxjeCwsOCwvyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LCJ4LCm4LCv4LCCJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgsK7gsKfgsY3gsK/gsL7gsLngsY3gsKjgsIInO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CwuOCwvuCwr+CwguCwpOCxjeCwsOCwgic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LCw4LC+4LCk4LGN4LCw4LC/JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGU7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///111\n");

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var tet = moment.defineLocale('tet', {\n        months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),\n        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),\n        weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),\n        weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),\n        weekdaysMin : 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Ohin iha] LT',\n            nextDay: '[Aban iha] LT',\n            nextWeek: 'dddd [iha] LT',\n            lastDay: '[Horiseik iha] LT',\n            lastWeek: 'dddd [semana kotuk] [iha] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'iha %s',\n            past : '%s liuba',\n            s : 'minutu balun',\n            ss : 'minutu %d',\n            m : 'minutu ida',\n            mm : 'minutu %d',\n            h : 'oras ida',\n            hh : 'oras %d',\n            d : 'loron ida',\n            dd : 'loron %d',\n            M : 'fulan ida',\n            MM : 'fulan %d',\n            y : 'tinan ida',\n            yy : 'tinan %d'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return tet;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZXQuanM/ODE0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB0ZXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0ZXQnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW5laXJ1X0ZldmVyZWlydV9NYXJzdV9BYnJpbF9NYWl1X0p1w7F1X0p1bGx1X0FndXN0dV9TZXRlbWJydV9PdXR1YnJ1X05vdmVtYnJ1X0RlemVtYnJ1Jy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRmV2X01hcl9BYnJfTWFpX0p1bl9KdWxfQWdvX1NldF9PdXRfTm92X0Rleicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnRG9taW5ndV9TZWd1bmRhX1RlcnNhX0t1YXJ0YV9LaW50YV9TZXN0YV9TYWJhZHUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnRG9tX1NlZ19UZXJzX0t1YV9LaW50X1Nlc3RfU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdEb19TZWdfVGVfS3VfS2lfU2VzX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tPaGluIGloYV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tBYmFuIGloYV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtpaGFdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbSG9yaXNlaWsgaWhhXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW3NlbWFuYSBrb3R1a10gW2loYV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnaWhhICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgbGl1YmEnLFxuICAgICAgICAgICAgcyA6ICdtaW51dHUgYmFsdW4nLFxuICAgICAgICAgICAgc3MgOiAnbWludXR1ICVkJyxcbiAgICAgICAgICAgIG0gOiAnbWludXR1IGlkYScsXG4gICAgICAgICAgICBtbSA6ICdtaW51dHUgJWQnLFxuICAgICAgICAgICAgaCA6ICdvcmFzIGlkYScsXG4gICAgICAgICAgICBoaCA6ICdvcmFzICVkJyxcbiAgICAgICAgICAgIGQgOiAnbG9yb24gaWRhJyxcbiAgICAgICAgICAgIGRkIDogJ2xvcm9uICVkJyxcbiAgICAgICAgICAgIE0gOiAnZnVsYW4gaWRhJyxcbiAgICAgICAgICAgIE1NIDogJ2Z1bGFuICVkJyxcbiAgICAgICAgICAgIHkgOiAndGluYW4gaWRhJyxcbiAgICAgICAgICAgIHl5IDogJ3RpbmFuICVkJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRldDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///112\n");

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var suffixes = {\n        0: '-',\n        1: '-',\n        2: '-',\n        3: '-',\n        4: '-',\n        5: '-',\n        6: '-',\n        7: '-',\n        8: '-',\n        9: '-',\n        10: '-',\n        12: '-',\n        13: '-',\n        20: '-',\n        30: '-',\n        40: '-',\n        50: '-',\n        60: '-',\n        70: '-',\n        80: '-',\n        90: '-',\n        100: '-'\n    };\n\n    var tg = moment.defineLocale('tg', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            lastDay : '[ ] LT',\n            nextWeek : 'dddd[] [  ] LT',\n            lastWeek : 'dddd[] [  ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        meridiemParse: /|||/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem: function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 11) {\n                return '';\n            } else if (hour < 16) {\n                return '';\n            } else if (hour < 19) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(|)/,\n        ordinal: function (number) {\n            var a = number % 10,\n                b = number >= 100 ? 100 : null;\n            return number + (suffixes[number] || suffixes[a] || suffixes[b]);\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1th is the first week of the year.\n        }\n    });\n\n    return tg;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90Zy5qcz9lNTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzdWZmaXhlcyA9IHtcbiAgICAgICAgMDogJy3Rg9C8JyxcbiAgICAgICAgMTogJy3Rg9C8JyxcbiAgICAgICAgMjogJy3RjtC8JyxcbiAgICAgICAgMzogJy3RjtC8JyxcbiAgICAgICAgNDogJy3Rg9C8JyxcbiAgICAgICAgNTogJy3Rg9C8JyxcbiAgICAgICAgNjogJy3Rg9C8JyxcbiAgICAgICAgNzogJy3Rg9C8JyxcbiAgICAgICAgODogJy3Rg9C8JyxcbiAgICAgICAgOTogJy3Rg9C8JyxcbiAgICAgICAgMTA6ICct0YPQvCcsXG4gICAgICAgIDEyOiAnLdGD0LwnLFxuICAgICAgICAxMzogJy3Rg9C8JyxcbiAgICAgICAgMjA6ICct0YPQvCcsXG4gICAgICAgIDMwOiAnLdGO0LwnLFxuICAgICAgICA0MDogJy3Rg9C8JyxcbiAgICAgICAgNTA6ICct0YPQvCcsXG4gICAgICAgIDYwOiAnLdGD0LwnLFxuICAgICAgICA3MDogJy3Rg9C8JyxcbiAgICAgICAgODA6ICct0YPQvCcsXG4gICAgICAgIDkwOiAnLdGD0LwnLFxuICAgICAgICAxMDA6ICct0YPQvCdcbiAgICB9O1xuXG4gICAgdmFyIHRnID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGcnLCB7XG4gICAgICAgIG1vbnRocyA6ICfRj9C90LLQsNGAX9GE0LXQstGA0LDQu1/QvNCw0YDRgl/QsNC/0YDQtdC7X9C80LDQuV/QuNGO0L1f0LjRjtC7X9Cw0LLQs9GD0YHRgl/RgdC10L3RgtGP0LHRgF/QvtC60YLRj9Cx0YBf0L3QvtGP0LHRgF/QtNC10LrQsNCx0YAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GP0L3Qsl/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Llf0LjRjtC9X9C40Y7Qu1/QsNCy0LNf0YHQtdC9X9C+0LrRgl/QvdC+0Y9f0LTQtdC6Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfRj9C60YjQsNC90LHQtV/QtNGD0YjQsNC90LHQtV/RgdC10YjQsNC90LHQtV/Rh9C+0YDRiNCw0L3QsdC1X9C/0LDQvdK30YjQsNC90LHQtV/St9GD0LzRitCwX9GI0LDQvdCx0LUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn0Y/RiNCxX9C00YjQsV/RgdGI0LFf0YfRiNCxX9C/0YjQsV/St9GD0Lxf0YjQvdCxJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfRj9GIX9C00Yhf0YHRiF/Rh9GIX9C/0Yhf0rfQvF/RiNCxJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb0JjQvNGA06/QtyDRgdC+0LDRgtC4XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vQn9Cw0LPQvtKzINGB0L7QsNGC0LhdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW9CU0LjRgNOv0Lcg0YHQvtCw0YLQuF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZFvQuF0gW9Kz0LDRhNGC0LDQuCDQvtGP0L3QtNCwINGB0L7QsNGC0LhdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGRb0LhdIFvSs9Cw0YTRgtCw0Lgg0LPRg9C30LDRiNGC0LAg0YHQvtCw0YLQuF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9Cx0LDRitC00LggJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDQv9C10YgnLFxuICAgICAgICAgICAgcyA6ICfRj9C60YfQsNC90LQg0YHQvtC90LjRjycsXG4gICAgICAgICAgICBtIDogJ9GP0Log0LTQsNKb0LjSm9CwJyxcbiAgICAgICAgICAgIG1tIDogJyVkINC00LDSm9C40pvQsCcsXG4gICAgICAgICAgICBoIDogJ9GP0Log0YHQvtCw0YInLFxuICAgICAgICAgICAgaGggOiAnJWQg0YHQvtCw0YInLFxuICAgICAgICAgICAgZCA6ICfRj9C6INGA06/QtycsXG4gICAgICAgICAgICBkZCA6ICclZCDRgNOv0LcnLFxuICAgICAgICAgICAgTSA6ICfRj9C6INC80L7SsycsXG4gICAgICAgICAgICBNTSA6ICclZCDQvNC+0rMnLFxuICAgICAgICAgICAgeSA6ICfRj9C6INGB0L7QuycsXG4gICAgICAgICAgICB5eSA6ICclZCDRgdC+0LsnXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/RiNCw0LF80YHRg9Cx0rN80YDTr9C3fNCx0LXQs9C+0rMvLFxuICAgICAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfRiNCw0LEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfRgdGD0LHSsycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfRgNOv0LcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ9Cx0LXQs9C+0rMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0YjQsNCxJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRgdGD0LHSsyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0YDTr9C3JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfQsdC10LPQvtKzJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRiNCw0LEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNGD0Lx80Y7QvCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIGIgPSBudW1iZXIgPj0gMTAwID8gMTAwIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAoc3VmZml4ZXNbbnVtYmVyXSB8fCBzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDF0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRnO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90Zy5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///113\n");

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var th = moment.defineLocale('th', {\n        months : '___________'.split('_'),\n        monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),\n        monthsParseExact: true,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'), // yes, three characters difference\n        weekdaysMin : '._._._._._._.'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY  H:mm',\n            LLLL : 'dddd D MMMM YYYY  H:mm'\n        },\n        meridiemParse: /|/,\n        isPM: function (input) {\n            return input === '';\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd[ ] LT',\n            lastDay : '[ ] LT',\n            lastWeek : '[]dddd[ ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s',\n            s : '',\n            ss : '%d ',\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        }\n    });\n\n    return th;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90aC5qcz81ZjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB0aCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RoJywge1xuICAgICAgICBtb250aHMgOiAn4Lih4LiB4Lij4Liy4LiE4LihX+C4geC4uOC4oeC4oOC4suC4nuC4seC4meC4mOC5jF/guKHguLXguJnguLLguITguKFf4LmA4Lih4Lip4Liy4Lii4LiZX+C4nuC4pOC4qeC4oOC4suC4hOC4oV/guKHguLTguJbguLjguJnguLLguKLguJlf4LiB4Lij4LiB4LiO4Liy4LiE4LihX+C4quC4tOC4h+C4q+C4suC4hOC4oV/guIHguLHguJnguKLguLLguKLguJlf4LiV4Li44Lil4Liy4LiE4LihX+C4nuC4pOC4qOC4iOC4tOC4geC4suC4ouC4mV/guJjguLHguJnguKfguLLguITguKEnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+C4oS7guIQuX+C4gS7guJ4uX+C4oeC4tS7guIQuX+C5gOC4oS7guKIuX+C4ni7guIQuX+C4oeC4tC7guKIuX+C4gS7guIQuX+C4qi7guIQuX+C4gS7guKIuX+C4lS7guIQuX+C4ni7guKIuX+C4mC7guIQuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICfguK3guLLguJfguLTguJXguKLguYxf4LiI4Lix4LiZ4LiX4Lij4LmMX+C4reC4seC4h+C4hOC4suC4o1/guJ7guLjguJhf4Lie4Lik4Lir4Lix4Liq4Lia4LiU4Li1X+C4qOC4uOC4geC4o+C5jF/guYDguKrguLLguKPguYwnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4Lit4Liy4LiX4Li04LiV4Lii4LmMX+C4iOC4seC4meC4l+C4o+C5jF/guK3guLHguIfguITguLLguKNf4Lie4Li44LiYX+C4nuC4pOC4q+C4seC4ql/guKjguLjguIHguKPguYxf4LmA4Liq4Liy4Lij4LmMJy5zcGxpdCgnXycpLCAvLyB5ZXMsIHRocmVlIGNoYXJhY3RlcnMgZGlmZmVyZW5jZVxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfguK3guLIuX+C4iC5f4LitLl/guJ4uX+C4nuC4pC5f4LioLl/guKouJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSDguYDguKfguKXguLIgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ+C4p+C4seC4mWRkZGTguJfguLXguYggRCBNTU1NIFlZWVkg4LmA4Lin4Lil4LiyIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/guIHguYjguK3guJnguYDguJfguLXguYjguKLguId84Lir4Lil4Lix4LiH4LmA4LiX4Li14LmI4Lii4LiHLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfguKvguKXguLHguIfguYDguJfguLXguYjguKLguIcnO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C4geC5iOC4reC4meC5gOC4l+C4teC5iOC4ouC4hyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Lir4Lil4Lix4LiH4LmA4LiX4Li14LmI4Lii4LiHJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vguKfguLHguJnguJnguLXguYkg4LmA4Lin4Lil4LiyXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vguJ7guKPguLjguYjguIfguJnguLXguYkg4LmA4Lin4Lil4LiyXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkW+C4q+C4meC5ieC4siDguYDguKfguKXguLJdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+C5gOC4oeC4t+C5iOC4reC4p+C4suC4meC4meC4teC5iSDguYDguKfguKXguLJdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vguKfguLHguJldZGRkZFvguJfguLXguYjguYHguKXguYnguKcg4LmA4Lin4Lil4LiyXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn4Lit4Li14LiBICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPguJfguLXguYjguYHguKXguYnguKcnLFxuICAgICAgICAgICAgcyA6ICfguYTguKHguYjguIHguLXguYjguKfguLTguJnguLLguJfguLUnLFxuICAgICAgICAgICAgc3MgOiAnJWQg4Lin4Li04LiZ4Liy4LiX4Li1JyxcbiAgICAgICAgICAgIG0gOiAnMSDguJnguLLguJfguLUnLFxuICAgICAgICAgICAgbW0gOiAnJWQg4LiZ4Liy4LiX4Li1JyxcbiAgICAgICAgICAgIGggOiAnMSDguIrguLHguYjguKfguYLguKHguIcnLFxuICAgICAgICAgICAgaGggOiAnJWQg4LiK4Lix4LmI4Lin4LmC4Lih4LiHJyxcbiAgICAgICAgICAgIGQgOiAnMSDguKfguLHguJknLFxuICAgICAgICAgICAgZGQgOiAnJWQg4Lin4Lix4LiZJyxcbiAgICAgICAgICAgIE0gOiAnMSDguYDguJTguLfguK3guJknLFxuICAgICAgICAgICAgTU0gOiAnJWQg4LmA4LiU4Li34Lit4LiZJyxcbiAgICAgICAgICAgIHkgOiAnMSDguJvguLUnLFxuICAgICAgICAgICAgeXkgOiAnJWQg4Lib4Li1J1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGg7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///114\n");

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var tlPh = moment.defineLocale('tl-ph', {\n        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),\n        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),\n        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),\n        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),\n        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'MM/D/YYYY',\n            LL : 'MMMM D, YYYY',\n            LLL : 'MMMM D, YYYY HH:mm',\n            LLLL : 'dddd, MMMM DD, YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: 'LT [ngayong araw]',\n            nextDay: '[Bukas ng] LT',\n            nextWeek: 'LT [sa susunod na] dddd',\n            lastDay: 'LT [kahapon]',\n            lastWeek: 'LT [noong nakaraang] dddd',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'sa loob ng %s',\n            past : '%s ang nakalipas',\n            s : 'ilang segundo',\n            ss : '%d segundo',\n            m : 'isang minuto',\n            mm : '%d minuto',\n            h : 'isang oras',\n            hh : '%d oras',\n            d : 'isang araw',\n            dd : '%d araw',\n            M : 'isang buwan',\n            MM : '%d buwan',\n            y : 'isang taon',\n            yy : '%d taon'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : function (number) {\n            return number;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return tlPh;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bC1waC5qcz9kY2IyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgdGxQaCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RsLXBoJywge1xuICAgICAgICBtb250aHMgOiAnRW5lcm9fUGVicmVyb19NYXJzb19BYnJpbF9NYXlvX0h1bnlvX0h1bHlvX0Fnb3N0b19TZXR5ZW1icmVfT2t0dWJyZV9Ob2J5ZW1icmVfRGlzeWVtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdFbmVfUGViX01hcl9BYnJfTWF5X0h1bl9IdWxfQWdvX1NldF9Pa3RfTm9iX0Rpcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnTGluZ2dvX0x1bmVzX01hcnRlc19NaXllcmt1bGVzX0h1d2ViZXNfQml5ZXJuZXNfU2FiYWRvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0xpbl9MdW5fTWFyX01peV9IdXdfQml5X1NhYicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnTGlfTHVfTWFfTWlfSHVfQmlfU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ01NL0QvWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ01NTU0gRCwgWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gREQsIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ0xUIFtuZ2F5b25nIGFyYXddJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbQnVrYXMgbmddIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnTFQgW3NhIHN1c3Vub2QgbmFdIGRkZGQnLFxuICAgICAgICAgICAgbGFzdERheTogJ0xUIFtrYWhhcG9uXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ0xUIFtub29uZyBuYWthcmFhbmddIGRkZGQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnc2EgbG9vYiBuZyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGFuZyBuYWthbGlwYXMnLFxuICAgICAgICAgICAgcyA6ICdpbGFuZyBzZWd1bmRvJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNlZ3VuZG8nLFxuICAgICAgICAgICAgbSA6ICdpc2FuZyBtaW51dG8nLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRvJyxcbiAgICAgICAgICAgIGggOiAnaXNhbmcgb3JhcycsXG4gICAgICAgICAgICBoaCA6ICclZCBvcmFzJyxcbiAgICAgICAgICAgIGQgOiAnaXNhbmcgYXJhdycsXG4gICAgICAgICAgICBkZCA6ICclZCBhcmF3JyxcbiAgICAgICAgICAgIE0gOiAnaXNhbmcgYnV3YW4nLFxuICAgICAgICAgICAgTU0gOiAnJWQgYnV3YW4nLFxuICAgICAgICAgICAgeSA6ICdpc2FuZyB0YW9uJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHRhb24nXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0bFBoO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bC1waC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///115\n");

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');\n\n    function translateFuture(output) {\n        var time = output;\n        time = (output.indexOf('jaj') !== -1) ?\n        time.slice(0, -3) + 'leS' :\n        (output.indexOf('jar') !== -1) ?\n        time.slice(0, -3) + 'waQ' :\n        (output.indexOf('DIS') !== -1) ?\n        time.slice(0, -3) + 'nem' :\n        time + ' pIq';\n        return time;\n    }\n\n    function translatePast(output) {\n        var time = output;\n        time = (output.indexOf('jaj') !== -1) ?\n        time.slice(0, -3) + 'Hu' :\n        (output.indexOf('jar') !== -1) ?\n        time.slice(0, -3) + 'wen' :\n        (output.indexOf('DIS') !== -1) ?\n        time.slice(0, -3) + 'ben' :\n        time + ' ret';\n        return time;\n    }\n\n    function translate(number, withoutSuffix, string, isFuture) {\n        var numberNoun = numberAsNoun(number);\n        switch (string) {\n            case 'ss':\n                return numberNoun + ' lup';\n            case 'mm':\n                return numberNoun + ' tup';\n            case 'hh':\n                return numberNoun + ' rep';\n            case 'dd':\n                return numberNoun + ' jaj';\n            case 'MM':\n                return numberNoun + ' jar';\n            case 'yy':\n                return numberNoun + ' DIS';\n        }\n    }\n\n    function numberAsNoun(number) {\n        var hundred = Math.floor((number % 1000) / 100),\n        ten = Math.floor((number % 100) / 10),\n        one = number % 10,\n        word = '';\n        if (hundred > 0) {\n            word += numbersNouns[hundred] + 'vatlh';\n        }\n        if (ten > 0) {\n            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';\n        }\n        if (one > 0) {\n            word += ((word !== '') ? ' ' : '') + numbersNouns[one];\n        }\n        return (word === '') ? 'pagh' : word;\n    }\n\n    var tlh = moment.defineLocale('tlh', {\n        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),\n        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),\n        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),\n        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[DaHjaj] LT',\n            nextDay: '[waleS] LT',\n            nextWeek: 'LLL',\n            lastDay: '[waHu] LT',\n            lastWeek: 'LLL',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : translateFuture,\n            past : translatePast,\n            s : 'puS lup',\n            ss : translate,\n            m : 'wa tup',\n            mm : translate,\n            h : 'wa rep',\n            hh : translate,\n            d : 'wa jaj',\n            dd : translate,\n            M : 'wa jar',\n            MM : translate,\n            y : 'wa DIS',\n            yy : translate\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return tlh;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bGguanM/OWJiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbnVtYmVyc05vdW5zID0gJ3BhZ2hfd2HigJlfY2hh4oCZX3dlal9sb1NfdmFnaF9qYXZfU29jaF9jaG9yZ2hfSHV0Jy5zcGxpdCgnXycpO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlRnV0dXJlKG91dHB1dCkge1xuICAgICAgICB2YXIgdGltZSA9IG91dHB1dDtcbiAgICAgICAgdGltZSA9IChvdXRwdXQuaW5kZXhPZignamFqJykgIT09IC0xKSA/XG4gICAgICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ2xlUycgOlxuICAgICAgICAob3V0cHV0LmluZGV4T2YoJ2phcicpICE9PSAtMSkgP1xuICAgICAgICB0aW1lLnNsaWNlKDAsIC0zKSArICd3YVEnIDpcbiAgICAgICAgKG91dHB1dC5pbmRleE9mKCdESVMnKSAhPT0gLTEpID9cbiAgICAgICAgdGltZS5zbGljZSgwLCAtMykgKyAnbmVtJyA6XG4gICAgICAgIHRpbWUgKyAnIHBJcSc7XG4gICAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVBhc3Qob3V0cHV0KSB7XG4gICAgICAgIHZhciB0aW1lID0gb3V0cHV0O1xuICAgICAgICB0aW1lID0gKG91dHB1dC5pbmRleE9mKCdqYWonKSAhPT0gLTEpID9cbiAgICAgICAgdGltZS5zbGljZSgwLCAtMykgKyAnSHXigJknIDpcbiAgICAgICAgKG91dHB1dC5pbmRleE9mKCdqYXInKSAhPT0gLTEpID9cbiAgICAgICAgdGltZS5zbGljZSgwLCAtMykgKyAnd2VuJyA6XG4gICAgICAgIChvdXRwdXQuaW5kZXhPZignRElTJykgIT09IC0xKSA/XG4gICAgICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ2JlbicgOlxuICAgICAgICB0aW1lICsgJyByZXQnO1xuICAgICAgICByZXR1cm4gdGltZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBudW1iZXJOb3VuID0gbnVtYmVyQXNOb3VuKG51bWJlcik7XG4gICAgICAgIHN3aXRjaCAoc3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlICdzcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIGx1cCc7XG4gICAgICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIHR1cCc7XG4gICAgICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIHJlcCc7XG4gICAgICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIGphaic7XG4gICAgICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIGphcic7XG4gICAgICAgICAgICBjYXNlICd5eSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIERJUyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBudW1iZXJBc05vdW4obnVtYmVyKSB7XG4gICAgICAgIHZhciBodW5kcmVkID0gTWF0aC5mbG9vcigobnVtYmVyICUgMTAwMCkgLyAxMDApLFxuICAgICAgICB0ZW4gPSBNYXRoLmZsb29yKChudW1iZXIgJSAxMDApIC8gMTApLFxuICAgICAgICBvbmUgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgd29yZCA9ICcnO1xuICAgICAgICBpZiAoaHVuZHJlZCA+IDApIHtcbiAgICAgICAgICAgIHdvcmQgKz0gbnVtYmVyc05vdW5zW2h1bmRyZWRdICsgJ3ZhdGxoJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVuID4gMCkge1xuICAgICAgICAgICAgd29yZCArPSAoKHdvcmQgIT09ICcnKSA/ICcgJyA6ICcnKSArIG51bWJlcnNOb3Vuc1t0ZW5dICsgJ21hSCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZSA+IDApIHtcbiAgICAgICAgICAgIHdvcmQgKz0gKCh3b3JkICE9PSAnJykgPyAnICcgOiAnJykgKyBudW1iZXJzTm91bnNbb25lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHdvcmQgPT09ICcnKSA/ICdwYWdoJyA6IHdvcmQ7XG4gICAgfVxuXG4gICAgdmFyIHRsaCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RsaCcsIHtcbiAgICAgICAgbW9udGhzIDogJ3RlcmHigJkgamFyIHdh4oCZX3RlcmHigJkgamFyIGNoYeKAmV90ZXJh4oCZIGphciB3ZWpfdGVyYeKAmSBqYXIgbG9TX3RlcmHigJkgamFyIHZhZ2hfdGVyYeKAmSBqYXIgamF2X3RlcmHigJkgamFyIFNvY2hfdGVyYeKAmSBqYXIgY2hvcmdoX3RlcmHigJkgamFyIEh1dF90ZXJh4oCZIGphciB3YeKAmW1hSF90ZXJh4oCZIGphciB3YeKAmW1hSCB3YeKAmV90ZXJh4oCZIGphciB3YeKAmW1hSCBjaGHigJknLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phciB3YeKAmV9qYXIgY2hh4oCZX2phciB3ZWpfamFyIGxvU19qYXIgdmFnaF9qYXIgamF2X2phciBTb2NoX2phciBjaG9yZ2hfamFyIEh1dF9qYXIgd2HigJltYUhfamFyIHdh4oCZbWFIIHdh4oCZX2phciB3YeKAmW1hSCBjaGHigJknLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdsb2ptSXRqYWpfRGFTamFqX3Bvdmphal9naEl0bGhqYWpfbG9naGphal9idXFqYWpfZ2hJbmphaicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdsb2ptSXRqYWpfRGFTamFqX3Bvdmphal9naEl0bGhqYWpfbG9naGphal9idXFqYWpfZ2hJbmphaicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnbG9qbUl0amFqX0RhU2phal9wb3ZqYWpfZ2hJdGxoamFqX2xvZ2hqYWpfYnVxamFqX2doSW5qYWonLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0RhSGphal0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1t3YeKAmWxlU10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdMTEwnLFxuICAgICAgICAgICAgbGFzdERheTogJ1t3YeKAmUh14oCZXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ0xMTCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IHRyYW5zbGF0ZUZ1dHVyZSxcbiAgICAgICAgICAgIHBhc3QgOiB0cmFuc2xhdGVQYXN0LFxuICAgICAgICAgICAgcyA6ICdwdVMgbHVwJyxcbiAgICAgICAgICAgIHNzIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbSA6ICd3YeKAmSB0dXAnLFxuICAgICAgICAgICAgbW0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoIDogJ3dh4oCZIHJlcCcsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiAnd2HigJkgamFqJyxcbiAgICAgICAgICAgIGRkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTSA6ICd3YeKAmSBqYXInLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogJ3dh4oCZIERJUycsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRsaDtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGxoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///116\n");

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n    var suffixes = {\n        1: '\\'inci',\n        5: '\\'inci',\n        8: '\\'inci',\n        70: '\\'inci',\n        80: '\\'inci',\n        2: '\\'nci',\n        7: '\\'nci',\n        20: '\\'nci',\n        50: '\\'nci',\n        3: '\\'nc',\n        4: '\\'nc',\n        100: '\\'nc',\n        6: '\\'nc',\n        9: '\\'uncu',\n        10: '\\'uncu',\n        30: '\\'uncu',\n        60: '\\'nc',\n        90: '\\'nc'\n    };\n\n    var tr = moment.defineLocale('tr', {\n        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),\n        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),\n        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),\n        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),\n        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[bugn saat] LT',\n            nextDay : '[yarn saat] LT',\n            nextWeek : '[gelecek] dddd [saat] LT',\n            lastDay : '[dn] LT',\n            lastWeek : '[geen] dddd [saat] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s sonra',\n            past : '%s nce',\n            s : 'birka saniye',\n            ss : '%d saniye',\n            m : 'bir dakika',\n            mm : '%d dakika',\n            h : 'bir saat',\n            hh : '%d saat',\n            d : 'bir gn',\n            dd : '%d gn',\n            M : 'bir ay',\n            MM : '%d ay',\n            y : 'bir yl',\n            yy : '%d yl'\n        },\n        ordinal: function (number, period) {\n            switch (period) {\n                case 'd':\n                case 'D':\n                case 'Do':\n                case 'DD':\n                    return number;\n                default:\n                    if (number === 0) {  // special case for zero\n                        return number + '\\'nc';\n                    }\n                    var a = number % 10,\n                        b = number % 100 - a,\n                        c = number >= 100 ? 100 : null;\n                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return tr;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ci5qcz85M2VlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgc3VmZml4ZXMgPSB7XG4gICAgICAgIDE6ICdcXCdpbmNpJyxcbiAgICAgICAgNTogJ1xcJ2luY2knLFxuICAgICAgICA4OiAnXFwnaW5jaScsXG4gICAgICAgIDcwOiAnXFwnaW5jaScsXG4gICAgICAgIDgwOiAnXFwnaW5jaScsXG4gICAgICAgIDI6ICdcXCduY2knLFxuICAgICAgICA3OiAnXFwnbmNpJyxcbiAgICAgICAgMjA6ICdcXCduY2knLFxuICAgICAgICA1MDogJ1xcJ25jaScsXG4gICAgICAgIDM6ICdcXCfDvG5jw7wnLFxuICAgICAgICA0OiAnXFwnw7xuY8O8JyxcbiAgICAgICAgMTAwOiAnXFwnw7xuY8O8JyxcbiAgICAgICAgNjogJ1xcJ25jxLEnLFxuICAgICAgICA5OiAnXFwndW5jdScsXG4gICAgICAgIDEwOiAnXFwndW5jdScsXG4gICAgICAgIDMwOiAnXFwndW5jdScsXG4gICAgICAgIDYwOiAnXFwnxLFuY8SxJyxcbiAgICAgICAgOTA6ICdcXCfEsW5jxLEnXG4gICAgfTtcblxuICAgIHZhciB0ciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RyJywge1xuICAgICAgICBtb250aHMgOiAnT2Nha1/FnnViYXRfTWFydF9OaXNhbl9NYXnEsXNfSGF6aXJhbl9UZW1tdXpfQcSfdXN0b3NfRXlsw7xsX0VraW1fS2FzxLFtX0FyYWzEsWsnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ09jYV/FnnViX01hcl9OaXNfTWF5X0hhel9UZW1fQcSfdV9FeWxfRWtpX0thc19BcmEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1BhemFyX1BhemFydGVzaV9TYWzEsV/Dh2FyxZ9hbWJhX1BlcsWfZW1iZV9DdW1hX0N1bWFydGVzaScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdQYXpfUHRzX1NhbF/Dh2FyX1Blcl9DdW1fQ3RzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdQel9QdF9TYV/Dh2FfUGVfQ3VfQ3QnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tidWfDvG4gc2FhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbeWFyxLFuIHNhYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1tnZWxlY2VrXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tkw7xuXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbZ2XDp2VuXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMgc29ucmEnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDDtm5jZScsXG4gICAgICAgICAgICBzIDogJ2Jpcmthw6cgc2FuaXllJyxcbiAgICAgICAgICAgIHNzIDogJyVkIHNhbml5ZScsXG4gICAgICAgICAgICBtIDogJ2JpciBkYWtpa2EnLFxuICAgICAgICAgICAgbW0gOiAnJWQgZGFraWthJyxcbiAgICAgICAgICAgIGggOiAnYmlyIHNhYXQnLFxuICAgICAgICAgICAgaGggOiAnJWQgc2FhdCcsXG4gICAgICAgICAgICBkIDogJ2JpciBnw7xuJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGfDvG4nLFxuICAgICAgICAgICAgTSA6ICdiaXIgYXknLFxuICAgICAgICAgICAgTU0gOiAnJWQgYXknLFxuICAgICAgICAgICAgeSA6ICdiaXIgecSxbCcsXG4gICAgICAgICAgICB5eSA6ICclZCB5xLFsJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0REJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7ICAvLyBzcGVjaWFsIGNhc2UgZm9yIHplcm9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnXFwnxLFuY8SxJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IG51bWJlciAlIDEwMCAtIGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gbnVtYmVyID49IDEwMCA/IDEwMCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAoc3VmZml4ZXNbYV0gfHwgc3VmZml4ZXNbYl0gfHwgc3VmZml4ZXNbY10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cjtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHIuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///117\n");

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.\n    // This is currently too difficult (maybe even impossible) to add.\n    var tzl = moment.defineLocale('tzl', {\n        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),\n        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),\n        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),\n        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),\n        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM [dallas] YYYY',\n            LLL : 'D. MMMM [dallas] YYYY HH.mm',\n            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'\n        },\n        meridiemParse: /d\\'o|d\\'a/i,\n        isPM : function (input) {\n            return 'd\\'o' === input.toLowerCase();\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? 'd\\'o' : 'D\\'O';\n            } else {\n                return isLower ? 'd\\'a' : 'D\\'A';\n            }\n        },\n        calendar : {\n            sameDay : '[oxhi ] LT',\n            nextDay : '[dem ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ieiri ] LT',\n            lastWeek : '[sr el] dddd [lasteu ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'osprei %s',\n            past : 'ja%s',\n            s : processRelativeTime,\n            ss : processRelativeTime,\n            m : processRelativeTime,\n            mm : processRelativeTime,\n            h : processRelativeTime,\n            hh : processRelativeTime,\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            's': ['viensas secunds', '\\'iensas secunds'],\n            'ss': [number + ' secunds', '' + number + ' secunds'],\n            'm': ['\\'n mut', '\\'iens mut'],\n            'mm': [number + ' muts', '' + number + ' muts'],\n            'h': ['\\'n ora', '\\'iensa ora'],\n            'hh': [number + ' oras', '' + number + ' oras'],\n            'd': ['\\'n ziua', '\\'iensa ziua'],\n            'dd': [number + ' ziuas', '' + number + ' ziuas'],\n            'M': ['\\'n mes', '\\'iens mes'],\n            'MM': [number + ' mesen', '' + number + ' mesen'],\n            'y': ['\\'n ar', '\\'iens ar'],\n            'yy': [number + ' ars', '' + number + ' ars']\n        };\n        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);\n    }\n\n    return tzl;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanM/ODhkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIC8vIEFmdGVyIHRoZSB5ZWFyIHRoZXJlIHNob3VsZCBiZSBhIHNsYXNoIGFuZCB0aGUgYW1vdW50IG9mIHllYXJzIHNpbmNlIERlY2VtYmVyIDI2LCAxOTc5IGluIFJvbWFuIG51bWVyYWxzLlxuICAgIC8vIFRoaXMgaXMgY3VycmVudGx5IHRvbyBkaWZmaWN1bHQgKG1heWJlIGV2ZW4gaW1wb3NzaWJsZSkgdG8gYWRkLlxuICAgIHZhciB0emwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0emwnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJfRmV2cmFnbGhfTWFyw6dfQXZyw691X01haV9Hw7xuX0p1bGlhX0d1c2NodF9TZXRlbXZhcl9MaXN0b3DDpHRzX05vZW12YXJfWmVjZW12YXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZXZfTWFyX0F2cl9NYWlfR8O8bl9KdWxfR3VzX1NldF9MaXNfTm9lX1plYycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnU8O6bGFkaV9Mw7puZcOnaV9NYWl0emlfTcOhcmN1cmlfWGjDumFkaV9WacOpbmVyw6dpX1PDoXR1cmknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnU8O6bF9Mw7puX01haV9Nw6FyX1how7pfVmnDqV9Tw6F0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTw7pfTMO6X01hX03DoV9YaF9WaV9Tw6EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEgubW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFtkYWxsYXNdIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gW2RhbGxhc10gWVlZWSBISC5tbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIFtsaV0gRC4gTU1NTSBbZGFsbGFzXSBZWVlZIEhILm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvZFxcJ298ZFxcJ2EvaSxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuICdkXFwnbycgPT09IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2RcXCdvJyA6ICdEXFwnTyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2RcXCdhJyA6ICdEXFwnQSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbb3hoaSDDoF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbZGVtw6Agw6BdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW8OgXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tpZWlyaSDDoF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW3PDvHIgZWxdIGRkZGQgW2xhc3RldSDDoF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29zcHJlaSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2phJXMnLFxuICAgICAgICAgICAgcyA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBzcyA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIG1tIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgaGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ3MnOiBbJ3ZpZW5zYXMgc2VjdW5kcycsICdcXCdpZW5zYXMgc2VjdW5kcyddLFxuICAgICAgICAgICAgJ3NzJzogW251bWJlciArICcgc2VjdW5kcycsICcnICsgbnVtYmVyICsgJyBzZWN1bmRzJ10sXG4gICAgICAgICAgICAnbSc6IFsnXFwnbiBtw611dCcsICdcXCdpZW5zIG3DrXV0J10sXG4gICAgICAgICAgICAnbW0nOiBbbnVtYmVyICsgJyBtw611dHMnLCAnJyArIG51bWJlciArICcgbcOtdXRzJ10sXG4gICAgICAgICAgICAnaCc6IFsnXFwnbiDDvm9yYScsICdcXCdpZW5zYSDDvm9yYSddLFxuICAgICAgICAgICAgJ2hoJzogW251bWJlciArICcgw75vcmFzJywgJycgKyBudW1iZXIgKyAnIMO+b3JhcyddLFxuICAgICAgICAgICAgJ2QnOiBbJ1xcJ24geml1YScsICdcXCdpZW5zYSB6aXVhJ10sXG4gICAgICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyB6aXVhcycsICcnICsgbnVtYmVyICsgJyB6aXVhcyddLFxuICAgICAgICAgICAgJ00nOiBbJ1xcJ24gbWVzJywgJ1xcJ2llbnMgbWVzJ10sXG4gICAgICAgICAgICAnTU0nOiBbbnVtYmVyICsgJyBtZXNlbicsICcnICsgbnVtYmVyICsgJyBtZXNlbiddLFxuICAgICAgICAgICAgJ3knOiBbJ1xcJ24gYXInLCAnXFwnaWVucyBhciddLFxuICAgICAgICAgICAgJ3l5JzogW251bWJlciArICcgYXJzJywgJycgKyBudW1iZXIgKyAnIGFycyddXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0Z1dHVyZSA/IGZvcm1hdFtrZXldWzBdIDogKHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHpsO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///118\n");

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var tzm = moment.defineLocale('tzm', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: 'dddd [] LT',\n            lastDay: '[ ] LT',\n            lastWeek: 'dddd [] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '   %s',\n            past : ' %s',\n            s : '',\n            ss : '%d ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d o',\n            M : 'o',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return tzm;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0uanM/MTUxMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB0em0gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0em0nLCB7XG4gICAgICAgIG1vbnRocyA6ICfitYnitY/itY/itLDitaLitZRf4rSx4rWV4rSw4rWi4rWVX+K1juK0sOK1leK1ml/itYnitLHitZTitYnitZRf4rWO4rSw4rWi4rWi4rWTX+K1ouK1k+K1j+K1ouK1k1/itaLitZPitY3itaLitZPitaNf4rWW4rWT4rWb4rWcX+K1m+K1k+K1nOK0sOK1j+K0seK1ieK1lF/itL3itZ/itZPitLHitZVf4rWP4rWT4rWh4rSw4rWP4rSx4rWJ4rWUX+K0t+K1k+K1iuK1j+K0seK1ieK1lCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4rWJ4rWP4rWP4rSw4rWi4rWUX+K0seK1leK0sOK1ouK1lV/itY7itLDitZXitZpf4rWJ4rSx4rWU4rWJ4rWUX+K1juK0sOK1ouK1ouK1k1/itaLitZPitY/itaLitZNf4rWi4rWT4rWN4rWi4rWT4rWjX+K1luK1k+K1m+K1nF/itZvitZPitZzitLDitY/itLHitYnitZRf4rS94rWf4rWT4rSx4rWVX+K1j+K1k+K1oeK0sOK1j+K0seK1ieK1lF/itLfitZPitYritY/itLHitYnitZQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+K0sOK1meK0sOK1juK0sOK1mV/itLDitaLitY/itLDitZlf4rSw4rWZ4rWJ4rWP4rSw4rWZX+K0sOK0veK1lOK0sOK1mV/itLDitL3itaHitLDitZlf4rSw4rWZ4rWJ4rWO4rWh4rSw4rWZX+K0sOK1meK1ieK0ueK1ouK0sOK1mScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfitLDitZnitLDitY7itLDitZlf4rSw4rWi4rWP4rSw4rWZX+K0sOK1meK1ieK1j+K0sOK1mV/itLDitL3itZTitLDitZlf4rSw4rS94rWh4rSw4rWZX+K0sOK1meK1ieK1juK1oeK0sOK1mV/itLDitZnitYnitLnitaLitLDitZknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+K0sOK1meK0sOK1juK0sOK1mV/itLDitaLitY/itLDitZlf4rSw4rWZ4rWJ4rWP4rSw4rWZX+K0sOK0veK1lOK0sOK1mV/itLDitL3itaHitLDitZlf4rSw4rWZ4rWJ4rWO4rWh4rSw4rWZX+K0sOK1meK1ieK0ueK1ouK0sOK1mScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFM6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW+K0sOK1meK0t+K1hSDitLRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb4rSw4rWZ4rS94rSwIOK0tF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvitLRdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb4rSw4rWa4rSw4rWP4rWcIOK0tF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvitLRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ+K0t+K0sOK0t+K1hSDitZkg4rWi4rSw4rWPICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAn4rWi4rSw4rWPICVzJyxcbiAgICAgICAgICAgIHMgOiAn4rWJ4rWO4rWJ4rS9JyxcbiAgICAgICAgICAgIHNzIDogJyVkIOK1ieK1juK1ieK0vScsXG4gICAgICAgICAgICBtIDogJ+K1juK1ieK1j+K1k+K0uicsXG4gICAgICAgICAgICBtbSA6ICclZCDitY7itYnitY/itZPitLonLFxuICAgICAgICAgICAgaCA6ICfitZnitLDitYTitLAnLFxuICAgICAgICAgICAgaGggOiAnJWQg4rWc4rSw4rWZ4rWZ4rSw4rWE4rWJ4rWPJyxcbiAgICAgICAgICAgIGQgOiAn4rSw4rWZ4rWZJyxcbiAgICAgICAgICAgIGRkIDogJyVkIG/itZnitZnitLDitY8nLFxuICAgICAgICAgICAgTSA6ICfitLDitaJv4rWT4rWUJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOK1ieK1ouK1ouK1ieK1lOK1jycsXG4gICAgICAgICAgICB5IDogJ+K0sOK1meK0s+K0sOK1mScsXG4gICAgICAgICAgICB5eSA6ICclZCDitYnitZnitLPitLDitZnitY8nXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHR6bTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///119\n");

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var tzmLatn = moment.defineLocale('tzm-latn', {\n        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),\n        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),\n        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[asdkh g] LT',\n            nextDay: '[aska g] LT',\n            nextWeek: 'dddd [g] LT',\n            lastDay: '[assant g] LT',\n            lastWeek: 'dddd [g] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'dadkh s yan %s',\n            past : 'yan %s',\n            s : 'imik',\n            ss : '%d imik',\n            m : 'minu',\n            mm : '%d minu',\n            h : 'saa',\n            hh : '%d tassain',\n            d : 'ass',\n            dd : '%d ossan',\n            M : 'ayowr',\n            MM : '%d iyyirn',\n            y : 'asgas',\n            yy : '%d isgasn'\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return tzmLatn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0tbGF0bi5qcz85MmIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHR6bUxhdG4gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0em0tbGF0bicsIHtcbiAgICAgICAgbW9udGhzIDogJ2lubmF5cl9icsukYXlyy6RfbWFyy6Rzy6RfaWJyaXJfbWF5eXdfeXdueXdfeXdseXd6X8mjd8WhdF/FoXd0YW5iaXJfa3TLpHdicsukX253d2FuYmlyX2R3am5iaXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2lubmF5cl9icsukYXlyy6RfbWFyy6Rzy6RfaWJyaXJfbWF5eXdfeXdueXdfeXdseXd6X8mjd8WhdF/FoXd0YW5iaXJfa3TLpHdicsukX253d2FuYmlyX2R3am5iaXInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ2FzYW1hc19heW5hc19hc2luYXNfYWtyYXNfYWt3YXNfYXNpbXdhc19hc2nhuI15YXMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnYXNhbWFzX2F5bmFzX2FzaW5hc19ha3Jhc19ha3dhc19hc2ltd2FzX2FzaeG4jXlhcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnYXNhbWFzX2F5bmFzX2FzaW5hc19ha3Jhc19ha3dhc19hc2ltd2FzX2FzaeG4jXlhcycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1thc2RraCBnXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW2Fza2EgZ10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtnXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW2Fzc2FudCBnXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW2ddIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2RhZGtoIHMgeWFuICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAneWFuICVzJyxcbiAgICAgICAgICAgIHMgOiAnaW1paycsXG4gICAgICAgICAgICBzcyA6ICclZCBpbWlrJyxcbiAgICAgICAgICAgIG0gOiAnbWludeG4jScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW514biNJyxcbiAgICAgICAgICAgIGggOiAnc2HJm2EnLFxuICAgICAgICAgICAgaGggOiAnJWQgdGFzc2HJm2luJyxcbiAgICAgICAgICAgIGQgOiAnYXNzJyxcbiAgICAgICAgICAgIGRkIDogJyVkIG9zc2FuJyxcbiAgICAgICAgICAgIE0gOiAnYXlvd3InLFxuICAgICAgICAgICAgTU0gOiAnJWQgaXl5aXJuJyxcbiAgICAgICAgICAgIHkgOiAnYXNnYXMnLFxuICAgICAgICAgICAgeXkgOiAnJWQgaXNnYXNuJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0em1MYXRuO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0tbGF0bi5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///120\n");

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js language configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var ugCn = moment.defineLocale('ug-cn', {\n        months: '___________'.split(\n            '_'\n        ),\n        monthsShort: '___________'.split(\n            '_'\n        ),\n        weekdays: '______'.split(\n            '_'\n        ),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'YYYY-MM-DD',\n            LL: 'YYYY-M-D-',\n            LLL: 'YYYY-M-D- HH:mm',\n            LLLL: 'dddd YYYY-M-D- HH:mm'\n        },\n        meridiemParse: / || || |/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (\n                meridiem === ' ' ||\n                meridiem === '' ||\n                meridiem === ' '\n            ) {\n                return hour;\n            } else if (meridiem === ' ' || meridiem === '') {\n                return hour + 12;\n            } else {\n                return hour >= 11 ? hour : hour + 12;\n            }\n        },\n        meridiem: function (hour, minute, isLower) {\n            var hm = hour * 100 + minute;\n            if (hm < 600) {\n                return ' ';\n            } else if (hm < 900) {\n                return '';\n            } else if (hm < 1130) {\n                return ' ';\n            } else if (hm < 1230) {\n                return '';\n            } else if (hm < 1800) {\n                return ' ';\n            } else {\n                return '';\n            }\n        },\n        calendar: {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: '[] dddd [] LT',\n            lastDay: '[] LT',\n            lastWeek: '[] dddd [] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: '%s ',\n            past: '%s ',\n            s: ' ',\n            ss: '%d ',\n            m: ' ',\n            mm: '%d ',\n            h: ' ',\n            hh: '%d ',\n            d: ' ',\n            dd: '%d ',\n            M: ' ',\n            MM: '%d ',\n            y: ' ',\n            yy: '%d '\n        },\n\n        dayOfMonthOrdinalParse: /\\d{1,2}(-|-|-)/,\n        ordinal: function (number, period) {\n            switch (period) {\n                case 'd':\n                case 'D':\n                case 'DDD':\n                    return number + '-';\n                case 'w':\n                case 'W':\n                    return number + '-';\n                default:\n                    return number;\n            }\n        },\n        preparse: function (string) {\n            return string.replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/,/g, '');\n        },\n        week: {\n            // GB/T 7408-1994ISO 8601:1988\n            dow: 1, // Monday is the first day of the week.\n            doy: 7 // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return ugCn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91Zy1jbi5qcz80ZThkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsYW5ndWFnZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB1Z0NuID0gbW9tZW50LmRlZmluZUxvY2FsZSgndWctY24nLCB7XG4gICAgICAgIG1vbnRoczogJ9mK2KfZhtuL2KfYsV/ZgduQ24vYsdin2YRf2YXYp9ix2Kpf2KbYp9m+2LHbkNmEX9mF2KfZil/YptmJ2Yrbh9mGX9im2YnZituH2YRf2KbYp9uL2Lrbh9iz2Kpf2LPbkNmG2Krbldio2YnYsV/YptuG2YPYqtuV2KjZidixX9mG2YjZitin2KjZidixX9iv25DZg9in2KjZidixJy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICBtb250aHNTaG9ydDogJ9mK2KfZhtuL2KfYsV/ZgduQ24vYsdin2YRf2YXYp9ix2Kpf2KbYp9m+2LHbkNmEX9mF2KfZil/YptmJ2Yrbh9mGX9im2YnZituH2YRf2KbYp9uL2Lrbh9iz2Kpf2LPbkNmG2Krbldio2YnYsV/YptuG2YPYqtuV2KjZidixX9mG2YjZitin2KjZidixX9iv25DZg9in2KjZidixJy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICB3ZWVrZGF5czogJ9mK25XZg9i025XZhtio25Vf2K/biNi025XZhtio25Vf2LPbldmK2LTbldmG2KjblV/ahtin2LHYtNuV2YbYqNuVX9m+25XZiti025XZhtio25Vf2KzbiNmF25Vf2LTbldmG2KjblScuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogJ9mK25Vf2K/biF/Ys9uVX9qG2Kdf2b7blV/YrNuIX9i025UnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAn2YrblV/Yr9uIX9iz25Vf2obYp1/ZvtuVX9is24hf2LTblScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEw6ICdZWVlZLdmK2YnZhNmJTS3Yptin2YrZhtmJ2q1ELdmD24jZhtmJJyxcbiAgICAgICAgICAgIExMTDogJ1lZWVkt2YrZidmE2YlNLdim2KfZitmG2YnarUQt2YPbiNmG2YnYjCBISDptbScsXG4gICAgICAgICAgICBMTExMOiAnZGRkZNiMIFlZWVkt2YrZidmE2YlNLdim2KfZitmG2YnarUQt2YPbiNmG2YnYjCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL9mK25DYsdmJ2YUg2YPbkNqG25V82LPbldq+25XYsXzahtuI2LTYqtmJ2YYg2Kjbh9ix24fZhnzahtuI2LR82obbiNi02KrZidmGINmD25DZitmJ2YZ82YPbldqGLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1lcmlkaWVtID09PSAn2YrbkNix2YnZhSDZg9uQ2obblScgfHxcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ9iz25XavtuV2LEnIHx8XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfahtuI2LTYqtmJ2YYg2Kjbh9ix24fZhidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ9qG24jYtNiq2YnZhiDZg9uQ2YrZidmGJyB8fCBtZXJpZGllbSA9PT0gJ9mD25XahicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBob3VyICogMTAwICsgbWludXRlO1xuICAgICAgICAgICAgaWYgKGhtIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfZituQ2LHZidmFINmD25DahtuVJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCA5MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9iz25XavtuV2LEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDExMzApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9qG24jYtNiq2YnZhiDYqNuH2LHbh9mGJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMjMwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfahtuI2LQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDE4MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9qG24jYtNiq2YnZhiDZg9uQ2YrZidmGJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfZg9uV2oYnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhcjoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vYqNuI2q/biNmGINiz2KfYptuV2KpdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb2Kbbldiq25Ug2LPYp9im25XYql0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdb2YPbkNmE25XYsdmD2YldIGRkZGQgW9iz2KfYptuV2KpdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb2KrbhtmG24jar9uI2YZdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW9im2KfZhNiv2YnZhtmC2YldIGRkZGQgW9iz2KfYptuV2KpdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiB7XG4gICAgICAgICAgICBmdXR1cmU6ICclcyDZg9uQ2YrZidmGJyxcbiAgICAgICAgICAgIHBhc3Q6ICclcyDYqNuH2LHbh9mGJyxcbiAgICAgICAgICAgIHM6ICfZhtuV2obahtuVINiz25DZg9mI2YbYqicsXG4gICAgICAgICAgICBzczogJyVkINiz25DZg9mI2YbYqicsXG4gICAgICAgICAgICBtOiAn2KjZidixINmF2YnZhtuH2KonLFxuICAgICAgICAgICAgbW06ICclZCDZhdmJ2Ybbh9iqJyxcbiAgICAgICAgICAgIGg6ICfYqNmJ2LEg2LPYp9im25XYqicsXG4gICAgICAgICAgICBoaDogJyVkINiz2KfYptuV2KonLFxuICAgICAgICAgICAgZDogJ9io2YnYsSDZg9uI2YYnLFxuICAgICAgICAgICAgZGQ6ICclZCDZg9uI2YYnLFxuICAgICAgICAgICAgTTogJ9io2YnYsSDYptin2YonLFxuICAgICAgICAgICAgTU06ICclZCDYptin2YonLFxuICAgICAgICAgICAgeTogJ9io2YnYsSDZitmJ2YQnLFxuICAgICAgICAgICAgeXk6ICclZCDZitmJ2YQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KC3Zg9uI2YbZiXwt2KbYp9mKfC3avtuV2b7YqtuVKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Zg9uI2YbZiSc7XG4gICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdq+25XZvtiq25UnO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLC9nLCAn2IwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2Vlazoge1xuICAgICAgICAgICAgLy8gR0IvVCA3NDA4LTE5OTTjgIrmlbDmja7lhYPlkozkuqTmjaLmoLzlvI/Ct+S/oeaBr+S6pOaNosK35pel5pyf5ZKM5pe26Ze06KGo56S65rOV44CL5LiOSVNPIDg2MDE6MTk4OOetieaViFxuICAgICAgICAgICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveTogNyAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB1Z0NuO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91Zy1jbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///121\n");

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function plural(word, num) {\n        var forms = word.split('_');\n        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n    }\n    function relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n            'ss': withoutSuffix ? '__' : '__',\n            'mm': withoutSuffix ? '__' : '__',\n            'hh': withoutSuffix ? '__' : '__',\n            'dd': '__',\n            'MM': '__',\n            'yy': '__'\n        };\n        if (key === 'm') {\n            return withoutSuffix ? '' : '';\n        }\n        else if (key === 'h') {\n            return withoutSuffix ? '' : '';\n        }\n        else {\n            return number + ' ' + plural(format[key], +number);\n        }\n    }\n    function weekdaysCaseReplace(m, format) {\n        var weekdays = {\n            'nominative': '______'.split('_'),\n            'accusative': '______'.split('_'),\n            'genitive': '______'.split('_')\n        };\n\n        if (!m) {\n            return weekdays['nominative'];\n        }\n\n        var nounCase = (/(\\[[]\\]) ?dddd/).test(format) ?\n            'accusative' :\n            ((/\\[?(?:|)? ?\\] ?dddd/).test(format) ?\n                'genitive' :\n                'nominative');\n        return weekdays[nounCase][m.day()];\n    }\n    function processHoursFunction(str) {\n        return function () {\n            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';\n        };\n    }\n\n    var uk = moment.defineLocale('uk', {\n        months : {\n            'format': '___________'.split('_'),\n            'standalone': '___________'.split('_')\n        },\n        monthsShort : '___________'.split('_'),\n        weekdays : weekdaysCaseReplace,\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: processHoursFunction('[ '),\n            nextDay: processHoursFunction('[ '),\n            lastDay: processHoursFunction('[ '),\n            nextWeek: processHoursFunction('[] dddd ['),\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                    case 3:\n                    case 5:\n                    case 6:\n                        return processHoursFunction('[] dddd [').call(this);\n                    case 1:\n                    case 2:\n                    case 4:\n                        return processHoursFunction('[] dddd [').call(this);\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            ss : relativeTimeWithPlural,\n            m : relativeTimeWithPlural,\n            mm : relativeTimeWithPlural,\n            h : '',\n            hh : relativeTimeWithPlural,\n            d : '',\n            dd : relativeTimeWithPlural,\n            M : '',\n            MM : relativeTimeWithPlural,\n            y : '',\n            yy : relativeTimeWithPlural\n        },\n        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason\n        meridiemParse: /|||/,\n        isPM: function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}-(|)/,\n        ordinal: function (number, period) {\n            switch (period) {\n                case 'M':\n                case 'd':\n                case 'DDD':\n                case 'w':\n                case 'W':\n                    return number + '-';\n                case 'D':\n                    return number + '-';\n                default:\n                    return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return uk;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ay5qcz85ZWQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwbHVyYWwod29yZCwgbnVtKSB7XG4gICAgICAgIHZhciBmb3JtcyA9IHdvcmQuc3BsaXQoJ18nKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDEwID09PSAxICYmIG51bSAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IChudW0gJSAxMCA+PSAyICYmIG51bSAlIDEwIDw9IDQgJiYgKG51bSAlIDEwMCA8IDEwIHx8IG51bSAlIDEwMCA+PSAyMCkgPyBmb3Jtc1sxXSA6IGZvcm1zWzJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ3NzJzogd2l0aG91dFN1ZmZpeCA/ICfRgdC10LrRg9C90LTQsF/RgdC10LrRg9C90LTQuF/RgdC10LrRg9C90LQnIDogJ9GB0LXQutGD0L3QtNGDX9GB0LXQutGD0L3QtNC4X9GB0LXQutGD0L3QtCcsXG4gICAgICAgICAgICAnbW0nOiB3aXRob3V0U3VmZml4ID8gJ9GF0LLQuNC70LjQvdCwX9GF0LLQuNC70LjQvdC4X9GF0LLQuNC70LjQvScgOiAn0YXQstC40LvQuNC90YNf0YXQstC40LvQuNC90Lhf0YXQstC40LvQuNC9JyxcbiAgICAgICAgICAgICdoaCc6IHdpdGhvdXRTdWZmaXggPyAn0LPQvtC00LjQvdCwX9Cz0L7QtNC40L3QuF/Qs9C+0LTQuNC9JyA6ICfQs9C+0LTQuNC90YNf0LPQvtC00LjQvdC4X9Cz0L7QtNC40L0nLFxuICAgICAgICAgICAgJ2RkJzogJ9C00LXQvdGMX9C00L3Rll/QtNC90ZbQsicsXG4gICAgICAgICAgICAnTU0nOiAn0LzRltGB0Y/RhtGMX9C80ZbRgdGP0YbRll/QvNGW0YHRj9GG0ZbQsicsXG4gICAgICAgICAgICAneXknOiAn0YDRltC6X9GA0L7QutC4X9GA0L7QutGW0LInXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXkgPT09ICdtJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0YXQstC40LvQuNC90LAnIDogJ9GF0LLQuNC70LjQvdGDJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdoJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0LPQvtC00LjQvdCwJyA6ICfQs9C+0LTQuNC90YMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHBsdXJhbChmb3JtYXRba2V5XSwgK251bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Vla2RheXNDYXNlUmVwbGFjZShtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXlzID0ge1xuICAgICAgICAgICAgJ25vbWluYXRpdmUnOiAn0L3QtdC00ZbQu9GPX9C/0L7QvdC10LTRltC70L7Qul/QstGW0LLRgtC+0YDQvtC6X9GB0LXRgNC10LTQsF/Rh9C10YLQstC10YBf0L/igJnRj9GC0L3QuNGG0Y9f0YHRg9Cx0L7RgtCwJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgJ2FjY3VzYXRpdmUnOiAn0L3QtdC00ZbQu9GOX9C/0L7QvdC10LTRltC70L7Qul/QstGW0LLRgtC+0YDQvtC6X9GB0LXRgNC10LTRg1/Rh9C10YLQstC10YBf0L/igJnRj9GC0L3QuNGG0Y5f0YHRg9Cx0L7RgtGDJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgJ2dlbml0aXZlJzogJ9C90LXQtNGW0LvRll/Qv9C+0L3QtdC00ZbQu9C60LBf0LLRltCy0YLQvtGA0LrQsF/RgdC10YDQtdC00Lhf0YfQtdGC0LLQtdGA0LPQsF/Qv+KAmdGP0YLQvdC40YbRll/RgdGD0LHQvtGC0LgnLnNwbGl0KCdfJylcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5c1snbm9taW5hdGl2ZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdW5DYXNlID0gKC8oXFxbW9CS0LLQo9GDXVxcXSkgP2RkZGQvKS50ZXN0KGZvcm1hdCkgP1xuICAgICAgICAgICAgJ2FjY3VzYXRpdmUnIDpcbiAgICAgICAgICAgICgoL1xcWz8oPzrQvNC40L3Rg9C70L7Rl3zQvdCw0YHRgtGD0L/QvdC+0ZcpPyA/XFxdID9kZGRkLykudGVzdChmb3JtYXQpID9cbiAgICAgICAgICAgICAgICAnZ2VuaXRpdmUnIDpcbiAgICAgICAgICAgICAgICAnbm9taW5hdGl2ZScpO1xuICAgICAgICByZXR1cm4gd2Vla2RheXNbbm91bkNhc2VdW20uZGF5KCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzSG91cnNGdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIgKyAn0L4nICsgKHRoaXMuaG91cnMoKSA9PT0gMTEgPyAn0LEnIDogJycpICsgJ10gTFQnO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB1ayA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3VrJywge1xuICAgICAgICBtb250aHMgOiB7XG4gICAgICAgICAgICAnZm9ybWF0JzogJ9GB0ZbRh9C90Y9f0LvRjtGC0L7Qs9C+X9Cx0LXRgNC10LfQvdGPX9C60LLRltGC0L3Rj1/RgtGA0LDQstC90Y9f0YfQtdGA0LLQvdGPX9C70LjQv9C90Y9f0YHQtdGA0L/QvdGPX9Cy0LXRgNC10YHQvdGPX9C20L7QstGC0L3Rj1/Qu9C40YHRgtC+0L/QsNC00LBf0LPRgNGD0LTQvdGPJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgJ3N0YW5kYWxvbmUnOiAn0YHRltGH0LXQvdGMX9C70Y7RgtC40Llf0LHQtdGA0LXQt9C10L3RjF/QutCy0ZbRgtC10L3RjF/RgtGA0LDQstC10L3RjF/Rh9C10YDQstC10L3RjF/Qu9C40L/QtdC90Yxf0YHQtdGA0L/QtdC90Yxf0LLQtdGA0LXRgdC10L3RjF/QttC+0LLRgtC10L3RjF/Qu9C40YHRgtC+0L/QsNC0X9Cz0YDRg9C00LXQvdGMJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GB0ZbRh1/Qu9GO0YJf0LHQtdGAX9C60LLRltGCX9GC0YDQsNCyX9GH0LXRgNCyX9C70LjQv1/RgdC10YDQv1/QstC10YBf0LbQvtCy0YJf0LvQuNGB0YJf0LPRgNGD0LQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogd2Vla2RheXNDYXNlUmVwbGFjZSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVkg0YAuJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSDRgC4sIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkg0YAuLCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9Ch0YzQvtCz0L7QtNC90ZYgJyksXG4gICAgICAgICAgICBuZXh0RGF5OiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9CX0LDQstGC0YDQsCAnKSxcbiAgICAgICAgICAgIGxhc3REYXk6IHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JLRh9C+0YDQsCAnKSxcbiAgICAgICAgICAgIG5leHRXZWVrOiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9CjXSBkZGRkIFsnKSxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9Cc0LjQvdGD0LvQvtGXXSBkZGRkIFsnKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JzQuNC90YPQu9C+0LPQvl0gZGRkZCBbJykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn0LfQsCAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzINGC0L7QvNGDJyxcbiAgICAgICAgICAgIHMgOiAn0LTQtdC60ZbQu9GM0LrQsCDRgdC10LrRg9C90LQnLFxuICAgICAgICAgICAgc3MgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBoIDogJ9Cz0L7QtNC40L3RgycsXG4gICAgICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBkIDogJ9C00LXQvdGMJyxcbiAgICAgICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIE0gOiAn0LzRltGB0Y/RhtGMJyxcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIHkgOiAn0YDRltC6JyxcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICAvLyBNLiBFLjogdGhvc2UgdHdvIGFyZSB2aXJ0dWFsbHkgdW51c2VkIGJ1dCBhIHVzZXIgbWlnaHQgd2FudCB0byBpbXBsZW1lbnQgdGhlbSBmb3IgaGlzL2hlciB3ZWJzaXRlIGZvciBzb21lIHJlYXNvblxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0ZZ80YDQsNC90LrRg3zQtNC90Y980LLQtdGH0L7RgNCwLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9C+0YDQsCkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9GWJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRgNCw0L3QutGDJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfQtNC90Y8nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9Cy0LXRh9C+0YDQsCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0Ll80LPQvikvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LknO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Qs9C+JztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB1aztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdWsuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///122\n");

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var months = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n    var days = [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ];\n\n    var ur = moment.defineLocale('ur', {\n        months : months,\n        monthsShort : months,\n        weekdays : days,\n        weekdaysShort : days,\n        weekdaysMin : days,\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            }\n            return '';\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[  ] LT',\n            lastWeek : '[] dddd [] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/,/g, '');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return ur;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ci5qcz9iOTI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG1vbnRocyA9IFtcbiAgICAgICAgJ9is2YbZiNix24wnLFxuICAgICAgICAn2YHYsdmI2LHbjCcsXG4gICAgICAgICfZhdin2LHahicsXG4gICAgICAgICfYp9m+2LHbjNmEJyxcbiAgICAgICAgJ9mF2KbbjCcsXG4gICAgICAgICfYrNmI2YYnLFxuICAgICAgICAn2KzZiNmE2KfYptuMJyxcbiAgICAgICAgJ9in2q/Ys9iqJyxcbiAgICAgICAgJ9iz2KrZhdio2LEnLFxuICAgICAgICAn2Kfaqdiq2YjYqNixJyxcbiAgICAgICAgJ9mG2YjZhdio2LEnLFxuICAgICAgICAn2K/Ys9mF2KjYsSdcbiAgICBdO1xuICAgIHZhciBkYXlzID0gW1xuICAgICAgICAn2KfYqtmI2KfYsScsXG4gICAgICAgICfZvtuM2LEnLFxuICAgICAgICAn2YXZhtqv2YQnLFxuICAgICAgICAn2KjYr9q+JyxcbiAgICAgICAgJ9is2YXYudix2KfYqicsXG4gICAgICAgICfYrNmF2LnbgScsXG4gICAgICAgICfbgdmB2KrbgSdcbiAgICBdO1xuXG4gICAgdmFyIHVyID0gbW9tZW50LmRlZmluZUxvY2FsZSgndXInLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHMsXG4gICAgICAgIHdlZWtkYXlzIDogZGF5cyxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6IGRheXMsXG4gICAgICAgIHdlZWtkYXlzTWluIDogZGF5cyxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGTYjCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL9i12KjYrXzYtNin2YUvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ9i02KfZhScgPT09IGlucHV0O1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9i12KjYrSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ9i02KfZhSc7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb2KLYrCDYqNmI2YLYql0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb2qnZhCDYqNmI2YLYql0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb2KjZiNmC2KpdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW9qv2LDYtNiq24Eg2LHZiNiyINio2YjZgtiqXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb2q/YsNi02KrbgV0gZGRkZCBb2KjZiNmC2KpdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDYqNi52K8nLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDZgtio2YQnLFxuICAgICAgICAgICAgcyA6ICfahtmG2K8g2LPbjNqp2YbaiCcsXG4gICAgICAgICAgICBzcyA6ICclZCDYs9uM2qnZhtqIJyxcbiAgICAgICAgICAgIG0gOiAn2KfbjNqpINmF2YbZuScsXG4gICAgICAgICAgICBtbSA6ICclZCDZhdmG2bknLFxuICAgICAgICAgICAgaCA6ICfYp9uM2qkg2q/avtmG2bnbgScsXG4gICAgICAgICAgICBoaCA6ICclZCDar9q+2YbZuduSJyxcbiAgICAgICAgICAgIGQgOiAn2KfbjNqpINiv2YYnLFxuICAgICAgICAgICAgZGQgOiAnJWQg2K/ZhicsXG4gICAgICAgICAgICBNIDogJ9in24zaqSDZhdin24EnLFxuICAgICAgICAgICAgTU0gOiAnJWQg2YXYp9uBJyxcbiAgICAgICAgICAgIHkgOiAn2KfbjNqpINiz2KfZhCcsXG4gICAgICAgICAgICB5eSA6ICclZCDYs9in2YQnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLC9nLCAn2IwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXI7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///123\n");

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var uz = moment.defineLocale('uz', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'D MMMM YYYY, dddd HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT []',\n            nextDay : '[] LT []',\n            nextWeek : 'dddd [ ] LT []',\n            lastDay : '[ ] LT []',\n            lastWeek : '[] dddd [ ] LT []',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s ',\n            past : '  %s ',\n            s : '',\n            ss : '%d ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return uz;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei5qcz81ZDRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHV6ID0gbW9tZW50LmRlZmluZUxvY2FsZSgndXonLCB7XG4gICAgICAgIG1vbnRocyA6ICfRj9C90LLQsNGAX9GE0LXQstGA0LDQu1/QvNCw0YDRgl/QsNC/0YDQtdC7X9C80LDQuV/QuNGO0L1f0LjRjtC7X9Cw0LLQs9GD0YHRgl/RgdC10L3RgtGP0LHRgF/QvtC60YLRj9Cx0YBf0L3QvtGP0LHRgF/QtNC10LrQsNCx0YAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GP0L3Qsl/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Llf0LjRjtC9X9C40Y7Qu1/QsNCy0LNf0YHQtdC9X9C+0LrRgl/QvdC+0Y9f0LTQtdC6Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfQr9C60YjQsNC90LHQsF/QlNGD0YjQsNC90LHQsF/QodC10YjQsNC90LHQsF/Qp9C+0YDRiNCw0L3QsdCwX9Cf0LDQudGI0LDQvdCx0LBf0JbRg9C80LBf0KjQsNC90LHQsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfQr9C60Yhf0JTRg9GIX9Ch0LXRiF/Qp9C+0YBf0J/QsNC5X9CW0YPQvF/QqNCw0L0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9Cv0Lpf0JTRg1/QodC1X9Cn0L5f0J/QsF/QltGDX9Co0LAnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdEIE1NTU0gWVlZWSwgZGRkZCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vQkdGD0LPRg9C9INGB0L7QsNGCXSBMVCBb0LTQsF0nLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb0K3RgNGC0LDQs9CwXSBMVCBb0LTQsF0nLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0LrRg9C90Lgg0YHQvtCw0YJdIExUIFvQtNCwXScsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vQmtC10YfQsCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vQo9GC0LPQsNC9XSBkZGRkIFvQutGD0L3QuCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfQr9C60LjQvSAlcyDQuNGH0LjQtNCwJyxcbiAgICAgICAgICAgIHBhc3QgOiAn0JHQuNGAINC90LXRh9CwICVzINC+0LvQtNC40L0nLFxuICAgICAgICAgICAgcyA6ICfRhNGD0YDRgdCw0YInLFxuICAgICAgICAgICAgc3MgOiAnJWQg0YTRg9GA0YHQsNGCJyxcbiAgICAgICAgICAgIG0gOiAn0LHQuNGAINC00LDQutC40LrQsCcsXG4gICAgICAgICAgICBtbSA6ICclZCDQtNCw0LrQuNC60LAnLFxuICAgICAgICAgICAgaCA6ICfQsdC40YAg0YHQvtCw0YInLFxuICAgICAgICAgICAgaGggOiAnJWQg0YHQvtCw0YInLFxuICAgICAgICAgICAgZCA6ICfQsdC40YAg0LrRg9C9JyxcbiAgICAgICAgICAgIGRkIDogJyVkINC60YPQvScsXG4gICAgICAgICAgICBNIDogJ9Cx0LjRgCDQvtC5JyxcbiAgICAgICAgICAgIE1NIDogJyVkINC+0LknLFxuICAgICAgICAgICAgeSA6ICfQsdC40YAg0LnQuNC7JyxcbiAgICAgICAgICAgIHl5IDogJyVkINC50LjQuydcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXo7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///124\n");

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var uzLatn = moment.defineLocale('uz-latn', {\n        months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),\n        monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),\n        weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),\n        weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),\n        weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'D MMMM YYYY, dddd HH:mm'\n        },\n        calendar : {\n            sameDay : '[Bugun soat] LT [da]',\n            nextDay : '[Ertaga] LT [da]',\n            nextWeek : 'dddd [kuni soat] LT [da]',\n            lastDay : '[Kecha soat] LT [da]',\n            lastWeek : '[O\\'tgan] dddd [kuni soat] LT [da]',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'Yaqin %s ichida',\n            past : 'Bir necha %s oldin',\n            s : 'soniya',\n            ss : '%d soniya',\n            m : 'bir daqiqa',\n            mm : '%d daqiqa',\n            h : 'bir soat',\n            hh : '%d soat',\n            d : 'bir kun',\n            dd : '%d kun',\n            M : 'bir oy',\n            MM : '%d oy',\n            y : 'bir yil',\n            yy : '%d yil'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    return uzLatn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei1sYXRuLmpzP2ZkYmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgdXpMYXRuID0gbW9tZW50LmRlZmluZUxvY2FsZSgndXotbGF0bicsIHtcbiAgICAgICAgbW9udGhzIDogJ1lhbnZhcl9GZXZyYWxfTWFydF9BcHJlbF9NYXlfSXl1bl9JeXVsX0F2Z3VzdF9TZW50YWJyX09rdGFicl9Ob3lhYnJfRGVrYWJyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdZYW5fRmV2X01hcl9BcHJfTWF5X0l5dW5fSXl1bF9BdmdfU2VuX09rdF9Ob3lfRGVrJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdZYWtzaGFuYmFfRHVzaGFuYmFfU2VzaGFuYmFfQ2hvcnNoYW5iYV9QYXlzaGFuYmFfSnVtYV9TaGFuYmEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnWWFrX0R1c2hfU2VzaF9DaG9yX1BheV9KdW1fU2hhbicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnWWFfRHVfU2VfQ2hvX1BhX0p1X1NoYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ0QgTU1NTSBZWVlZLCBkZGRkIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW0J1Z3VuIHNvYXRdIExUIFtkYV0nLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbRXJ0YWdhXSBMVCBbZGFdJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2t1bmkgc29hdF0gTFQgW2RhXScsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tLZWNoYSBzb2F0XSBMVCBbZGFdJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tPXFwndGdhbl0gZGRkZCBba3VuaSBzb2F0XSBMVCBbZGFdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdZYXFpbiAlcyBpY2hpZGEnLFxuICAgICAgICAgICAgcGFzdCA6ICdCaXIgbmVjaGEgJXMgb2xkaW4nLFxuICAgICAgICAgICAgcyA6ICdzb25peWEnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc29uaXlhJyxcbiAgICAgICAgICAgIG0gOiAnYmlyIGRhcWlxYScsXG4gICAgICAgICAgICBtbSA6ICclZCBkYXFpcWEnLFxuICAgICAgICAgICAgaCA6ICdiaXIgc29hdCcsXG4gICAgICAgICAgICBoaCA6ICclZCBzb2F0JyxcbiAgICAgICAgICAgIGQgOiAnYmlyIGt1bicsXG4gICAgICAgICAgICBkZCA6ICclZCBrdW4nLFxuICAgICAgICAgICAgTSA6ICdiaXIgb3knLFxuICAgICAgICAgICAgTU0gOiAnJWQgb3knLFxuICAgICAgICAgICAgeSA6ICdiaXIgeWlsJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHlpbCdcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXpMYXRuO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei1sYXRuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///125\n");

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var vi = moment.defineLocale('vi', {\n        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),\n        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),\n        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),\n        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),\n        weekdaysParseExact : true,\n        meridiemParse: /sa|ch/i,\n        isPM : function (input) {\n            return /^ch$/i.test(input);\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 12) {\n                return isLower ? 'sa' : 'SA';\n            } else {\n                return isLower ? 'ch' : 'CH';\n            }\n        },\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM [nm] YYYY',\n            LLL : 'D MMMM [nm] YYYY HH:mm',\n            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',\n            l : 'DD/M/YYYY',\n            ll : 'D MMM YYYY',\n            lll : 'D MMM YYYY HH:mm',\n            llll : 'ddd, D MMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Hm nay lc] LT',\n            nextDay: '[Ngy mai lc] LT',\n            nextWeek: 'dddd [tun ti lc] LT',\n            lastDay: '[Hm qua lc] LT',\n            lastWeek: 'dddd [tun ri lc] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '%s ti',\n            past : '%s trc',\n            s : 'vi giy',\n            ss : '%d giy' ,\n            m : 'mt pht',\n            mm : '%d pht',\n            h : 'mt gi',\n            hh : '%d gi',\n            d : 'mt ngy',\n            dd : '%d ngy',\n            M : 'mt thng',\n            MM : '%d thng',\n            y : 'mt nm',\n            yy : '%d nm'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal : function (number) {\n            return number;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return vi;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS92aS5qcz9kMTdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjEyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHZpID0gbW9tZW50LmRlZmluZUxvY2FsZSgndmknLCB7XG4gICAgICAgIG1vbnRocyA6ICd0aMOhbmcgMV90aMOhbmcgMl90aMOhbmcgM190aMOhbmcgNF90aMOhbmcgNV90aMOhbmcgNl90aMOhbmcgN190aMOhbmcgOF90aMOhbmcgOV90aMOhbmcgMTBfdGjDoW5nIDExX3Row6FuZyAxMicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnVGgwMV9UaDAyX1RoMDNfVGgwNF9UaDA1X1RoMDZfVGgwN19UaDA4X1RoMDlfVGgxMF9UaDExX1RoMTInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICB3ZWVrZGF5cyA6ICdjaOG7pyBuaOG6rXRfdGjhu6kgaGFpX3Ro4bupIGJhX3Ro4bupIHTGsF90aOG7qSBuxINtX3Ro4bupIHPDoXVfdGjhu6kgYuG6o3knLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnQ05fVDJfVDNfVDRfVDVfVDZfVDcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0NOX1QyX1QzX1Q0X1Q1X1Q2X1Q3Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvc2F8Y2gvaSxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eY2gkL2kudGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3NhJyA6ICdTQSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2NoJyA6ICdDSCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gW27Eg21dIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBbbsSDbV0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBbbsSDbV0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBsIDogJ0REL00vWVlZWScsXG4gICAgICAgICAgICBsbCA6ICdEIE1NTSBZWVlZJyxcbiAgICAgICAgICAgIGxsbCA6ICdEIE1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnZGRkLCBEIE1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSMO0bSBuYXkgbMO6Y10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tOZ8OgeSBtYWkgbMO6Y10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt0deG6p24gdOG7m2kgbMO6Y10gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tIw7RtIHF1YSBsw7pjXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW3R14bqnbiBy4buTaSBsw7pjXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyB04bubaScsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHRyxrDhu5tjJyxcbiAgICAgICAgICAgIHMgOiAndsOgaSBnacOieScsXG4gICAgICAgICAgICBzcyA6ICclZCBnacOieScgLFxuICAgICAgICAgICAgbSA6ICdt4buZdCBwaMO6dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBwaMO6dCcsXG4gICAgICAgICAgICBoIDogJ23hu5l0IGdp4budJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGdp4budJyxcbiAgICAgICAgICAgIGQgOiAnbeG7mXQgbmfDoHknLFxuICAgICAgICAgICAgZGQgOiAnJWQgbmfDoHknLFxuICAgICAgICAgICAgTSA6ICdt4buZdCB0aMOhbmcnLFxuICAgICAgICAgICAgTU0gOiAnJWQgdGjDoW5nJyxcbiAgICAgICAgICAgIHkgOiAnbeG7mXQgbsSDbScsXG4gICAgICAgICAgICB5eSA6ICclZCBuxINtJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0vLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmk7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3ZpLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///126\n");

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var xPseudo = moment.defineLocale('x-pseudo', {\n        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),\n        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),\n        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),\n        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT : 'HH:mm',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[T~d~ t] LT',\n            nextDay : '[T~m~rr~w t] LT',\n            nextWeek : 'dddd [t] LT',\n            lastDay : '[~st~rd~ t] LT',\n            lastWeek : '[L~st] dddd [t] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '~ %s',\n            past : '%s ~g',\n            s : ' ~fw ~sc~ds',\n            ss : '%d s~c~ds',\n            m : ' ~m~t',\n            mm : '%d m~~ts',\n            h : '~ h~r',\n            hh : '%d h~rs',\n            d : ' ~d',\n            dd : '%d d~s',\n            M : ' ~m~th',\n            MM : '%d m~t~hs',\n            y : ' ~r',\n            yy : '%d ~rs'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return xPseudo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS94LXBzZXVkby5qcz83YmYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgeFBzZXVkbyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3gtcHNldWRvJywge1xuICAgICAgICBtb250aHMgOiAnSn7DocOxw7rDoX5yw71fRn7DqWJyw7p+w6Fyw71ffk3DoXJjfmhfw4FwfnLDrWxffk3DocO9X35Kw7rDscOpfl9Kw7psfsO9X8OBw7p+Z8O6c3R+X1PDqXB+dMOpbWJ+w6lyX8OTfmN0w7NifsOpcl/DkX7Ds3bDqW1+YsOpcl9+RMOpY8Opfm1iw6lyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKfsOhw7FffkbDqWJffk3DoXJffsOBcHJffk3DocO9X35Kw7rDsV9+SsO6bF9+w4HDumdfflPDqXBffsOTY3RffsORw7N2X35Ew6ljJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICAgICAgd2Vla2RheXMgOiAnU37DusOxZMOhfsO9X03Ds37DsWTDocO9fl9Uw7rDqX5zZMOhw71+X1fDqWR+w7HDqXNkfsOhw71fVH5ow7pyc35kw6HDvV9+RnLDrWR+w6HDvV9TfsOhdMO6cn5kw6HDvScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdTfsO6w7Fffk3Ds8OxX35Uw7rDqV9+V8OpZF9+VGjDul9+RnLDrV9+U8OhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU37Dul9Nw7N+X1TDul9+V8OpX1R+aF9Gcn5fU8OhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUfsOzZMOhfsO9IMOhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVH7Ds23Ds35ycsOzfncgw6F0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvDoXRdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW8OdfsOpc3R+w6lyZMOhfsO9IMOhdF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW0x+w6FzdF0gZGRkZCBbw6F0XSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnw61+w7EgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDDoX5nw7MnLFxuICAgICAgICAgICAgcyA6ICfDoSB+ZsOpdyB+c8OpY8OzfsOxZHMnLFxuICAgICAgICAgICAgc3MgOiAnJWQgc37DqWPDs8OxfmRzJyxcbiAgICAgICAgICAgIG0gOiAnw6Egfm3DrcOxfsO6dMOpJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1+w63DscO6fnTDqXMnLFxuICAgICAgICAgICAgaCA6ICfDoX7DsSBow7N+w7pyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGh+w7PDunJzJyxcbiAgICAgICAgICAgIGQgOiAnw6EgfmTDocO9JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGR+w6HDvXMnLFxuICAgICAgICAgICAgTSA6ICfDoSB+bcOzw7F+dGgnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbX7Ds8OxdH5ocycsXG4gICAgICAgICAgICB5IDogJ8OhIH7DvcOpw6FyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIMO9fsOpw6FycydcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB4UHNldWRvO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS94LXBzZXVkby5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///127\n");

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var yo = moment.defineLocale('yo', {\n        months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),\n        monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),\n        weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),\n        weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),\n        weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Oni ni] LT',\n            nextDay : '[la ni] LT',\n            nextWeek : 'dddd [s ton\\'b] [ni] LT',\n            lastDay : '[Ana ni] LT',\n            lastWeek : 'dddd [s tol] [ni] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'ni %s',\n            past : '%s kja',\n            s : 'isju aaya die',\n            ss :'aaya %d',\n            m : 'isju kan',\n            mm : 'isju %d',\n            h : 'wakati kan',\n            hh : 'wakati %d',\n            d : 'j kan',\n            dd : 'j %d',\n            M : 'osu kan',\n            MM : 'osu %d',\n            y : 'dun kan',\n            yy : 'dun %d'\n        },\n        dayOfMonthOrdinalParse : /j\\s\\d{1,2}/,\n        ordinal : 'j %d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4 // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return yo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS95by5qcz82MTc5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgeW8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd5bycsIHtcbiAgICAgICAgbW9udGhzIDogJ1PhurnMgXLhurnMgV9FzIByZcyAbGXMgF/hurhy4bq5zIBuYcyAX0nMgGdiZcyBX0XMgGJpYmlfT8yAa3XMgGR1X0Fn4bq5bW9fT8yAZ3XMgW5fT3dld2Vf4buMzIB3YcyAcmHMgF9CZcyBbHXMgV/hu4zMgHDhurnMgMyAJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdT4bq5zIFyX0XMgHJsX+G6uHJuX0nMgGdiX0XMgGJpX0/MgGt1zIBfQWfhurlfT8yAZ3XMgV9Pd2Vf4buMzIB3YcyAX0JlzIFsX+G7jMyAcOG6ucyAzIAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0HMgGnMgGt1zIFfQWplzIFfScyAc+G6ucyBZ3VuX+G7jGrhu43MgXJ1zIFf4buMauG7jcyBYuG7jV/hurh0acyAX0HMgGJhzIFt4bq5zIF0YScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdBzIBpzIBrX0FqZcyBX0nMgHPhurnMgV/hu4xqcl/hu4xqYl/hurh0acyAX0HMgGJhzIEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0HMgGnMgF9Bal9JzIBzX+G7jHJf4buMYl/hurh0X0HMgGInLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbT8yAbmnMgCBuaV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb4buMzIBsYSBuaV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb4buMc+G6ucyAIHRvzIFuXFwnYuG7jV0gW25pXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tBzIBuYSBuaV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBb4buMc+G6ucyAIHRvzIFs4buNzIFdIFtuaV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ25pzIEgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBr4buNamHMgScsXG4gICAgICAgICAgICBzIDogJ2nMgHPhurlqdcyBIGFheWHMgSBkaWUnLFxuICAgICAgICAgICAgc3MgOidhYXlhzIEgJWQnLFxuICAgICAgICAgICAgbSA6ICdpzIBz4bq5anXMgSBrYW4nLFxuICAgICAgICAgICAgbW0gOiAnacyAc+G6uWp1zIEgJWQnLFxuICAgICAgICAgICAgaCA6ICd3YcyBa2F0aSBrYW4nLFxuICAgICAgICAgICAgaGggOiAnd2HMgWthdGkgJWQnLFxuICAgICAgICAgICAgZCA6ICfhu41q4buNzIEga2FuJyxcbiAgICAgICAgICAgIGRkIDogJ+G7jWrhu43MgSAlZCcsXG4gICAgICAgICAgICBNIDogJ29zdcyAIGthbicsXG4gICAgICAgICAgICBNTSA6ICdvc3XMgCAlZCcsXG4gICAgICAgICAgICB5IDogJ+G7jWR1zIFuIGthbicsXG4gICAgICAgICAgICB5eSA6ICfhu41kdcyBbiAlZCdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC/hu41q4buNzIFcXHNcXGR7MSwyfS8sXG4gICAgICAgIG9yZGluYWwgOiAn4buNauG7jcyBICVkJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB5bztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveW8uanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///128\n");

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var zhCn = moment.defineLocale('zh-cn', {\n        months : '___________'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYYMD',\n            LLL : 'YYYYMDAhmm',\n            LLLL : 'YYYYMDddddAhmm',\n            l : 'YYYY/M/D',\n            ll : 'YYYYMD',\n            lll : 'YYYYMD HH:mm',\n            llll : 'YYYYMDdddd HH:mm'\n        },\n        meridiemParse: /|||||/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '' || meridiem === '' ||\n                    meridiem === '') {\n                return hour;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour + 12;\n            } else {\n                // ''\n                return hour >= 11 ? hour : hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            var hm = hour * 100 + minute;\n            if (hm < 600) {\n                return '';\n            } else if (hm < 900) {\n                return '';\n            } else if (hm < 1130) {\n                return '';\n            } else if (hm < 1230) {\n                return '';\n            } else if (hm < 1800) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[]LT',\n            nextDay : '[]LT',\n            nextWeek : '[]ddddLT',\n            lastDay : '[]LT',\n            lastWeek : '[]ddddLT',\n            sameElse : 'L'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(||)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                case 'd':\n                case 'D':\n                case 'DDD':\n                    return number + '';\n                case 'M':\n                    return number + '';\n                case 'w':\n                case 'W':\n                    return number + '';\n                default:\n                    return number;\n            }\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            ss : '%d ',\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        },\n        week : {\n            // GB/T 7408-1994ISO 8601:1988\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return zhCn;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1jbi5qcz81NzNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiMTI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgemhDbiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3poLWNuJywge1xuICAgICAgICBtb250aHMgOiAn5LiA5pyIX+S6jOaciF/kuInmnIhf5Zub5pyIX+S6lOaciF/lha3mnIhf5LiD5pyIX+WFq+aciF/kuZ3mnIhf5Y2B5pyIX+WNgeS4gOaciF/ljYHkuozmnIgnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn5ZGo5pelX+WRqOS4gF/lkajkuoxf5ZGo5LiJX+WRqOWbm1/lkajkupRf5ZGo5YWtJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfml6Vf5LiAX+S6jF/kuIlf5ZubX+S6lF/lha0nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS9NTS9ERCcsXG4gICAgICAgICAgICBMTCA6ICdZWVlZ5bm0TeaciETml6UnLFxuICAgICAgICAgICAgTExMIDogJ1lZWVnlubRN5pyIROaXpUFo54K5bW3liIYnLFxuICAgICAgICAgICAgTExMTCA6ICdZWVlZ5bm0TeaciETml6VkZGRkQWjngrltbeWIhicsXG4gICAgICAgICAgICBsIDogJ1lZWVkvTS9EJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVnlubRN5pyIROaXpScsXG4gICAgICAgICAgICBsbGwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnWVlZWeW5tE3mnIhE5pelZGRkZCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+WHjOaZqHzml6nkuIp85LiK5Y2IfOS4reWNiHzkuIvljYh85pma5LiKLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn5YeM5pmoJyB8fCBtZXJpZGllbSA9PT0gJ+aXqeS4iicgfHxcbiAgICAgICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfkuIrljYgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAn5Lit5Y2IJ1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBob3VyICogMTAwICsgbWludXRlO1xuICAgICAgICAgICAgaWYgKGhtIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICflh4zmmagnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDkwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5pep5LiKJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMTMwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfkuIrljYgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDEyMzApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+S4reWNiCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTgwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5LiL5Y2IJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfmmZrkuIonO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW+S7iuWkqV1MVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vmmI7lpKldTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnW+S4i11kZGRkTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb5pio5aSpXUxUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vkuIpdZGRkZExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjml6V85pyIfOWRqCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pelJztcbiAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfmnIgnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+WRqCc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVz5YaFJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPliY0nLFxuICAgICAgICAgICAgcyA6ICflh6Dnp5InLFxuICAgICAgICAgICAgc3MgOiAnJWQg56eSJyxcbiAgICAgICAgICAgIG0gOiAnMSDliIbpkp8nLFxuICAgICAgICAgICAgbW0gOiAnJWQg5YiG6ZKfJyxcbiAgICAgICAgICAgIGggOiAnMSDlsI/ml7YnLFxuICAgICAgICAgICAgaGggOiAnJWQg5bCP5pe2JyxcbiAgICAgICAgICAgIGQgOiAnMSDlpKknLFxuICAgICAgICAgICAgZGQgOiAnJWQg5aSpJyxcbiAgICAgICAgICAgIE0gOiAnMSDkuKrmnIgnLFxuICAgICAgICAgICAgTU0gOiAnJWQg5Liq5pyIJyxcbiAgICAgICAgICAgIHkgOiAnMSDlubQnLFxuICAgICAgICAgICAgeXkgOiAnJWQg5bm0J1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgLy8gR0IvVCA3NDA4LTE5OTTjgIrmlbDmja7lhYPlkozkuqTmjaLmoLzlvI/Ct+S/oeaBr+S6pOaNosK35pel5pyf5ZKM5pe26Ze06KGo56S65rOV44CL5LiOSVNPIDg2MDE6MTk4OOetieaViFxuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB6aENuO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1jbi5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///129\n");

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var zhHk = moment.defineLocale('zh-hk', {\n        months : '___________'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYYMD',\n            LLL : 'YYYYMD HH:mm',\n            LLLL : 'YYYYMDdddd HH:mm',\n            l : 'YYYY/M/D',\n            ll : 'YYYYMD',\n            lll : 'YYYYMD HH:mm',\n            llll : 'YYYYMDdddd HH:mm'\n        },\n        meridiemParse: /|||||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '' || meridiem === '' || meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            var hm = hour * 100 + minute;\n            if (hm < 600) {\n                return '';\n            } else if (hm < 900) {\n                return '';\n            } else if (hm < 1130) {\n                return '';\n            } else if (hm < 1230) {\n                return '';\n            } else if (hm < 1800) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[]LT',\n            nextDay : '[]LT',\n            nextWeek : '[]ddddLT',\n            lastDay : '[]LT',\n            lastWeek : '[]ddddLT',\n            sameElse : 'L'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(||)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                case 'd' :\n                case 'D' :\n                case 'DDD' :\n                    return number + '';\n                case 'M' :\n                    return number + '';\n                case 'w' :\n                case 'W' :\n                    return number + '';\n                default :\n                    return number;\n            }\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            ss : '%d ',\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        }\n    });\n\n    return zhHk;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1oay5qcz82NTRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6aEhrID0gbW9tZW50LmRlZmluZUxvY2FsZSgnemgtaGsnLCB7XG4gICAgICAgIG1vbnRocyA6ICfkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+aYn+acn+aXpV/mmJ/mnJ/kuIBf5pif5pyf5LqMX+aYn+acn+S4iV/mmJ/mnJ/lm5tf5pif5pyf5LqUX+aYn+acn+WFrScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfpgLHml6Vf6YCx5LiAX+mAseS6jF/pgLHkuIlf6YCx5ZubX+mAseS6lF/pgLHlha0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+aXpV/kuIBf5LqMX+S4iV/lm5tf5LqUX+WFrScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdZWVlZL01NL0REJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVnlubRN5pyIROaXpScsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWeW5tE3mnIhE5pelZGRkZCBISDptbScsXG4gICAgICAgICAgICBsIDogJ1lZWVkvTS9EJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVnlubRN5pyIROaXpScsXG4gICAgICAgICAgICBsbGwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnWVlZWeW5tE3mnIhE5pelZGRkZCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+WHjOaZqHzml6nkuIp85LiK5Y2IfOS4reWNiHzkuIvljYh85pma5LiKLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+WHjOaZqCcgfHwgbWVyaWRpZW0gPT09ICfml6nkuIonIHx8IG1lcmlkaWVtID09PSAn5LiK5Y2IJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+S4reWNiCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIHZhciBobSA9IGhvdXIgKiAxMDAgKyBtaW51dGU7XG4gICAgICAgICAgICBpZiAoaG0gPCA2MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+WHjOaZqCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgOTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDExMzApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+S4iuWNiCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5Lit5Y2IJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxODAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+aZmuS4iic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb5LuK5aSpXUxUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+aYjuWkqV1MVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdb5LiLXWRkZGRMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vmmKjlpKldTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+S4il1kZGRkTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KOaXpXzmnIh86YCxKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCcgOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0QnIDpcbiAgICAgICAgICAgICAgICBjYXNlICdEREQnIDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfml6UnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nIDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfmnIgnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3cnIDpcbiAgICAgICAgICAgICAgICBjYXNlICdXJyA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn6YCxJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVz5YWnJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPliY0nLFxuICAgICAgICAgICAgcyA6ICflub7np5InLFxuICAgICAgICAgICAgc3MgOiAnJWQg56eSJyxcbiAgICAgICAgICAgIG0gOiAnMSDliIbpkJgnLFxuICAgICAgICAgICAgbW0gOiAnJWQg5YiG6ZCYJyxcbiAgICAgICAgICAgIGggOiAnMSDlsI/mmYInLFxuICAgICAgICAgICAgaGggOiAnJWQg5bCP5pmCJyxcbiAgICAgICAgICAgIGQgOiAnMSDlpKknLFxuICAgICAgICAgICAgZGQgOiAnJWQg5aSpJyxcbiAgICAgICAgICAgIE0gOiAnMSDlgIvmnIgnLFxuICAgICAgICAgICAgTU0gOiAnJWQg5YCL5pyIJyxcbiAgICAgICAgICAgIHkgOiAnMSDlubQnLFxuICAgICAgICAgICAgeXkgOiAnJWQg5bm0J1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gemhIaztcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///130\n");

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

eval("//! moment.js locale configuration\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(8)) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    var zhTw = moment.defineLocale('zh-tw', {\n        months : '___________'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYYMD',\n            LLL : 'YYYYMD HH:mm',\n            LLLL : 'YYYYMDdddd HH:mm',\n            l : 'YYYY/M/D',\n            ll : 'YYYYMD',\n            lll : 'YYYYMD HH:mm',\n            llll : 'YYYYMDdddd HH:mm'\n        },\n        meridiemParse: /|||||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '' || meridiem === '' || meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            var hm = hour * 100 + minute;\n            if (hm < 600) {\n                return '';\n            } else if (hm < 900) {\n                return '';\n            } else if (hm < 1130) {\n                return '';\n            } else if (hm < 1230) {\n                return '';\n            } else if (hm < 1800) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[]dddd LT',\n            lastDay : '[] LT',\n            lastWeek : '[]dddd LT',\n            sameElse : 'L'\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}(||)/,\n        ordinal : function (number, period) {\n            switch (period) {\n                case 'd' :\n                case 'D' :\n                case 'DDD' :\n                    return number + '';\n                case 'M' :\n                    return number + '';\n                case 'w' :\n                case 'W' :\n                    return number + '';\n                default :\n                    return number;\n            }\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            ss : '%d ',\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        }\n    });\n\n    return zhTw;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC10dy5qcz8wNWI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6aFR3ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnemgtdHcnLCB7XG4gICAgICAgIG1vbnRocyA6ICfkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+aYn+acn+aXpV/mmJ/mnJ/kuIBf5pif5pyf5LqMX+aYn+acn+S4iV/mmJ/mnJ/lm5tf5pif5pyf5LqUX+aYn+acn+WFrScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfpgLHml6Vf6YCx5LiAX+mAseS6jF/pgLHkuIlf6YCx5ZubX+mAseS6lF/pgLHlha0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+aXpV/kuIBf5LqMX+S4iV/lm5tf5LqUX+WFrScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdZWVlZL01NL0REJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVnlubRN5pyIROaXpScsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWeW5tE3mnIhE5pelZGRkZCBISDptbScsXG4gICAgICAgICAgICBsIDogJ1lZWVkvTS9EJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVnlubRN5pyIROaXpScsXG4gICAgICAgICAgICBsbGwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnWVlZWeW5tE3mnIhE5pelZGRkZCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+WHjOaZqHzml6nkuIp85LiK5Y2IfOS4reWNiHzkuIvljYh85pma5LiKLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+WHjOaZqCcgfHwgbWVyaWRpZW0gPT09ICfml6nkuIonIHx8IG1lcmlkaWVtID09PSAn5LiK5Y2IJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+S4reWNiCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIHZhciBobSA9IGhvdXIgKiAxMDAgKyBtaW51dGU7XG4gICAgICAgICAgICBpZiAoaG0gPCA2MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+WHjOaZqCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgOTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDExMzApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+S4iuWNiCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5Lit5Y2IJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxODAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+aZmuS4iic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb5LuK5aSpXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vmmI7lpKldIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vkuItdZGRkZCBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vmmKjlpKldIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vkuIpdZGRkZCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0o5pelfOaciHzpgLEpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkJyA6XG4gICAgICAgICAgICAgICAgY2FzZSAnRCcgOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RERCcgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aXpSc7XG4gICAgICAgICAgICAgICAgY2FzZSAnTScgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aciCc7XG4gICAgICAgICAgICAgICAgY2FzZSAndycgOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1cnIDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfpgLEnO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXPlhacnLFxuICAgICAgICAgICAgcGFzdCA6ICclc+WJjScsXG4gICAgICAgICAgICBzIDogJ+W5vuenkicsXG4gICAgICAgICAgICBzcyA6ICclZCDnp5InLFxuICAgICAgICAgICAgbSA6ICcxIOWIhumQmCcsXG4gICAgICAgICAgICBtbSA6ICclZCDliIbpkJgnLFxuICAgICAgICAgICAgaCA6ICcxIOWwj+aZgicsXG4gICAgICAgICAgICBoaCA6ICclZCDlsI/mmYInLFxuICAgICAgICAgICAgZCA6ICcxIOWkqScsXG4gICAgICAgICAgICBkZCA6ICclZCDlpKknLFxuICAgICAgICAgICAgTSA6ICcxIOWAi+aciCcsXG4gICAgICAgICAgICBNTSA6ICclZCDlgIvmnIgnLFxuICAgICAgICAgICAgeSA6ICcxIOW5tCcsXG4gICAgICAgICAgICB5eSA6ICclZCDlubQnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB6aFR3O1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC10dy5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///131\n");

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FullCalendar v3.9.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2018 Adam Shaw\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(8), __webpack_require__(7));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"moment\", \"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FullCalendar\"] = factory(require(\"moment\"), require(\"jquery\"));\n\telse\n\t\troot[\"FullCalendar\"] = factory(root[\"moment\"], root[\"jQuery\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 236);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports) {\n\n/*\r\nderived from:\r\nhttps://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js\r\n\nonly include the helpers we need, to keep down filesize\r\n*/\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b)\r\n        if (b.hasOwnProperty(p))\r\n            d[p] = b[p]; };\r\nexports.__extends = function (d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\n/* FullCalendar-specific DOM Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\r\n// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\r\nfunction compensateScroll(rowEls, scrollbarWidths) {\r\n    if (scrollbarWidths.left) {\r\n        rowEls.css({\r\n            'border-left-width': 1,\r\n            'margin-left': scrollbarWidths.left - 1\r\n        });\r\n    }\r\n    if (scrollbarWidths.right) {\r\n        rowEls.css({\r\n            'border-right-width': 1,\r\n            'margin-right': scrollbarWidths.right - 1\r\n        });\r\n    }\r\n}\r\nexports.compensateScroll = compensateScroll;\r\n// Undoes compensateScroll and restores all borders/margins\r\nfunction uncompensateScroll(rowEls) {\r\n    rowEls.css({\r\n        'margin-left': '',\r\n        'margin-right': '',\r\n        'border-left-width': '',\r\n        'border-right-width': ''\r\n    });\r\n}\r\nexports.uncompensateScroll = uncompensateScroll;\r\n// Make the mouse cursor express that an event is not allowed in the current area\r\nfunction disableCursor() {\r\n    $('body').addClass('fc-not-allowed');\r\n}\r\nexports.disableCursor = disableCursor;\r\n// Returns the mouse cursor to its original look\r\nfunction enableCursor() {\r\n    $('body').removeClass('fc-not-allowed');\r\n}\r\nexports.enableCursor = enableCursor;\r\n// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\r\n// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\r\n// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and\r\n// reduces the available height.\r\nfunction distributeHeight(els, availableHeight, shouldRedistribute) {\r\n    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\r\n    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\r\n    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\r\n    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\r\n    var flexEls = []; // elements that are allowed to expand. array of DOM nodes\r\n    var flexOffsets = []; // amount of vertical space it takes up\r\n    var flexHeights = []; // actual css height\r\n    var usedHeight = 0;\r\n    undistributeHeight(els); // give all elements their natural height\r\n    // find elements that are below the recommended height (expandable).\r\n    // important to query for heights in a single first pass (to avoid reflow oscillation).\r\n    els.each(function (i, el) {\r\n        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\r\n        var naturalOffset = $(el).outerHeight(true);\r\n        if (naturalOffset < minOffset) {\r\n            flexEls.push(el);\r\n            flexOffsets.push(naturalOffset);\r\n            flexHeights.push($(el).height());\r\n        }\r\n        else {\r\n            // this element stretches past recommended height (non-expandable). mark the space as occupied.\r\n            usedHeight += naturalOffset;\r\n        }\r\n    });\r\n    // readjust the recommended height to only consider the height available to non-maxed-out rows.\r\n    if (shouldRedistribute) {\r\n        availableHeight -= usedHeight;\r\n        minOffset1 = Math.floor(availableHeight / flexEls.length);\r\n        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\r\n    }\r\n    // assign heights to all expandable elements\r\n    $(flexEls).each(function (i, el) {\r\n        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\r\n        var naturalOffset = flexOffsets[i];\r\n        var naturalHeight = flexHeights[i];\r\n        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\r\n        if (naturalOffset < minOffset) {\r\n            $(el).height(newHeight);\r\n        }\r\n    });\r\n}\r\nexports.distributeHeight = distributeHeight;\r\n// Undoes distrubuteHeight, restoring all els to their natural height\r\nfunction undistributeHeight(els) {\r\n    els.height('');\r\n}\r\nexports.undistributeHeight = undistributeHeight;\r\n// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\r\n// cells to be that width.\r\n// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\r\nfunction matchCellWidths(els) {\r\n    var maxInnerWidth = 0;\r\n    els.find('> *').each(function (i, innerEl) {\r\n        var innerWidth = $(innerEl).outerWidth();\r\n        if (innerWidth > maxInnerWidth) {\r\n            maxInnerWidth = innerWidth;\r\n        }\r\n    });\r\n    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\r\n    els.width(maxInnerWidth);\r\n    return maxInnerWidth;\r\n}\r\nexports.matchCellWidths = matchCellWidths;\r\n// Given one element that resides inside another,\r\n// Subtracts the height of the inner element from the outer element.\r\nfunction subtractInnerElHeight(outerEl, innerEl) {\r\n    var both = outerEl.add(innerEl);\r\n    var diff;\r\n    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\r\n    both.css({\r\n        position: 'relative',\r\n        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\r\n    });\r\n    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\r\n    both.css({ position: '', left: '' }); // undo hack\r\n    return diff;\r\n}\r\nexports.subtractInnerElHeight = subtractInnerElHeight;\r\n/* Element Geom Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\r\nfunction getScrollParent(el) {\r\n    var position = el.css('position');\r\n    var scrollParent = el.parents().filter(function () {\r\n        var parent = $(this);\r\n        return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));\r\n    }).eq(0);\r\n    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\r\n}\r\nexports.getScrollParent = getScrollParent;\r\n// Queries the outer bounding area of a jQuery element.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\nfunction getOuterRect(el, origin) {\r\n    var offset = el.offset();\r\n    var left = offset.left - (origin ? origin.left : 0);\r\n    var top = offset.top - (origin ? origin.top : 0);\r\n    return {\r\n        left: left,\r\n        right: left + el.outerWidth(),\r\n        top: top,\r\n        bottom: top + el.outerHeight()\r\n    };\r\n}\r\nexports.getOuterRect = getOuterRect;\r\n// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\n// WARNING: given element can't have borders\r\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\r\nfunction getClientRect(el, origin) {\r\n    var offset = el.offset();\r\n    var scrollbarWidths = getScrollbarWidths(el);\r\n    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\r\n    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\r\n    return {\r\n        left: left,\r\n        right: left + el[0].clientWidth,\r\n        top: top,\r\n        bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\r\n    };\r\n}\r\nexports.getClientRect = getClientRect;\r\n// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\nfunction getContentRect(el, origin) {\r\n    var offset = el.offset(); // just outside of border, margin not included\r\n    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\r\n        (origin ? origin.left : 0);\r\n    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\r\n        (origin ? origin.top : 0);\r\n    return {\r\n        left: left,\r\n        right: left + el.width(),\r\n        top: top,\r\n        bottom: top + el.height()\r\n    };\r\n}\r\nexports.getContentRect = getContentRect;\r\n// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\r\n// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).\r\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\r\nfunction getScrollbarWidths(el) {\r\n    var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;\r\n    var bottomWidth = el[0].offsetHeight - el[0].clientHeight;\r\n    var widths;\r\n    leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);\r\n    bottomWidth = sanitizeScrollbarWidth(bottomWidth);\r\n    widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };\r\n    if (getIsLeftRtlScrollbars() && el.css('direction') === 'rtl') {\r\n        widths.left = leftRightWidth;\r\n    }\r\n    else {\r\n        widths.right = leftRightWidth;\r\n    }\r\n    return widths;\r\n}\r\nexports.getScrollbarWidths = getScrollbarWidths;\r\n// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to\r\n// retina displays, rounding, and IE11. Massage them into a usable value.\r\nfunction sanitizeScrollbarWidth(width) {\r\n    width = Math.max(0, width); // no negatives\r\n    width = Math.round(width);\r\n    return width;\r\n}\r\n// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\r\nvar _isLeftRtlScrollbars = null;\r\nfunction getIsLeftRtlScrollbars() {\r\n    if (_isLeftRtlScrollbars === null) {\r\n        _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\r\n    }\r\n    return _isLeftRtlScrollbars;\r\n}\r\nfunction computeIsLeftRtlScrollbars() {\r\n    var el = $('<div><div/></div>')\r\n        .css({\r\n        position: 'absolute',\r\n        top: -1000,\r\n        left: 0,\r\n        border: 0,\r\n        padding: 0,\r\n        overflow: 'scroll',\r\n        direction: 'rtl'\r\n    })\r\n        .appendTo('body');\r\n    var innerEl = el.children();\r\n    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\r\n    el.remove();\r\n    return res;\r\n}\r\n// Retrieves a jQuery element's computed CSS value as a floating-point number.\r\n// If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\r\nfunction getCssFloat(el, prop) {\r\n    return parseFloat(el.css(prop)) || 0;\r\n}\r\n/* Mouse / Touch Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\r\nfunction isPrimaryMouseButton(ev) {\r\n    return ev.which === 1 && !ev.ctrlKey;\r\n}\r\nexports.isPrimaryMouseButton = isPrimaryMouseButton;\r\nfunction getEvX(ev) {\r\n    var touches = ev.originalEvent.touches;\r\n    // on mobile FF, pageX for touch events is present, but incorrect,\r\n    // so, look at touch coordinates first.\r\n    if (touches && touches.length) {\r\n        return touches[0].pageX;\r\n    }\r\n    return ev.pageX;\r\n}\r\nexports.getEvX = getEvX;\r\nfunction getEvY(ev) {\r\n    var touches = ev.originalEvent.touches;\r\n    // on mobile FF, pageX for touch events is present, but incorrect,\r\n    // so, look at touch coordinates first.\r\n    if (touches && touches.length) {\r\n        return touches[0].pageY;\r\n    }\r\n    return ev.pageY;\r\n}\r\nexports.getEvY = getEvY;\r\nfunction getEvIsTouch(ev) {\r\n    return /^touch/.test(ev.type);\r\n}\r\nexports.getEvIsTouch = getEvIsTouch;\r\nfunction preventSelection(el) {\r\n    el.addClass('fc-unselectable')\r\n        .on('selectstart', preventDefault);\r\n}\r\nexports.preventSelection = preventSelection;\r\nfunction allowSelection(el) {\r\n    el.removeClass('fc-unselectable')\r\n        .off('selectstart', preventDefault);\r\n}\r\nexports.allowSelection = allowSelection;\r\n// Stops a mouse/touch event from doing it's native browser action\r\nfunction preventDefault(ev) {\r\n    ev.preventDefault();\r\n}\r\nexports.preventDefault = preventDefault;\r\n/* General Geometry Utils\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\r\nfunction intersectRects(rect1, rect2) {\r\n    var res = {\r\n        left: Math.max(rect1.left, rect2.left),\r\n        right: Math.min(rect1.right, rect2.right),\r\n        top: Math.max(rect1.top, rect2.top),\r\n        bottom: Math.min(rect1.bottom, rect2.bottom)\r\n    };\r\n    if (res.left < res.right && res.top < res.bottom) {\r\n        return res;\r\n    }\r\n    return false;\r\n}\r\nexports.intersectRects = intersectRects;\r\n// Returns a new point that will have been moved to reside within the given rectangle\r\nfunction constrainPoint(point, rect) {\r\n    return {\r\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\r\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\r\n    };\r\n}\r\nexports.constrainPoint = constrainPoint;\r\n// Returns a point that is the center of the given rectangle\r\nfunction getRectCenter(rect) {\r\n    return {\r\n        left: (rect.left + rect.right) / 2,\r\n        top: (rect.top + rect.bottom) / 2\r\n    };\r\n}\r\nexports.getRectCenter = getRectCenter;\r\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\r\nfunction diffPoints(point1, point2) {\r\n    return {\r\n        left: point1.left - point2.left,\r\n        top: point1.top - point2.top\r\n    };\r\n}\r\nexports.diffPoints = diffPoints;\r\n/* Object Ordering by Field\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nfunction parseFieldSpecs(input) {\r\n    var specs = [];\r\n    var tokens = [];\r\n    var i;\r\n    var token;\r\n    if (typeof input === 'string') {\r\n        tokens = input.split(/\\s*,\\s*/);\r\n    }\r\n    else if (typeof input === 'function') {\r\n        tokens = [input];\r\n    }\r\n    else if ($.isArray(input)) {\r\n        tokens = input;\r\n    }\r\n    for (i = 0; i < tokens.length; i++) {\r\n        token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            specs.push(token.charAt(0) === '-' ?\r\n                { field: token.substring(1), order: -1 } :\r\n                { field: token, order: 1 });\r\n        }\r\n        else if (typeof token === 'function') {\r\n            specs.push({ func: token });\r\n        }\r\n    }\r\n    return specs;\r\n}\r\nexports.parseFieldSpecs = parseFieldSpecs;\r\nfunction compareByFieldSpecs(obj1, obj2, fieldSpecs, obj1fallback, obj2fallback) {\r\n    var i;\r\n    var cmp;\r\n    for (i = 0; i < fieldSpecs.length; i++) {\r\n        cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i], obj1fallback, obj2fallback);\r\n        if (cmp) {\r\n            return cmp;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nexports.compareByFieldSpecs = compareByFieldSpecs;\r\nfunction compareByFieldSpec(obj1, obj2, fieldSpec, obj1fallback, obj2fallback) {\r\n    if (fieldSpec.func) {\r\n        return fieldSpec.func(obj1, obj2);\r\n    }\r\n    var val1 = obj1[fieldSpec.field];\r\n    var val2 = obj2[fieldSpec.field];\r\n    if (val1 == null && obj1fallback) {\r\n        val1 = obj1fallback[fieldSpec.field];\r\n    }\r\n    if (val2 == null && obj2fallback) {\r\n        val2 = obj2fallback[fieldSpec.field];\r\n    }\r\n    return flexibleCompare(val1, val2) * (fieldSpec.order || 1);\r\n}\r\nexports.compareByFieldSpec = compareByFieldSpec;\r\nfunction flexibleCompare(a, b) {\r\n    if (!a && !b) {\r\n        return 0;\r\n    }\r\n    if (b == null) {\r\n        return -1;\r\n    }\r\n    if (a == null) {\r\n        return 1;\r\n    }\r\n    if ($.type(a) === 'string' || $.type(b) === 'string') {\r\n        return String(a).localeCompare(String(b));\r\n    }\r\n    return a - b;\r\n}\r\nexports.flexibleCompare = flexibleCompare;\r\n/* Date Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nexports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\r\nexports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending\r\n// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\r\n// Moments will have their timezones normalized.\r\nfunction diffDayTime(a, b) {\r\n    return moment.duration({\r\n        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\r\n        ms: a.time() - b.time() // time-of-day from day start. disregards timezone\r\n    });\r\n}\r\nexports.diffDayTime = diffDayTime;\r\n// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\r\nfunction diffDay(a, b) {\r\n    return moment.duration({\r\n        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\r\n    });\r\n}\r\nexports.diffDay = diffDay;\r\n// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\r\nfunction diffByUnit(a, b, unit) {\r\n    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true\r\n    unit);\r\n}\r\nexports.diffByUnit = diffByUnit;\r\n// Computes the unit name of the largest whole-unit period of time.\r\n// For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\r\n// Accepts start/end, a range object, or an original duration object.\r\nfunction computeGreatestUnit(start, end) {\r\n    var i;\r\n    var unit;\r\n    var val;\r\n    for (i = 0; i < exports.unitsDesc.length; i++) {\r\n        unit = exports.unitsDesc[i];\r\n        val = computeRangeAs(unit, start, end);\r\n        if (val >= 1 && isInt(val)) {\r\n            break;\r\n        }\r\n    }\r\n    return unit; // will be \"milliseconds\" if nothing else matches\r\n}\r\nexports.computeGreatestUnit = computeGreatestUnit;\r\n// like computeGreatestUnit, but has special abilities to interpret the source input for clues\r\nfunction computeDurationGreatestUnit(duration, durationInput) {\r\n    var unit = computeGreatestUnit(duration);\r\n    // prevent days:7 from being interpreted as a week\r\n    if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {\r\n        unit = 'day';\r\n    }\r\n    return unit;\r\n}\r\nexports.computeDurationGreatestUnit = computeDurationGreatestUnit;\r\n// Computes the number of units (like \"hours\") in the given range.\r\n// Range can be a {start,end} object, separate start/end args, or a Duration.\r\n// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\r\n// of month-diffing logic (which tends to vary from version to version).\r\nfunction computeRangeAs(unit, start, end) {\r\n    if (end != null) {\r\n        return end.diff(start, unit, true);\r\n    }\r\n    else if (moment.isDuration(start)) {\r\n        return start.as(unit);\r\n    }\r\n    else {\r\n        return start.end.diff(start.start, unit, true);\r\n    }\r\n}\r\n// Intelligently divides a range (specified by a start/end params) by a duration\r\nfunction divideRangeByDuration(start, end, dur) {\r\n    var months;\r\n    if (durationHasTime(dur)) {\r\n        return (end - start) / dur;\r\n    }\r\n    months = dur.asMonths();\r\n    if (Math.abs(months) >= 1 && isInt(months)) {\r\n        return end.diff(start, 'months', true) / months;\r\n    }\r\n    return end.diff(start, 'days', true) / dur.asDays();\r\n}\r\nexports.divideRangeByDuration = divideRangeByDuration;\r\n// Intelligently divides one duration by another\r\nfunction divideDurationByDuration(dur1, dur2) {\r\n    var months1;\r\n    var months2;\r\n    if (durationHasTime(dur1) || durationHasTime(dur2)) {\r\n        return dur1 / dur2;\r\n    }\r\n    months1 = dur1.asMonths();\r\n    months2 = dur2.asMonths();\r\n    if (Math.abs(months1) >= 1 && isInt(months1) &&\r\n        Math.abs(months2) >= 1 && isInt(months2)) {\r\n        return months1 / months2;\r\n    }\r\n    return dur1.asDays() / dur2.asDays();\r\n}\r\nexports.divideDurationByDuration = divideDurationByDuration;\r\n// Intelligently multiplies a duration by a number\r\nfunction multiplyDuration(dur, n) {\r\n    var months;\r\n    if (durationHasTime(dur)) {\r\n        return moment.duration(dur * n);\r\n    }\r\n    months = dur.asMonths();\r\n    if (Math.abs(months) >= 1 && isInt(months)) {\r\n        return moment.duration({ months: months * n });\r\n    }\r\n    return moment.duration({ days: dur.asDays() * n });\r\n}\r\nexports.multiplyDuration = multiplyDuration;\r\n// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\r\nfunction durationHasTime(dur) {\r\n    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\r\n}\r\nexports.durationHasTime = durationHasTime;\r\nfunction isNativeDate(input) {\r\n    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\r\n}\r\nexports.isNativeDate = isNativeDate;\r\n// Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\r\nfunction isTimeString(str) {\r\n    return typeof str === 'string' &&\r\n        /^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\r\n}\r\nexports.isTimeString = isTimeString;\r\n/* Logging and Debug\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nfunction log() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var console = window.console;\r\n    if (console && console.log) {\r\n        return console.log.apply(console, args);\r\n    }\r\n}\r\nexports.log = log;\r\nfunction warn() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var console = window.console;\r\n    if (console && console.warn) {\r\n        return console.warn.apply(console, args);\r\n    }\r\n    else {\r\n        return log.apply(null, args);\r\n    }\r\n}\r\nexports.warn = warn;\r\n/* General Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar hasOwnPropMethod = {}.hasOwnProperty;\r\n// Merges an array of objects into a single object.\r\n// The second argument allows for an array of property names who's object values will be merged together.\r\nfunction mergeProps(propObjs, complexProps) {\r\n    var dest = {};\r\n    var i;\r\n    var name;\r\n    var complexObjs;\r\n    var j;\r\n    var val;\r\n    var props;\r\n    if (complexProps) {\r\n        for (i = 0; i < complexProps.length; i++) {\r\n            name = complexProps[i];\r\n            complexObjs = [];\r\n            // collect the trailing object values, stopping when a non-object is discovered\r\n            for (j = propObjs.length - 1; j >= 0; j--) {\r\n                val = propObjs[j][name];\r\n                if (typeof val === 'object') {\r\n                    complexObjs.unshift(val);\r\n                }\r\n                else if (val !== undefined) {\r\n                    dest[name] = val; // if there were no objects, this value will be used\r\n                    break;\r\n                }\r\n            }\r\n            // if the trailing values were objects, use the merged value\r\n            if (complexObjs.length) {\r\n                dest[name] = mergeProps(complexObjs);\r\n            }\r\n        }\r\n    }\r\n    // copy values into the destination, going from last to first\r\n    for (i = propObjs.length - 1; i >= 0; i--) {\r\n        props = propObjs[i];\r\n        for (name in props) {\r\n            if (!(name in dest)) {\r\n                dest[name] = props[name];\r\n            }\r\n        }\r\n    }\r\n    return dest;\r\n}\r\nexports.mergeProps = mergeProps;\r\nfunction copyOwnProps(src, dest) {\r\n    for (var name_1 in src) {\r\n        if (hasOwnProp(src, name_1)) {\r\n            dest[name_1] = src[name_1];\r\n        }\r\n    }\r\n}\r\nexports.copyOwnProps = copyOwnProps;\r\nfunction hasOwnProp(obj, name) {\r\n    return hasOwnPropMethod.call(obj, name);\r\n}\r\nexports.hasOwnProp = hasOwnProp;\r\nfunction applyAll(functions, thisObj, args) {\r\n    if ($.isFunction(functions)) {\r\n        functions = [functions];\r\n    }\r\n    if (functions) {\r\n        var i = void 0;\r\n        var ret = void 0;\r\n        for (i = 0; i < functions.length; i++) {\r\n            ret = functions[i].apply(thisObj, args) || ret;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nexports.applyAll = applyAll;\r\nfunction removeMatching(array, testFunc) {\r\n    var removeCnt = 0;\r\n    var i = 0;\r\n    while (i < array.length) {\r\n        if (testFunc(array[i])) {\r\n            array.splice(i, 1);\r\n            removeCnt++;\r\n        }\r\n        else {\r\n            i++;\r\n        }\r\n    }\r\n    return removeCnt;\r\n}\r\nexports.removeMatching = removeMatching;\r\nfunction removeExact(array, exactVal) {\r\n    var removeCnt = 0;\r\n    var i = 0;\r\n    while (i < array.length) {\r\n        if (array[i] === exactVal) {\r\n            array.splice(i, 1);\r\n            removeCnt++;\r\n        }\r\n        else {\r\n            i++;\r\n        }\r\n    }\r\n    return removeCnt;\r\n}\r\nexports.removeExact = removeExact;\r\nfunction isArraysEqual(a0, a1) {\r\n    var len = a0.length;\r\n    var i;\r\n    if (len == null || len !== a1.length) {\r\n        return false;\r\n    }\r\n    for (i = 0; i < len; i++) {\r\n        if (a0[i] !== a1[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isArraysEqual = isArraysEqual;\r\nfunction firstDefined() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    for (var i = 0; i < args.length; i++) {\r\n        if (args[i] !== undefined) {\r\n            return args[i];\r\n        }\r\n    }\r\n}\r\nexports.firstDefined = firstDefined;\r\nfunction htmlEscape(s) {\r\n    return (s + '').replace(/&/g, '&amp;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;')\r\n        .replace(/'/g, '&#039;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/\\n/g, '<br />');\r\n}\r\nexports.htmlEscape = htmlEscape;\r\nfunction stripHtmlEntities(text) {\r\n    return text.replace(/&.*?;/g, '');\r\n}\r\nexports.stripHtmlEntities = stripHtmlEntities;\r\n// Given a hash of CSS properties, returns a string of CSS.\r\n// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\r\nfunction cssToStr(cssProps) {\r\n    var statements = [];\r\n    $.each(cssProps, function (name, val) {\r\n        if (val != null) {\r\n            statements.push(name + ':' + val);\r\n        }\r\n    });\r\n    return statements.join(';');\r\n}\r\nexports.cssToStr = cssToStr;\r\n// Given an object hash of HTML attribute names to values,\r\n// generates a string that can be injected between < > in HTML\r\nfunction attrsToStr(attrs) {\r\n    var parts = [];\r\n    $.each(attrs, function (name, val) {\r\n        if (val != null) {\r\n            parts.push(name + '=\"' + htmlEscape(val) + '\"');\r\n        }\r\n    });\r\n    return parts.join(' ');\r\n}\r\nexports.attrsToStr = attrsToStr;\r\nfunction capitaliseFirstLetter(str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\nexports.capitaliseFirstLetter = capitaliseFirstLetter;\r\nfunction compareNumbers(a, b) {\r\n    return a - b;\r\n}\r\nexports.compareNumbers = compareNumbers;\r\nfunction isInt(n) {\r\n    return n % 1 === 0;\r\n}\r\nexports.isInt = isInt;\r\n// Returns a method bound to the given object context.\r\n// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\r\n// different contexts as identical when binding/unbinding events.\r\nfunction proxy(obj, methodName) {\r\n    var method = obj[methodName];\r\n    return function () {\r\n        return method.apply(obj, arguments);\r\n    };\r\n}\r\nexports.proxy = proxy;\r\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\n// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\r\nfunction debounce(func, wait, immediate) {\r\n    if (immediate === void 0) { immediate = false; }\r\n    var timeout;\r\n    var args;\r\n    var context;\r\n    var timestamp;\r\n    var result;\r\n    var later = function () {\r\n        var last = +new Date() - timestamp;\r\n        if (last < wait) {\r\n            timeout = setTimeout(later, wait - last);\r\n        }\r\n        else {\r\n            timeout = null;\r\n            if (!immediate) {\r\n                result = func.apply(context, args);\r\n                context = args = null;\r\n            }\r\n        }\r\n    };\r\n    return function () {\r\n        context = this;\r\n        args = arguments;\r\n        timestamp = +new Date();\r\n        var callNow = immediate && !timeout;\r\n        if (!timeout) {\r\n            timeout = setTimeout(later, wait);\r\n        }\r\n        if (callNow) {\r\n            result = func.apply(context, args);\r\n            context = args = null;\r\n        }\r\n        return result;\r\n    };\r\n}\r\nexports.debounce = debounce;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar UnzonedRange = /** @class */ (function () {\r\n    function UnzonedRange(startInput, endInput) {\r\n        // TODO: move these into footprint.\r\n        // Especially, doesn't make sense for null startMs/endMs.\r\n        this.isStart = true;\r\n        this.isEnd = true;\r\n        if (moment.isMoment(startInput)) {\r\n            startInput = startInput.clone().stripZone();\r\n        }\r\n        if (moment.isMoment(endInput)) {\r\n            endInput = endInput.clone().stripZone();\r\n        }\r\n        if (startInput) {\r\n            this.startMs = startInput.valueOf();\r\n        }\r\n        if (endInput) {\r\n            this.endMs = endInput.valueOf();\r\n        }\r\n    }\r\n    /*\r\n    SIDEEFFECT: will mutate eventRanges.\r\n    Will return a new array result.\r\n    Only works for non-open-ended ranges.\r\n    */\r\n    UnzonedRange.invertRanges = function (ranges, constraintRange) {\r\n        var invertedRanges = [];\r\n        var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range\r\n        var i;\r\n        var dateRange;\r\n        // ranges need to be in order. required for our date-walking algorithm\r\n        ranges.sort(compareUnzonedRanges);\r\n        for (i = 0; i < ranges.length; i++) {\r\n            dateRange = ranges[i];\r\n            // add the span of time before the event (if there is any)\r\n            if (dateRange.startMs > startMs) {\r\n                invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));\r\n            }\r\n            if (dateRange.endMs > startMs) {\r\n                startMs = dateRange.endMs;\r\n            }\r\n        }\r\n        // add the span of time after the last event (if there is any)\r\n        if (startMs < constraintRange.endMs) {\r\n            invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));\r\n        }\r\n        return invertedRanges;\r\n    };\r\n    UnzonedRange.prototype.intersect = function (otherRange) {\r\n        var startMs = this.startMs;\r\n        var endMs = this.endMs;\r\n        var newRange = null;\r\n        if (otherRange.startMs != null) {\r\n            if (startMs == null) {\r\n                startMs = otherRange.startMs;\r\n            }\r\n            else {\r\n                startMs = Math.max(startMs, otherRange.startMs);\r\n            }\r\n        }\r\n        if (otherRange.endMs != null) {\r\n            if (endMs == null) {\r\n                endMs = otherRange.endMs;\r\n            }\r\n            else {\r\n                endMs = Math.min(endMs, otherRange.endMs);\r\n            }\r\n        }\r\n        if (startMs == null || endMs == null || startMs < endMs) {\r\n            newRange = new UnzonedRange(startMs, endMs);\r\n            newRange.isStart = this.isStart && startMs === this.startMs;\r\n            newRange.isEnd = this.isEnd && endMs === this.endMs;\r\n        }\r\n        return newRange;\r\n    };\r\n    UnzonedRange.prototype.intersectsWith = function (otherRange) {\r\n        return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&\r\n            (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);\r\n    };\r\n    UnzonedRange.prototype.containsRange = function (innerRange) {\r\n        return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&\r\n            (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));\r\n    };\r\n    // `date` can be a moment, a Date, or a millisecond time.\r\n    UnzonedRange.prototype.containsDate = function (date) {\r\n        var ms = date.valueOf();\r\n        return (this.startMs == null || ms >= this.startMs) &&\r\n            (this.endMs == null || ms < this.endMs);\r\n    };\r\n    // If the given date is not within the given range, move it inside.\r\n    // (If it's past the end, make it one millisecond before the end).\r\n    // `date` can be a moment, a Date, or a millisecond time.\r\n    // Returns a MS-time.\r\n    UnzonedRange.prototype.constrainDate = function (date) {\r\n        var ms = date.valueOf();\r\n        if (this.startMs != null && ms < this.startMs) {\r\n            ms = this.startMs;\r\n        }\r\n        if (this.endMs != null && ms >= this.endMs) {\r\n            ms = this.endMs - 1;\r\n        }\r\n        return ms;\r\n    };\r\n    UnzonedRange.prototype.equals = function (otherRange) {\r\n        return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;\r\n    };\r\n    UnzonedRange.prototype.clone = function () {\r\n        var range = new UnzonedRange(this.startMs, this.endMs);\r\n        range.isStart = this.isStart;\r\n        range.isEnd = this.isEnd;\r\n        return range;\r\n    };\r\n    // Returns an ambig-zoned moment from startMs.\r\n    // BEWARE: returned moment is not localized.\r\n    // Formatting and start-of-week will be default.\r\n    UnzonedRange.prototype.getStart = function () {\r\n        if (this.startMs != null) {\r\n            return moment_ext_1.default.utc(this.startMs).stripZone();\r\n        }\r\n        return null;\r\n    };\r\n    // Returns an ambig-zoned moment from startMs.\r\n    // BEWARE: returned moment is not localized.\r\n    // Formatting and start-of-week will be default.\r\n    UnzonedRange.prototype.getEnd = function () {\r\n        if (this.endMs != null) {\r\n            return moment_ext_1.default.utc(this.endMs).stripZone();\r\n        }\r\n        return null;\r\n    };\r\n    UnzonedRange.prototype.as = function (unit) {\r\n        return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);\r\n    };\r\n    return UnzonedRange;\r\n}());\r\nexports.default = UnzonedRange;\r\n/*\r\nOnly works for non-open-ended ranges.\r\n*/\r\nfunction compareUnzonedRanges(range1, range2) {\r\n    return range1.startMs - range2.startMs; // earlier ranges go first\r\n}\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar ParsableModelMixin_1 = __webpack_require__(208);\r\nvar Class_1 = __webpack_require__(33);\r\nvar EventDefParser_1 = __webpack_require__(49);\r\nvar EventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventSource, _super);\r\n    // can we do away with calendar? at least for the abstract?\r\n    // useful for buildEventDef\r\n    function EventSource(calendar) {\r\n        var _this = _super.call(this) || this;\r\n        _this.calendar = calendar;\r\n        _this.className = [];\r\n        _this.uid = String(EventSource.uuid++);\r\n        return _this;\r\n    }\r\n    /*\r\n    rawInput can be any data type!\r\n    */\r\n    EventSource.parse = function (rawInput, calendar) {\r\n        var source = new this(calendar);\r\n        if (typeof rawInput === 'object') {\r\n            if (source.applyProps(rawInput)) {\r\n                return source;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    EventSource.normalizeId = function (id) {\r\n        if (id) {\r\n            return String(id);\r\n        }\r\n        return null;\r\n    };\r\n    EventSource.prototype.fetch = function (start, end, timezone) {\r\n        // subclasses must implement. must return a promise.\r\n    };\r\n    EventSource.prototype.removeEventDefsById = function (eventDefId) {\r\n        // optional for subclasses to implement\r\n    };\r\n    EventSource.prototype.removeAllEventDefs = function () {\r\n        // optional for subclasses to implement\r\n    };\r\n    /*\r\n    For compairing/matching\r\n    */\r\n    EventSource.prototype.getPrimitive = function (otherSource) {\r\n        // subclasses must implement\r\n    };\r\n    EventSource.prototype.parseEventDefs = function (rawEventDefs) {\r\n        var i;\r\n        var eventDef;\r\n        var eventDefs = [];\r\n        for (i = 0; i < rawEventDefs.length; i++) {\r\n            eventDef = this.parseEventDef(rawEventDefs[i]);\r\n            if (eventDef) {\r\n                eventDefs.push(eventDef);\r\n            }\r\n        }\r\n        return eventDefs;\r\n    };\r\n    EventSource.prototype.parseEventDef = function (rawInput) {\r\n        var calendarTransform = this.calendar.opt('eventDataTransform');\r\n        var sourceTransform = this.eventDataTransform;\r\n        if (calendarTransform) {\r\n            rawInput = calendarTransform(rawInput, this.calendar);\r\n        }\r\n        if (sourceTransform) {\r\n            rawInput = sourceTransform(rawInput, this.calendar);\r\n        }\r\n        return EventDefParser_1.default.parse(rawInput, this);\r\n    };\r\n    EventSource.prototype.applyManualStandardProps = function (rawProps) {\r\n        if (rawProps.id != null) {\r\n            this.id = EventSource.normalizeId(rawProps.id);\r\n        }\r\n        // TODO: converge with EventDef\r\n        if ($.isArray(rawProps.className)) {\r\n            this.className = rawProps.className;\r\n        }\r\n        else if (typeof rawProps.className === 'string') {\r\n            this.className = rawProps.className.split(/\\s+/);\r\n        }\r\n        return true;\r\n    };\r\n    EventSource.uuid = 0;\r\n    EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;\r\n    EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;\r\n    return EventSource;\r\n}(Class_1.default));\r\nexports.default = EventSource;\r\nParsableModelMixin_1.default.mixInto(EventSource);\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nEventSource.defineStandardProps({\r\n    // manually process...\r\n    id: false,\r\n    className: false,\r\n    // automatically transfer...\r\n    color: true,\r\n    backgroundColor: true,\r\n    borderColor: true,\r\n    textColor: true,\r\n    editable: true,\r\n    startEditable: true,\r\n    durationEditable: true,\r\n    rendering: true,\r\n    overlap: true,\r\n    constraint: true,\r\n    allDayDefault: true,\r\n    eventDataTransform: true\r\n});\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\r\nUtility methods for easily listening to events on another object,\r\nand more importantly, easily unlistening from them.\r\n\nUSAGE:\r\n  import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'\r\nin class:\r\n  listenTo: ListenerInterface['listenTo']\r\n  stopListeningTo: ListenerInterface['stopListeningTo']\r\nafter class:\r\n  ListenerMixin.mixInto(TheClass)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar guid = 0;\r\nvar ListenerMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListenerMixin, _super);\r\n    function ListenerMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /*\r\n    Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\r\n    The `callback` will be called with the `this` context of the object that .listenTo is being called on.\r\n    Can be called:\r\n      .listenTo(other, eventName, callback)\r\n    OR\r\n      .listenTo(other, {\r\n        eventName1: callback1,\r\n        eventName2: callback2\r\n      })\r\n    */\r\n    ListenerMixin.prototype.listenTo = function (other, arg, callback) {\r\n        if (typeof arg === 'object') {\r\n            for (var eventName in arg) {\r\n                if (arg.hasOwnProperty(eventName)) {\r\n                    this.listenTo(other, eventName, arg[eventName]);\r\n                }\r\n            }\r\n        }\r\n        else if (typeof arg === 'string') {\r\n            other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\r\n            $.proxy(callback, this) // always use `this` context\r\n            // the usually-undesired jQuery guid behavior doesn't matter,\r\n            // because we always unbind via namespace\r\n            );\r\n        }\r\n    };\r\n    /*\r\n    Causes the current object to stop listening to events on the `other` object.\r\n    `eventName` is optional. If omitted, will stop listening to ALL events on `other`.\r\n    */\r\n    ListenerMixin.prototype.stopListeningTo = function (other, eventName) {\r\n        other.off((eventName || '') + '.' + this.getListenerNamespace());\r\n    };\r\n    /*\r\n    Returns a string, unique to this object, to be used for event namespacing\r\n    */\r\n    ListenerMixin.prototype.getListenerNamespace = function () {\r\n        if (this.listenerId == null) {\r\n            this.listenerId = guid++;\r\n        }\r\n        return '_listener' + this.listenerId;\r\n    };\r\n    return ListenerMixin;\r\n}(Mixin_1.default));\r\nexports.default = ListenerMixin;\r\n\n\n/***/ }),\n/* 8 */,\n/* 9 */,\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\r\nvar ambigTimeOrZoneRegex = /^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\r\nvar newMomentProto = moment.fn; // where we will attach our new methods\r\nexports.newMomentProto = newMomentProto;\r\nvar oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\r\nexports.oldMomentProto = oldMomentProto;\r\n// tell momentjs to transfer these properties upon clone\r\nvar momentProperties = moment.momentProperties;\r\nmomentProperties.push('_fullCalendar');\r\nmomentProperties.push('_ambigTime');\r\nmomentProperties.push('_ambigZone');\r\n/*\r\nCall this if you want Moment's original format method to be used\r\n*/\r\nfunction oldMomentFormat(mom, formatStr) {\r\n    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\r\n}\r\nexports.oldMomentFormat = oldMomentFormat;\r\n// Creating\r\n// -------------------------------------------------------------------------------------------------\r\n// Creates a new moment, similar to the vanilla moment(...) constructor, but with\r\n// extra features (ambiguous time, enhanced formatting). When given an existing moment,\r\n// it will function as a clone (and retain the zone of the moment). Anything else will\r\n// result in a moment in the local zone.\r\nvar momentExt = function () {\r\n    return makeMoment(arguments);\r\n};\r\nexports.default = momentExt;\r\n// Sames as momentExt, but forces the resulting moment to be in the UTC timezone.\r\nmomentExt.utc = function () {\r\n    var mom = makeMoment(arguments, true);\r\n    // Force it into UTC because makeMoment doesn't guarantee it\r\n    // (if given a pre-existing moment for example)\r\n    if (mom.hasTime()) {\r\n        mom.utc();\r\n    }\r\n    return mom;\r\n};\r\n// Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.\r\n// ISO8601 strings with no timezone offset will become ambiguously zoned.\r\nmomentExt.parseZone = function () {\r\n    return makeMoment(arguments, true, true);\r\n};\r\n// Builds an enhanced moment from args. When given an existing moment, it clones. When given a\r\n// native Date, or called with no arguments (the current time), the resulting moment will be local.\r\n// Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\r\n//    parseAsUTC - if there is no zone information, should we parse the input in UTC?\r\n//    parseZone - if there is zone information, should we force the zone of the moment?\r\nfunction makeMoment(args, parseAsUTC, parseZone) {\r\n    if (parseAsUTC === void 0) { parseAsUTC = false; }\r\n    if (parseZone === void 0) { parseZone = false; }\r\n    var input = args[0];\r\n    var isSingleString = args.length === 1 && typeof input === 'string';\r\n    var isAmbigTime;\r\n    var isAmbigZone;\r\n    var ambigMatch;\r\n    var mom;\r\n    if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {\r\n        mom = moment.apply(null, args);\r\n    }\r\n    else {\r\n        isAmbigTime = false;\r\n        isAmbigZone = false;\r\n        if (isSingleString) {\r\n            if (ambigDateOfMonthRegex.test(input)) {\r\n                // accept strings like '2014-05', but convert to the first of the month\r\n                input += '-01';\r\n                args = [input]; // for when we pass it on to moment's constructor\r\n                isAmbigTime = true;\r\n                isAmbigZone = true;\r\n            }\r\n            else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\r\n                isAmbigTime = !ambigMatch[5]; // no time part?\r\n                isAmbigZone = true;\r\n            }\r\n        }\r\n        else if ($.isArray(input)) {\r\n            // arrays have no timezone information, so assume ambiguous zone\r\n            isAmbigZone = true;\r\n        }\r\n        // otherwise, probably a string with a format\r\n        if (parseAsUTC || isAmbigTime) {\r\n            mom = moment.utc.apply(moment, args);\r\n        }\r\n        else {\r\n            mom = moment.apply(null, args);\r\n        }\r\n        if (isAmbigTime) {\r\n            mom._ambigTime = true;\r\n            mom._ambigZone = true; // ambiguous time always means ambiguous zone\r\n        }\r\n        else if (parseZone) {\r\n            if (isAmbigZone) {\r\n                mom._ambigZone = true;\r\n            }\r\n            else if (isSingleString) {\r\n                mom.utcOffset(input); // if not a valid zone, will assign UTC\r\n            }\r\n        }\r\n    }\r\n    mom._fullCalendar = true; // flag for extended functionality\r\n    return mom;\r\n}\r\n// Week Number\r\n// -------------------------------------------------------------------------------------------------\r\n// Returns the week number, considering the locale's custom week number calcuation\r\n// `weeks` is an alias for `week`\r\nnewMomentProto.week = newMomentProto.weeks = function (input) {\r\n    var weekCalc = this._locale._fullCalendar_weekCalc;\r\n    if (input == null && typeof weekCalc === 'function') {\r\n        return weekCalc(this);\r\n    }\r\n    else if (weekCalc === 'ISO') {\r\n        return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\r\n    }\r\n    return oldMomentProto.week.apply(this, arguments); // local getter/setter\r\n};\r\n// Time-of-day\r\n// -------------------------------------------------------------------------------------------------\r\n// GETTER\r\n// Returns a Duration with the hours/minutes/seconds/ms values of the moment.\r\n// If the moment has an ambiguous time, a duration of 00:00 will be returned.\r\n//\r\n// SETTER\r\n// You can supply a Duration, a Moment, or a Duration-like argument.\r\n// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\r\nnewMomentProto.time = function (time) {\r\n    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\r\n    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\r\n    if (!this._fullCalendar) {\r\n        return oldMomentProto.time.apply(this, arguments);\r\n    }\r\n    if (time == null) {\r\n        return moment.duration({\r\n            hours: this.hours(),\r\n            minutes: this.minutes(),\r\n            seconds: this.seconds(),\r\n            milliseconds: this.milliseconds()\r\n        });\r\n    }\r\n    else {\r\n        this._ambigTime = false; // mark that the moment now has a time\r\n        if (!moment.isDuration(time) && !moment.isMoment(time)) {\r\n            time = moment.duration(time);\r\n        }\r\n        // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\r\n        // Only for Duration times, not Moment times.\r\n        var dayHours = 0;\r\n        if (moment.isDuration(time)) {\r\n            dayHours = Math.floor(time.asDays()) * 24;\r\n        }\r\n        // We need to set the individual fields.\r\n        // Can't use startOf('day') then add duration. In case of DST at start of day.\r\n        return this.hours(dayHours + time.hours())\r\n            .minutes(time.minutes())\r\n            .seconds(time.seconds())\r\n            .milliseconds(time.milliseconds());\r\n    }\r\n};\r\n// Converts the moment to UTC, stripping out its time-of-day and timezone offset,\r\n// but preserving its YMD. A moment with a stripped time will display no time\r\n// nor timezone offset when .format() is called.\r\nnewMomentProto.stripTime = function () {\r\n    if (!this._ambigTime) {\r\n        this.utc(true); // keepLocalTime=true (for keeping *date* value)\r\n        // set time to zero\r\n        this.set({\r\n            hours: 0,\r\n            minutes: 0,\r\n            seconds: 0,\r\n            ms: 0\r\n        });\r\n        // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\r\n        // which clears all ambig flags.\r\n        this._ambigTime = true;\r\n        this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\r\n    }\r\n    return this; // for chaining\r\n};\r\n// Returns if the moment has a non-ambiguous time (boolean)\r\nnewMomentProto.hasTime = function () {\r\n    return !this._ambigTime;\r\n};\r\n// Timezone\r\n// -------------------------------------------------------------------------------------------------\r\n// Converts the moment to UTC, stripping out its timezone offset, but preserving its\r\n// YMD and time-of-day. A moment with a stripped timezone offset will display no\r\n// timezone offset when .format() is called.\r\nnewMomentProto.stripZone = function () {\r\n    var wasAmbigTime;\r\n    if (!this._ambigZone) {\r\n        wasAmbigTime = this._ambigTime;\r\n        this.utc(true); // keepLocalTime=true (for keeping date and time values)\r\n        // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\r\n        this._ambigTime = wasAmbigTime || false;\r\n        // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\r\n        // which clears the ambig flags.\r\n        this._ambigZone = true;\r\n    }\r\n    return this; // for chaining\r\n};\r\n// Returns of the moment has a non-ambiguous timezone offset (boolean)\r\nnewMomentProto.hasZone = function () {\r\n    return !this._ambigZone;\r\n};\r\n// implicitly marks a zone\r\nnewMomentProto.local = function (keepLocalTime) {\r\n    // for when converting from ambiguously-zoned to local,\r\n    // keep the time values when converting from UTC -> local\r\n    oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\r\n    // ensure non-ambiguous\r\n    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\r\n    this._ambigTime = false;\r\n    this._ambigZone = false;\r\n    return this; // for chaining\r\n};\r\n// implicitly marks a zone\r\nnewMomentProto.utc = function (keepLocalTime) {\r\n    oldMomentProto.utc.call(this, keepLocalTime);\r\n    // ensure non-ambiguous\r\n    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\r\n    this._ambigTime = false;\r\n    this._ambigZone = false;\r\n    return this;\r\n};\r\n// implicitly marks a zone (will probably get called upon .utc() and .local())\r\nnewMomentProto.utcOffset = function (tzo) {\r\n    if (tzo != null) {\r\n        // these assignments needs to happen before the original zone method is called.\r\n        // I forget why, something to do with a browser crash.\r\n        this._ambigTime = false;\r\n        this._ambigZone = false;\r\n    }\r\n    return oldMomentProto.utcOffset.apply(this, arguments);\r\n};\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\r\nUSAGE:\r\n  import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'\r\nin class:\r\n  on: EmitterInterface['on']\r\n  one: EmitterInterface['one']\r\n  off: EmitterInterface['off']\r\n  trigger: EmitterInterface['trigger']\r\n  triggerWith: EmitterInterface['triggerWith']\r\n  hasHandlers: EmitterInterface['hasHandlers']\r\nafter class:\r\n  EmitterMixin.mixInto(TheClass)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar EmitterMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EmitterMixin, _super);\r\n    function EmitterMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // jQuery-ification via $(this) allows a non-DOM object to have\r\n    // the same event handling capabilities (including namespaces).\r\n    EmitterMixin.prototype.on = function (types, handler) {\r\n        $(this).on(types, this._prepareIntercept(handler));\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.one = function (types, handler) {\r\n        $(this).one(types, this._prepareIntercept(handler));\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype._prepareIntercept = function (handler) {\r\n        // handlers are always called with an \"event\" object as their first param.\r\n        // sneak the `this` context and arguments into the extra parameter object\r\n        // and forward them on to the original handler.\r\n        var intercept = function (ev, extra) {\r\n            return handler.apply(extra.context || this, extra.args || []);\r\n        };\r\n        // mimick jQuery's internal \"proxy\" system (risky, I know)\r\n        // causing all functions with the same .guid to appear to be the same.\r\n        // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\r\n        // this is needed for calling .off with the original non-intercept handler.\r\n        if (!handler.guid) {\r\n            handler.guid = $.guid++;\r\n        }\r\n        intercept.guid = handler.guid;\r\n        return intercept;\r\n    };\r\n    EmitterMixin.prototype.off = function (types, handler) {\r\n        $(this).off(types, handler);\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.trigger = function (types) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        // pass in \"extra\" info to the intercept\r\n        $(this).triggerHandler(types, { args: args });\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.triggerWith = function (types, context, args) {\r\n        // `triggerHandler` is less reliant on the DOM compared to `trigger`.\r\n        // pass in \"extra\" info to the intercept.\r\n        $(this).triggerHandler(types, { context: context, args: args });\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.hasHandlers = function (type) {\r\n        var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/\r\n        return hash && hash[type] && hash[type].length > 0;\r\n    };\r\n    return EmitterMixin;\r\n}(Mixin_1.default));\r\nexports.default = EmitterMixin;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\nMeant to be immutable\r\n*/\r\nvar ComponentFootprint = /** @class */ (function () {\r\n    function ComponentFootprint(unzonedRange, isAllDay) {\r\n        this.isAllDay = false; // component can choose to ignore this\r\n        this.unzonedRange = unzonedRange;\r\n        this.isAllDay = isAllDay;\r\n    }\r\n    /*\r\n    Only works for non-open-ended ranges.\r\n    */\r\n    ComponentFootprint.prototype.toLegacy = function (calendar) {\r\n        return {\r\n            start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),\r\n            end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)\r\n        };\r\n    };\r\n    return ComponentFootprint;\r\n}());\r\nexports.default = ComponentFootprint;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar EventDef_1 = __webpack_require__(34);\r\nvar EventInstance_1 = __webpack_require__(209);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar SingleEventDef = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SingleEventDef, _super);\r\n    function SingleEventDef() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /*\r\n    Will receive start/end params, but will be ignored.\r\n    */\r\n    SingleEventDef.prototype.buildInstances = function () {\r\n        return [this.buildInstance()];\r\n    };\r\n    SingleEventDef.prototype.buildInstance = function () {\r\n        return new EventInstance_1.default(this, // definition\r\n        this.dateProfile);\r\n    };\r\n    SingleEventDef.prototype.isAllDay = function () {\r\n        return this.dateProfile.isAllDay();\r\n    };\r\n    SingleEventDef.prototype.clone = function () {\r\n        var def = _super.prototype.clone.call(this);\r\n        def.dateProfile = this.dateProfile;\r\n        return def;\r\n    };\r\n    SingleEventDef.prototype.rezone = function () {\r\n        var calendar = this.source.calendar;\r\n        var dateProfile = this.dateProfile;\r\n        this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);\r\n    };\r\n    /*\r\n    NOTE: if super-method fails, should still attempt to apply\r\n    */\r\n    SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {\r\n        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\r\n        var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure\r\n        if (dateProfile) {\r\n            this.dateProfile = dateProfile;\r\n            // make sure `date` shows up in the legacy event objects as-is\r\n            if (rawProps.date != null) {\r\n                this.miscProps.date = rawProps.date;\r\n            }\r\n            return superSuccess;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    return SingleEventDef;\r\n}(EventDef_1.default));\r\nexports.default = SingleEventDef;\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nSingleEventDef.defineStandardProps({\r\n    start: false,\r\n    date: false,\r\n    end: false,\r\n    allDay: false\r\n});\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Mixin = /** @class */ (function () {\r\n    function Mixin() {\r\n    }\r\n    Mixin.mixInto = function (destClass) {\r\n        var _this = this;\r\n        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\r\n            if (!destClass.prototype[name]) {\r\n                destClass.prototype[name] = _this.prototype[name];\r\n            }\r\n        });\r\n    };\r\n    /*\r\n    will override existing methods\r\n    TODO: remove! not used anymore\r\n    */\r\n    Mixin.mixOver = function (destClass) {\r\n        var _this = this;\r\n        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\r\n            destClass.prototype[name] = _this.prototype[name];\r\n        });\r\n    };\r\n    return Mixin;\r\n}());\r\nexports.default = Mixin;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Interaction = /** @class */ (function () {\r\n    function Interaction(component) {\r\n        this.view = component._getView();\r\n        this.component = component;\r\n    }\r\n    Interaction.prototype.opt = function (name) {\r\n        return this.view.opt(name);\r\n    };\r\n    Interaction.prototype.end = function () {\r\n        // subclasses can implement\r\n    };\r\n    return Interaction;\r\n}());\r\nexports.default = Interaction;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.version = '3.9.0';\r\n// When introducing internal API incompatibilities (where fullcalendar plugins would break),\r\n// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)\r\n// and the below integer should be incremented.\r\nexports.internalApiVersion = 12;\r\nvar util_1 = __webpack_require__(4);\r\nexports.applyAll = util_1.applyAll;\r\nexports.debounce = util_1.debounce;\r\nexports.isInt = util_1.isInt;\r\nexports.htmlEscape = util_1.htmlEscape;\r\nexports.cssToStr = util_1.cssToStr;\r\nexports.proxy = util_1.proxy;\r\nexports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;\r\nexports.getOuterRect = util_1.getOuterRect;\r\nexports.getClientRect = util_1.getClientRect;\r\nexports.getContentRect = util_1.getContentRect;\r\nexports.getScrollbarWidths = util_1.getScrollbarWidths;\r\nexports.preventDefault = util_1.preventDefault;\r\nexports.parseFieldSpecs = util_1.parseFieldSpecs;\r\nexports.compareByFieldSpecs = util_1.compareByFieldSpecs;\r\nexports.compareByFieldSpec = util_1.compareByFieldSpec;\r\nexports.flexibleCompare = util_1.flexibleCompare;\r\nexports.computeGreatestUnit = util_1.computeGreatestUnit;\r\nexports.divideRangeByDuration = util_1.divideRangeByDuration;\r\nexports.divideDurationByDuration = util_1.divideDurationByDuration;\r\nexports.multiplyDuration = util_1.multiplyDuration;\r\nexports.durationHasTime = util_1.durationHasTime;\r\nexports.log = util_1.log;\r\nexports.warn = util_1.warn;\r\nexports.removeExact = util_1.removeExact;\r\nexports.intersectRects = util_1.intersectRects;\r\nvar date_formatting_1 = __webpack_require__(47);\r\nexports.formatDate = date_formatting_1.formatDate;\r\nexports.formatRange = date_formatting_1.formatRange;\r\nexports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;\r\nvar locale_1 = __webpack_require__(31);\r\nexports.datepickerLocale = locale_1.datepickerLocale;\r\nexports.locale = locale_1.locale;\r\nvar moment_ext_1 = __webpack_require__(10);\r\nexports.moment = moment_ext_1.default;\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nexports.EmitterMixin = EmitterMixin_1.default;\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nexports.ListenerMixin = ListenerMixin_1.default;\r\nvar Model_1 = __webpack_require__(48);\r\nexports.Model = Model_1.default;\r\nvar Constraints_1 = __webpack_require__(207);\r\nexports.Constraints = Constraints_1.default;\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nexports.UnzonedRange = UnzonedRange_1.default;\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nexports.ComponentFootprint = ComponentFootprint_1.default;\r\nvar BusinessHourGenerator_1 = __webpack_require__(212);\r\nexports.BusinessHourGenerator = BusinessHourGenerator_1.default;\r\nvar EventDef_1 = __webpack_require__(34);\r\nexports.EventDef = EventDef_1.default;\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nexports.EventDefMutation = EventDefMutation_1.default;\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nexports.EventSourceParser = EventSourceParser_1.default;\r\nvar EventSource_1 = __webpack_require__(6);\r\nexports.EventSource = EventSource_1.default;\r\nvar ThemeRegistry_1 = __webpack_require__(51);\r\nexports.defineThemeSystem = ThemeRegistry_1.defineThemeSystem;\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nexports.EventInstanceGroup = EventInstanceGroup_1.default;\r\nvar ArrayEventSource_1 = __webpack_require__(52);\r\nexports.ArrayEventSource = ArrayEventSource_1.default;\r\nvar FuncEventSource_1 = __webpack_require__(215);\r\nexports.FuncEventSource = FuncEventSource_1.default;\r\nvar JsonFeedEventSource_1 = __webpack_require__(216);\r\nexports.JsonFeedEventSource = JsonFeedEventSource_1.default;\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nexports.EventFootprint = EventFootprint_1.default;\r\nvar Class_1 = __webpack_require__(33);\r\nexports.Class = Class_1.default;\r\nvar Mixin_1 = __webpack_require__(14);\r\nexports.Mixin = Mixin_1.default;\r\nvar CoordCache_1 = __webpack_require__(53);\r\nexports.CoordCache = CoordCache_1.default;\r\nvar DragListener_1 = __webpack_require__(54);\r\nexports.DragListener = DragListener_1.default;\r\nvar Promise_1 = __webpack_require__(20);\r\nexports.Promise = Promise_1.default;\r\nvar TaskQueue_1 = __webpack_require__(217);\r\nexports.TaskQueue = TaskQueue_1.default;\r\nvar RenderQueue_1 = __webpack_require__(218);\r\nexports.RenderQueue = RenderQueue_1.default;\r\nvar Scroller_1 = __webpack_require__(39);\r\nexports.Scroller = Scroller_1.default;\r\nvar Theme_1 = __webpack_require__(19);\r\nexports.Theme = Theme_1.default;\r\nvar DateComponent_1 = __webpack_require__(219);\r\nexports.DateComponent = DateComponent_1.default;\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nexports.InteractiveDateComponent = InteractiveDateComponent_1.default;\r\nvar Calendar_1 = __webpack_require__(220);\r\nexports.Calendar = Calendar_1.default;\r\nvar View_1 = __webpack_require__(41);\r\nexports.View = View_1.default;\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nexports.defineView = ViewRegistry_1.defineView;\r\nexports.getViewConfig = ViewRegistry_1.getViewConfig;\r\nvar DayTableMixin_1 = __webpack_require__(55);\r\nexports.DayTableMixin = DayTableMixin_1.default;\r\nvar BusinessHourRenderer_1 = __webpack_require__(56);\r\nexports.BusinessHourRenderer = BusinessHourRenderer_1.default;\r\nvar EventRenderer_1 = __webpack_require__(42);\r\nexports.EventRenderer = EventRenderer_1.default;\r\nvar FillRenderer_1 = __webpack_require__(57);\r\nexports.FillRenderer = FillRenderer_1.default;\r\nvar HelperRenderer_1 = __webpack_require__(58);\r\nexports.HelperRenderer = HelperRenderer_1.default;\r\nvar ExternalDropping_1 = __webpack_require__(222);\r\nexports.ExternalDropping = ExternalDropping_1.default;\r\nvar EventResizing_1 = __webpack_require__(223);\r\nexports.EventResizing = EventResizing_1.default;\r\nvar EventPointing_1 = __webpack_require__(59);\r\nexports.EventPointing = EventPointing_1.default;\r\nvar EventDragging_1 = __webpack_require__(224);\r\nexports.EventDragging = EventDragging_1.default;\r\nvar DateSelecting_1 = __webpack_require__(225);\r\nexports.DateSelecting = DateSelecting_1.default;\r\nvar StandardInteractionsMixin_1 = __webpack_require__(60);\r\nexports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;\r\nvar AgendaView_1 = __webpack_require__(226);\r\nexports.AgendaView = AgendaView_1.default;\r\nvar TimeGrid_1 = __webpack_require__(227);\r\nexports.TimeGrid = TimeGrid_1.default;\r\nvar DayGrid_1 = __webpack_require__(61);\r\nexports.DayGrid = DayGrid_1.default;\r\nvar BasicView_1 = __webpack_require__(62);\r\nexports.BasicView = BasicView_1.default;\r\nvar MonthView_1 = __webpack_require__(229);\r\nexports.MonthView = MonthView_1.default;\r\nvar ListView_1 = __webpack_require__(230);\r\nexports.ListView = ListView_1.default;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\n/*\r\nMeant to be immutable\r\n*/\r\nvar EventDateProfile = /** @class */ (function () {\r\n    function EventDateProfile(start, end, calendar) {\r\n        this.start = start;\r\n        this.end = end || null;\r\n        this.unzonedRange = this.buildUnzonedRange(calendar);\r\n    }\r\n    /*\r\n    Needs an EventSource object\r\n    */\r\n    EventDateProfile.parse = function (rawProps, source) {\r\n        var startInput = rawProps.start || rawProps.date;\r\n        var endInput = rawProps.end;\r\n        if (!startInput) {\r\n            return false;\r\n        }\r\n        var calendar = source.calendar;\r\n        var start = calendar.moment(startInput);\r\n        var end = endInput ? calendar.moment(endInput) : null;\r\n        var forcedAllDay = rawProps.allDay;\r\n        var forceEventDuration = calendar.opt('forceEventDuration');\r\n        if (!start.isValid()) {\r\n            return false;\r\n        }\r\n        if (end && (!end.isValid() || !end.isAfter(start))) {\r\n            end = null;\r\n        }\r\n        if (forcedAllDay == null) {\r\n            forcedAllDay = source.allDayDefault;\r\n            if (forcedAllDay == null) {\r\n                forcedAllDay = calendar.opt('allDayDefault');\r\n            }\r\n        }\r\n        if (forcedAllDay === true) {\r\n            start.stripTime();\r\n            if (end) {\r\n                end.stripTime();\r\n            }\r\n        }\r\n        else if (forcedAllDay === false) {\r\n            if (!start.hasTime()) {\r\n                start.time(0);\r\n            }\r\n            if (end && !end.hasTime()) {\r\n                end.time(0);\r\n            }\r\n        }\r\n        if (!end && forceEventDuration) {\r\n            end = calendar.getDefaultEventEnd(!start.hasTime(), start);\r\n        }\r\n        return new EventDateProfile(start, end, calendar);\r\n    };\r\n    EventDateProfile.isStandardProp = function (propName) {\r\n        return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';\r\n    };\r\n    EventDateProfile.prototype.isAllDay = function () {\r\n        return !(this.start.hasTime() || (this.end && this.end.hasTime()));\r\n    };\r\n    /*\r\n    Needs a Calendar object\r\n    */\r\n    EventDateProfile.prototype.buildUnzonedRange = function (calendar) {\r\n        var startMs = this.start.clone().stripZone().valueOf();\r\n        var endMs = this.getEnd(calendar).stripZone().valueOf();\r\n        return new UnzonedRange_1.default(startMs, endMs);\r\n    };\r\n    /*\r\n    Needs a Calendar object\r\n    */\r\n    EventDateProfile.prototype.getEnd = function (calendar) {\r\n        return this.end ?\r\n            this.end.clone() :\r\n            // derive the end from the start and allDay. compute allDay if necessary\r\n            calendar.getDefaultEventEnd(this.isAllDay(), this.start);\r\n    };\r\n    return EventDateProfile;\r\n}());\r\nexports.default = EventDateProfile;\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar util_1 = __webpack_require__(35);\r\nvar EventRange_1 = __webpack_require__(211);\r\n/*\r\nIt's expected that there will be at least one EventInstance,\r\nOR that an explicitEventDef is assigned.\r\n*/\r\nvar EventInstanceGroup = /** @class */ (function () {\r\n    function EventInstanceGroup(eventInstances) {\r\n        this.eventInstances = eventInstances || [];\r\n    }\r\n    EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {\r\n        if (constraintRange) {\r\n            return this.sliceNormalRenderRanges(constraintRange);\r\n        }\r\n        else {\r\n            return this.eventInstances.map(util_1.eventInstanceToEventRange);\r\n        }\r\n    };\r\n    EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {\r\n        if (this.isInverse()) {\r\n            return this.sliceInverseRenderRanges(constraintRange);\r\n        }\r\n        else {\r\n            return this.sliceNormalRenderRanges(constraintRange);\r\n        }\r\n    };\r\n    EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {\r\n        var eventInstances = this.eventInstances;\r\n        var i;\r\n        var eventInstance;\r\n        var slicedRange;\r\n        var slicedEventRanges = [];\r\n        for (i = 0; i < eventInstances.length; i++) {\r\n            eventInstance = eventInstances[i];\r\n            slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);\r\n            if (slicedRange) {\r\n                slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));\r\n            }\r\n        }\r\n        return slicedEventRanges;\r\n    };\r\n    EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {\r\n        var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);\r\n        var ownerDef = this.getEventDef();\r\n        unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);\r\n        return unzonedRanges.map(function (unzonedRange) {\r\n            return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance\r\n        });\r\n    };\r\n    EventInstanceGroup.prototype.isInverse = function () {\r\n        return this.getEventDef().hasInverseRendering();\r\n    };\r\n    EventInstanceGroup.prototype.getEventDef = function () {\r\n        return this.explicitEventDef || this.eventInstances[0].def;\r\n    };\r\n    return EventInstanceGroup;\r\n}());\r\nexports.default = EventInstanceGroup;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar Theme = /** @class */ (function () {\r\n    function Theme(optionsManager) {\r\n        this.optionsManager = optionsManager;\r\n        this.processIconOverride();\r\n    }\r\n    Theme.prototype.processIconOverride = function () {\r\n        if (this.iconOverrideOption) {\r\n            this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));\r\n        }\r\n    };\r\n    Theme.prototype.setIconOverride = function (iconOverrideHash) {\r\n        var iconClassesCopy;\r\n        var buttonName;\r\n        if ($.isPlainObject(iconOverrideHash)) {\r\n            iconClassesCopy = $.extend({}, this.iconClasses);\r\n            for (buttonName in iconOverrideHash) {\r\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\r\n            }\r\n            this.iconClasses = iconClassesCopy;\r\n        }\r\n        else if (iconOverrideHash === false) {\r\n            this.iconClasses = {};\r\n        }\r\n    };\r\n    Theme.prototype.applyIconOverridePrefix = function (className) {\r\n        var prefix = this.iconOverridePrefix;\r\n        if (prefix && className.indexOf(prefix) !== 0) {\r\n            className = prefix + className;\r\n        }\r\n        return className;\r\n    };\r\n    Theme.prototype.getClass = function (key) {\r\n        return this.classes[key] || '';\r\n    };\r\n    Theme.prototype.getIconClass = function (buttonName) {\r\n        var className = this.iconClasses[buttonName];\r\n        if (className) {\r\n            return this.baseIconClass + ' ' + className;\r\n        }\r\n        return '';\r\n    };\r\n    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\r\n        var className;\r\n        if (this.iconOverrideCustomButtonOption) {\r\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\r\n            if (className) {\r\n                return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n    return Theme;\r\n}());\r\nexports.default = Theme;\r\nTheme.prototype.classes = {};\r\nTheme.prototype.iconClasses = {};\r\nTheme.prototype.baseIconClass = '';\r\nTheme.prototype.iconOverridePrefix = '';\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar PromiseStub = {\r\n    construct: function (executor) {\r\n        var deferred = $.Deferred();\r\n        var promise = deferred.promise();\r\n        if (typeof executor === 'function') {\r\n            executor(function (val) {\r\n                deferred.resolve(val);\r\n                attachImmediatelyResolvingThen(promise, val);\r\n            }, function () {\r\n                deferred.reject();\r\n                attachImmediatelyRejectingThen(promise);\r\n            });\r\n        }\r\n        return promise;\r\n    },\r\n    resolve: function (val) {\r\n        var deferred = $.Deferred().resolve(val);\r\n        var promise = deferred.promise();\r\n        attachImmediatelyResolvingThen(promise, val);\r\n        return promise;\r\n    },\r\n    reject: function () {\r\n        var deferred = $.Deferred().reject();\r\n        var promise = deferred.promise();\r\n        attachImmediatelyRejectingThen(promise);\r\n        return promise;\r\n    }\r\n};\r\nexports.default = PromiseStub;\r\nfunction attachImmediatelyResolvingThen(promise, val) {\r\n    promise.then = function (onResolve) {\r\n        if (typeof onResolve === 'function') {\r\n            return PromiseStub.resolve(onResolve(val));\r\n        }\r\n        return promise;\r\n    };\r\n}\r\nfunction attachImmediatelyRejectingThen(promise) {\r\n    promise.then = function (onResolve, onReject) {\r\n        if (typeof onReject === 'function') {\r\n            onReject();\r\n        }\r\n        return promise;\r\n    };\r\n}\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar exportHooks = __webpack_require__(16);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nexportHooks.touchMouseIgnoreWait = 500;\r\nvar globalEmitter = null;\r\nvar neededCount = 0;\r\n/*\r\nListens to document and window-level user-interaction events, like touch events and mouse events,\r\nand fires these events as-is to whoever is observing a GlobalEmitter.\r\nBest when used as a singleton via GlobalEmitter.get()\r\n\nNormalizes mouse/touch events. For examples:\r\n- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click\r\n- compensates for various buggy scenarios where a touchend does not fire\r\n*/\r\nvar GlobalEmitter = /** @class */ (function () {\r\n    function GlobalEmitter() {\r\n        this.isTouching = false;\r\n        this.mouseIgnoreDepth = 0;\r\n    }\r\n    // gets the singleton\r\n    GlobalEmitter.get = function () {\r\n        if (!globalEmitter) {\r\n            globalEmitter = new GlobalEmitter();\r\n            globalEmitter.bind();\r\n        }\r\n        return globalEmitter;\r\n    };\r\n    // called when an object knows it will need a GlobalEmitter in the near future.\r\n    GlobalEmitter.needed = function () {\r\n        GlobalEmitter.get(); // ensures globalEmitter\r\n        neededCount++;\r\n    };\r\n    // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.\r\n    GlobalEmitter.unneeded = function () {\r\n        neededCount--;\r\n        if (!neededCount) {\r\n            globalEmitter.unbind();\r\n            globalEmitter = null;\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.bind = function () {\r\n        var _this = this;\r\n        this.listenTo($(document), {\r\n            touchstart: this.handleTouchStart,\r\n            touchcancel: this.handleTouchCancel,\r\n            touchend: this.handleTouchEnd,\r\n            mousedown: this.handleMouseDown,\r\n            mousemove: this.handleMouseMove,\r\n            mouseup: this.handleMouseUp,\r\n            click: this.handleClick,\r\n            selectstart: this.handleSelectStart,\r\n            contextmenu: this.handleContextMenu\r\n        });\r\n        // because we need to call preventDefault\r\n        // because https://www.chromestatus.com/features/5093566007214080\r\n        // TODO: investigate performance because this is a global handler\r\n        window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {\r\n            _this.handleTouchMove($.Event(ev));\r\n        }, { passive: false } // allows preventDefault()\r\n        );\r\n        // attach a handler to get called when ANY scroll action happens on the page.\r\n        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\r\n        // http://stackoverflow.com/a/32954565/96342\r\n        window.addEventListener('scroll', this.handleScrollProxy = function (ev) {\r\n            _this.handleScroll($.Event(ev));\r\n        }, true // useCapture\r\n        );\r\n    };\r\n    GlobalEmitter.prototype.unbind = function () {\r\n        this.stopListeningTo($(document));\r\n        window.removeEventListener('touchmove', this.handleTouchMoveProxy);\r\n        window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture\r\n        );\r\n    };\r\n    // Touch Handlers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.handleTouchStart = function (ev) {\r\n        // if a previous touch interaction never ended with a touchend, then implicitly end it,\r\n        // but since a new touch interaction is about to begin, don't start the mouse ignore period.\r\n        this.stopTouch(ev, true); // skipMouseIgnore=true\r\n        this.isTouching = true;\r\n        this.trigger('touchstart', ev);\r\n    };\r\n    GlobalEmitter.prototype.handleTouchMove = function (ev) {\r\n        if (this.isTouching) {\r\n            this.trigger('touchmove', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleTouchCancel = function (ev) {\r\n        if (this.isTouching) {\r\n            this.trigger('touchcancel', ev);\r\n            // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.\r\n            // If touchend fires later, it won't have any effect b/c isTouching will be false.\r\n            this.stopTouch(ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleTouchEnd = function (ev) {\r\n        this.stopTouch(ev);\r\n    };\r\n    // Mouse Handlers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.handleMouseDown = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('mousedown', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleMouseMove = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('mousemove', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleMouseUp = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('mouseup', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleClick = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('click', ev);\r\n        }\r\n    };\r\n    // Misc Handlers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.handleSelectStart = function (ev) {\r\n        this.trigger('selectstart', ev);\r\n    };\r\n    GlobalEmitter.prototype.handleContextMenu = function (ev) {\r\n        this.trigger('contextmenu', ev);\r\n    };\r\n    GlobalEmitter.prototype.handleScroll = function (ev) {\r\n        this.trigger('scroll', ev);\r\n    };\r\n    // Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {\r\n        if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }\r\n        if (this.isTouching) {\r\n            this.isTouching = false;\r\n            this.trigger('touchend', ev);\r\n            if (!skipMouseIgnore) {\r\n                this.startTouchMouseIgnore();\r\n            }\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.startTouchMouseIgnore = function () {\r\n        var _this = this;\r\n        var wait = exportHooks.touchMouseIgnoreWait;\r\n        if (wait) {\r\n            this.mouseIgnoreDepth++;\r\n            setTimeout(function () {\r\n                _this.mouseIgnoreDepth--;\r\n            }, wait);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.shouldIgnoreMouse = function () {\r\n        return this.isTouching || Boolean(this.mouseIgnoreDepth);\r\n    };\r\n    return GlobalEmitter;\r\n}());\r\nexports.default = GlobalEmitter;\r\nListenerMixin_1.default.mixInto(GlobalEmitter);\r\nEmitterMixin_1.default.mixInto(GlobalEmitter);\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar exportHooks = __webpack_require__(16);\r\nexports.viewHash = {};\r\nexportHooks.views = exports.viewHash;\r\nfunction defineView(viewName, viewConfig) {\r\n    exports.viewHash[viewName] = viewConfig;\r\n}\r\nexports.defineView = defineView;\r\nfunction getViewConfig(viewName) {\r\n    return exports.viewHash[viewName];\r\n}\r\nexports.getViewConfig = getViewConfig;\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar DragListener_1 = __webpack_require__(54);\r\n/* Tracks mouse movements over a component and raises events about which hit the mouse is over.\r\n------------------------------------------------------------------------------------------------------------------------\r\noptions:\r\n- subjectEl\r\n- subjectCenter\r\n*/\r\nvar HitDragListener = /** @class */ (function (_super) {\r\n    tslib_1.__extends(HitDragListener, _super);\r\n    function HitDragListener(component, options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this.component = component;\r\n        return _this;\r\n    }\r\n    // Called when drag listening starts (but a real drag has not necessarily began).\r\n    // ev might be undefined if dragging was started manually.\r\n    HitDragListener.prototype.handleInteractionStart = function (ev) {\r\n        var subjectEl = this.subjectEl;\r\n        var subjectRect;\r\n        var origPoint;\r\n        var point;\r\n        this.component.hitsNeeded();\r\n        this.computeScrollBounds(); // for autoscroll\r\n        if (ev) {\r\n            origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };\r\n            point = origPoint;\r\n            // constrain the point to bounds of the element being dragged\r\n            if (subjectEl) {\r\n                subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well\r\n                point = util_1.constrainPoint(point, subjectRect);\r\n            }\r\n            this.origHit = this.queryHit(point.left, point.top);\r\n            // treat the center of the subject as the collision point?\r\n            if (subjectEl && this.options.subjectCenter) {\r\n                // only consider the area the subject overlaps the hit. best for large subjects.\r\n                // TODO: skip this if hit didn't supply left/right/top/bottom\r\n                if (this.origHit) {\r\n                    subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||\r\n                        subjectRect; // in case there is no intersection\r\n                }\r\n                point = util_1.getRectCenter(subjectRect);\r\n            }\r\n            this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint\r\n        }\r\n        else {\r\n            this.origHit = null;\r\n            this.coordAdjust = null;\r\n        }\r\n        // call the super-method. do it after origHit has been computed\r\n        _super.prototype.handleInteractionStart.call(this, ev);\r\n    };\r\n    // Called when the actual drag has started\r\n    HitDragListener.prototype.handleDragStart = function (ev) {\r\n        var hit;\r\n        _super.prototype.handleDragStart.call(this, ev);\r\n        // might be different from this.origHit if the min-distance is large\r\n        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));\r\n        // report the initial hit the mouse is over\r\n        // especially important if no min-distance and drag starts immediately\r\n        if (hit) {\r\n            this.handleHitOver(hit);\r\n        }\r\n    };\r\n    // Called when the drag moves\r\n    HitDragListener.prototype.handleDrag = function (dx, dy, ev) {\r\n        var hit;\r\n        _super.prototype.handleDrag.call(this, dx, dy, ev);\r\n        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));\r\n        if (!isHitsEqual(hit, this.hit)) {\r\n            if (this.hit) {\r\n                this.handleHitOut();\r\n            }\r\n            if (hit) {\r\n                this.handleHitOver(hit);\r\n            }\r\n        }\r\n    };\r\n    // Called when dragging has been stopped\r\n    HitDragListener.prototype.handleDragEnd = function (ev) {\r\n        this.handleHitDone();\r\n        _super.prototype.handleDragEnd.call(this, ev);\r\n    };\r\n    // Called when a the mouse has just moved over a new hit\r\n    HitDragListener.prototype.handleHitOver = function (hit) {\r\n        var isOrig = isHitsEqual(hit, this.origHit);\r\n        this.hit = hit;\r\n        this.trigger('hitOver', this.hit, isOrig, this.origHit);\r\n    };\r\n    // Called when the mouse has just moved out of a hit\r\n    HitDragListener.prototype.handleHitOut = function () {\r\n        if (this.hit) {\r\n            this.trigger('hitOut', this.hit);\r\n            this.handleHitDone();\r\n            this.hit = null;\r\n        }\r\n    };\r\n    // Called after a hitOut. Also called before a dragStop\r\n    HitDragListener.prototype.handleHitDone = function () {\r\n        if (this.hit) {\r\n            this.trigger('hitDone', this.hit);\r\n        }\r\n    };\r\n    // Called when the interaction ends, whether there was a real drag or not\r\n    HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {\r\n        _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);\r\n        this.origHit = null;\r\n        this.hit = null;\r\n        this.component.hitsNotNeeded();\r\n    };\r\n    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\r\n    HitDragListener.prototype.handleScrollEnd = function () {\r\n        _super.prototype.handleScrollEnd.call(this);\r\n        // hits' absolute positions will be in new places after a user's scroll.\r\n        // HACK for recomputing.\r\n        if (this.isDragging) {\r\n            this.component.releaseHits();\r\n            this.component.prepareHits();\r\n        }\r\n    };\r\n    // Gets the hit underneath the coordinates for the given mouse event\r\n    HitDragListener.prototype.queryHit = function (left, top) {\r\n        if (this.coordAdjust) {\r\n            left += this.coordAdjust.left;\r\n            top += this.coordAdjust.top;\r\n        }\r\n        return this.component.queryHit(left, top);\r\n    };\r\n    return HitDragListener;\r\n}(DragListener_1.default));\r\nexports.default = HitDragListener;\r\n// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\r\n// Two null values will be considered equal, as two \"out of the component\" states are the same.\r\nfunction isHitsEqual(hit0, hit1) {\r\n    if (!hit0 && !hit1) {\r\n        return true;\r\n    }\r\n    if (hit0 && hit1) {\r\n        return hit0.component === hit1.component &&\r\n            isHitPropsWithin(hit0, hit1) &&\r\n            isHitPropsWithin(hit1, hit0); // ensures all props are identical\r\n    }\r\n    return false;\r\n}\r\n// Returns true if all of subHit's non-standard properties are within superHit\r\nfunction isHitPropsWithin(subHit, superHit) {\r\n    for (var propName in subHit) {\r\n        if (!/^(component|left|right|top|bottom)$/.test(propName)) {\r\n            if (subHit[propName] !== superHit[propName]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n/***/ }),\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar exportHooks = __webpack_require__(16);\r\nvar options_1 = __webpack_require__(32);\r\nvar util_1 = __webpack_require__(4);\r\nexports.localeOptionHash = {};\r\nexportHooks.locales = exports.localeOptionHash;\r\n// NOTE: can't guarantee any of these computations will run because not every locale has datepicker\r\n// configs, so make sure there are English fallbacks for these in the defaults file.\r\nvar dpComputableOptions = {\r\n    buttonText: function (dpOptions) {\r\n        return {\r\n            // the translations sometimes wrongly contain HTML entities\r\n            prev: util_1.stripHtmlEntities(dpOptions.prevText),\r\n            next: util_1.stripHtmlEntities(dpOptions.nextText),\r\n            today: util_1.stripHtmlEntities(dpOptions.currentText)\r\n        };\r\n    },\r\n    // Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\r\n    monthYearFormat: function (dpOptions) {\r\n        return dpOptions.showMonthAfterYear ?\r\n            'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\r\n            'MMMM YYYY[' + dpOptions.yearSuffix + ']';\r\n    }\r\n};\r\nvar momComputableOptions = {\r\n    // Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\r\n    dayOfMonthFormat: function (momOptions, fcOptions) {\r\n        var format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\r\n        // strip the year off the edge, as well as other misc non-whitespace chars\r\n        format = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\r\n        if (fcOptions.isRTL) {\r\n            format += ' ddd'; // for RTL, add day-of-week to end\r\n        }\r\n        else {\r\n            format = 'ddd ' + format; // for LTR, add day-of-week to beginning\r\n        }\r\n        return format;\r\n    },\r\n    // Produces format strings like \"h:mma\" -> \"6:00pm\"\r\n    mediumTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\r\n    smallTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(':mm', '(:mm)')\r\n            .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\r\n            .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\r\n    extraSmallTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(':mm', '(:mm)')\r\n            .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\r\n            .replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\r\n    hourFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(':mm', '')\r\n            .replace(/(\\Wmm)$/, '') // like above, but for foreign locales\r\n            .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\r\n    noMeridiemTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(/\\s*a$/i, ''); // remove trailing AM/PM\r\n    }\r\n};\r\n// options that should be computed off live calendar options (considers override options)\r\n// TODO: best place for this? related to locale?\r\n// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\r\nvar instanceComputableOptions = {\r\n    // Produces format strings for results like \"Mo 16\"\r\n    smallDayDateFormat: function (options) {\r\n        return options.isRTL ?\r\n            'D dd' :\r\n            'dd D';\r\n    },\r\n    // Produces format strings for results like \"Wk 5\"\r\n    weekFormat: function (options) {\r\n        return options.isRTL ?\r\n            'w[ ' + options.weekNumberTitle + ']' :\r\n            '[' + options.weekNumberTitle + ' ]w';\r\n    },\r\n    // Produces format strings for results like \"Wk5\"\r\n    smallWeekFormat: function (options) {\r\n        return options.isRTL ?\r\n            'w[' + options.weekNumberTitle + ']' :\r\n            '[' + options.weekNumberTitle + ']w';\r\n    }\r\n};\r\n// TODO: make these computable properties in optionsManager\r\nfunction populateInstanceComputableOptions(options) {\r\n    $.each(instanceComputableOptions, function (name, func) {\r\n        if (options[name] == null) {\r\n            options[name] = func(options);\r\n        }\r\n    });\r\n}\r\nexports.populateInstanceComputableOptions = populateInstanceComputableOptions;\r\n// Initialize jQuery UI datepicker translations while using some of the translations\r\n// Will set this as the default locales for datepicker.\r\nfunction datepickerLocale(localeCode, dpLocaleCode, dpOptions) {\r\n    // get the FullCalendar internal option hash for this locale. create if necessary\r\n    var fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});\r\n    // transfer some simple options from datepicker to fc\r\n    fcOptions.isRTL = dpOptions.isRTL;\r\n    fcOptions.weekNumberTitle = dpOptions.weekHeader;\r\n    // compute some more complex options from datepicker\r\n    $.each(dpComputableOptions, function (name, func) {\r\n        fcOptions[name] = func(dpOptions);\r\n    });\r\n    var jqDatePicker = $.datepicker;\r\n    // is jQuery UI Datepicker is on the page?\r\n    if (jqDatePicker) {\r\n        // Register the locale data.\r\n        // FullCalendar and MomentJS use locale codes like \"pt-br\" but Datepicker\r\n        // does it like \"pt-BR\" or if it doesn't have the locale, maybe just \"pt\".\r\n        // Make an alias so the locale can be referenced either way.\r\n        jqDatePicker.regional[dpLocaleCode] =\r\n            jqDatePicker.regional[localeCode] = // alias\r\n                dpOptions;\r\n        // Alias 'en' to the default locale data. Do this every time.\r\n        jqDatePicker.regional.en = jqDatePicker.regional[''];\r\n        // Set as Datepicker's global defaults.\r\n        jqDatePicker.setDefaults(dpOptions);\r\n    }\r\n}\r\nexports.datepickerLocale = datepickerLocale;\r\n// Sets FullCalendar-specific translations. Will set the locales as the global default.\r\nfunction locale(localeCode, newFcOptions) {\r\n    var fcOptions;\r\n    var momOptions;\r\n    // get the FullCalendar internal option hash for this locale. create if necessary\r\n    fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});\r\n    // provided new options for this locales? merge them in\r\n    if (newFcOptions) {\r\n        fcOptions = exports.localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);\r\n    }\r\n    // compute locale options that weren't defined.\r\n    // always do this. newFcOptions can be undefined when initializing from i18n file,\r\n    // so no way to tell if this is an initialization or a default-setting.\r\n    momOptions = getMomentLocaleData(localeCode); // will fall back to en\r\n    $.each(momComputableOptions, function (name, func) {\r\n        if (fcOptions[name] == null) {\r\n            fcOptions[name] = (func)(momOptions, fcOptions);\r\n        }\r\n    });\r\n    // set it as the default locale for FullCalendar\r\n    options_1.globalDefaults.locale = localeCode;\r\n}\r\nexports.locale = locale;\r\n// Returns moment's internal locale data. If doesn't exist, returns English.\r\nfunction getMomentLocaleData(localeCode) {\r\n    return moment.localeData(localeCode) || moment.localeData('en');\r\n}\r\nexports.getMomentLocaleData = getMomentLocaleData;\r\n// Initialize English by forcing computation of moment-derived options.\r\n// Also, sets it as the default.\r\nlocale('en', options_1.englishDefaults);\r\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(4);\r\nexports.globalDefaults = {\r\n    titleRangeSeparator: ' \\u2013 ',\r\n    monthYearFormat: 'MMMM YYYY',\r\n    defaultTimedEventDuration: '02:00:00',\r\n    defaultAllDayEventDuration: { days: 1 },\r\n    forceEventDuration: false,\r\n    nextDayThreshold: '09:00:00',\r\n    // display\r\n    columnHeader: true,\r\n    defaultView: 'month',\r\n    aspectRatio: 1.35,\r\n    header: {\r\n        left: 'title',\r\n        center: '',\r\n        right: 'today prev,next'\r\n    },\r\n    weekends: true,\r\n    weekNumbers: false,\r\n    weekNumberTitle: 'W',\r\n    weekNumberCalculation: 'local',\r\n    // editable: false,\r\n    // nowIndicator: false,\r\n    scrollTime: '06:00:00',\r\n    minTime: '00:00:00',\r\n    maxTime: '24:00:00',\r\n    showNonCurrentDates: true,\r\n    // event ajax\r\n    lazyFetching: true,\r\n    startParam: 'start',\r\n    endParam: 'end',\r\n    timezoneParam: 'timezone',\r\n    timezone: false,\r\n    // allDayDefault: undefined,\r\n    // locale\r\n    locale: null,\r\n    isRTL: false,\r\n    buttonText: {\r\n        prev: 'prev',\r\n        next: 'next',\r\n        prevYear: 'prev year',\r\n        nextYear: 'next year',\r\n        year: 'year',\r\n        today: 'today',\r\n        month: 'month',\r\n        week: 'week',\r\n        day: 'day'\r\n    },\r\n    // buttonIcons: null,\r\n    allDayText: 'all-day',\r\n    // allows setting a min-height to the event segment to prevent short events overlapping each other\r\n    agendaEventMinHeight: 0,\r\n    // jquery-ui theming\r\n    theme: false,\r\n    // themeButtonIcons: null,\r\n    // eventResizableFromStart: false,\r\n    dragOpacity: .75,\r\n    dragRevertDuration: 500,\r\n    dragScroll: true,\r\n    // selectable: false,\r\n    unselectAuto: true,\r\n    // selectMinDistance: 0,\r\n    dropAccept: '*',\r\n    eventOrder: 'title',\r\n    // eventRenderWait: null,\r\n    eventLimit: false,\r\n    eventLimitText: 'more',\r\n    eventLimitClick: 'popover',\r\n    dayPopoverFormat: 'LL',\r\n    handleWindowResize: true,\r\n    windowResizeDelay: 100,\r\n    longPressDelay: 1000\r\n};\r\nexports.englishDefaults = {\r\n    dayPopoverFormat: 'dddd, MMMM D'\r\n};\r\nexports.rtlDefaults = {\r\n    header: {\r\n        left: 'next,prev today',\r\n        center: '',\r\n        right: 'title'\r\n    },\r\n    buttonIcons: {\r\n        prev: 'right-single-arrow',\r\n        next: 'left-single-arrow',\r\n        prevYear: 'right-double-arrow',\r\n        nextYear: 'left-double-arrow'\r\n    },\r\n    themeButtonIcons: {\r\n        prev: 'circle-triangle-e',\r\n        next: 'circle-triangle-w',\r\n        nextYear: 'seek-prev',\r\n        prevYear: 'seek-next'\r\n    }\r\n};\r\nvar complexOptions = [\r\n    'header',\r\n    'footer',\r\n    'buttonText',\r\n    'buttonIcons',\r\n    'themeButtonIcons'\r\n];\r\n// Merges an array of option objects into a single object\r\nfunction mergeOptions(optionObjs) {\r\n    return util_1.mergeProps(optionObjs, complexOptions);\r\n}\r\nexports.mergeOptions = mergeOptions;\r\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\n// Class that all other classes will inherit from\r\nvar Class = /** @class */ (function () {\r\n    function Class() {\r\n    }\r\n    // Called on a class to create a subclass.\r\n    // LIMITATION: cannot provide a constructor!\r\n    Class.extend = function (members) {\r\n        var SubClass = /** @class */ (function (_super) {\r\n            tslib_1.__extends(SubClass, _super);\r\n            function SubClass() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            return SubClass;\r\n        }(this));\r\n        util_1.copyOwnProps(members, SubClass.prototype);\r\n        return SubClass;\r\n    };\r\n    // Adds new member variables/methods to the class's prototype.\r\n    // Can be called with another class, or a plain object hash containing new members.\r\n    Class.mixin = function (members) {\r\n        util_1.copyOwnProps(members, this.prototype);\r\n    };\r\n    return Class;\r\n}());\r\nexports.default = Class;\r\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar ParsableModelMixin_1 = __webpack_require__(208);\r\nvar EventDef = /** @class */ (function () {\r\n    function EventDef(source) {\r\n        this.source = source;\r\n        this.className = [];\r\n        this.miscProps = {};\r\n    }\r\n    EventDef.parse = function (rawInput, source) {\r\n        var def = new this(source);\r\n        if (def.applyProps(rawInput)) {\r\n            return def;\r\n        }\r\n        return false;\r\n    };\r\n    EventDef.normalizeId = function (id) {\r\n        return String(id);\r\n    };\r\n    EventDef.generateId = function () {\r\n        return '_fc' + (EventDef.uuid++);\r\n    };\r\n    EventDef.prototype.clone = function () {\r\n        var copy = new this.constructor(this.source);\r\n        copy.id = this.id;\r\n        copy.rawId = this.rawId;\r\n        copy.uid = this.uid; // not really unique anymore :(\r\n        EventDef.copyVerbatimStandardProps(this, copy);\r\n        copy.className = this.className.slice(); // copy\r\n        copy.miscProps = $.extend({}, this.miscProps);\r\n        return copy;\r\n    };\r\n    EventDef.prototype.hasInverseRendering = function () {\r\n        return this.getRendering() === 'inverse-background';\r\n    };\r\n    EventDef.prototype.hasBgRendering = function () {\r\n        var rendering = this.getRendering();\r\n        return rendering === 'inverse-background' || rendering === 'background';\r\n    };\r\n    EventDef.prototype.getRendering = function () {\r\n        if (this.rendering != null) {\r\n            return this.rendering;\r\n        }\r\n        return this.source.rendering;\r\n    };\r\n    EventDef.prototype.getConstraint = function () {\r\n        if (this.constraint != null) {\r\n            return this.constraint;\r\n        }\r\n        if (this.source.constraint != null) {\r\n            return this.source.constraint;\r\n        }\r\n        return this.source.calendar.opt('eventConstraint'); // what about View option?\r\n    };\r\n    EventDef.prototype.getOverlap = function () {\r\n        if (this.overlap != null) {\r\n            return this.overlap;\r\n        }\r\n        if (this.source.overlap != null) {\r\n            return this.source.overlap;\r\n        }\r\n        return this.source.calendar.opt('eventOverlap'); // what about View option?\r\n    };\r\n    EventDef.prototype.isStartExplicitlyEditable = function () {\r\n        if (this.startEditable != null) {\r\n            return this.startEditable;\r\n        }\r\n        return this.source.startEditable;\r\n    };\r\n    EventDef.prototype.isDurationExplicitlyEditable = function () {\r\n        if (this.durationEditable != null) {\r\n            return this.durationEditable;\r\n        }\r\n        return this.source.durationEditable;\r\n    };\r\n    EventDef.prototype.isExplicitlyEditable = function () {\r\n        if (this.editable != null) {\r\n            return this.editable;\r\n        }\r\n        return this.source.editable;\r\n    };\r\n    EventDef.prototype.toLegacy = function () {\r\n        var obj = $.extend({}, this.miscProps);\r\n        obj._id = this.uid;\r\n        obj.source = this.source;\r\n        obj.className = this.className.slice(); // copy\r\n        obj.allDay = this.isAllDay();\r\n        if (this.rawId != null) {\r\n            obj.id = this.rawId;\r\n        }\r\n        EventDef.copyVerbatimStandardProps(this, obj);\r\n        return obj;\r\n    };\r\n    EventDef.prototype.applyManualStandardProps = function (rawProps) {\r\n        if (rawProps.id != null) {\r\n            this.id = EventDef.normalizeId((this.rawId = rawProps.id));\r\n        }\r\n        else {\r\n            this.id = EventDef.generateId();\r\n        }\r\n        if (rawProps._id != null) {\r\n            this.uid = String(rawProps._id);\r\n        }\r\n        else {\r\n            this.uid = EventDef.generateId();\r\n        }\r\n        // TODO: converge with EventSource\r\n        if ($.isArray(rawProps.className)) {\r\n            this.className = rawProps.className;\r\n        }\r\n        if (typeof rawProps.className === 'string') {\r\n            this.className = rawProps.className.split(/\\s+/);\r\n        }\r\n        return true;\r\n    };\r\n    EventDef.prototype.applyMiscProps = function (rawProps) {\r\n        $.extend(this.miscProps, rawProps);\r\n    };\r\n    EventDef.uuid = 0;\r\n    EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;\r\n    EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;\r\n    return EventDef;\r\n}());\r\nexports.default = EventDef;\r\nParsableModelMixin_1.default.mixInto(EventDef);\r\nEventDef.defineStandardProps({\r\n    // not automatically assigned (`false`)\r\n    _id: false,\r\n    id: false,\r\n    className: false,\r\n    source: false,\r\n    // automatically assigned (`true`)\r\n    title: true,\r\n    url: true,\r\n    rendering: true,\r\n    constraint: true,\r\n    overlap: true,\r\n    editable: true,\r\n    startEditable: true,\r\n    durationEditable: true,\r\n    color: true,\r\n    backgroundColor: true,\r\n    borderColor: true,\r\n    textColor: true\r\n});\r\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventRange_1 = __webpack_require__(211);\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nfunction eventDefsToEventInstances(eventDefs, unzonedRange) {\r\n    var eventInstances = [];\r\n    var i;\r\n    for (i = 0; i < eventDefs.length; i++) {\r\n        eventInstances.push.apply(eventInstances, // append\r\n        eventDefs[i].buildInstances(unzonedRange));\r\n    }\r\n    return eventInstances;\r\n}\r\nexports.eventDefsToEventInstances = eventDefsToEventInstances;\r\nfunction eventInstanceToEventRange(eventInstance) {\r\n    return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);\r\n}\r\nexports.eventInstanceToEventRange = eventInstanceToEventRange;\r\nfunction eventRangeToEventFootprint(eventRange) {\r\n    return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist\r\n    );\r\n}\r\nexports.eventRangeToEventFootprint = eventRangeToEventFootprint;\r\nfunction eventInstanceToUnzonedRange(eventInstance) {\r\n    return eventInstance.dateProfile.unzonedRange;\r\n}\r\nexports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;\r\nfunction eventFootprintToComponentFootprint(eventFootprint) {\r\n    return eventFootprint.componentFootprint;\r\n}\r\nexports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;\r\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventFootprint = /** @class */ (function () {\r\n    function EventFootprint(componentFootprint, eventDef, eventInstance) {\r\n        this.componentFootprint = componentFootprint;\r\n        this.eventDef = eventDef;\r\n        if (eventInstance) {\r\n            this.eventInstance = eventInstance;\r\n        }\r\n    }\r\n    EventFootprint.prototype.getEventLegacy = function () {\r\n        return (this.eventInstance || this.eventDef).toLegacy();\r\n    };\r\n    return EventFootprint;\r\n}());\r\nexports.default = EventFootprint;\r\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar EventDef_1 = __webpack_require__(34);\r\nvar EventDefDateMutation_1 = __webpack_require__(50);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventDefMutation = /** @class */ (function () {\r\n    function EventDefMutation() {\r\n    }\r\n    EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {\r\n        var eventDef = eventInstance.def;\r\n        var dateProps = {};\r\n        var standardProps = {};\r\n        var miscProps = {};\r\n        var verbatimStandardProps = {};\r\n        var eventDefId = null;\r\n        var className = null;\r\n        var propName;\r\n        var dateProfile;\r\n        var dateMutation;\r\n        var defMutation;\r\n        for (propName in rawProps) {\r\n            if (EventDateProfile_1.default.isStandardProp(propName)) {\r\n                dateProps[propName] = rawProps[propName];\r\n            }\r\n            else if (eventDef.isStandardProp(propName)) {\r\n                standardProps[propName] = rawProps[propName];\r\n            }\r\n            else if (eventDef.miscProps[propName] !== rawProps[propName]) {\r\n                miscProps[propName] = rawProps[propName];\r\n            }\r\n        }\r\n        dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);\r\n        if (dateProfile) {\r\n            dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);\r\n        }\r\n        if (standardProps.id !== eventDef.id) {\r\n            eventDefId = standardProps.id; // only apply if there's a change\r\n        }\r\n        if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {\r\n            className = standardProps.className; // only apply if there's a change\r\n        }\r\n        EventDef_1.default.copyVerbatimStandardProps(standardProps, // src\r\n        verbatimStandardProps // dest\r\n        );\r\n        defMutation = new EventDefMutation();\r\n        defMutation.eventDefId = eventDefId;\r\n        defMutation.className = className;\r\n        defMutation.verbatimStandardProps = verbatimStandardProps;\r\n        defMutation.miscProps = miscProps;\r\n        if (dateMutation) {\r\n            defMutation.dateMutation = dateMutation;\r\n        }\r\n        return defMutation;\r\n    };\r\n    /*\r\n    eventDef assumed to be a SingleEventDef.\r\n    returns an undo function.\r\n    */\r\n    EventDefMutation.prototype.mutateSingle = function (eventDef) {\r\n        var origDateProfile;\r\n        if (this.dateMutation) {\r\n            origDateProfile = eventDef.dateProfile;\r\n            eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);\r\n        }\r\n        // can't undo\r\n        // TODO: more DRY with EventDef::applyManualStandardProps\r\n        if (this.eventDefId != null) {\r\n            eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));\r\n        }\r\n        // can't undo\r\n        // TODO: more DRY with EventDef::applyManualStandardProps\r\n        if (this.className) {\r\n            eventDef.className = this.className;\r\n        }\r\n        // can't undo\r\n        if (this.verbatimStandardProps) {\r\n            SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src\r\n            eventDef // dest\r\n            );\r\n        }\r\n        // can't undo\r\n        if (this.miscProps) {\r\n            eventDef.applyMiscProps(this.miscProps);\r\n        }\r\n        if (origDateProfile) {\r\n            return function () {\r\n                eventDef.dateProfile = origDateProfile;\r\n            };\r\n        }\r\n        else {\r\n            return function () { };\r\n        }\r\n    };\r\n    EventDefMutation.prototype.setDateMutation = function (dateMutation) {\r\n        if (dateMutation && !dateMutation.isEmpty()) {\r\n            this.dateMutation = dateMutation;\r\n        }\r\n        else {\r\n            this.dateMutation = null;\r\n        }\r\n    };\r\n    EventDefMutation.prototype.isEmpty = function () {\r\n        return !this.dateMutation;\r\n    };\r\n    return EventDefMutation;\r\n}());\r\nexports.default = EventDefMutation;\r\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    sourceClasses: [],\r\n    registerClass: function (EventSourceClass) {\r\n        this.sourceClasses.unshift(EventSourceClass); // give highest priority\r\n    },\r\n    parse: function (rawInput, calendar) {\r\n        var sourceClasses = this.sourceClasses;\r\n        var i;\r\n        var eventSource;\r\n        for (i = 0; i < sourceClasses.length; i++) {\r\n            eventSource = sourceClasses[i].parse(rawInput, calendar);\r\n            if (eventSource) {\r\n                return eventSource;\r\n            }\r\n        }\r\n    }\r\n};\r\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Class_1 = __webpack_require__(33);\r\n/*\r\nEmbodies a div that has potential scrollbars\r\n*/\r\nvar Scroller = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Scroller, _super);\r\n    function Scroller(options) {\r\n        var _this = _super.call(this) || this;\r\n        options = options || {};\r\n        _this.overflowX = options.overflowX || options.overflow || 'auto';\r\n        _this.overflowY = options.overflowY || options.overflow || 'auto';\r\n        return _this;\r\n    }\r\n    Scroller.prototype.render = function () {\r\n        this.el = this.renderEl();\r\n        this.applyOverflow();\r\n    };\r\n    Scroller.prototype.renderEl = function () {\r\n        return (this.scrollEl = $('<div class=\"fc-scroller\"></div>'));\r\n    };\r\n    // sets to natural height, unlocks overflow\r\n    Scroller.prototype.clear = function () {\r\n        this.setHeight('auto');\r\n        this.applyOverflow();\r\n    };\r\n    Scroller.prototype.destroy = function () {\r\n        this.el.remove();\r\n    };\r\n    // Overflow\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Scroller.prototype.applyOverflow = function () {\r\n        this.scrollEl.css({\r\n            'overflow-x': this.overflowX,\r\n            'overflow-y': this.overflowY\r\n        });\r\n    };\r\n    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\r\n    // Useful for preserving scrollbar widths regardless of future resizes.\r\n    // Can pass in scrollbarWidths for optimization.\r\n    Scroller.prototype.lockOverflow = function (scrollbarWidths) {\r\n        var overflowX = this.overflowX;\r\n        var overflowY = this.overflowY;\r\n        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\r\n        if (overflowX === 'auto') {\r\n            overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\r\n                // OR scrolling pane with massless scrollbars?\r\n                this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth) ? 'scroll' : 'hidden';\r\n        }\r\n        if (overflowY === 'auto') {\r\n            overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\r\n                // OR scrolling pane with massless scrollbars?\r\n                this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight) ? 'scroll' : 'hidden';\r\n        }\r\n        this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\r\n    };\r\n    // Getters / Setters\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Scroller.prototype.setHeight = function (height) {\r\n        this.scrollEl.height(height);\r\n    };\r\n    Scroller.prototype.getScrollTop = function () {\r\n        return this.scrollEl.scrollTop();\r\n    };\r\n    Scroller.prototype.setScrollTop = function (top) {\r\n        this.scrollEl.scrollTop(top);\r\n    };\r\n    Scroller.prototype.getClientWidth = function () {\r\n        return this.scrollEl[0].clientWidth;\r\n    };\r\n    Scroller.prototype.getClientHeight = function () {\r\n        return this.scrollEl[0].clientHeight;\r\n    };\r\n    Scroller.prototype.getScrollbarWidths = function () {\r\n        return util_1.getScrollbarWidths(this.scrollEl);\r\n    };\r\n    return Scroller;\r\n}(Class_1.default));\r\nexports.default = Scroller;\r\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar DateComponent_1 = __webpack_require__(219);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar InteractiveDateComponent = /** @class */ (function (_super) {\r\n    tslib_1.__extends(InteractiveDateComponent, _super);\r\n    function InteractiveDateComponent(_view, _options) {\r\n        var _this = _super.call(this, _view, _options) || this;\r\n        // self-config, overridable by subclasses\r\n        _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?\r\n        if (_this.dateSelectingClass) {\r\n            _this.dateClicking = new _this.dateClickingClass(_this);\r\n        }\r\n        if (_this.dateSelectingClass) {\r\n            _this.dateSelecting = new _this.dateSelectingClass(_this);\r\n        }\r\n        if (_this.eventPointingClass) {\r\n            _this.eventPointing = new _this.eventPointingClass(_this);\r\n        }\r\n        if (_this.eventDraggingClass && _this.eventPointing) {\r\n            _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);\r\n        }\r\n        if (_this.eventResizingClass && _this.eventPointing) {\r\n            _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);\r\n        }\r\n        if (_this.externalDroppingClass) {\r\n            _this.externalDropping = new _this.externalDroppingClass(_this);\r\n        }\r\n        return _this;\r\n    }\r\n    // Sets the container element that the view should render inside of, does global DOM-related initializations,\r\n    // and renders all the non-date-related content inside.\r\n    InteractiveDateComponent.prototype.setElement = function (el) {\r\n        _super.prototype.setElement.call(this, el);\r\n        if (this.dateClicking) {\r\n            this.dateClicking.bindToEl(el);\r\n        }\r\n        if (this.dateSelecting) {\r\n            this.dateSelecting.bindToEl(el);\r\n        }\r\n        this.bindAllSegHandlersToEl(el);\r\n    };\r\n    InteractiveDateComponent.prototype.removeElement = function () {\r\n        this.endInteractions();\r\n        _super.prototype.removeElement.call(this);\r\n    };\r\n    InteractiveDateComponent.prototype.executeEventUnrender = function () {\r\n        this.endInteractions();\r\n        _super.prototype.executeEventUnrender.call(this);\r\n    };\r\n    InteractiveDateComponent.prototype.bindGlobalHandlers = function () {\r\n        _super.prototype.bindGlobalHandlers.call(this);\r\n        if (this.externalDropping) {\r\n            this.externalDropping.bindToDocument();\r\n        }\r\n    };\r\n    InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {\r\n        _super.prototype.unbindGlobalHandlers.call(this);\r\n        if (this.externalDropping) {\r\n            this.externalDropping.unbindFromDocument();\r\n        }\r\n    };\r\n    InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {\r\n        var _this = this;\r\n        // attach a handler to the grid's root element.\r\n        // jQuery will take care of unregistering them when removeElement gets called.\r\n        this.el.on(name, function (ev) {\r\n            if (!$(ev.target).is(_this.segSelector + ':not(.fc-helper),' + // directly on an event element\r\n                _this.segSelector + ':not(.fc-helper) *,' + // within an event element\r\n                '.fc-more,' + // a \"more..\" link\r\n                'a[data-goto]' // a clickable nav link\r\n            )) {\r\n                return handler.call(_this, ev);\r\n            }\r\n        });\r\n    };\r\n    InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {\r\n        [\r\n            this.eventPointing,\r\n            this.eventDragging,\r\n            this.eventResizing\r\n        ].forEach(function (eventInteraction) {\r\n            if (eventInteraction) {\r\n                eventInteraction.bindToEl(el);\r\n            }\r\n        });\r\n    };\r\n    InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {\r\n        var _this = this;\r\n        el.on(name, this.segSelector, function (ev) {\r\n            var segEl = $(ev.currentTarget);\r\n            if (!segEl.is('.fc-helper')) {\r\n                var seg = segEl.data('fc-seg'); // grab segment data. put there by View::renderEventsPayload\r\n                if (seg && !_this.shouldIgnoreEventPointing()) {\r\n                    return handler.call(_this, seg, ev); // context will be the Grid\r\n                }\r\n            }\r\n        });\r\n    };\r\n    InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {\r\n        // HACK\r\n        // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.\r\n        return GlobalEmitter_1.default.get().shouldIgnoreMouse();\r\n    };\r\n    InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {\r\n        var view = this._getView();\r\n        // On iOS (and Android?) when a new selection is initiated overtop another selection,\r\n        // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).\r\n        // HACK: simply don't allow this to happen.\r\n        // ALSO: prevent selection when an *event* is already raised.\r\n        return view.isSelected || view.selectedEvent;\r\n    };\r\n    InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {\r\n        // only call the handlers if there is not a drag/resize in progress\r\n        return (this.eventDragging && this.eventDragging.isDragging) ||\r\n            (this.eventResizing && this.eventResizing.isResizing);\r\n    };\r\n    InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {\r\n        return util_1.getEvIsTouch(ev) &&\r\n            !this.canStartResize(seg, ev) &&\r\n            (this.isEventDefDraggable(seg.footprint.eventDef) ||\r\n                this.isEventDefResizable(seg.footprint.eventDef));\r\n    };\r\n    InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {\r\n        return !this.canStartResize(seg, ev) &&\r\n            this.isEventDefDraggable(seg.footprint.eventDef);\r\n    };\r\n    InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {\r\n        var view = this._getView();\r\n        var eventDef = seg.footprint.eventDef;\r\n        return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&\r\n            this.isEventDefResizable(eventDef) &&\r\n            $(ev.target).is('.fc-resizer');\r\n    };\r\n    // Kills all in-progress dragging.\r\n    // Useful for when public API methods that result in re-rendering are invoked during a drag.\r\n    // Also useful for when touch devices misbehave and don't fire their touchend.\r\n    InteractiveDateComponent.prototype.endInteractions = function () {\r\n        [\r\n            this.dateClicking,\r\n            this.dateSelecting,\r\n            this.eventPointing,\r\n            this.eventDragging,\r\n            this.eventResizing\r\n        ].forEach(function (interaction) {\r\n            if (interaction) {\r\n                interaction.end();\r\n            }\r\n        });\r\n    };\r\n    // Event Drag-n-Drop\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Computes if the given event is allowed to be dragged by the user\r\n    InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {\r\n        return this.isEventDefStartEditable(eventDef);\r\n    };\r\n    InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {\r\n        var isEditable = eventDef.isStartExplicitlyEditable();\r\n        if (isEditable == null) {\r\n            isEditable = this.opt('eventStartEditable');\r\n            if (isEditable == null) {\r\n                isEditable = this.isEventDefGenerallyEditable(eventDef);\r\n            }\r\n        }\r\n        return isEditable;\r\n    };\r\n    InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {\r\n        var isEditable = eventDef.isExplicitlyEditable();\r\n        if (isEditable == null) {\r\n            isEditable = this.opt('editable');\r\n        }\r\n        return isEditable;\r\n    };\r\n    // Event Resizing\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Computes if the given event is allowed to be resized from its starting edge\r\n    InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {\r\n        return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);\r\n    };\r\n    // Computes if the given event is allowed to be resized from its ending edge\r\n    InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {\r\n        return this.isEventDefResizable(eventDef);\r\n    };\r\n    // Computes if the given event is allowed to be resized by the user at all\r\n    InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {\r\n        var isResizable = eventDef.isDurationExplicitlyEditable();\r\n        if (isResizable == null) {\r\n            isResizable = this.opt('eventDurationEditable');\r\n            if (isResizable == null) {\r\n                isResizable = this.isEventDefGenerallyEditable(eventDef);\r\n            }\r\n        }\r\n        return isResizable;\r\n    };\r\n    // Event Mutation / Constraints\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Diffs the two dates, returning a duration, based on granularity of the grid\r\n    // TODO: port isTimeScale into this system?\r\n    InteractiveDateComponent.prototype.diffDates = function (a, b) {\r\n        if (this.largeUnit) {\r\n            return util_1.diffByUnit(a, b, this.largeUnit);\r\n        }\r\n        else {\r\n            return util_1.diffDayTime(a, b);\r\n        }\r\n    };\r\n    // is it allowed, in relation to the view's validRange?\r\n    // NOTE: very similar to isExternalInstanceGroupAllowed\r\n    InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {\r\n        var view = this._getView();\r\n        var dateProfile = this.dateProfile;\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            // TODO: just use getAllEventRanges directly\r\n            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\r\n                return false;\r\n            }\r\n        }\r\n        return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);\r\n    };\r\n    // NOTE: very similar to isEventInstanceGroupAllowed\r\n    // when it's a completely anonymous external drag, no event.\r\n    InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {\r\n        var view = this._getView();\r\n        var dateProfile = this.dateProfile;\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\r\n                return false;\r\n            }\r\n        }\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            // treat it as a selection\r\n            // TODO: pass in eventInstanceGroup instead\r\n            //  because we don't want calendar's constraint system to depend on a component's\r\n            //  determination of footprints.\r\n            if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return InteractiveDateComponent;\r\n}(DateComponent_1.default));\r\nexports.default = InteractiveDateComponent;\r\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar RenderQueue_1 = __webpack_require__(218);\r\nvar DateProfileGenerator_1 = __webpack_require__(221);\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\n/* An abstract class from which other views inherit from\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar View = /** @class */ (function (_super) {\r\n    tslib_1.__extends(View, _super);\r\n    function View(calendar, viewSpec) {\r\n        var _this = _super.call(this, null, viewSpec.options) || this;\r\n        _this.batchRenderDepth = 0;\r\n        _this.isSelected = false; // boolean whether a range of time is user-selected or not\r\n        _this.calendar = calendar;\r\n        _this.viewSpec = viewSpec;\r\n        // shortcuts\r\n        _this.type = viewSpec.type;\r\n        // .name is deprecated\r\n        _this.name = _this.type;\r\n        _this.initRenderQueue();\r\n        _this.initHiddenDays();\r\n        _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);\r\n        _this.bindBaseRenderHandlers();\r\n        _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));\r\n        // legacy\r\n        if (_this['initialize']) {\r\n            _this['initialize']();\r\n        }\r\n        return _this;\r\n    }\r\n    View.prototype._getView = function () {\r\n        return this;\r\n    };\r\n    // Retrieves an option with the given name\r\n    View.prototype.opt = function (name) {\r\n        return this.options[name];\r\n    };\r\n    /* Render Queue\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.initRenderQueue = function () {\r\n        this.renderQueue = new RenderQueue_1.default({\r\n            event: this.opt('eventRenderWait')\r\n        });\r\n        this.renderQueue.on('start', this.onRenderQueueStart.bind(this));\r\n        this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));\r\n        this.on('before:change', this.startBatchRender);\r\n        this.on('change', this.stopBatchRender);\r\n    };\r\n    View.prototype.onRenderQueueStart = function () {\r\n        this.calendar.freezeContentHeight();\r\n        this.addScroll(this.queryScroll());\r\n    };\r\n    View.prototype.onRenderQueueStop = function () {\r\n        if (this.calendar.updateViewSize()) {\r\n            this.popScroll();\r\n        }\r\n        this.calendar.thawContentHeight();\r\n    };\r\n    View.prototype.startBatchRender = function () {\r\n        if (!(this.batchRenderDepth++)) {\r\n            this.renderQueue.pause();\r\n        }\r\n    };\r\n    View.prototype.stopBatchRender = function () {\r\n        if (!(--this.batchRenderDepth)) {\r\n            this.renderQueue.resume();\r\n        }\r\n    };\r\n    View.prototype.requestRender = function (func, namespace, actionType) {\r\n        this.renderQueue.queue(func, namespace, actionType);\r\n    };\r\n    // given func will auto-bind to `this`\r\n    View.prototype.whenSizeUpdated = function (func) {\r\n        if (this.renderQueue.isRunning) {\r\n            this.renderQueue.one('stop', func.bind(this));\r\n        }\r\n        else {\r\n            func.call(this);\r\n        }\r\n    };\r\n    /* Title and Date Formatting\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Computes what the title at the top of the calendar should be for this view\r\n    View.prototype.computeTitle = function (dateProfile) {\r\n        var unzonedRange;\r\n        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\r\n        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\r\n            unzonedRange = dateProfile.currentUnzonedRange;\r\n        }\r\n        else {\r\n            unzonedRange = dateProfile.activeUnzonedRange;\r\n        }\r\n        return this.formatRange({\r\n            start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),\r\n            end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)\r\n        }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));\r\n    };\r\n    // Generates the format string that should be used to generate the title for the current date range.\r\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\r\n    View.prototype.computeTitleFormat = function (dateProfile) {\r\n        var currentRangeUnit = dateProfile.currentRangeUnit;\r\n        if (currentRangeUnit === 'year') {\r\n            return 'YYYY';\r\n        }\r\n        else if (currentRangeUnit === 'month') {\r\n            return this.opt('monthYearFormat'); // like \"September 2014\"\r\n        }\r\n        else if (dateProfile.currentUnzonedRange.as('days') > 1) {\r\n            return 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\r\n        }\r\n        else {\r\n            return 'LL'; // one day. longer, like \"September 9 2014\"\r\n        }\r\n    };\r\n    // Date Setting/Unsetting\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.setDate = function (date) {\r\n        var currentDateProfile = this.get('dateProfile');\r\n        var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true\r\n        if (!currentDateProfile ||\r\n            !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {\r\n            this.set('dateProfile', newDateProfile);\r\n        }\r\n    };\r\n    View.prototype.unsetDate = function () {\r\n        this.unset('dateProfile');\r\n    };\r\n    // Event Data\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.fetchInitialEvents = function (dateProfile) {\r\n        var calendar = this.calendar;\r\n        var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;\r\n        return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));\r\n    };\r\n    View.prototype.bindEventChanges = function () {\r\n        this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event\r\n    };\r\n    View.prototype.unbindEventChanges = function () {\r\n        this.stopListeningTo(this.calendar, 'eventsReset');\r\n    };\r\n    View.prototype.setEvents = function (eventsPayload) {\r\n        this.set('currentEvents', eventsPayload);\r\n        this.set('hasEvents', true);\r\n    };\r\n    View.prototype.unsetEvents = function () {\r\n        this.unset('currentEvents');\r\n        this.unset('hasEvents');\r\n    };\r\n    View.prototype.resetEvents = function (eventsPayload) {\r\n        this.startBatchRender();\r\n        this.unsetEvents();\r\n        this.setEvents(eventsPayload);\r\n        this.stopBatchRender();\r\n    };\r\n    // Date High-level Rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.requestDateRender = function (dateProfile) {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.executeDateRender(dateProfile);\r\n        }, 'date', 'init');\r\n    };\r\n    View.prototype.requestDateUnrender = function () {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.executeDateUnrender();\r\n        }, 'date', 'destroy');\r\n    };\r\n    // if dateProfile not specified, uses current\r\n    View.prototype.executeDateRender = function (dateProfile) {\r\n        _super.prototype.executeDateRender.call(this, dateProfile);\r\n        if (this['render']) {\r\n            this['render'](); // TODO: deprecate\r\n        }\r\n        this.trigger('datesRendered');\r\n        this.addScroll({ isDateInit: true });\r\n        this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon\r\n    };\r\n    View.prototype.executeDateUnrender = function () {\r\n        this.unselect();\r\n        this.stopNowIndicator();\r\n        this.trigger('before:datesUnrendered');\r\n        if (this['destroy']) {\r\n            this['destroy'](); // TODO: deprecate\r\n        }\r\n        _super.prototype.executeDateUnrender.call(this);\r\n    };\r\n    // \"Base\" rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.bindBaseRenderHandlers = function () {\r\n        var _this = this;\r\n        this.on('datesRendered', function () {\r\n            _this.whenSizeUpdated(_this.triggerViewRender);\r\n        });\r\n        this.on('before:datesUnrendered', function () {\r\n            _this.triggerViewDestroy();\r\n        });\r\n    };\r\n    View.prototype.triggerViewRender = function () {\r\n        this.publiclyTrigger('viewRender', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    View.prototype.triggerViewDestroy = function () {\r\n        this.publiclyTrigger('viewDestroy', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    // Event High-level Rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.requestEventsRender = function (eventsPayload) {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.executeEventRender(eventsPayload);\r\n            _this.whenSizeUpdated(_this.triggerAfterEventsRendered);\r\n        }, 'event', 'init');\r\n    };\r\n    View.prototype.requestEventsUnrender = function () {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.triggerBeforeEventsDestroyed();\r\n            _this.executeEventUnrender();\r\n        }, 'event', 'destroy');\r\n    };\r\n    // Business Hour High-level Rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.renderBusinessHours(businessHourGenerator);\r\n        }, 'businessHours', 'init');\r\n    };\r\n    View.prototype.requestBusinessHoursUnrender = function () {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.unrenderBusinessHours();\r\n        }, 'businessHours', 'destroy');\r\n    };\r\n    // Misc view rendering utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Binds DOM handlers to elements that reside outside the view container, such as the document\r\n    View.prototype.bindGlobalHandlers = function () {\r\n        _super.prototype.bindGlobalHandlers.call(this);\r\n        this.listenTo(GlobalEmitter_1.default.get(), {\r\n            touchstart: this.processUnselect,\r\n            mousedown: this.handleDocumentMousedown\r\n        });\r\n    };\r\n    // Unbinds DOM handlers from elements that reside outside the view container\r\n    View.prototype.unbindGlobalHandlers = function () {\r\n        _super.prototype.unbindGlobalHandlers.call(this);\r\n        this.stopListeningTo(GlobalEmitter_1.default.get());\r\n    };\r\n    /* Now Indicator\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Immediately render the current time indicator and begins re-rendering it at an interval,\r\n    // which is defined by this.getNowIndicatorUnit().\r\n    // TODO: somehow do this for the current whole day's background too\r\n    View.prototype.startNowIndicator = function () {\r\n        var _this = this;\r\n        var unit;\r\n        var update;\r\n        var delay; // ms wait value\r\n        if (this.opt('nowIndicator')) {\r\n            unit = this.getNowIndicatorUnit();\r\n            if (unit) {\r\n                update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`\r\n                this.initialNowDate = this.calendar.getNow();\r\n                this.initialNowQueriedMs = new Date().valueOf();\r\n                // wait until the beginning of the next interval\r\n                delay = this.initialNowDate.clone().startOf(unit).add(1, unit).valueOf() - this.initialNowDate.valueOf();\r\n                this.nowIndicatorTimeoutID = setTimeout(function () {\r\n                    _this.nowIndicatorTimeoutID = null;\r\n                    update();\r\n                    delay = +moment.duration(1, unit);\r\n                    delay = Math.max(100, delay); // prevent too frequent\r\n                    _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\r\n                }, delay);\r\n            }\r\n            // rendering will be initiated in updateSize\r\n        }\r\n    };\r\n    // rerenders the now indicator, computing the new current time from the amount of time that has passed\r\n    // since the initial getNow call.\r\n    View.prototype.updateNowIndicator = function () {\r\n        if (this.isDatesRendered &&\r\n            this.initialNowDate // activated before?\r\n        ) {\r\n            this.unrenderNowIndicator(); // won't unrender if unnecessary\r\n            this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms\r\n            );\r\n            this.isNowIndicatorRendered = true;\r\n        }\r\n    };\r\n    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.\r\n    // Won't cause side effects if indicator isn't rendered.\r\n    View.prototype.stopNowIndicator = function () {\r\n        if (this.isNowIndicatorRendered) {\r\n            if (this.nowIndicatorTimeoutID) {\r\n                clearTimeout(this.nowIndicatorTimeoutID);\r\n                this.nowIndicatorTimeoutID = null;\r\n            }\r\n            if (this.nowIndicatorIntervalID) {\r\n                clearInterval(this.nowIndicatorIntervalID);\r\n                this.nowIndicatorIntervalID = null;\r\n            }\r\n            this.unrenderNowIndicator();\r\n            this.isNowIndicatorRendered = false;\r\n        }\r\n    };\r\n    /* Dimensions\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        if (this['setHeight']) {\r\n            this['setHeight'](totalHeight, isAuto);\r\n        }\r\n        else {\r\n            _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        }\r\n        this.updateNowIndicator();\r\n    };\r\n    /* Scroller\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.addScroll = function (scroll) {\r\n        var queuedScroll = this.queuedScroll || (this.queuedScroll = {});\r\n        $.extend(queuedScroll, scroll);\r\n    };\r\n    View.prototype.popScroll = function () {\r\n        this.applyQueuedScroll();\r\n        this.queuedScroll = null;\r\n    };\r\n    View.prototype.applyQueuedScroll = function () {\r\n        if (this.queuedScroll) {\r\n            this.applyScroll(this.queuedScroll);\r\n        }\r\n    };\r\n    View.prototype.queryScroll = function () {\r\n        var scroll = {};\r\n        if (this.isDatesRendered) {\r\n            $.extend(scroll, this.queryDateScroll());\r\n        }\r\n        return scroll;\r\n    };\r\n    View.prototype.applyScroll = function (scroll) {\r\n        if (scroll.isDateInit && this.isDatesRendered) {\r\n            $.extend(scroll, this.computeInitialDateScroll());\r\n        }\r\n        if (this.isDatesRendered) {\r\n            this.applyDateScroll(scroll);\r\n        }\r\n    };\r\n    View.prototype.computeInitialDateScroll = function () {\r\n        return {}; // subclasses must implement\r\n    };\r\n    View.prototype.queryDateScroll = function () {\r\n        return {}; // subclasses must implement\r\n    };\r\n    View.prototype.applyDateScroll = function (scroll) {\r\n        // subclasses must implement\r\n    };\r\n    /* Event Drag-n-Drop\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {\r\n        var eventManager = this.calendar.eventManager;\r\n        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);\r\n        var dateMutation = eventMutation.dateMutation;\r\n        // update the EventInstance, for handlers\r\n        if (dateMutation) {\r\n            eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);\r\n        }\r\n        this.triggerEventDrop(eventInstance, \r\n        // a drop doesn't necessarily mean a date mutation (ex: resource change)\r\n        (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);\r\n    };\r\n    // Triggers event-drop handlers that have subscribed via the API\r\n    View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {\r\n        this.publiclyTrigger('eventDrop', {\r\n            context: el[0],\r\n            args: [\r\n                eventInstance.toLegacy(),\r\n                dateDelta,\r\n                undoFunc,\r\n                ev,\r\n                {},\r\n                this\r\n            ]\r\n        });\r\n    };\r\n    /* External Element Drag-n-Drop\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\r\n    // `meta` is the parsed data that has been embedded into the dragging event.\r\n    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\r\n    View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {\r\n        if (isEvent) {\r\n            this.calendar.eventManager.addEventDef(singleEventDef, isSticky);\r\n        }\r\n        this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);\r\n    };\r\n    // Triggers external-drop handlers that have subscribed via the API\r\n    View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {\r\n        // trigger 'drop' regardless of whether element represents an event\r\n        this.publiclyTrigger('drop', {\r\n            context: el[0],\r\n            args: [\r\n                singleEventDef.dateProfile.start.clone(),\r\n                ev,\r\n                ui,\r\n                this\r\n            ]\r\n        });\r\n        if (isEvent) {\r\n            // signal an external event landed\r\n            this.publiclyTrigger('eventReceive', {\r\n                context: this,\r\n                args: [\r\n                    singleEventDef.buildInstance().toLegacy(),\r\n                    this\r\n                ]\r\n            });\r\n        }\r\n    };\r\n    /* Event Resizing\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Must be called when an event in the view has been resized to a new length\r\n    View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {\r\n        var eventManager = this.calendar.eventManager;\r\n        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);\r\n        // update the EventInstance, for handlers\r\n        eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);\r\n        this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);\r\n    };\r\n    // Triggers event-resize handlers that have subscribed via the API\r\n    View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {\r\n        this.publiclyTrigger('eventResize', {\r\n            context: el[0],\r\n            args: [\r\n                eventInstance.toLegacy(),\r\n                durationDelta,\r\n                undoFunc,\r\n                ev,\r\n                {},\r\n                this\r\n            ]\r\n        });\r\n    };\r\n    /* Selection (time range)\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Selects a date span on the view. `start` and `end` are both Moments.\r\n    // `ev` is the native mouse event that begin the interaction.\r\n    View.prototype.select = function (footprint, ev) {\r\n        this.unselect(ev);\r\n        this.renderSelectionFootprint(footprint);\r\n        this.reportSelection(footprint, ev);\r\n    };\r\n    View.prototype.renderSelectionFootprint = function (footprint) {\r\n        if (this['renderSelection']) {\r\n            this['renderSelection'](footprint.toLegacy(this.calendar));\r\n        }\r\n        else {\r\n            _super.prototype.renderSelectionFootprint.call(this, footprint);\r\n        }\r\n    };\r\n    // Called when a new selection is made. Updates internal state and triggers handlers.\r\n    View.prototype.reportSelection = function (footprint, ev) {\r\n        this.isSelected = true;\r\n        this.triggerSelect(footprint, ev);\r\n    };\r\n    // Triggers handlers to 'select'\r\n    View.prototype.triggerSelect = function (footprint, ev) {\r\n        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\r\n        this.publiclyTrigger('select', {\r\n            context: this,\r\n            args: [\r\n                dateProfile.start,\r\n                dateProfile.end,\r\n                ev,\r\n                this\r\n            ]\r\n        });\r\n    };\r\n    // Undoes a selection. updates in the internal state and triggers handlers.\r\n    // `ev` is the native mouse event that began the interaction.\r\n    View.prototype.unselect = function (ev) {\r\n        if (this.isSelected) {\r\n            this.isSelected = false;\r\n            if (this['destroySelection']) {\r\n                this['destroySelection'](); // TODO: deprecate\r\n            }\r\n            this.unrenderSelection();\r\n            this.publiclyTrigger('unselect', {\r\n                context: this,\r\n                args: [ev, this]\r\n            });\r\n        }\r\n    };\r\n    /* Event Selection\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.selectEventInstance = function (eventInstance) {\r\n        if (!this.selectedEventInstance ||\r\n            this.selectedEventInstance !== eventInstance) {\r\n            this.unselectEventInstance();\r\n            this.getEventSegs().forEach(function (seg) {\r\n                if (seg.footprint.eventInstance === eventInstance &&\r\n                    seg.el // necessary?\r\n                ) {\r\n                    seg.el.addClass('fc-selected');\r\n                }\r\n            });\r\n            this.selectedEventInstance = eventInstance;\r\n        }\r\n    };\r\n    View.prototype.unselectEventInstance = function () {\r\n        if (this.selectedEventInstance) {\r\n            this.getEventSegs().forEach(function (seg) {\r\n                if (seg.el) {\r\n                    seg.el.removeClass('fc-selected');\r\n                }\r\n            });\r\n            this.selectedEventInstance = null;\r\n        }\r\n    };\r\n    View.prototype.isEventDefSelected = function (eventDef) {\r\n        // event references might change on refetchEvents(), while selectedEventInstance doesn't,\r\n        // so compare IDs\r\n        return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;\r\n    };\r\n    /* Mouse / Touch Unselecting (time range & event unselection)\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // TODO: move consistently to down/start or up/end?\r\n    // TODO: don't kill previous selection if touch scrolling\r\n    View.prototype.handleDocumentMousedown = function (ev) {\r\n        if (util_1.isPrimaryMouseButton(ev)) {\r\n            this.processUnselect(ev);\r\n        }\r\n    };\r\n    View.prototype.processUnselect = function (ev) {\r\n        this.processRangeUnselect(ev);\r\n        this.processEventUnselect(ev);\r\n    };\r\n    View.prototype.processRangeUnselect = function (ev) {\r\n        var ignore;\r\n        // is there a time-range selection?\r\n        if (this.isSelected && this.opt('unselectAuto')) {\r\n            // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\r\n            ignore = this.opt('unselectCancel');\r\n            if (!ignore || !$(ev.target).closest(ignore).length) {\r\n                this.unselect(ev);\r\n            }\r\n        }\r\n    };\r\n    View.prototype.processEventUnselect = function (ev) {\r\n        if (this.selectedEventInstance) {\r\n            if (!$(ev.target).closest('.fc-selected').length) {\r\n                this.unselectEventInstance();\r\n            }\r\n        }\r\n    };\r\n    /* Triggers\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.triggerBaseRendered = function () {\r\n        this.publiclyTrigger('viewRender', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    View.prototype.triggerBaseUnrendered = function () {\r\n        this.publiclyTrigger('viewDestroy', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    // Triggers handlers to 'dayClick'\r\n    // Span has start/end of the clicked area. Only the start is useful.\r\n    View.prototype.triggerDayClick = function (footprint, dayEl, ev) {\r\n        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\r\n        this.publiclyTrigger('dayClick', {\r\n            context: dayEl,\r\n            args: [dateProfile.start, ev, this]\r\n        });\r\n    };\r\n    /* Date Utils\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // For DateComponent::getDayClasses\r\n    View.prototype.isDateInOtherMonth = function (date, dateProfile) {\r\n        return false;\r\n    };\r\n    // Arguments after name will be forwarded to a hypothetical function value\r\n    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\r\n    // Always clone your objects if you fear mutation.\r\n    View.prototype.getUnzonedRangeOption = function (name) {\r\n        var val = this.opt(name);\r\n        if (typeof val === 'function') {\r\n            val = val.apply(null, Array.prototype.slice.call(arguments, 1));\r\n        }\r\n        if (val) {\r\n            return this.calendar.parseUnzonedRange(val);\r\n        }\r\n    };\r\n    /* Hidden Days\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Initializes internal variables related to calculating hidden days-of-week\r\n    View.prototype.initHiddenDays = function () {\r\n        var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\r\n        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\r\n        var dayCnt = 0;\r\n        var i;\r\n        if (this.opt('weekends') === false) {\r\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\r\n        }\r\n        for (i = 0; i < 7; i++) {\r\n            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {\r\n                dayCnt++;\r\n            }\r\n        }\r\n        if (!dayCnt) {\r\n            throw new Error('invalid hiddenDays'); // all days were hidden? bad.\r\n        }\r\n        this.isHiddenDayHash = isHiddenDayHash;\r\n    };\r\n    // Remove days from the beginning and end of the range that are computed as hidden.\r\n    // If the whole range is trimmed off, returns null\r\n    View.prototype.trimHiddenDays = function (inputUnzonedRange) {\r\n        var start = inputUnzonedRange.getStart();\r\n        var end = inputUnzonedRange.getEnd();\r\n        if (start) {\r\n            start = this.skipHiddenDays(start);\r\n        }\r\n        if (end) {\r\n            end = this.skipHiddenDays(end, -1, true);\r\n        }\r\n        if (start === null || end === null || start < end) {\r\n            return new UnzonedRange_1.default(start, end);\r\n        }\r\n        return null;\r\n    };\r\n    // Is the current day hidden?\r\n    // `day` is a day-of-week index (0-6), or a Moment\r\n    View.prototype.isHiddenDay = function (day) {\r\n        if (moment.isMoment(day)) {\r\n            day = day.day();\r\n        }\r\n        return this.isHiddenDayHash[day];\r\n    };\r\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\r\n    // DOES NOT CONSIDER validUnzonedRange!\r\n    // If the initial value of `date` is not a hidden day, don't do anything.\r\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\r\n    // `inc` defaults to `1` (increment one day forward each time)\r\n    View.prototype.skipHiddenDays = function (date, inc, isExclusive) {\r\n        if (inc === void 0) { inc = 1; }\r\n        if (isExclusive === void 0) { isExclusive = false; }\r\n        var out = date.clone();\r\n        while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {\r\n            out.add(inc, 'days');\r\n        }\r\n        return out;\r\n    };\r\n    return View;\r\n}(InteractiveDateComponent_1.default));\r\nexports.default = View;\r\nView.prototype.usesMinMaxTime = false;\r\nView.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;\r\nView.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {\r\n    this.requestDateRender(deps.dateProfile);\r\n}, function () {\r\n    this.requestDateUnrender();\r\n});\r\nView.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {\r\n    this.requestBusinessHoursRender(deps.businessHourGenerator);\r\n}, function () {\r\n    this.requestBusinessHoursUnrender();\r\n});\r\nView.watch('initialEvents', ['dateProfile'], function (deps) {\r\n    return this.fetchInitialEvents(deps.dateProfile);\r\n});\r\nView.watch('bindingEvents', ['initialEvents'], function (deps) {\r\n    this.setEvents(deps.initialEvents);\r\n    this.bindEventChanges();\r\n}, function () {\r\n    this.unbindEventChanges();\r\n    this.unsetEvents();\r\n});\r\nView.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {\r\n    this.requestEventsRender(this.get('currentEvents'));\r\n}, function () {\r\n    this.requestEventsUnrender();\r\n});\r\nView.watch('title', ['dateProfile'], function (deps) {\r\n    return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons\r\n});\r\nView.watch('legacyDateProps', ['dateProfile'], function (deps) {\r\n    var calendar = this.calendar;\r\n    var dateProfile = deps.dateProfile;\r\n    // DEPRECATED, but we need to keep it updated...\r\n    this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);\r\n    this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);\r\n    this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);\r\n    this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);\r\n});\r\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer = /** @class */ (function () {\r\n    function EventRenderer(component, fillRenderer) {\r\n        this.view = component._getView();\r\n        this.component = component;\r\n        this.fillRenderer = fillRenderer;\r\n    }\r\n    EventRenderer.prototype.opt = function (name) {\r\n        return this.view.opt(name);\r\n    };\r\n    // Updates values that rely on options and also relate to range\r\n    EventRenderer.prototype.rangeUpdated = function () {\r\n        var displayEventTime;\r\n        var displayEventEnd;\r\n        this.eventTimeFormat =\r\n            this.opt('eventTimeFormat') ||\r\n                this.opt('timeFormat') || // deprecated\r\n                this.computeEventTimeFormat();\r\n        displayEventTime = this.opt('displayEventTime');\r\n        if (displayEventTime == null) {\r\n            displayEventTime = this.computeDisplayEventTime(); // might be based off of range\r\n        }\r\n        displayEventEnd = this.opt('displayEventEnd');\r\n        if (displayEventEnd == null) {\r\n            displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\r\n        }\r\n        this.displayEventTime = displayEventTime;\r\n        this.displayEventEnd = displayEventEnd;\r\n    };\r\n    EventRenderer.prototype.render = function (eventsPayload) {\r\n        var dateProfile = this.component._getDateProfile();\r\n        var eventDefId;\r\n        var instanceGroup;\r\n        var eventRanges;\r\n        var bgRanges = [];\r\n        var fgRanges = [];\r\n        for (eventDefId in eventsPayload) {\r\n            instanceGroup = eventsPayload[eventDefId];\r\n            eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);\r\n            if (instanceGroup.getEventDef().hasBgRendering()) {\r\n                bgRanges.push.apply(bgRanges, eventRanges);\r\n            }\r\n            else {\r\n                fgRanges.push.apply(fgRanges, eventRanges);\r\n            }\r\n        }\r\n        this.renderBgRanges(bgRanges);\r\n        this.renderFgRanges(fgRanges);\r\n    };\r\n    EventRenderer.prototype.unrender = function () {\r\n        this.unrenderBgRanges();\r\n        this.unrenderFgRanges();\r\n    };\r\n    EventRenderer.prototype.renderFgRanges = function (eventRanges) {\r\n        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        // render an `.el` on each seg\r\n        // returns a subset of the segs. segs that were actually rendered\r\n        segs = this.renderFgSegEls(segs);\r\n        if (this.renderFgSegs(segs) !== false) {\r\n            this.fgSegs = segs;\r\n        }\r\n    };\r\n    EventRenderer.prototype.unrenderFgRanges = function () {\r\n        this.unrenderFgSegs(this.fgSegs || []);\r\n        this.fgSegs = null;\r\n    };\r\n    EventRenderer.prototype.renderBgRanges = function (eventRanges) {\r\n        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        if (this.renderBgSegs(segs) !== false) {\r\n            this.bgSegs = segs;\r\n        }\r\n    };\r\n    EventRenderer.prototype.unrenderBgRanges = function () {\r\n        this.unrenderBgSegs();\r\n        this.bgSegs = null;\r\n    };\r\n    EventRenderer.prototype.getSegs = function () {\r\n        return (this.bgSegs || []).concat(this.fgSegs || []);\r\n    };\r\n    // Renders foreground event segments onto the grid\r\n    EventRenderer.prototype.renderFgSegs = function (segs) {\r\n        // subclasses must implement\r\n        // segs already has rendered els, and has been filtered.\r\n        return false; // signal failure if not implemented\r\n    };\r\n    // Unrenders all currently rendered foreground segments\r\n    EventRenderer.prototype.unrenderFgSegs = function (segs) {\r\n        // subclasses must implement\r\n    };\r\n    EventRenderer.prototype.renderBgSegs = function (segs) {\r\n        var _this = this;\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.renderSegs('bgEvent', segs, {\r\n                getClasses: function (seg) {\r\n                    return _this.getBgClasses(seg.footprint.eventDef);\r\n                },\r\n                getCss: function (seg) {\r\n                    return {\r\n                        'background-color': _this.getBgColor(seg.footprint.eventDef)\r\n                    };\r\n                },\r\n                filterEl: function (seg, el) {\r\n                    return _this.filterEventRenderEl(seg.footprint, el);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return false; // signal failure if no fillRenderer\r\n        }\r\n    };\r\n    EventRenderer.prototype.unrenderBgSegs = function () {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.unrender('bgEvent');\r\n        }\r\n    };\r\n    // Renders and assigns an `el` property for each foreground event segment.\r\n    // Only returns segments that successfully rendered.\r\n    EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {\r\n        var _this = this;\r\n        if (disableResizing === void 0) { disableResizing = false; }\r\n        var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');\r\n        var html = '';\r\n        var renderedSegs = [];\r\n        var i;\r\n        if (segs.length) {\r\n            // build a large concatenation of event segment HTML\r\n            for (i = 0; i < segs.length; i++) {\r\n                this.beforeFgSegHtml(segs[i]);\r\n                html += this.fgSegHtml(segs[i], disableResizing);\r\n            }\r\n            // Grab individual elements from the combined HTML string. Use each as the default rendering.\r\n            // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\r\n            $(html).each(function (i, node) {\r\n                var seg = segs[i];\r\n                var el = $(node);\r\n                if (hasEventRenderHandlers) {\r\n                    el = _this.filterEventRenderEl(seg.footprint, el);\r\n                }\r\n                if (el) {\r\n                    el.data('fc-seg', seg); // used by handlers\r\n                    seg.el = el;\r\n                    renderedSegs.push(seg);\r\n                }\r\n            });\r\n        }\r\n        return renderedSegs;\r\n    };\r\n    EventRenderer.prototype.beforeFgSegHtml = function (seg) {\r\n    };\r\n    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\r\n    EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\r\n        // subclasses should implement\r\n    };\r\n    // Generic utility for generating the HTML classNames for an event segment's element\r\n    EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {\r\n        var classes = [\r\n            'fc-event',\r\n            seg.isStart ? 'fc-start' : 'fc-not-start',\r\n            seg.isEnd ? 'fc-end' : 'fc-not-end'\r\n        ].concat(this.getClasses(seg.footprint.eventDef));\r\n        if (isDraggable) {\r\n            classes.push('fc-draggable');\r\n        }\r\n        if (isResizable) {\r\n            classes.push('fc-resizable');\r\n        }\r\n        // event is currently selected? attach a className.\r\n        if (this.view.isEventDefSelected(seg.footprint.eventDef)) {\r\n            classes.push('fc-selected');\r\n        }\r\n        return classes;\r\n    };\r\n    // Given an event and the default element used for rendering, returns the element that should actually be used.\r\n    // Basically runs events and elements through the eventRender hook.\r\n    EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {\r\n        var legacy = eventFootprint.getEventLegacy();\r\n        var custom = this.view.publiclyTrigger('eventRender', {\r\n            context: legacy,\r\n            args: [legacy, el, this.view]\r\n        });\r\n        if (custom === false) {\r\n            el = null;\r\n        }\r\n        else if (custom && custom !== true) {\r\n            el = $(custom);\r\n        }\r\n        return el;\r\n    };\r\n    // Compute the text that should be displayed on an event's element.\r\n    // `range` can be the Event object itself, or something range-like, with at least a `start`.\r\n    // If event times are disabled, or the event has no time, will return a blank string.\r\n    // If not specified, formatStr will default to the eventTimeFormat setting,\r\n    // and displayEnd will default to the displayEventEnd setting.\r\n    EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {\r\n        return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);\r\n    };\r\n    EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {\r\n        if (formatStr == null) {\r\n            formatStr = this.eventTimeFormat;\r\n        }\r\n        if (displayEnd == null) {\r\n            displayEnd = this.displayEventEnd;\r\n        }\r\n        if (this.displayEventTime && !isAllDay) {\r\n            if (displayEnd && end) {\r\n                return this.view.formatRange({ start: start, end: end }, false, // allDay\r\n                formatStr);\r\n            }\r\n            else {\r\n                return start.format(formatStr);\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n    EventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('smallTimeFormat');\r\n    };\r\n    EventRenderer.prototype.computeDisplayEventTime = function () {\r\n        return true;\r\n    };\r\n    EventRenderer.prototype.computeDisplayEventEnd = function () {\r\n        return true;\r\n    };\r\n    EventRenderer.prototype.getBgClasses = function (eventDef) {\r\n        var classNames = this.getClasses(eventDef);\r\n        classNames.push('fc-bgevent');\r\n        return classNames;\r\n    };\r\n    EventRenderer.prototype.getClasses = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var classNames = [];\r\n        for (i = 0; i < objs.length; i++) {\r\n            classNames.push.apply(// append\r\n            classNames, objs[i].eventClassName || objs[i].className || []);\r\n        }\r\n        return classNames;\r\n    };\r\n    // Utility for generating event skin-related CSS properties\r\n    EventRenderer.prototype.getSkinCss = function (eventDef) {\r\n        return {\r\n            'background-color': this.getBgColor(eventDef),\r\n            'border-color': this.getBorderColor(eventDef),\r\n            color: this.getTextColor(eventDef)\r\n        };\r\n    };\r\n    // Queries for caller-specified color, then falls back to default\r\n    EventRenderer.prototype.getBgColor = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var val;\r\n        for (i = 0; i < objs.length && !val; i++) {\r\n            val = objs[i].eventBackgroundColor || objs[i].eventColor ||\r\n                objs[i].backgroundColor || objs[i].color;\r\n        }\r\n        if (!val) {\r\n            val = this.opt('eventBackgroundColor') || this.opt('eventColor');\r\n        }\r\n        return val;\r\n    };\r\n    // Queries for caller-specified color, then falls back to default\r\n    EventRenderer.prototype.getBorderColor = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var val;\r\n        for (i = 0; i < objs.length && !val; i++) {\r\n            val = objs[i].eventBorderColor || objs[i].eventColor ||\r\n                objs[i].borderColor || objs[i].color;\r\n        }\r\n        if (!val) {\r\n            val = this.opt('eventBorderColor') || this.opt('eventColor');\r\n        }\r\n        return val;\r\n    };\r\n    // Queries for caller-specified color, then falls back to default\r\n    EventRenderer.prototype.getTextColor = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var val;\r\n        for (i = 0; i < objs.length && !val; i++) {\r\n            val = objs[i].eventTextColor ||\r\n                objs[i].textColor;\r\n        }\r\n        if (!val) {\r\n            val = this.opt('eventTextColor');\r\n        }\r\n        return val;\r\n    };\r\n    EventRenderer.prototype.getStylingObjs = function (eventDef) {\r\n        var objs = this.getFallbackStylingObjs(eventDef);\r\n        objs.unshift(eventDef);\r\n        return objs;\r\n    };\r\n    EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {\r\n        return [eventDef.source];\r\n    };\r\n    EventRenderer.prototype.sortEventSegs = function (segs) {\r\n        segs.sort(util_1.proxy(this, 'compareEventSegs'));\r\n    };\r\n    // A cmp function for determining which segments should take visual priority\r\n    EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {\r\n        var f1 = seg1.footprint;\r\n        var f2 = seg2.footprint;\r\n        var cf1 = f1.componentFootprint;\r\n        var cf2 = f2.componentFootprint;\r\n        var r1 = cf1.unzonedRange;\r\n        var r2 = cf2.unzonedRange;\r\n        return r1.startMs - r2.startMs || // earlier events go first\r\n            (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first\r\n            cf2.isAllDay - cf1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)\r\n            util_1.compareByFieldSpecs(f1.eventDef, f2.eventDef, this.view.eventOrderSpecs, f1.eventDef.miscProps, f2.eventDef.miscProps);\r\n    };\r\n    return EventRenderer;\r\n}());\r\nexports.default = EventRenderer;\r\n\n\n/***/ }),\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment_ext_1 = __webpack_require__(10);\r\n// Plugin\r\n// -------------------------------------------------------------------------------------------------\r\nmoment_ext_1.newMomentProto.format = function () {\r\n    if (this._fullCalendar && arguments[0]) {\r\n        return formatDate(this, arguments[0]); // our extended formatting\r\n    }\r\n    if (this._ambigTime) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\r\n    }\r\n    if (this._ambigZone) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\r\n    }\r\n    if (this._fullCalendar) {\r\n        // moment.format() doesn't ensure english, but we want to.\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this));\r\n    }\r\n    return moment_ext_1.oldMomentProto.format.apply(this, arguments);\r\n};\r\nmoment_ext_1.newMomentProto.toISOString = function () {\r\n    if (this._ambigTime) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\r\n    }\r\n    if (this._ambigZone) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\r\n    }\r\n    if (this._fullCalendar) {\r\n        // depending on browser, moment might not output english. ensure english.\r\n        // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22\r\n        return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);\r\n    }\r\n    return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);\r\n};\r\nfunction englishMoment(mom) {\r\n    if (mom.locale() !== 'en') {\r\n        return mom.clone().locale('en');\r\n    }\r\n    return mom;\r\n}\r\n// Config\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n/*\r\nInserted between chunks in the fake (\"intermediate\") formatting string.\r\nImportant that it passes as whitespace (\\s) because moment often identifies non-standalone months\r\nvia a regexp with an \\s.\r\n*/\r\nvar PART_SEPARATOR = '\\u000b'; // vertical tab\r\n/*\r\nInserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,\r\nbut rather, a \"special\" token that has custom rendering (see specialTokens map).\r\n*/\r\nvar SPECIAL_TOKEN_MARKER = '\\u001f'; // information separator 1\r\n/*\r\nInserted at the beginning and end of a span of text that must have non-zero numeric characters.\r\nHandling of these markers is done in a post-processing step at the very end of text rendering.\r\n*/\r\nvar MAYBE_MARKER = '\\u001e'; // information separator 2\r\nvar MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global\r\n/*\r\nAddition formatting tokens we want recognized\r\n*/\r\nvar specialTokens = {\r\n    t: function (date) {\r\n        return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);\r\n    },\r\n    T: function (date) {\r\n        return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);\r\n    }\r\n};\r\n/*\r\nThe first characters of formatting tokens for units that are 1 day or larger.\r\n`value` is for ranking relative size (lower means bigger).\r\n`unit` is a normalized unit, used for comparing moments.\r\n*/\r\nvar largeTokenMap = {\r\n    Y: { value: 1, unit: 'year' },\r\n    M: { value: 2, unit: 'month' },\r\n    W: { value: 3, unit: 'week' },\r\n    w: { value: 3, unit: 'week' },\r\n    D: { value: 4, unit: 'day' },\r\n    d: { value: 4, unit: 'day' } // day of week\r\n};\r\n// Single Date Formatting\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n/*\r\nFormats `date` with a Moment formatting string, but allow our non-zero areas and special token\r\n*/\r\nfunction formatDate(date, formatStr) {\r\n    return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);\r\n}\r\nexports.formatDate = formatDate;\r\n// Date Range Formatting\r\n// -------------------------------------------------------------------------------------------------\r\n// TODO: make it work with timezone offset\r\n/*\r\nUsing a formatting string meant for a single date, generate a range string, like\r\n\"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\r\nIf the dates are the same as far as the format string is concerned, just return a single\r\nrendering of one date, without any separator.\r\n*/\r\nfunction formatRange(date1, date2, formatStr, separator, isRTL) {\r\n    var localeData;\r\n    date1 = moment_ext_1.default.parseZone(date1);\r\n    date2 = moment_ext_1.default.parseZone(date2);\r\n    localeData = date1.localeData();\r\n    // Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\".\r\n    // BTW, this is not important for `formatDate` because it is impossible to put custom tokens\r\n    // or non-zero areas in Moment's localized format strings.\r\n    formatStr = localeData.longDateFormat(formatStr) || formatStr;\r\n    return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);\r\n}\r\nexports.formatRange = formatRange;\r\n/*\r\nRenders a range with an already-parsed format string.\r\n*/\r\nfunction renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {\r\n    var sameUnits = parsedFormat.sameUnits;\r\n    var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons\r\n    var unzonedDate2 = date2.clone().stripZone(); // \"\r\n    var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);\r\n    var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);\r\n    var leftI;\r\n    var leftStr = '';\r\n    var rightI;\r\n    var rightStr = '';\r\n    var middleI;\r\n    var middleStr1 = '';\r\n    var middleStr2 = '';\r\n    var middleStr = '';\r\n    // Start at the leftmost side of the formatting string and continue until you hit a token\r\n    // that is not the same between dates.\r\n    for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {\r\n        leftStr += renderedParts1[leftI];\r\n    }\r\n    // Similarly, start at the rightmost side of the formatting string and move left\r\n    for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {\r\n        // If current chunk is on the boundary of unique date-content, and is a special-case\r\n        // date-formatting postfix character, then don't consume it. Consider it unique date-content.\r\n        // TODO: make configurable\r\n        if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {\r\n            break;\r\n        }\r\n        rightStr = renderedParts1[rightI] + rightStr;\r\n    }\r\n    // The area in the middle is different for both of the dates.\r\n    // Collect them distinctly so we can jam them together later.\r\n    for (middleI = leftI; middleI <= rightI; middleI++) {\r\n        middleStr1 += renderedParts1[middleI];\r\n        middleStr2 += renderedParts2[middleI];\r\n    }\r\n    if (middleStr1 || middleStr2) {\r\n        if (isRTL) {\r\n            middleStr = middleStr2 + separator + middleStr1;\r\n        }\r\n        else {\r\n            middleStr = middleStr1 + separator + middleStr2;\r\n        }\r\n    }\r\n    return processMaybeMarkers(leftStr + middleStr + rightStr);\r\n}\r\n// Format String Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nvar parsedFormatStrCache = {};\r\n/*\r\nReturns a parsed format string, leveraging a cache.\r\n*/\r\nfunction getParsedFormatString(formatStr) {\r\n    return parsedFormatStrCache[formatStr] ||\r\n        (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));\r\n}\r\n/*\r\nParses a format string into the following:\r\n- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.\r\n- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like \"day\"),\r\n  that indicates how similar a range's start & end must be in order to share the same formatted text.\r\n  If not a token, then the value is null.\r\n  Always a flat array (not nested liked \"chunks\").\r\n*/\r\nfunction parseFormatString(formatStr) {\r\n    var chunks = chunkFormatString(formatStr);\r\n    return {\r\n        fakeFormatString: buildFakeFormatString(chunks),\r\n        sameUnits: buildSameUnits(chunks)\r\n    };\r\n}\r\n/*\r\nBreak the formatting string into an array of chunks.\r\nA 'maybe' chunk will have nested chunks.\r\n*/\r\nfunction chunkFormatString(formatStr) {\r\n    var chunks = [];\r\n    var match;\r\n    // TODO: more descrimination\r\n    // \\4 is a backreference to the first character of a multi-character set.\r\n    var chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g;\r\n    while ((match = chunker.exec(formatStr))) {\r\n        if (match[1]) {\r\n            chunks.push.apply(chunks, // append\r\n            splitStringLiteral(match[1]));\r\n        }\r\n        else if (match[2]) {\r\n            chunks.push({ maybe: chunkFormatString(match[2]) });\r\n        }\r\n        else if (match[3]) {\r\n            chunks.push({ token: match[3] });\r\n        }\r\n        else if (match[5]) {\r\n            chunks.push.apply(chunks, // append\r\n            splitStringLiteral(match[5]));\r\n        }\r\n    }\r\n    return chunks;\r\n}\r\n/*\r\nPotentially splits a literal-text string into multiple parts. For special cases.\r\n*/\r\nfunction splitStringLiteral(s) {\r\n    if (s === '. ') {\r\n        return ['.', ' ']; // for locales with periods bound to the end of each year/month/date\r\n    }\r\n    else {\r\n        return [s];\r\n    }\r\n}\r\n/*\r\nGiven chunks parsed from a real format string, generate a fake (aka \"intermediate\") format string with special control\r\ncharacters that will eventually be given to moment for formatting, and then post-processed.\r\n*/\r\nfunction buildFakeFormatString(chunks) {\r\n    var parts = [];\r\n    var i;\r\n    var chunk;\r\n    for (i = 0; i < chunks.length; i++) {\r\n        chunk = chunks[i];\r\n        if (typeof chunk === 'string') {\r\n            parts.push('[' + chunk + ']');\r\n        }\r\n        else if (chunk.token) {\r\n            if (chunk.token in specialTokens) {\r\n                parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing\r\n                    '[' + chunk.token + ']' // preserve as literal text\r\n                );\r\n            }\r\n            else {\r\n                parts.push(chunk.token); // unprotected text implies a format string\r\n            }\r\n        }\r\n        else if (chunk.maybe) {\r\n            parts.push(MAYBE_MARKER + // useful during post-processing\r\n                buildFakeFormatString(chunk.maybe) +\r\n                MAYBE_MARKER);\r\n        }\r\n    }\r\n    return parts.join(PART_SEPARATOR);\r\n}\r\n/*\r\nGiven parsed chunks from a real formatting string, generates an array of unit strings (like \"day\") that indicate\r\nin which regard two dates must be similar in order to share range formatting text.\r\nThe `chunks` can be nested (because of \"maybe\" chunks), however, the returned array will be flat.\r\n*/\r\nfunction buildSameUnits(chunks) {\r\n    var units = [];\r\n    var i;\r\n    var chunk;\r\n    var tokenInfo;\r\n    for (i = 0; i < chunks.length; i++) {\r\n        chunk = chunks[i];\r\n        if (chunk.token) {\r\n            tokenInfo = largeTokenMap[chunk.token.charAt(0)];\r\n            units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second\r\n        }\r\n        else if (chunk.maybe) {\r\n            units.push.apply(units, // append\r\n            buildSameUnits(chunk.maybe));\r\n        }\r\n        else {\r\n            units.push(null);\r\n        }\r\n    }\r\n    return units;\r\n}\r\n// Rendering to text\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n/*\r\nFormats a date with a fake format string, post-processes the control characters, then returns.\r\n*/\r\nfunction renderFakeFormatString(fakeFormatString, date) {\r\n    return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));\r\n}\r\n/*\r\nFormats a date into parts that will have been post-processed, EXCEPT for the \"maybe\" markers.\r\n*/\r\nfunction renderFakeFormatStringParts(fakeFormatString, date) {\r\n    var parts = [];\r\n    var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);\r\n    var fakeParts = fakeRender.split(PART_SEPARATOR);\r\n    var i;\r\n    var fakePart;\r\n    for (i = 0; i < fakeParts.length; i++) {\r\n        fakePart = fakeParts[i];\r\n        if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {\r\n            parts.push(\r\n            // the literal string IS the token's name.\r\n            // call special token's registered function.\r\n            specialTokens[fakePart.substring(1)](date));\r\n        }\r\n        else {\r\n            parts.push(fakePart);\r\n        }\r\n    }\r\n    return parts;\r\n}\r\n/*\r\nAccepts an almost-finally-formatted string and processes the \"maybe\" control characters, returning a new string.\r\n*/\r\nfunction processMaybeMarkers(s) {\r\n    return s.replace(MAYBE_REGEXP, function (m0, m1) {\r\n        if (m1.match(/[1-9]/)) {\r\n            return m1;\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    });\r\n}\r\n// Misc Utils\r\n// -------------------------------------------------------------------------------------------------\r\n/*\r\nReturns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.\r\n*/\r\nfunction queryMostGranularFormatUnit(formatStr) {\r\n    var chunks = chunkFormatString(formatStr);\r\n    var i;\r\n    var chunk;\r\n    var candidate;\r\n    var best;\r\n    for (i = 0; i < chunks.length; i++) {\r\n        chunk = chunks[i];\r\n        if (chunk.token) {\r\n            candidate = largeTokenMap[chunk.token.charAt(0)];\r\n            if (candidate) {\r\n                if (!best || candidate.value > best.value) {\r\n                    best = candidate;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (best) {\r\n        return best.unit;\r\n    }\r\n    return null;\r\n}\r\nexports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;\r\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Class_1 = __webpack_require__(33);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar Model = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Model, _super);\r\n    function Model() {\r\n        var _this = _super.call(this) || this;\r\n        _this._watchers = {};\r\n        _this._props = {};\r\n        _this.applyGlobalWatchers();\r\n        _this.constructed();\r\n        return _this;\r\n    }\r\n    Model.watch = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        // subclasses should make a masked-copy of the superclass's map\r\n        // TODO: write test\r\n        if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {\r\n            this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);\r\n        }\r\n        this.prototype._globalWatchArgs[name] = args;\r\n    };\r\n    Model.prototype.constructed = function () {\r\n        // useful for monkeypatching. TODO: BaseClass?\r\n    };\r\n    Model.prototype.applyGlobalWatchers = function () {\r\n        var map = this._globalWatchArgs;\r\n        var name;\r\n        for (name in map) {\r\n            this.watch.apply(this, [name].concat(map[name]));\r\n        }\r\n    };\r\n    Model.prototype.has = function (name) {\r\n        return name in this._props;\r\n    };\r\n    Model.prototype.get = function (name) {\r\n        if (name === undefined) {\r\n            return this._props;\r\n        }\r\n        return this._props[name];\r\n    };\r\n    Model.prototype.set = function (name, val) {\r\n        var newProps;\r\n        if (typeof name === 'string') {\r\n            newProps = {};\r\n            newProps[name] = val === undefined ? null : val;\r\n        }\r\n        else {\r\n            newProps = name;\r\n        }\r\n        this.setProps(newProps);\r\n    };\r\n    Model.prototype.reset = function (newProps) {\r\n        var oldProps = this._props;\r\n        var changeset = {}; // will have undefined's to signal unsets\r\n        var name;\r\n        for (name in oldProps) {\r\n            changeset[name] = undefined;\r\n        }\r\n        for (name in newProps) {\r\n            changeset[name] = newProps[name];\r\n        }\r\n        this.setProps(changeset);\r\n    };\r\n    Model.prototype.unset = function (name) {\r\n        var newProps = {};\r\n        var names;\r\n        var i;\r\n        if (typeof name === 'string') {\r\n            names = [name];\r\n        }\r\n        else {\r\n            names = name;\r\n        }\r\n        for (i = 0; i < names.length; i++) {\r\n            newProps[names[i]] = undefined;\r\n        }\r\n        this.setProps(newProps);\r\n    };\r\n    Model.prototype.setProps = function (newProps) {\r\n        var changedProps = {};\r\n        var changedCnt = 0;\r\n        var name;\r\n        var val;\r\n        for (name in newProps) {\r\n            val = newProps[name];\r\n            // a change in value?\r\n            // if an object, don't check equality, because might have been mutated internally.\r\n            // TODO: eventually enforce immutability.\r\n            if (typeof val === 'object' ||\r\n                val !== this._props[name]) {\r\n                changedProps[name] = val;\r\n                changedCnt++;\r\n            }\r\n        }\r\n        if (changedCnt) {\r\n            this.trigger('before:batchChange', changedProps);\r\n            for (name in changedProps) {\r\n                val = changedProps[name];\r\n                this.trigger('before:change', name, val);\r\n                this.trigger('before:change:' + name, val);\r\n            }\r\n            for (name in changedProps) {\r\n                val = changedProps[name];\r\n                if (val === undefined) {\r\n                    delete this._props[name];\r\n                }\r\n                else {\r\n                    this._props[name] = val;\r\n                }\r\n                this.trigger('change:' + name, val);\r\n                this.trigger('change', name, val);\r\n            }\r\n            this.trigger('batchChange', changedProps);\r\n        }\r\n    };\r\n    Model.prototype.watch = function (name, depList, startFunc, stopFunc) {\r\n        var _this = this;\r\n        this.unwatch(name);\r\n        this._watchers[name] = this._watchDeps(depList, function (deps) {\r\n            var res = startFunc.call(_this, deps);\r\n            if (res && res.then) {\r\n                _this.unset(name); // put in an unset state while resolving\r\n                res.then(function (val) {\r\n                    _this.set(name, val);\r\n                });\r\n            }\r\n            else {\r\n                _this.set(name, res);\r\n            }\r\n        }, function (deps) {\r\n            _this.unset(name);\r\n            if (stopFunc) {\r\n                stopFunc.call(_this, deps);\r\n            }\r\n        });\r\n    };\r\n    Model.prototype.unwatch = function (name) {\r\n        var watcher = this._watchers[name];\r\n        if (watcher) {\r\n            delete this._watchers[name];\r\n            watcher.teardown();\r\n        }\r\n    };\r\n    Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {\r\n        var _this = this;\r\n        var queuedChangeCnt = 0;\r\n        var depCnt = depList.length;\r\n        var satisfyCnt = 0;\r\n        var values = {}; // what's passed as the `deps` arguments\r\n        var bindTuples = []; // array of [ eventName, handlerFunc ] arrays\r\n        var isCallingStop = false;\r\n        var onBeforeDepChange = function (depName, val, isOptional) {\r\n            queuedChangeCnt++;\r\n            if (queuedChangeCnt === 1) {\r\n                if (satisfyCnt === depCnt) {\r\n                    isCallingStop = true;\r\n                    stopFunc(values);\r\n                    isCallingStop = false;\r\n                }\r\n            }\r\n        };\r\n        var onDepChange = function (depName, val, isOptional) {\r\n            if (val === undefined) {\r\n                // required dependency that was previously set?\r\n                if (!isOptional && values[depName] !== undefined) {\r\n                    satisfyCnt--;\r\n                }\r\n                delete values[depName];\r\n            }\r\n            else {\r\n                // required dependency that was previously unset?\r\n                if (!isOptional && values[depName] === undefined) {\r\n                    satisfyCnt++;\r\n                }\r\n                values[depName] = val;\r\n            }\r\n            queuedChangeCnt--;\r\n            if (!queuedChangeCnt) {\r\n                // now finally satisfied or satisfied all along?\r\n                if (satisfyCnt === depCnt) {\r\n                    // if the stopFunc initiated another value change, ignore it.\r\n                    // it will be processed by another change event anyway.\r\n                    if (!isCallingStop) {\r\n                        startFunc(values);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        // intercept for .on() that remembers handlers\r\n        var bind = function (eventName, handler) {\r\n            _this.on(eventName, handler);\r\n            bindTuples.push([eventName, handler]);\r\n        };\r\n        // listen to dependency changes\r\n        depList.forEach(function (depName) {\r\n            var isOptional = false;\r\n            if (depName.charAt(0) === '?') {\r\n                depName = depName.substring(1);\r\n                isOptional = true;\r\n            }\r\n            bind('before:change:' + depName, function (val) {\r\n                onBeforeDepChange(depName, val, isOptional);\r\n            });\r\n            bind('change:' + depName, function (val) {\r\n                onDepChange(depName, val, isOptional);\r\n            });\r\n        });\r\n        // process current dependency values\r\n        depList.forEach(function (depName) {\r\n            var isOptional = false;\r\n            if (depName.charAt(0) === '?') {\r\n                depName = depName.substring(1);\r\n                isOptional = true;\r\n            }\r\n            if (_this.has(depName)) {\r\n                values[depName] = _this.get(depName);\r\n                satisfyCnt++;\r\n            }\r\n            else if (isOptional) {\r\n                satisfyCnt++;\r\n            }\r\n        });\r\n        // initially satisfied\r\n        if (satisfyCnt === depCnt) {\r\n            startFunc(values);\r\n        }\r\n        return {\r\n            teardown: function () {\r\n                // remove all handlers\r\n                for (var i = 0; i < bindTuples.length; i++) {\r\n                    _this.off(bindTuples[i][0], bindTuples[i][1]);\r\n                }\r\n                bindTuples = null;\r\n                // was satisfied, so call stopFunc\r\n                if (satisfyCnt === depCnt) {\r\n                    stopFunc();\r\n                }\r\n            },\r\n            flash: function () {\r\n                if (satisfyCnt === depCnt) {\r\n                    stopFunc();\r\n                    startFunc(values);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    Model.prototype.flash = function (name) {\r\n        var watcher = this._watchers[name];\r\n        if (watcher) {\r\n            watcher.flash();\r\n        }\r\n    };\r\n    return Model;\r\n}(Class_1.default));\r\nexports.default = Model;\r\nModel.prototype._globalWatchArgs = {}; // mutation protection in Model.watch\r\nEmitterMixin_1.default.mixInto(Model);\r\nListenerMixin_1.default.mixInto(Model);\r\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar RecurringEventDef_1 = __webpack_require__(210);\r\nexports.default = {\r\n    parse: function (eventInput, source) {\r\n        if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||\r\n            util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {\r\n            return RecurringEventDef_1.default.parse(eventInput, source);\r\n        }\r\n        else {\r\n            return SingleEventDef_1.default.parse(eventInput, source);\r\n        }\r\n    }\r\n};\r\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar EventDefDateMutation = /** @class */ (function () {\r\n    function EventDefDateMutation() {\r\n        this.clearEnd = false;\r\n        this.forceTimed = false;\r\n        this.forceAllDay = false;\r\n    }\r\n    EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {\r\n        var clearEnd = dateProfile0.end && !dateProfile1.end;\r\n        var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();\r\n        var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();\r\n        var dateDelta;\r\n        var endDiff;\r\n        var endDelta;\r\n        var mutation;\r\n        // subtracts the dates in the appropriate way, returning a duration\r\n        function subtractDates(date1, date0) {\r\n            if (largeUnit) {\r\n                return util_1.diffByUnit(date1, date0, largeUnit); // poorly named\r\n            }\r\n            else if (dateProfile1.isAllDay()) {\r\n                return util_1.diffDay(date1, date0); // poorly named\r\n            }\r\n            else {\r\n                return util_1.diffDayTime(date1, date0); // poorly named\r\n            }\r\n        }\r\n        dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);\r\n        if (dateProfile1.end) {\r\n            // use unzonedRanges because dateProfile0.end might be null\r\n            endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());\r\n            endDelta = endDiff.subtract(dateDelta);\r\n        }\r\n        mutation = new EventDefDateMutation();\r\n        mutation.clearEnd = clearEnd;\r\n        mutation.forceTimed = forceTimed;\r\n        mutation.forceAllDay = forceAllDay;\r\n        mutation.setDateDelta(dateDelta);\r\n        mutation.setEndDelta(endDelta);\r\n        return mutation;\r\n    };\r\n    /*\r\n    returns an undo function.\r\n    */\r\n    EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {\r\n        var start = eventDateProfile.start.clone();\r\n        var end = null;\r\n        var shouldRezone = false;\r\n        if (eventDateProfile.end && !this.clearEnd) {\r\n            end = eventDateProfile.end.clone();\r\n        }\r\n        else if (this.endDelta && !end) {\r\n            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\r\n        }\r\n        if (this.forceTimed) {\r\n            shouldRezone = true;\r\n            if (!start.hasTime()) {\r\n                start.time(0);\r\n            }\r\n            if (end && !end.hasTime()) {\r\n                end.time(0);\r\n            }\r\n        }\r\n        else if (this.forceAllDay) {\r\n            if (start.hasTime()) {\r\n                start.stripTime();\r\n            }\r\n            if (end && end.hasTime()) {\r\n                end.stripTime();\r\n            }\r\n        }\r\n        if (this.dateDelta) {\r\n            shouldRezone = true;\r\n            start.add(this.dateDelta);\r\n            if (end) {\r\n                end.add(this.dateDelta);\r\n            }\r\n        }\r\n        // do this before adding startDelta to start, so we can work off of start\r\n        if (this.endDelta) {\r\n            shouldRezone = true;\r\n            end.add(this.endDelta);\r\n        }\r\n        if (this.startDelta) {\r\n            shouldRezone = true;\r\n            start.add(this.startDelta);\r\n        }\r\n        if (shouldRezone) {\r\n            start = calendar.applyTimezone(start);\r\n            if (end) {\r\n                end = calendar.applyTimezone(end);\r\n            }\r\n        }\r\n        // TODO: okay to access calendar option?\r\n        if (!end && calendar.opt('forceEventDuration')) {\r\n            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\r\n        }\r\n        return new EventDateProfile_1.default(start, end, calendar);\r\n    };\r\n    EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {\r\n        if (dateDelta && dateDelta.valueOf()) {\r\n            this.dateDelta = dateDelta;\r\n        }\r\n        else {\r\n            this.dateDelta = null;\r\n        }\r\n    };\r\n    EventDefDateMutation.prototype.setStartDelta = function (startDelta) {\r\n        if (startDelta && startDelta.valueOf()) {\r\n            this.startDelta = startDelta;\r\n        }\r\n        else {\r\n            this.startDelta = null;\r\n        }\r\n    };\r\n    EventDefDateMutation.prototype.setEndDelta = function (endDelta) {\r\n        if (endDelta && endDelta.valueOf()) {\r\n            this.endDelta = endDelta;\r\n        }\r\n        else {\r\n            this.endDelta = null;\r\n        }\r\n    };\r\n    EventDefDateMutation.prototype.isEmpty = function () {\r\n        return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&\r\n            !this.dateDelta && !this.startDelta && !this.endDelta;\r\n    };\r\n    return EventDefDateMutation;\r\n}());\r\nexports.default = EventDefDateMutation;\r\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StandardTheme_1 = __webpack_require__(213);\r\nvar JqueryUiTheme_1 = __webpack_require__(214);\r\nvar themeClassHash = {};\r\nfunction defineThemeSystem(themeName, themeClass) {\r\n    themeClassHash[themeName] = themeClass;\r\n}\r\nexports.defineThemeSystem = defineThemeSystem;\r\nfunction getThemeSystemClass(themeSetting) {\r\n    if (!themeSetting) {\r\n        return StandardTheme_1.default;\r\n    }\r\n    else if (themeSetting === true) {\r\n        return JqueryUiTheme_1.default;\r\n    }\r\n    else {\r\n        return themeClassHash[themeSetting];\r\n    }\r\n}\r\nexports.getThemeSystemClass = getThemeSystemClass;\r\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar ArrayEventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrayEventSource, _super);\r\n    function ArrayEventSource(calendar) {\r\n        var _this = _super.call(this, calendar) || this;\r\n        _this.eventDefs = []; // for if setRawEventDefs is never called\r\n        return _this;\r\n    }\r\n    ArrayEventSource.parse = function (rawInput, calendar) {\r\n        var rawProps;\r\n        // normalize raw input\r\n        if ($.isArray(rawInput.events)) {\r\n            rawProps = rawInput;\r\n        }\r\n        else if ($.isArray(rawInput)) {\r\n            rawProps = { events: rawInput };\r\n        }\r\n        if (rawProps) {\r\n            return EventSource_1.default.parse.call(this, rawProps, calendar);\r\n        }\r\n        return false;\r\n    };\r\n    ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {\r\n        this.rawEventDefs = rawEventDefs;\r\n        this.eventDefs = this.parseEventDefs(rawEventDefs);\r\n    };\r\n    ArrayEventSource.prototype.fetch = function (start, end, timezone) {\r\n        var eventDefs = this.eventDefs;\r\n        var i;\r\n        if (this.currentTimezone != null &&\r\n            this.currentTimezone !== timezone) {\r\n            for (i = 0; i < eventDefs.length; i++) {\r\n                if (eventDefs[i] instanceof SingleEventDef_1.default) {\r\n                    eventDefs[i].rezone();\r\n                }\r\n            }\r\n        }\r\n        this.currentTimezone = timezone;\r\n        return Promise_1.default.resolve(eventDefs);\r\n    };\r\n    ArrayEventSource.prototype.addEventDef = function (eventDef) {\r\n        this.eventDefs.push(eventDef);\r\n    };\r\n    /*\r\n    eventDefId already normalized to a string\r\n    */\r\n    ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {\r\n        return util_1.removeMatching(this.eventDefs, function (eventDef) {\r\n            return eventDef.id === eventDefId;\r\n        });\r\n    };\r\n    ArrayEventSource.prototype.removeAllEventDefs = function () {\r\n        this.eventDefs = [];\r\n    };\r\n    ArrayEventSource.prototype.getPrimitive = function () {\r\n        return this.rawEventDefs;\r\n    };\r\n    ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {\r\n        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\r\n        this.setRawEventDefs(rawProps.events);\r\n        return superSuccess;\r\n    };\r\n    return ArrayEventSource;\r\n}(EventSource_1.default));\r\nexports.default = ArrayEventSource;\r\nArrayEventSource.defineStandardProps({\r\n    events: false // don't automatically transfer\r\n});\r\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\n/*\r\nA cache for the left/right/top/bottom/width/height values for one or more elements.\r\nWorks with both offset (from topleft document) and position (from offsetParent).\r\n\noptions:\r\n- els\r\n- isHorizontal\r\n- isVertical\r\n*/\r\nvar CoordCache = /** @class */ (function () {\r\n    function CoordCache(options) {\r\n        this.isHorizontal = false; // whether to query for left/right/width\r\n        this.isVertical = false; // whether to query for top/bottom/height\r\n        this.els = $(options.els);\r\n        this.isHorizontal = options.isHorizontal;\r\n        this.isVertical = options.isVertical;\r\n        this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\r\n    }\r\n    // Queries the els for coordinates and stores them.\r\n    // Call this method before using and of the get* methods below.\r\n    CoordCache.prototype.build = function () {\r\n        var offsetParentEl = this.forcedOffsetParentEl;\r\n        if (!offsetParentEl && this.els.length > 0) {\r\n            offsetParentEl = this.els.eq(0).offsetParent();\r\n        }\r\n        this.origin = offsetParentEl ?\r\n            offsetParentEl.offset() :\r\n            null;\r\n        this.boundingRect = this.queryBoundingRect();\r\n        if (this.isHorizontal) {\r\n            this.buildElHorizontals();\r\n        }\r\n        if (this.isVertical) {\r\n            this.buildElVerticals();\r\n        }\r\n    };\r\n    // Destroys all internal data about coordinates, freeing memory\r\n    CoordCache.prototype.clear = function () {\r\n        this.origin = null;\r\n        this.boundingRect = null;\r\n        this.lefts = null;\r\n        this.rights = null;\r\n        this.tops = null;\r\n        this.bottoms = null;\r\n    };\r\n    // When called, if coord caches aren't built, builds them\r\n    CoordCache.prototype.ensureBuilt = function () {\r\n        if (!this.origin) {\r\n            this.build();\r\n        }\r\n    };\r\n    // Populates the left/right internal coordinate arrays\r\n    CoordCache.prototype.buildElHorizontals = function () {\r\n        var lefts = [];\r\n        var rights = [];\r\n        this.els.each(function (i, node) {\r\n            var el = $(node);\r\n            var left = el.offset().left;\r\n            var width = el.outerWidth();\r\n            lefts.push(left);\r\n            rights.push(left + width);\r\n        });\r\n        this.lefts = lefts;\r\n        this.rights = rights;\r\n    };\r\n    // Populates the top/bottom internal coordinate arrays\r\n    CoordCache.prototype.buildElVerticals = function () {\r\n        var tops = [];\r\n        var bottoms = [];\r\n        this.els.each(function (i, node) {\r\n            var el = $(node);\r\n            var top = el.offset().top;\r\n            var height = el.outerHeight();\r\n            tops.push(top);\r\n            bottoms.push(top + height);\r\n        });\r\n        this.tops = tops;\r\n        this.bottoms = bottoms;\r\n    };\r\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\r\n    // If no intersection is made, returns undefined.\r\n    CoordCache.prototype.getHorizontalIndex = function (leftOffset) {\r\n        this.ensureBuilt();\r\n        var lefts = this.lefts;\r\n        var rights = this.rights;\r\n        var len = lefts.length;\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            if (leftOffset >= lefts[i] && leftOffset < rights[i]) {\r\n                return i;\r\n            }\r\n        }\r\n    };\r\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\r\n    // If no intersection is made, returns undefined.\r\n    CoordCache.prototype.getVerticalIndex = function (topOffset) {\r\n        this.ensureBuilt();\r\n        var tops = this.tops;\r\n        var bottoms = this.bottoms;\r\n        var len = tops.length;\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            if (topOffset >= tops[i] && topOffset < bottoms[i]) {\r\n                return i;\r\n            }\r\n        }\r\n    };\r\n    // Gets the left offset (from document left) of the element at the given index\r\n    CoordCache.prototype.getLeftOffset = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.lefts[leftIndex];\r\n    };\r\n    // Gets the left position (from offsetParent left) of the element at the given index\r\n    CoordCache.prototype.getLeftPosition = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.lefts[leftIndex] - this.origin.left;\r\n    };\r\n    // Gets the right offset (from document left) of the element at the given index.\r\n    // This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\r\n    CoordCache.prototype.getRightOffset = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.rights[leftIndex];\r\n    };\r\n    // Gets the right position (from offsetParent left) of the element at the given index.\r\n    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\r\n    CoordCache.prototype.getRightPosition = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.rights[leftIndex] - this.origin.left;\r\n    };\r\n    // Gets the width of the element at the given index\r\n    CoordCache.prototype.getWidth = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.rights[leftIndex] - this.lefts[leftIndex];\r\n    };\r\n    // Gets the top offset (from document top) of the element at the given index\r\n    CoordCache.prototype.getTopOffset = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.tops[topIndex];\r\n    };\r\n    // Gets the top position (from offsetParent top) of the element at the given position\r\n    CoordCache.prototype.getTopPosition = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.tops[topIndex] - this.origin.top;\r\n    };\r\n    // Gets the bottom offset (from the document top) of the element at the given index.\r\n    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\r\n    CoordCache.prototype.getBottomOffset = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.bottoms[topIndex];\r\n    };\r\n    // Gets the bottom position (from the offsetParent top) of the element at the given index.\r\n    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\r\n    CoordCache.prototype.getBottomPosition = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.bottoms[topIndex] - this.origin.top;\r\n    };\r\n    // Gets the height of the element at the given index\r\n    CoordCache.prototype.getHeight = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.bottoms[topIndex] - this.tops[topIndex];\r\n    };\r\n    // Bounding Rect\r\n    // TODO: decouple this from CoordCache\r\n    // Compute and return what the elements' bounding rectangle is, from the user's perspective.\r\n    // Right now, only returns a rectangle if constrained by an overflow:scroll element.\r\n    // Returns null if there are no elements\r\n    CoordCache.prototype.queryBoundingRect = function () {\r\n        var scrollParentEl;\r\n        if (this.els.length > 0) {\r\n            scrollParentEl = util_1.getScrollParent(this.els.eq(0));\r\n            if (!scrollParentEl.is(document)) {\r\n                return util_1.getClientRect(scrollParentEl);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {\r\n        return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\r\n    };\r\n    CoordCache.prototype.isLeftInBounds = function (leftOffset) {\r\n        return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\r\n    };\r\n    CoordCache.prototype.isTopInBounds = function (topOffset) {\r\n        return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\r\n    };\r\n    return CoordCache;\r\n}());\r\nexports.default = CoordCache;\r\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\n/* Tracks a drag's mouse movement, firing various handlers\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// TODO: use Emitter\r\nvar DragListener = /** @class */ (function () {\r\n    function DragListener(options) {\r\n        this.isInteracting = false;\r\n        this.isDistanceSurpassed = false;\r\n        this.isDelayEnded = false;\r\n        this.isDragging = false;\r\n        this.isTouch = false;\r\n        this.isGeneric = false; // initiated by 'dragstart' (jqui)\r\n        this.shouldCancelTouchScroll = true;\r\n        this.scrollAlwaysKills = false;\r\n        this.isAutoScroll = false;\r\n        // defaults\r\n        this.scrollSensitivity = 30; // pixels from edge for scrolling to start\r\n        this.scrollSpeed = 200; // pixels per second, at maximum speed\r\n        this.scrollIntervalMs = 50; // millisecond wait between scroll increment\r\n        this.options = options || {};\r\n    }\r\n    // Interaction (high-level)\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.startInteraction = function (ev, extraOptions) {\r\n        if (extraOptions === void 0) { extraOptions = {}; }\r\n        if (ev.type === 'mousedown') {\r\n            if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {\r\n                return;\r\n            }\r\n            else if (!util_1.isPrimaryMouseButton(ev)) {\r\n                return;\r\n            }\r\n            else {\r\n                ev.preventDefault(); // prevents native selection in most browsers\r\n            }\r\n        }\r\n        if (!this.isInteracting) {\r\n            // process options\r\n            this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);\r\n            this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);\r\n            this.subjectEl = this.options.subjectEl;\r\n            util_1.preventSelection($('body'));\r\n            this.isInteracting = true;\r\n            this.isTouch = util_1.getEvIsTouch(ev);\r\n            this.isGeneric = ev.type === 'dragstart';\r\n            this.isDelayEnded = false;\r\n            this.isDistanceSurpassed = false;\r\n            this.originX = util_1.getEvX(ev);\r\n            this.originY = util_1.getEvY(ev);\r\n            this.scrollEl = util_1.getScrollParent($(ev.target));\r\n            this.bindHandlers();\r\n            this.initAutoScroll();\r\n            this.handleInteractionStart(ev);\r\n            this.startDelay(ev);\r\n            if (!this.minDistance) {\r\n                this.handleDistanceSurpassed(ev);\r\n            }\r\n        }\r\n    };\r\n    DragListener.prototype.handleInteractionStart = function (ev) {\r\n        this.trigger('interactionStart', ev);\r\n    };\r\n    DragListener.prototype.endInteraction = function (ev, isCancelled) {\r\n        if (this.isInteracting) {\r\n            this.endDrag(ev);\r\n            if (this.delayTimeoutId) {\r\n                clearTimeout(this.delayTimeoutId);\r\n                this.delayTimeoutId = null;\r\n            }\r\n            this.destroyAutoScroll();\r\n            this.unbindHandlers();\r\n            this.isInteracting = false;\r\n            this.handleInteractionEnd(ev, isCancelled);\r\n            util_1.allowSelection($('body'));\r\n        }\r\n    };\r\n    DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {\r\n        this.trigger('interactionEnd', ev, isCancelled || false);\r\n    };\r\n    // Binding To DOM\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.bindHandlers = function () {\r\n        // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,\r\n        // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.\r\n        var globalEmitter = GlobalEmitter_1.default.get();\r\n        if (this.isGeneric) {\r\n            this.listenTo($(document), {\r\n                drag: this.handleMove,\r\n                dragstop: this.endInteraction\r\n            });\r\n        }\r\n        else if (this.isTouch) {\r\n            this.listenTo(globalEmitter, {\r\n                touchmove: this.handleTouchMove,\r\n                touchend: this.endInteraction,\r\n                scroll: this.handleTouchScroll\r\n            });\r\n        }\r\n        else {\r\n            this.listenTo(globalEmitter, {\r\n                mousemove: this.handleMouseMove,\r\n                mouseup: this.endInteraction\r\n            });\r\n        }\r\n        this.listenTo(globalEmitter, {\r\n            selectstart: util_1.preventDefault,\r\n            contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools\r\n        });\r\n    };\r\n    DragListener.prototype.unbindHandlers = function () {\r\n        this.stopListeningTo(GlobalEmitter_1.default.get());\r\n        this.stopListeningTo($(document)); // for isGeneric\r\n    };\r\n    // Drag (high-level)\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // extraOptions ignored if drag already started\r\n    DragListener.prototype.startDrag = function (ev, extraOptions) {\r\n        this.startInteraction(ev, extraOptions); // ensure interaction began\r\n        if (!this.isDragging) {\r\n            this.isDragging = true;\r\n            this.handleDragStart(ev);\r\n        }\r\n    };\r\n    DragListener.prototype.handleDragStart = function (ev) {\r\n        this.trigger('dragStart', ev);\r\n    };\r\n    DragListener.prototype.handleMove = function (ev) {\r\n        var dx = util_1.getEvX(ev) - this.originX;\r\n        var dy = util_1.getEvY(ev) - this.originY;\r\n        var minDistance = this.minDistance;\r\n        var distanceSq; // current distance from the origin, squared\r\n        if (!this.isDistanceSurpassed) {\r\n            distanceSq = dx * dx + dy * dy;\r\n            if (distanceSq >= minDistance * minDistance) {\r\n                this.handleDistanceSurpassed(ev);\r\n            }\r\n        }\r\n        if (this.isDragging) {\r\n            this.handleDrag(dx, dy, ev);\r\n        }\r\n    };\r\n    // Called while the mouse is being moved and when we know a legitimate drag is taking place\r\n    DragListener.prototype.handleDrag = function (dx, dy, ev) {\r\n        this.trigger('drag', dx, dy, ev);\r\n        this.updateAutoScroll(ev); // will possibly cause scrolling\r\n    };\r\n    DragListener.prototype.endDrag = function (ev) {\r\n        if (this.isDragging) {\r\n            this.isDragging = false;\r\n            this.handleDragEnd(ev);\r\n        }\r\n    };\r\n    DragListener.prototype.handleDragEnd = function (ev) {\r\n        this.trigger('dragEnd', ev);\r\n    };\r\n    // Delay\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.startDelay = function (initialEv) {\r\n        var _this = this;\r\n        if (this.delay) {\r\n            this.delayTimeoutId = setTimeout(function () {\r\n                _this.handleDelayEnd(initialEv);\r\n            }, this.delay);\r\n        }\r\n        else {\r\n            this.handleDelayEnd(initialEv);\r\n        }\r\n    };\r\n    DragListener.prototype.handleDelayEnd = function (initialEv) {\r\n        this.isDelayEnded = true;\r\n        if (this.isDistanceSurpassed) {\r\n            this.startDrag(initialEv);\r\n        }\r\n    };\r\n    // Distance\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.handleDistanceSurpassed = function (ev) {\r\n        this.isDistanceSurpassed = true;\r\n        if (this.isDelayEnded) {\r\n            this.startDrag(ev);\r\n        }\r\n    };\r\n    // Mouse / Touch\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.handleTouchMove = function (ev) {\r\n        // prevent inertia and touchmove-scrolling while dragging\r\n        if (this.isDragging && this.shouldCancelTouchScroll) {\r\n            ev.preventDefault();\r\n        }\r\n        this.handleMove(ev);\r\n    };\r\n    DragListener.prototype.handleMouseMove = function (ev) {\r\n        this.handleMove(ev);\r\n    };\r\n    // Scrolling (unrelated to auto-scroll)\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.handleTouchScroll = function (ev) {\r\n        // if the drag is being initiated by touch, but a scroll happens before\r\n        // the drag-initiating delay is over, cancel the drag\r\n        if (!this.isDragging || this.scrollAlwaysKills) {\r\n            this.endInteraction(ev, true); // isCancelled=true\r\n        }\r\n    };\r\n    // Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Triggers a callback. Calls a function in the option hash of the same name.\r\n    // Arguments beyond the first `name` are forwarded on.\r\n    DragListener.prototype.trigger = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.options[name]) {\r\n            this.options[name].apply(this, args);\r\n        }\r\n        // makes _methods callable by event name. TODO: kill this\r\n        if (this['_' + name]) {\r\n            this['_' + name].apply(this, args);\r\n        }\r\n    };\r\n    // Auto-scroll\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.initAutoScroll = function () {\r\n        var scrollEl = this.scrollEl;\r\n        this.isAutoScroll =\r\n            this.options.scroll &&\r\n                scrollEl &&\r\n                !scrollEl.is(window) &&\r\n                !scrollEl.is(document);\r\n        if (this.isAutoScroll) {\r\n            // debounce makes sure rapid calls don't happen\r\n            this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));\r\n        }\r\n    };\r\n    DragListener.prototype.destroyAutoScroll = function () {\r\n        this.endAutoScroll(); // kill any animation loop\r\n        // remove the scroll handler if there is a scrollEl\r\n        if (this.isAutoScroll) {\r\n            this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\r\n        }\r\n    };\r\n    // Computes and stores the bounding rectangle of scrollEl\r\n    DragListener.prototype.computeScrollBounds = function () {\r\n        if (this.isAutoScroll) {\r\n            this.scrollBounds = util_1.getOuterRect(this.scrollEl);\r\n            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\r\n        }\r\n    };\r\n    // Called when the dragging is in progress and scrolling should be updated\r\n    DragListener.prototype.updateAutoScroll = function (ev) {\r\n        var sensitivity = this.scrollSensitivity;\r\n        var bounds = this.scrollBounds;\r\n        var topCloseness;\r\n        var bottomCloseness;\r\n        var leftCloseness;\r\n        var rightCloseness;\r\n        var topVel = 0;\r\n        var leftVel = 0;\r\n        if (bounds) {\r\n            // compute closeness to edges. valid range is from 0.0 - 1.0\r\n            topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;\r\n            bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;\r\n            leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;\r\n            rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;\r\n            // translate vertical closeness into velocity.\r\n            // mouse must be completely in bounds for velocity to happen.\r\n            if (topCloseness >= 0 && topCloseness <= 1) {\r\n                topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\r\n            }\r\n            else if (bottomCloseness >= 0 && bottomCloseness <= 1) {\r\n                topVel = bottomCloseness * this.scrollSpeed;\r\n            }\r\n            // translate horizontal closeness into velocity\r\n            if (leftCloseness >= 0 && leftCloseness <= 1) {\r\n                leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\r\n            }\r\n            else if (rightCloseness >= 0 && rightCloseness <= 1) {\r\n                leftVel = rightCloseness * this.scrollSpeed;\r\n            }\r\n        }\r\n        this.setScrollVel(topVel, leftVel);\r\n    };\r\n    // Sets the speed-of-scrolling for the scrollEl\r\n    DragListener.prototype.setScrollVel = function (topVel, leftVel) {\r\n        this.scrollTopVel = topVel;\r\n        this.scrollLeftVel = leftVel;\r\n        this.constrainScrollVel(); // massages into realistic values\r\n        // if there is non-zero velocity, and an animation loop hasn't already started, then START\r\n        if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\r\n            this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`\r\n            this.scrollIntervalMs);\r\n        }\r\n    };\r\n    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\r\n    DragListener.prototype.constrainScrollVel = function () {\r\n        var el = this.scrollEl;\r\n        if (this.scrollTopVel < 0) {\r\n            if (el.scrollTop() <= 0) {\r\n                this.scrollTopVel = 0;\r\n            }\r\n        }\r\n        else if (this.scrollTopVel > 0) {\r\n            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {\r\n                this.scrollTopVel = 0;\r\n            }\r\n        }\r\n        if (this.scrollLeftVel < 0) {\r\n            if (el.scrollLeft() <= 0) {\r\n                this.scrollLeftVel = 0;\r\n            }\r\n        }\r\n        else if (this.scrollLeftVel > 0) {\r\n            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {\r\n                this.scrollLeftVel = 0;\r\n            }\r\n        }\r\n    };\r\n    // This function gets called during every iteration of the scrolling animation loop\r\n    DragListener.prototype.scrollIntervalFunc = function () {\r\n        var el = this.scrollEl;\r\n        var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\r\n        // change the value of scrollEl's scroll\r\n        if (this.scrollTopVel) {\r\n            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\r\n        }\r\n        if (this.scrollLeftVel) {\r\n            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\r\n        }\r\n        this.constrainScrollVel(); // since the scroll values changed, recompute the velocities\r\n        // if scrolled all the way, which causes the vels to be zero, stop the animation loop\r\n        if (!this.scrollTopVel && !this.scrollLeftVel) {\r\n            this.endAutoScroll();\r\n        }\r\n    };\r\n    // Kills any existing scrolling animation loop\r\n    DragListener.prototype.endAutoScroll = function () {\r\n        if (this.scrollIntervalId) {\r\n            clearInterval(this.scrollIntervalId);\r\n            this.scrollIntervalId = null;\r\n            this.handleScrollEnd();\r\n        }\r\n    };\r\n    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\r\n    DragListener.prototype.handleDebouncedScroll = function () {\r\n        // recompute all coordinates, but *only* if this is *not* part of our scrolling animation\r\n        if (!this.scrollIntervalId) {\r\n            this.handleScrollEnd();\r\n        }\r\n    };\r\n    DragListener.prototype.handleScrollEnd = function () {\r\n        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\r\n    };\r\n    return DragListener;\r\n}());\r\nexports.default = DragListener;\r\nListenerMixin_1.default.mixInto(DragListener);\r\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar Mixin_1 = __webpack_require__(14);\r\n/*\r\nA set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\r\nPrerequisite: the object being mixed into needs to be a *Grid*\r\n*/\r\nvar DayTableMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayTableMixin, _super);\r\n    function DayTableMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Populates internal variables used for date calculation and rendering\r\n    DayTableMixin.prototype.updateDayTable = function () {\r\n        var t = this;\r\n        var view = t.view;\r\n        var calendar = view.calendar;\r\n        var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);\r\n        var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);\r\n        var dayIndex = -1;\r\n        var dayIndices = [];\r\n        var dayDates = [];\r\n        var daysPerRow;\r\n        var firstDay;\r\n        var rowCnt;\r\n        while (date.isBefore(end)) {\r\n            if (view.isHiddenDay(date)) {\r\n                dayIndices.push(dayIndex + 0.5); // mark that it's between indices\r\n            }\r\n            else {\r\n                dayIndex++;\r\n                dayIndices.push(dayIndex);\r\n                dayDates.push(date.clone());\r\n            }\r\n            date.add(1, 'days');\r\n        }\r\n        if (this.breakOnWeeks) {\r\n            // count columns until the day-of-week repeats\r\n            firstDay = dayDates[0].day();\r\n            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\r\n                if (dayDates[daysPerRow].day() === firstDay) {\r\n                    break;\r\n                }\r\n            }\r\n            rowCnt = Math.ceil(dayDates.length / daysPerRow);\r\n        }\r\n        else {\r\n            rowCnt = 1;\r\n            daysPerRow = dayDates.length;\r\n        }\r\n        this.dayDates = dayDates;\r\n        this.dayIndices = dayIndices;\r\n        this.daysPerRow = daysPerRow;\r\n        this.rowCnt = rowCnt;\r\n        this.updateDayTableCols();\r\n    };\r\n    // Computes and assigned the colCnt property and updates any options that may be computed from it\r\n    DayTableMixin.prototype.updateDayTableCols = function () {\r\n        this.colCnt = this.computeColCnt();\r\n        this.colHeadFormat =\r\n            this.opt('columnHeaderFormat') ||\r\n                this.opt('columnFormat') || // deprecated\r\n                this.computeColHeadFormat();\r\n    };\r\n    // Determines how many columns there should be in the table\r\n    DayTableMixin.prototype.computeColCnt = function () {\r\n        return this.daysPerRow;\r\n    };\r\n    // Computes the ambiguously-timed moment for the given cell\r\n    DayTableMixin.prototype.getCellDate = function (row, col) {\r\n        return this.dayDates[this.getCellDayIndex(row, col)].clone();\r\n    };\r\n    // Computes the ambiguously-timed date range for the given cell\r\n    DayTableMixin.prototype.getCellRange = function (row, col) {\r\n        var start = this.getCellDate(row, col);\r\n        var end = start.clone().add(1, 'days');\r\n        return { start: start, end: end };\r\n    };\r\n    // Returns the number of day cells, chronologically, from the first of the grid (0-based)\r\n    DayTableMixin.prototype.getCellDayIndex = function (row, col) {\r\n        return row * this.daysPerRow + this.getColDayIndex(col);\r\n    };\r\n    // Returns the numner of day cells, chronologically, from the first cell in *any given row*\r\n    DayTableMixin.prototype.getColDayIndex = function (col) {\r\n        if (this.isRTL) {\r\n            return this.colCnt - 1 - col;\r\n        }\r\n        else {\r\n            return col;\r\n        }\r\n    };\r\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\r\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\r\n    // If before the first offset, returns a negative number.\r\n    // If after the last offset, returns an offset past the last cell offset.\r\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\r\n    DayTableMixin.prototype.getDateDayIndex = function (date) {\r\n        var dayIndices = this.dayIndices;\r\n        var dayOffset = date.diff(this.dayDates[0], 'days');\r\n        if (dayOffset < 0) {\r\n            return dayIndices[0] - 1;\r\n        }\r\n        else if (dayOffset >= dayIndices.length) {\r\n            return dayIndices[dayIndices.length - 1] + 1;\r\n        }\r\n        else {\r\n            return dayIndices[dayOffset];\r\n        }\r\n    };\r\n    /* Options\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\r\n    DayTableMixin.prototype.computeColHeadFormat = function () {\r\n        // if more than one week row, or if there are a lot of columns with not much space,\r\n        // put just the day numbers will be in each cell\r\n        if (this.rowCnt > 1 || this.colCnt > 10) {\r\n            return 'ddd'; // \"Sat\"\r\n        }\r\n        else if (this.colCnt > 1) {\r\n            return this.opt('dayOfMonthFormat'); // \"Sat 12/10\"\r\n        }\r\n        else {\r\n            return 'dddd'; // \"Saturday\"\r\n        }\r\n    };\r\n    /* Slicing\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Slices up a date range into a segment for every week-row it intersects with\r\n    DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {\r\n        var daysPerRow = this.daysPerRow;\r\n        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\r\n        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\r\n        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\r\n        var segs = [];\r\n        var row;\r\n        var rowFirst;\r\n        var rowLast; // inclusive day-index range for current row\r\n        var segFirst;\r\n        var segLast; // inclusive day-index range for segment\r\n        for (row = 0; row < this.rowCnt; row++) {\r\n            rowFirst = row * daysPerRow;\r\n            rowLast = rowFirst + daysPerRow - 1;\r\n            // intersect segment's offset range with the row's\r\n            segFirst = Math.max(rangeFirst, rowFirst);\r\n            segLast = Math.min(rangeLast, rowLast);\r\n            // deal with in-between indices\r\n            segFirst = Math.ceil(segFirst); // in-between starts round to next cell\r\n            segLast = Math.floor(segLast); // in-between ends round to prev cell\r\n            if (segFirst <= segLast) {\r\n                segs.push({\r\n                    row: row,\r\n                    // normalize to start of row\r\n                    firstRowDayIndex: segFirst - rowFirst,\r\n                    lastRowDayIndex: segLast - rowFirst,\r\n                    // must be matching integers to be the segment's start/end\r\n                    isStart: segFirst === rangeFirst,\r\n                    isEnd: segLast === rangeLast\r\n                });\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    // Slices up a date range into a segment for every day-cell it intersects with.\r\n    // TODO: make more DRY with sliceRangeByRow somehow.\r\n    DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {\r\n        var daysPerRow = this.daysPerRow;\r\n        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\r\n        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\r\n        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\r\n        var segs = [];\r\n        var row;\r\n        var rowFirst;\r\n        var rowLast; // inclusive day-index range for current row\r\n        var i;\r\n        var segFirst;\r\n        var segLast; // inclusive day-index range for segment\r\n        for (row = 0; row < this.rowCnt; row++) {\r\n            rowFirst = row * daysPerRow;\r\n            rowLast = rowFirst + daysPerRow - 1;\r\n            for (i = rowFirst; i <= rowLast; i++) {\r\n                // intersect segment's offset range with the row's\r\n                segFirst = Math.max(rangeFirst, i);\r\n                segLast = Math.min(rangeLast, i);\r\n                // deal with in-between indices\r\n                segFirst = Math.ceil(segFirst); // in-between starts round to next cell\r\n                segLast = Math.floor(segLast); // in-between ends round to prev cell\r\n                if (segFirst <= segLast) {\r\n                    segs.push({\r\n                        row: row,\r\n                        // normalize to start of row\r\n                        firstRowDayIndex: segFirst - rowFirst,\r\n                        lastRowDayIndex: segLast - rowFirst,\r\n                        // must be matching integers to be the segment's start/end\r\n                        isStart: segFirst === rangeFirst,\r\n                        isEnd: segLast === rangeLast\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Header Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayTableMixin.prototype.renderHeadHtml = function () {\r\n        var theme = this.view.calendar.theme;\r\n        return '' +\r\n            '<div class=\"fc-row ' + theme.getClass('headerRow') + '\">' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            '<thead>' +\r\n            this.renderHeadTrHtml() +\r\n            '</thead>' +\r\n            '</table>' +\r\n            '</div>';\r\n    };\r\n    DayTableMixin.prototype.renderHeadIntroHtml = function () {\r\n        return this.renderIntroHtml(); // fall back to generic\r\n    };\r\n    DayTableMixin.prototype.renderHeadTrHtml = function () {\r\n        return '' +\r\n            '<tr>' +\r\n            (this.isRTL ? '' : this.renderHeadIntroHtml()) +\r\n            this.renderHeadDateCellsHtml() +\r\n            (this.isRTL ? this.renderHeadIntroHtml() : '') +\r\n            '</tr>';\r\n    };\r\n    DayTableMixin.prototype.renderHeadDateCellsHtml = function () {\r\n        var htmls = [];\r\n        var col;\r\n        var date;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            date = this.getCellDate(0, col);\r\n            htmls.push(this.renderHeadDateCellHtml(date));\r\n        }\r\n        return htmls.join('');\r\n    };\r\n    // TODO: when internalApiVersion, accept an object for HTML attributes\r\n    // (colspan should be no different)\r\n    DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {\r\n        var t = this;\r\n        var view = t.view;\r\n        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n        var classNames = [\r\n            'fc-day-header',\r\n            view.calendar.theme.getClass('widgetHeader')\r\n        ];\r\n        var innerHtml;\r\n        if (typeof t.opt('columnHeaderHtml') === 'function') {\r\n            innerHtml = t.opt('columnHeaderHtml')(date);\r\n        }\r\n        else if (typeof t.opt('columnHeaderText') === 'function') {\r\n            innerHtml = util_1.htmlEscape(t.opt('columnHeaderText')(date));\r\n        }\r\n        else {\r\n            innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));\r\n        }\r\n        // if only one row of days, the classNames on the header can represent the specific days beneath\r\n        if (t.rowCnt === 1) {\r\n            classNames = classNames.concat(\r\n            // includes the day-of-week class\r\n            // noThemeHighlight=true (don't highlight the header)\r\n            t.getDayClasses(date, true));\r\n        }\r\n        else {\r\n            classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class\r\n        }\r\n        return '' +\r\n            '<th class=\"' + classNames.join(' ') + '\"' +\r\n            ((isDateValid && t.rowCnt) === 1 ?\r\n                ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\r\n                '') +\r\n            (colspan > 1 ?\r\n                ' colspan=\"' + colspan + '\"' :\r\n                '') +\r\n            (otherAttrs ?\r\n                ' ' + otherAttrs :\r\n                '') +\r\n            '>' +\r\n            (isDateValid ?\r\n                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\r\n                view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :\r\n                // if not valid, display text, but no link\r\n                innerHtml) +\r\n            '</th>';\r\n    };\r\n    /* Background Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayTableMixin.prototype.renderBgTrHtml = function (row) {\r\n        return '' +\r\n            '<tr>' +\r\n            (this.isRTL ? '' : this.renderBgIntroHtml(row)) +\r\n            this.renderBgCellsHtml(row) +\r\n            (this.isRTL ? this.renderBgIntroHtml(row) : '') +\r\n            '</tr>';\r\n    };\r\n    DayTableMixin.prototype.renderBgIntroHtml = function (row) {\r\n        return this.renderIntroHtml(); // fall back to generic\r\n    };\r\n    DayTableMixin.prototype.renderBgCellsHtml = function (row) {\r\n        var htmls = [];\r\n        var col;\r\n        var date;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            date = this.getCellDate(row, col);\r\n            htmls.push(this.renderBgCellHtml(date));\r\n        }\r\n        return htmls.join('');\r\n    };\r\n    DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {\r\n        var t = this;\r\n        var view = t.view;\r\n        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n        var classes = t.getDayClasses(date);\r\n        classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));\r\n        return '<td class=\"' + classes.join(' ') + '\"' +\r\n            (isDateValid ?\r\n                ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' : // if date has a time, won't format it\r\n                '') +\r\n            (otherAttrs ?\r\n                ' ' + otherAttrs :\r\n                '') +\r\n            '></td>';\r\n    };\r\n    /* Generic\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayTableMixin.prototype.renderIntroHtml = function () {\r\n        // Generates the default HTML intro for any row. User classes should override\r\n    };\r\n    // TODO: a generic method for dealing with <tr>, RTL, intro\r\n    // when increment internalApiVersion\r\n    // wrapTr (scheduler)\r\n    /* Utils\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Applies the generic \"intro\" and \"outro\" HTML to the given cells.\r\n    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\r\n    DayTableMixin.prototype.bookendCells = function (trEl) {\r\n        var introHtml = this.renderIntroHtml();\r\n        if (introHtml) {\r\n            if (this.isRTL) {\r\n                trEl.append(introHtml);\r\n            }\r\n            else {\r\n                trEl.prepend(introHtml);\r\n            }\r\n        }\r\n    };\r\n    return DayTableMixin;\r\n}(Mixin_1.default));\r\nexports.default = DayTableMixin;\r\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BusinessHourRenderer = /** @class */ (function () {\r\n    /*\r\n    component implements:\r\n      - eventRangesToEventFootprints\r\n      - eventFootprintsToSegs\r\n    */\r\n    function BusinessHourRenderer(component, fillRenderer) {\r\n        this.component = component;\r\n        this.fillRenderer = fillRenderer;\r\n    }\r\n    BusinessHourRenderer.prototype.render = function (businessHourGenerator) {\r\n        var component = this.component;\r\n        var unzonedRange = component._getDateProfile().activeUnzonedRange;\r\n        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);\r\n        var eventFootprints = eventInstanceGroup ?\r\n            component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :\r\n            [];\r\n        this.renderEventFootprints(eventFootprints);\r\n    };\r\n    BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        this.renderSegs(segs);\r\n        this.segs = segs;\r\n    };\r\n    BusinessHourRenderer.prototype.renderSegs = function (segs) {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.renderSegs('businessHours', segs, {\r\n                getClasses: function (seg) {\r\n                    return ['fc-nonbusiness', 'fc-bgevent'];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    BusinessHourRenderer.prototype.unrender = function () {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.unrender('businessHours');\r\n        }\r\n        this.segs = null;\r\n    };\r\n    BusinessHourRenderer.prototype.getSegs = function () {\r\n        return this.segs || [];\r\n    };\r\n    return BusinessHourRenderer;\r\n}());\r\nexports.default = BusinessHourRenderer;\r\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar FillRenderer = /** @class */ (function () {\r\n    function FillRenderer(component) {\r\n        this.fillSegTag = 'div';\r\n        this.component = component;\r\n        this.elsByFill = {};\r\n    }\r\n    FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {\r\n        this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);\r\n    };\r\n    FillRenderer.prototype.renderSegs = function (type, segs, props) {\r\n        var els;\r\n        segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs\r\n        els = this.attachSegEls(type, segs);\r\n        if (els) {\r\n            this.reportEls(type, els);\r\n        }\r\n        return segs;\r\n    };\r\n    // Unrenders a specific type of fill that is currently rendered on the grid\r\n    FillRenderer.prototype.unrender = function (type) {\r\n        var el = this.elsByFill[type];\r\n        if (el) {\r\n            el.remove();\r\n            delete this.elsByFill[type];\r\n        }\r\n    };\r\n    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\r\n    // Only returns segments that successfully rendered.\r\n    FillRenderer.prototype.buildSegEls = function (type, segs, props) {\r\n        var _this = this;\r\n        var html = '';\r\n        var renderedSegs = [];\r\n        var i;\r\n        if (segs.length) {\r\n            // build a large concatenation of segment HTML\r\n            for (i = 0; i < segs.length; i++) {\r\n                html += this.buildSegHtml(type, segs[i], props);\r\n            }\r\n            // Grab individual elements from the combined HTML string. Use each as the default rendering.\r\n            // Then, compute the 'el' for each segment.\r\n            $(html).each(function (i, node) {\r\n                var seg = segs[i];\r\n                var el = $(node);\r\n                // allow custom filter methods per-type\r\n                if (props.filterEl) {\r\n                    el = props.filterEl(seg, el);\r\n                }\r\n                if (el) {\r\n                    el = $(el); // allow custom filter to return raw DOM node\r\n                    // correct element type? (would be bad if a non-TD were inserted into a table for example)\r\n                    if (el.is(_this.fillSegTag)) {\r\n                        seg.el = el;\r\n                        renderedSegs.push(seg);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return renderedSegs;\r\n    };\r\n    // Builds the HTML needed for one fill segment. Generic enough to work with different types.\r\n    FillRenderer.prototype.buildSegHtml = function (type, seg, props) {\r\n        // custom hooks per-type\r\n        var classes = props.getClasses ? props.getClasses(seg) : [];\r\n        var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});\r\n        return '<' + this.fillSegTag +\r\n            (classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') +\r\n            (css ? ' style=\"' + css + '\"' : '') +\r\n            ' />';\r\n    };\r\n    // Should return wrapping DOM structure\r\n    FillRenderer.prototype.attachSegEls = function (type, segs) {\r\n        // subclasses must implement\r\n    };\r\n    FillRenderer.prototype.reportEls = function (type, nodes) {\r\n        if (this.elsByFill[type]) {\r\n            this.elsByFill[type] = this.elsByFill[type].add(nodes);\r\n        }\r\n        else {\r\n            this.elsByFill[type] = $(nodes);\r\n        }\r\n    };\r\n    return FillRenderer;\r\n}());\r\nexports.default = FillRenderer;\r\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar HelperRenderer = /** @class */ (function () {\r\n    function HelperRenderer(component, eventRenderer) {\r\n        this.view = component._getView();\r\n        this.component = component;\r\n        this.eventRenderer = eventRenderer;\r\n    }\r\n    HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {\r\n        this.renderEventFootprints([\r\n            this.fabricateEventFootprint(componentFootprint)\r\n        ]);\r\n    };\r\n    HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {\r\n        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));\r\n    };\r\n    HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {\r\n        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');\r\n    };\r\n    HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        var classNames = 'fc-helper ' + (extraClassNames || '');\r\n        var i;\r\n        // assigns each seg's el and returns a subset of segs that were rendered\r\n        segs = this.eventRenderer.renderFgSegEls(segs);\r\n        for (i = 0; i < segs.length; i++) {\r\n            segs[i].el.addClass(classNames);\r\n        }\r\n        if (opacity != null) {\r\n            for (i = 0; i < segs.length; i++) {\r\n                segs[i].el.css('opacity', opacity);\r\n            }\r\n        }\r\n        this.helperEls = this.renderSegs(segs, sourceSeg);\r\n    };\r\n    /*\r\n    Must return all mock event elements\r\n    */\r\n    HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\r\n        // Subclasses must implement\r\n    };\r\n    HelperRenderer.prototype.unrender = function () {\r\n        if (this.helperEls) {\r\n            this.helperEls.remove();\r\n            this.helperEls = null;\r\n        }\r\n    };\r\n    HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {\r\n        var calendar = this.view.calendar;\r\n        var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);\r\n        var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));\r\n        var dummyInstance;\r\n        dummyEvent.dateProfile = eventDateProfile;\r\n        dummyInstance = dummyEvent.buildInstance();\r\n        return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);\r\n    };\r\n    return HelperRenderer;\r\n}());\r\nexports.default = HelperRenderer;\r\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar EventPointing = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventPointing, _super);\r\n    function EventPointing() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /*\r\n    component must implement:\r\n      - publiclyTrigger\r\n    */\r\n    EventPointing.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));\r\n        component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));\r\n        component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));\r\n    };\r\n    EventPointing.prototype.handleClick = function (seg, ev) {\r\n        var res = this.component.publiclyTrigger('eventClick', {\r\n            context: seg.el[0],\r\n            args: [seg.footprint.getEventLegacy(), ev, this.view]\r\n        });\r\n        if (res === false) {\r\n            ev.preventDefault();\r\n        }\r\n    };\r\n    // Updates internal state and triggers handlers for when an event element is moused over\r\n    EventPointing.prototype.handleMouseover = function (seg, ev) {\r\n        if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&\r\n            !this.mousedOverSeg) {\r\n            this.mousedOverSeg = seg;\r\n            // TODO: move to EventSelecting's responsibility\r\n            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {\r\n                seg.el.addClass('fc-allow-mouse-resize');\r\n            }\r\n            this.component.publiclyTrigger('eventMouseover', {\r\n                context: seg.el[0],\r\n                args: [seg.footprint.getEventLegacy(), ev, this.view]\r\n            });\r\n        }\r\n    };\r\n    // Updates internal state and triggers handlers for when an event element is moused out.\r\n    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\r\n    EventPointing.prototype.handleMouseout = function (seg, ev) {\r\n        if (this.mousedOverSeg) {\r\n            this.mousedOverSeg = null;\r\n            // TODO: move to EventSelecting's responsibility\r\n            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {\r\n                seg.el.removeClass('fc-allow-mouse-resize');\r\n            }\r\n            this.component.publiclyTrigger('eventMouseout', {\r\n                context: seg.el[0],\r\n                args: [\r\n                    seg.footprint.getEventLegacy(),\r\n                    ev || {},\r\n                    this.view\r\n                ]\r\n            });\r\n        }\r\n    };\r\n    EventPointing.prototype.end = function () {\r\n        if (this.mousedOverSeg) {\r\n            this.handleMouseout(this.mousedOverSeg);\r\n        }\r\n    };\r\n    return EventPointing;\r\n}(Interaction_1.default));\r\nexports.default = EventPointing;\r\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar DateClicking_1 = __webpack_require__(245);\r\nvar DateSelecting_1 = __webpack_require__(225);\r\nvar EventPointing_1 = __webpack_require__(59);\r\nvar EventDragging_1 = __webpack_require__(224);\r\nvar EventResizing_1 = __webpack_require__(223);\r\nvar ExternalDropping_1 = __webpack_require__(222);\r\nvar StandardInteractionsMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StandardInteractionsMixin, _super);\r\n    function StandardInteractionsMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return StandardInteractionsMixin;\r\n}(Mixin_1.default));\r\nexports.default = StandardInteractionsMixin;\r\nStandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;\r\nStandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;\r\nStandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;\r\nStandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;\r\nStandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;\r\nStandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;\r\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar CoordCache_1 = __webpack_require__(53);\r\nvar Popover_1 = __webpack_require__(249);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nvar BusinessHourRenderer_1 = __webpack_require__(56);\r\nvar StandardInteractionsMixin_1 = __webpack_require__(60);\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nvar DayTableMixin_1 = __webpack_require__(55);\r\nvar DayGridEventRenderer_1 = __webpack_require__(250);\r\nvar DayGridHelperRenderer_1 = __webpack_require__(251);\r\nvar DayGridFillRenderer_1 = __webpack_require__(252);\r\n/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar DayGrid = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGrid, _super);\r\n    function DayGrid(view) {\r\n        var _this = _super.call(this, view) || this;\r\n        _this.cellWeekNumbersVisible = false; // display week numbers in day cell?\r\n        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid\r\n        // isRigid determines whether the individual rows should ignore the contents and be a constant height.\r\n        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\r\n        _this.isRigid = false;\r\n        _this.hasAllDayBusinessHours = true;\r\n        return _this;\r\n    }\r\n    // Slices up the given span (unzoned start/end with other misc data) into an array of segments\r\n    DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\r\n        var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            if (this.isRTL) {\r\n                seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\r\n                seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\r\n            }\r\n            else {\r\n                seg.leftCol = seg.firstRowDayIndex;\r\n                seg.rightCol = seg.lastRowDayIndex;\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Date Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.renderDates = function (dateProfile) {\r\n        this.dateProfile = dateProfile;\r\n        this.updateDayTable();\r\n        this.renderGrid();\r\n    };\r\n    DayGrid.prototype.unrenderDates = function () {\r\n        this.removeSegPopover();\r\n    };\r\n    // Renders the rows and columns into the component's `this.el`, which should already be assigned.\r\n    DayGrid.prototype.renderGrid = function () {\r\n        var view = this.view;\r\n        var rowCnt = this.rowCnt;\r\n        var colCnt = this.colCnt;\r\n        var html = '';\r\n        var row;\r\n        var col;\r\n        if (this.headContainerEl) {\r\n            this.headContainerEl.html(this.renderHeadHtml());\r\n        }\r\n        for (row = 0; row < rowCnt; row++) {\r\n            html += this.renderDayRowHtml(row, this.isRigid);\r\n        }\r\n        this.el.html(html);\r\n        this.rowEls = this.el.find('.fc-row');\r\n        this.cellEls = this.el.find('.fc-day, .fc-disabled-day');\r\n        this.rowCoordCache = new CoordCache_1.default({\r\n            els: this.rowEls,\r\n            isVertical: true\r\n        });\r\n        this.colCoordCache = new CoordCache_1.default({\r\n            els: this.cellEls.slice(0, this.colCnt),\r\n            isHorizontal: true\r\n        });\r\n        // trigger dayRender with each cell's element\r\n        for (row = 0; row < rowCnt; row++) {\r\n            for (col = 0; col < colCnt; col++) {\r\n                this.publiclyTrigger('dayRender', {\r\n                    context: view,\r\n                    args: [\r\n                        this.getCellDate(row, col),\r\n                        this.getCellEl(row, col),\r\n                        view\r\n                    ]\r\n                });\r\n            }\r\n        }\r\n    };\r\n    // Generates the HTML for a single row, which is a div that wraps a table.\r\n    // `row` is the row number.\r\n    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {\r\n        var theme = this.view.calendar.theme;\r\n        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];\r\n        if (isRigid) {\r\n            classes.push('fc-rigid');\r\n        }\r\n        return '' +\r\n            '<div class=\"' + classes.join(' ') + '\">' +\r\n            '<div class=\"fc-bg\">' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            this.renderBgTrHtml(row) +\r\n            '</table>' +\r\n            '</div>' +\r\n            '<div class=\"fc-content-skeleton\">' +\r\n            '<table>' +\r\n            (this.getIsNumbersVisible() ?\r\n                '<thead>' +\r\n                    this.renderNumberTrHtml(row) +\r\n                    '</thead>' :\r\n                '') +\r\n            '</table>' +\r\n            '</div>' +\r\n            '</div>';\r\n    };\r\n    DayGrid.prototype.getIsNumbersVisible = function () {\r\n        return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;\r\n    };\r\n    DayGrid.prototype.getIsDayNumbersVisible = function () {\r\n        return this.rowCnt > 1;\r\n    };\r\n    /* Grid Number Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.renderNumberTrHtml = function (row) {\r\n        return '' +\r\n            '<tr>' +\r\n            (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\r\n            this.renderNumberCellsHtml(row) +\r\n            (this.isRTL ? this.renderNumberIntroHtml(row) : '') +\r\n            '</tr>';\r\n    };\r\n    DayGrid.prototype.renderNumberIntroHtml = function (row) {\r\n        return this.renderIntroHtml();\r\n    };\r\n    DayGrid.prototype.renderNumberCellsHtml = function (row) {\r\n        var htmls = [];\r\n        var col;\r\n        var date;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            date = this.getCellDate(row, col);\r\n            htmls.push(this.renderNumberCellHtml(date));\r\n        }\r\n        return htmls.join('');\r\n    };\r\n    // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\r\n    // The number row will only exist if either day numbers or week numbers are turned on.\r\n    DayGrid.prototype.renderNumberCellHtml = function (date) {\r\n        var view = this.view;\r\n        var html = '';\r\n        var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\r\n        var classes;\r\n        var weekCalcFirstDoW;\r\n        if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {\r\n            // no numbers in day cell (week number must be along the side)\r\n            return '<td/>'; //  will create an empty space above events :(\r\n        }\r\n        classes = this.getDayClasses(date);\r\n        classes.unshift('fc-day-top');\r\n        if (this.cellWeekNumbersVisible) {\r\n            // To determine the day of week number change under ISO, we cannot\r\n            // rely on moment.js methods such as firstDayOfWeek() or weekday(),\r\n            // because they rely on the locale's dow (possibly overridden by\r\n            // our firstDay option), which may not be Monday. We cannot change\r\n            // dow, because that would affect the calendar start day as well.\r\n            if (date._locale._fullCalendar_weekCalc === 'ISO') {\r\n                weekCalcFirstDoW = 1; // Monday by ISO 8601 definition\r\n            }\r\n            else {\r\n                weekCalcFirstDoW = date._locale.firstDayOfWeek();\r\n            }\r\n        }\r\n        html += '<td class=\"' + classes.join(' ') + '\"' +\r\n            (isDateValid ?\r\n                ' data-date=\"' + date.format() + '\"' :\r\n                '') +\r\n            '>';\r\n        if (this.cellWeekNumbersVisible && (date.day() === weekCalcFirstDoW)) {\r\n            html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML\r\n            );\r\n        }\r\n        if (isDayNumberVisible) {\r\n            html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.format('D') // inner HTML\r\n            );\r\n        }\r\n        html += '</td>';\r\n        return html;\r\n    };\r\n    /* Hit System\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.prepareHits = function () {\r\n        this.colCoordCache.build();\r\n        this.rowCoordCache.build();\r\n        this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\r\n    };\r\n    DayGrid.prototype.releaseHits = function () {\r\n        this.colCoordCache.clear();\r\n        this.rowCoordCache.clear();\r\n    };\r\n    DayGrid.prototype.queryHit = function (leftOffset, topOffset) {\r\n        if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\r\n            var col = this.colCoordCache.getHorizontalIndex(leftOffset);\r\n            var row = this.rowCoordCache.getVerticalIndex(topOffset);\r\n            if (row != null && col != null) {\r\n                return this.getCellHit(row, col);\r\n            }\r\n        }\r\n    };\r\n    DayGrid.prototype.getHitFootprint = function (hit) {\r\n        var range = this.getCellRange(hit.row, hit.col);\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?\r\n        );\r\n    };\r\n    DayGrid.prototype.getHitEl = function (hit) {\r\n        return this.getCellEl(hit.row, hit.col);\r\n    };\r\n    /* Cell System\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // FYI: the first column is the leftmost column, regardless of date\r\n    DayGrid.prototype.getCellHit = function (row, col) {\r\n        return {\r\n            row: row,\r\n            col: col,\r\n            component: this,\r\n            left: this.colCoordCache.getLeftOffset(col),\r\n            right: this.colCoordCache.getRightOffset(col),\r\n            top: this.rowCoordCache.getTopOffset(row),\r\n            bottom: this.rowCoordCache.getBottomOffset(row)\r\n        };\r\n    };\r\n    DayGrid.prototype.getCellEl = function (row, col) {\r\n        return this.cellEls.eq(row * this.colCnt + col);\r\n    };\r\n    /* Event Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Unrenders all events currently rendered on the grid\r\n    DayGrid.prototype.executeEventUnrender = function () {\r\n        this.removeSegPopover(); // removes the \"more..\" events popover\r\n        _super.prototype.executeEventUnrender.call(this);\r\n    };\r\n    // Retrieves all rendered segment objects currently rendered on the grid\r\n    DayGrid.prototype.getOwnEventSegs = function () {\r\n        // append the segments from the \"more...\" popover\r\n        return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);\r\n    };\r\n    /* Event Drag Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event or external element being dragged.\r\n    // `eventLocation` has zoned start and end (optional)\r\n    DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            this.renderHighlight(eventFootprints[i].componentFootprint);\r\n        }\r\n        // render drags from OTHER components as helpers\r\n        if (eventFootprints.length && seg && seg.component !== this) {\r\n            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\r\n            return true; // signal helpers rendered\r\n        }\r\n    };\r\n    // Unrenders any visual indication of a hovering event\r\n    DayGrid.prototype.unrenderDrag = function () {\r\n        this.unrenderHighlight();\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* Event Resize Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event being resized\r\n    DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            this.renderHighlight(eventFootprints[i].componentFootprint);\r\n        }\r\n        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\r\n    };\r\n    // Unrenders a visual indication of an event being resized\r\n    DayGrid.prototype.unrenderEventResize = function () {\r\n        this.unrenderHighlight();\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* More+ Link Popover\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.removeSegPopover = function () {\r\n        if (this.segPopover) {\r\n            this.segPopover.hide(); // in handler, will call segPopover's removeElement\r\n        }\r\n    };\r\n    // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\r\n    // `levelLimit` can be false (don't limit), a number, or true (should be computed).\r\n    DayGrid.prototype.limitRows = function (levelLimit) {\r\n        var rowStructs = this.eventRenderer.rowStructs || [];\r\n        var row; // row #\r\n        var rowLevelLimit;\r\n        for (row = 0; row < rowStructs.length; row++) {\r\n            this.unlimitRow(row);\r\n            if (!levelLimit) {\r\n                rowLevelLimit = false;\r\n            }\r\n            else if (typeof levelLimit === 'number') {\r\n                rowLevelLimit = levelLimit;\r\n            }\r\n            else {\r\n                rowLevelLimit = this.computeRowLevelLimit(row);\r\n            }\r\n            if (rowLevelLimit !== false) {\r\n                this.limitRow(row, rowLevelLimit);\r\n            }\r\n        }\r\n    };\r\n    // Computes the number of levels a row will accomodate without going outside its bounds.\r\n    // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\r\n    // `row` is the row number.\r\n    DayGrid.prototype.computeRowLevelLimit = function (row) {\r\n        var rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\r\n        var rowHeight = rowEl.height(); // TODO: cache somehow?\r\n        var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();\r\n        var i;\r\n        var trEl;\r\n        var trHeight;\r\n        function iterInnerHeights(i, childNode) {\r\n            trHeight = Math.max(trHeight, $(childNode).outerHeight());\r\n        }\r\n        // Reveal one level <tr> at a time and stop when we find one out of bounds\r\n        for (i = 0; i < trEls.length; i++) {\r\n            trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\r\n            // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\r\n            // so instead, find the tallest inner content element.\r\n            trHeight = 0;\r\n            trEl.find('> td > :first-child').each(iterInnerHeights);\r\n            if (trEl.position().top + trHeight > rowHeight) {\r\n                return i;\r\n            }\r\n        }\r\n        return false; // should not limit at all\r\n    };\r\n    // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\r\n    // `row` is the row number.\r\n    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\r\n    DayGrid.prototype.limitRow = function (row, levelLimit) {\r\n        var _this = this;\r\n        var rowStruct = this.eventRenderer.rowStructs[row];\r\n        var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\r\n        var col = 0; // col #, left-to-right (not chronologically)\r\n        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\r\n        var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\r\n        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\r\n        var i;\r\n        var seg;\r\n        var segsBelow; // array of segment objects below `seg` in the current `col`\r\n        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\r\n        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\r\n        var td;\r\n        var rowspan;\r\n        var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\r\n        var j;\r\n        var moreTd;\r\n        var moreWrap;\r\n        var moreLink;\r\n        // Iterates through empty level cells and places \"more\" links inside if need be\r\n        var emptyCellsUntil = function (endCol) {\r\n            while (col < endCol) {\r\n                segsBelow = _this.getCellSegs(row, col, levelLimit);\r\n                if (segsBelow.length) {\r\n                    td = cellMatrix[levelLimit - 1][col];\r\n                    moreLink = _this.renderMoreLink(row, col, segsBelow);\r\n                    moreWrap = $('<div/>').append(moreLink);\r\n                    td.append(moreWrap);\r\n                    moreNodes.push(moreWrap[0]);\r\n                }\r\n                col++;\r\n            }\r\n        };\r\n        if (levelLimit && levelLimit < rowStruct.segLevels.length) {\r\n            levelSegs = rowStruct.segLevels[levelLimit - 1];\r\n            cellMatrix = rowStruct.cellMatrix;\r\n            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\r\n                .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\r\n            // iterate though segments in the last allowable level\r\n            for (i = 0; i < levelSegs.length; i++) {\r\n                seg = levelSegs[i];\r\n                emptyCellsUntil(seg.leftCol); // process empty cells before the segment\r\n                // determine *all* segments below `seg` that occupy the same columns\r\n                colSegsBelow = [];\r\n                totalSegsBelow = 0;\r\n                while (col <= seg.rightCol) {\r\n                    segsBelow = this.getCellSegs(row, col, levelLimit);\r\n                    colSegsBelow.push(segsBelow);\r\n                    totalSegsBelow += segsBelow.length;\r\n                    col++;\r\n                }\r\n                if (totalSegsBelow) {\r\n                    td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\r\n                    rowspan = td.attr('rowspan') || 1;\r\n                    segMoreNodes = [];\r\n                    // make a replacement <td> for each column the segment occupies. will be one for each colspan\r\n                    for (j = 0; j < colSegsBelow.length; j++) {\r\n                        moreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\r\n                        segsBelow = colSegsBelow[j];\r\n                        moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\r\n                        );\r\n                        moreWrap = $('<div/>').append(moreLink);\r\n                        moreTd.append(moreWrap);\r\n                        segMoreNodes.push(moreTd[0]);\r\n                        moreNodes.push(moreTd[0]);\r\n                    }\r\n                    td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\r\n                    limitedNodes.push(td[0]);\r\n                }\r\n            }\r\n            emptyCellsUntil(this.colCnt); // finish off the level\r\n            rowStruct.moreEls = $(moreNodes); // for easy undoing later\r\n            rowStruct.limitedEls = $(limitedNodes); // for easy undoing later\r\n        }\r\n    };\r\n    // Reveals all levels and removes all \"more\"-related elements for a grid's row.\r\n    // `row` is a row number.\r\n    DayGrid.prototype.unlimitRow = function (row) {\r\n        var rowStruct = this.eventRenderer.rowStructs[row];\r\n        if (rowStruct.moreEls) {\r\n            rowStruct.moreEls.remove();\r\n            rowStruct.moreEls = null;\r\n        }\r\n        if (rowStruct.limitedEls) {\r\n            rowStruct.limitedEls.removeClass('fc-limited');\r\n            rowStruct.limitedEls = null;\r\n        }\r\n    };\r\n    // Renders an <a> element that represents hidden event element for a cell.\r\n    // Responsible for attaching click handler as well.\r\n    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {\r\n        var _this = this;\r\n        var view = this.view;\r\n        return $('<a class=\"fc-more\"/>')\r\n            .text(this.getMoreLinkText(hiddenSegs.length))\r\n            .on('click', function (ev) {\r\n            var clickOption = _this.opt('eventLimitClick');\r\n            var date = _this.getCellDate(row, col);\r\n            var moreEl = $(ev.currentTarget);\r\n            var dayEl = _this.getCellEl(row, col);\r\n            var allSegs = _this.getCellSegs(row, col);\r\n            // rescope the segments to be within the cell's date\r\n            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\r\n            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\r\n            if (typeof clickOption === 'function') {\r\n                // the returned value can be an atomic option\r\n                clickOption = _this.publiclyTrigger('eventLimitClick', {\r\n                    context: view,\r\n                    args: [\r\n                        {\r\n                            date: date.clone(),\r\n                            dayEl: dayEl,\r\n                            moreEl: moreEl,\r\n                            segs: reslicedAllSegs,\r\n                            hiddenSegs: reslicedHiddenSegs\r\n                        },\r\n                        ev,\r\n                        view\r\n                    ]\r\n                });\r\n            }\r\n            if (clickOption === 'popover') {\r\n                _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\r\n            }\r\n            else if (typeof clickOption === 'string') {\r\n                view.calendar.zoomTo(date, clickOption);\r\n            }\r\n        });\r\n    };\r\n    // Reveals the popover that displays all events within a cell\r\n    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {\r\n        var _this = this;\r\n        var view = this.view;\r\n        var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\r\n        var topEl; // the element we want to match the top coordinate of\r\n        var options;\r\n        if (this.rowCnt === 1) {\r\n            topEl = view.el; // will cause the popover to cover any sort of header\r\n        }\r\n        else {\r\n            topEl = this.rowEls.eq(row); // will align with top of row\r\n        }\r\n        options = {\r\n            className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),\r\n            content: this.renderSegPopoverContent(row, col, segs),\r\n            parentEl: view.el,\r\n            top: topEl.offset().top,\r\n            autoHide: true,\r\n            viewportConstrain: this.opt('popoverViewportConstrain'),\r\n            hide: function () {\r\n                // kill everything when the popover is hidden\r\n                // notify events to be removed\r\n                if (_this.popoverSegs) {\r\n                    _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);\r\n                }\r\n                _this.segPopover.removeElement();\r\n                _this.segPopover = null;\r\n                _this.popoverSegs = null;\r\n            }\r\n        };\r\n        // Determine horizontal coordinate.\r\n        // We use the moreWrap instead of the <td> to avoid border confusion.\r\n        if (this.isRTL) {\r\n            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\r\n        }\r\n        else {\r\n            options.left = moreWrap.offset().left - 1; // -1 to be over cell border\r\n        }\r\n        this.segPopover = new Popover_1.default(options);\r\n        this.segPopover.show();\r\n        // the popover doesn't live within the grid's container element, and thus won't get the event\r\n        // delegated-handlers for free. attach event-related handlers to the popover.\r\n        this.bindAllSegHandlersToEl(this.segPopover.el);\r\n        this.triggerAfterEventSegsRendered(segs);\r\n    };\r\n    // Builds the inner DOM contents of the segment popover\r\n    DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {\r\n        var view = this.view;\r\n        var theme = view.calendar.theme;\r\n        var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));\r\n        var content = $('<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' +\r\n            '<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' +\r\n            '<span class=\"fc-title\">' +\r\n            util_1.htmlEscape(title) +\r\n            '</span>' +\r\n            '<div class=\"fc-clear\"/>' +\r\n            '</div>' +\r\n            '<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' +\r\n            '<div class=\"fc-event-container\"></div>' +\r\n            '</div>');\r\n        var segContainer = content.find('.fc-event-container');\r\n        var i;\r\n        // render each seg's `el` and only return the visible segs\r\n        segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true\r\n        this.popoverSegs = segs;\r\n        for (i = 0; i < segs.length; i++) {\r\n            // because segments in the popover are not part of a grid coordinate system, provide a hint to any\r\n            // grids that want to do drag-n-drop about which cell it came from\r\n            this.hitsNeeded();\r\n            segs[i].hit = this.getCellHit(row, col);\r\n            this.hitsNotNeeded();\r\n            segContainer.append(segs[i].el);\r\n        }\r\n        return content;\r\n    };\r\n    // Given the events within an array of segment objects, reslice them to be in a single day\r\n    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {\r\n        var dayStart = dayDate.clone();\r\n        var dayEnd = dayStart.clone().add(1, 'days');\r\n        var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);\r\n        var newSegs = [];\r\n        var i;\r\n        var seg;\r\n        var slicedRange;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);\r\n            if (slicedRange) {\r\n                newSegs.push($.extend({}, seg, {\r\n                    footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),\r\n                    isStart: seg.isStart && slicedRange.isStart,\r\n                    isEnd: seg.isEnd && slicedRange.isEnd\r\n                }));\r\n            }\r\n        }\r\n        // force an order because eventsToSegs doesn't guarantee one\r\n        // TODO: research if still needed\r\n        this.eventRenderer.sortEventSegs(newSegs);\r\n        return newSegs;\r\n    };\r\n    // Generates the text that should be inside a \"more\" link, given the number of events it represents\r\n    DayGrid.prototype.getMoreLinkText = function (num) {\r\n        var opt = this.opt('eventLimitText');\r\n        if (typeof opt === 'function') {\r\n            return opt(num);\r\n        }\r\n        else {\r\n            return '+' + num + ' ' + opt;\r\n        }\r\n    };\r\n    // Returns segments within a given cell.\r\n    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\r\n    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {\r\n        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\r\n        var level = startLevel || 0;\r\n        var segs = [];\r\n        var seg;\r\n        while (level < segMatrix.length) {\r\n            seg = segMatrix[level][col];\r\n            if (seg) {\r\n                segs.push(seg);\r\n            }\r\n            level++;\r\n        }\r\n        return segs;\r\n    };\r\n    return DayGrid;\r\n}(InteractiveDateComponent_1.default));\r\nexports.default = DayGrid;\r\nDayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;\r\nDayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;\r\nDayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;\r\nDayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;\r\nStandardInteractionsMixin_1.default.mixInto(DayGrid);\r\nDayTableMixin_1.default.mixInto(DayGrid);\r\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Scroller_1 = __webpack_require__(39);\r\nvar View_1 = __webpack_require__(41);\r\nvar BasicViewDateProfileGenerator_1 = __webpack_require__(228);\r\nvar DayGrid_1 = __webpack_require__(61);\r\n/* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\r\n// It is responsible for managing width/height.\r\nvar BasicView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BasicView, _super);\r\n    function BasicView(calendar, viewSpec) {\r\n        var _this = _super.call(this, calendar, viewSpec) || this;\r\n        _this.dayGrid = _this.instantiateDayGrid();\r\n        _this.dayGrid.isRigid = _this.hasRigidRows();\r\n        if (_this.opt('weekNumbers')) {\r\n            if (_this.opt('weekNumbersWithinDays')) {\r\n                _this.dayGrid.cellWeekNumbersVisible = true;\r\n                _this.dayGrid.colWeekNumbersVisible = false;\r\n            }\r\n            else {\r\n                _this.dayGrid.cellWeekNumbersVisible = false;\r\n                _this.dayGrid.colWeekNumbersVisible = true;\r\n            }\r\n        }\r\n        _this.addChild(_this.dayGrid);\r\n        _this.scroller = new Scroller_1.default({\r\n            overflowX: 'hidden',\r\n            overflowY: 'auto'\r\n        });\r\n        return _this;\r\n    }\r\n    // Generates the DayGrid object this view needs. Draws from this.dayGridClass\r\n    BasicView.prototype.instantiateDayGrid = function () {\r\n        // generate a subclass on the fly with BasicView-specific behavior\r\n        // TODO: cache this subclass\r\n        var subclass = makeDayGridSubclass(this.dayGridClass);\r\n        return new subclass(this);\r\n    };\r\n    BasicView.prototype.executeDateRender = function (dateProfile) {\r\n        this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);\r\n        _super.prototype.executeDateRender.call(this, dateProfile);\r\n    };\r\n    BasicView.prototype.renderSkeleton = function () {\r\n        var dayGridContainerEl;\r\n        var dayGridEl;\r\n        this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\r\n        this.scroller.render();\r\n        dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\r\n        dayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\r\n        this.el.find('.fc-body > tr > td').append(dayGridContainerEl);\r\n        this.dayGrid.headContainerEl = this.el.find('.fc-head-container');\r\n        this.dayGrid.setElement(dayGridEl);\r\n    };\r\n    BasicView.prototype.unrenderSkeleton = function () {\r\n        this.dayGrid.removeElement();\r\n        this.scroller.destroy();\r\n    };\r\n    // Builds the HTML skeleton for the view.\r\n    // The day-grid component will render inside of a container defined by this HTML.\r\n    BasicView.prototype.renderSkeletonHtml = function () {\r\n        var theme = this.calendar.theme;\r\n        return '' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            (this.opt('columnHeader') ?\r\n                '<thead class=\"fc-head\">' +\r\n                    '<tr>' +\r\n                    '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\r\n                    '</tr>' +\r\n                    '</thead>' :\r\n                '') +\r\n            '<tbody class=\"fc-body\">' +\r\n            '<tr>' +\r\n            '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' +\r\n            '</tr>' +\r\n            '</tbody>' +\r\n            '</table>';\r\n    };\r\n    // Generates an HTML attribute string for setting the width of the week number column, if it is known\r\n    BasicView.prototype.weekNumberStyleAttr = function () {\r\n        if (this.weekNumberWidth != null) {\r\n            return 'style=\"width:' + this.weekNumberWidth + 'px\"';\r\n        }\r\n        return '';\r\n    };\r\n    // Determines whether each row should have a constant height\r\n    BasicView.prototype.hasRigidRows = function () {\r\n        var eventLimit = this.opt('eventLimit');\r\n        return eventLimit && typeof eventLimit !== 'number';\r\n    };\r\n    /* Dimensions\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Refreshes the horizontal dimensions of the view\r\n    BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        var eventLimit = this.opt('eventLimit');\r\n        var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');\r\n        var scrollerHeight;\r\n        var scrollbarWidths;\r\n        // hack to give the view some height prior to dayGrid's columns being rendered\r\n        // TODO: separate setting height from scroller VS dayGrid.\r\n        if (!this.dayGrid.rowEls) {\r\n            if (!isAuto) {\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            return;\r\n        }\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        if (this.dayGrid.colWeekNumbersVisible) {\r\n            // Make sure all week number cells running down the side have the same width.\r\n            // Record the width for cells created later.\r\n            this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));\r\n        }\r\n        // reset all heights to be natural\r\n        this.scroller.clear();\r\n        util_1.uncompensateScroll(headRowEl);\r\n        this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\r\n        // is the event limit a constant level number?\r\n        if (eventLimit && typeof eventLimit === 'number') {\r\n            this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\r\n        }\r\n        // distribute the height to the rows\r\n        // (totalHeight is a \"recommended\" value if isAuto)\r\n        scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n        this.setGridHeight(scrollerHeight, isAuto);\r\n        // is the event limit dynamically calculated?\r\n        if (eventLimit && typeof eventLimit !== 'number') {\r\n            this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\r\n        }\r\n        if (!isAuto) {\r\n            this.scroller.setHeight(scrollerHeight);\r\n            scrollbarWidths = this.scroller.getScrollbarWidths();\r\n            if (scrollbarWidths.left || scrollbarWidths.right) {\r\n                util_1.compensateScroll(headRowEl, scrollbarWidths);\r\n                // doing the scrollbar compensation might have created text overflow which created more height. redo\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            // guarantees the same scrollbar widths\r\n            this.scroller.lockOverflow(scrollbarWidths);\r\n        }\r\n    };\r\n    // given a desired total height of the view, returns what the height of the scroller should be\r\n    BasicView.prototype.computeScrollerHeight = function (totalHeight) {\r\n        return totalHeight -\r\n            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n    };\r\n    // Sets the height of just the DayGrid component in this view\r\n    BasicView.prototype.setGridHeight = function (height, isAuto) {\r\n        if (isAuto) {\r\n            util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\r\n        }\r\n        else {\r\n            util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\r\n        }\r\n    };\r\n    /* Scroll\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    BasicView.prototype.computeInitialDateScroll = function () {\r\n        return { top: 0 };\r\n    };\r\n    BasicView.prototype.queryDateScroll = function () {\r\n        return { top: this.scroller.getScrollTop() };\r\n    };\r\n    BasicView.prototype.applyDateScroll = function (scroll) {\r\n        if (scroll.top !== undefined) {\r\n            this.scroller.setScrollTop(scroll.top);\r\n        }\r\n    };\r\n    return BasicView;\r\n}(View_1.default));\r\nexports.default = BasicView;\r\nBasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;\r\nBasicView.prototype.dayGridClass = DayGrid_1.default;\r\n// customize the rendering behavior of BasicView's dayGrid\r\nfunction makeDayGridSubclass(SuperClass) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(SubClass, _super);\r\n        function SubClass() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this.colWeekNumbersVisible = false; // display week numbers along the side?\r\n            return _this;\r\n        }\r\n        // Generates the HTML that will go before the day-of week header cells\r\n        SubClass.prototype.renderHeadIntroHtml = function () {\r\n            var view = this.view;\r\n            if (this.colWeekNumbersVisible) {\r\n                return '' +\r\n                    '<th class=\"fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '\" ' + view.weekNumberStyleAttr() + '>' +\r\n                    '<span>' + // needed for matchCellWidths\r\n                    util_1.htmlEscape(this.opt('weekNumberTitle')) +\r\n                    '</span>' +\r\n                    '</th>';\r\n            }\r\n            return '';\r\n        };\r\n        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\r\n        SubClass.prototype.renderNumberIntroHtml = function (row) {\r\n            var view = this.view;\r\n            var weekStart = this.getCellDate(row, 0);\r\n            if (this.colWeekNumbersVisible) {\r\n                return '' +\r\n                    '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' +\r\n                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\r\n                    { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML\r\n                    ) +\r\n                    '</td>';\r\n            }\r\n            return '';\r\n        };\r\n        // Generates the HTML that goes before the day bg cells for each day-row\r\n        SubClass.prototype.renderBgIntroHtml = function () {\r\n            var view = this.view;\r\n            if (this.colWeekNumbersVisible) {\r\n                return '<td class=\"fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '\" ' +\r\n                    view.weekNumberStyleAttr() + '></td>';\r\n            }\r\n            return '';\r\n        };\r\n        // Generates the HTML that goes before every other type of row generated by DayGrid.\r\n        // Affects helper-skeleton and highlight-skeleton rows.\r\n        SubClass.prototype.renderIntroHtml = function () {\r\n            var view = this.view;\r\n            if (this.colWeekNumbersVisible) {\r\n                return '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\r\n            }\r\n            return '';\r\n        };\r\n        SubClass.prototype.getIsNumbersVisible = function () {\r\n            return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;\r\n        };\r\n        return SubClass;\r\n    }(SuperClass));\r\n}\r\n\n\n/***/ }),\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */,\n/* 90 */,\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */,\n/* 114 */,\n/* 115 */,\n/* 116 */,\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */,\n/* 123 */,\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */,\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */,\n/* 143 */,\n/* 144 */,\n/* 145 */,\n/* 146 */,\n/* 147 */,\n/* 148 */,\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */,\n/* 159 */,\n/* 160 */,\n/* 161 */,\n/* 162 */,\n/* 163 */,\n/* 164 */,\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */,\n/* 170 */,\n/* 171 */,\n/* 172 */,\n/* 173 */,\n/* 174 */,\n/* 175 */,\n/* 176 */,\n/* 177 */,\n/* 178 */,\n/* 179 */,\n/* 180 */,\n/* 181 */,\n/* 182 */,\n/* 183 */,\n/* 184 */,\n/* 185 */,\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */,\n/* 192 */,\n/* 193 */,\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar EventDefParser_1 = __webpack_require__(49);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar util_1 = __webpack_require__(35);\r\nvar Constraints = /** @class */ (function () {\r\n    function Constraints(eventManager, _calendar) {\r\n        this.eventManager = eventManager;\r\n        this._calendar = _calendar;\r\n    }\r\n    Constraints.prototype.opt = function (name) {\r\n        return this._calendar.opt(name);\r\n    };\r\n    /*\r\n    determines if eventInstanceGroup is allowed,\r\n    in relation to other EVENTS and business hours.\r\n    */\r\n    Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {\r\n        var eventDef = eventInstanceGroup.getEventDef();\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n        var i;\r\n        var peerEventInstances = this.getPeerEventInstances(eventDef);\r\n        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);\r\n        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\r\n        var constraintVal = eventDef.getConstraint();\r\n        var overlapVal = eventDef.getOverlap();\r\n        var eventAllowFunc = this.opt('eventAllow');\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (eventAllowFunc) {\r\n            for (i = 0; i < eventFootprints.length; i++) {\r\n                if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Constraints.prototype.getPeerEventInstances = function (eventDef) {\r\n        return this.eventManager.getEventInstancesWithoutId(eventDef.id);\r\n    };\r\n    Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {\r\n        var peerEventInstances = this.eventManager.getEventInstances();\r\n        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);\r\n        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\r\n        var selectAllowFunc;\r\n        if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {\r\n            selectAllowFunc = this.opt('selectAllow');\r\n            if (selectAllowFunc) {\r\n                return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional\r\n    ) {\r\n        var constraintFootprints; // ComponentFootprint[]\r\n        var overlapEventFootprints; // EventFootprint[]\r\n        if (constraintVal != null) {\r\n            constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);\r\n            if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {\r\n                return false;\r\n            }\r\n        }\r\n        overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);\r\n        if (overlapVal === false) {\r\n            if (overlapEventFootprints.length) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (typeof overlapVal === 'function') {\r\n            if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (subjectEventInstance) {\r\n            if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    // Constraint\r\n    // ------------------------------------------------------------------------------------------------\r\n    Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {\r\n        var i;\r\n        for (i = 0; i < constraintFootprints.length; i++) {\r\n            if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {\r\n        var eventInstances;\r\n        if (constraintVal === 'businessHours') {\r\n            return this.buildCurrentBusinessFootprints(isAllDay);\r\n        }\r\n        else if (typeof constraintVal === 'object') {\r\n            eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events\r\n            if (!eventInstances) {\r\n                return this.parseFootprints(constraintVal);\r\n            }\r\n            else {\r\n                return this.eventInstancesToFootprints(eventInstances);\r\n            }\r\n        }\r\n        else if (constraintVal != null) {\r\n            eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);\r\n            return this.eventInstancesToFootprints(eventInstances);\r\n        }\r\n    };\r\n    // returns ComponentFootprint[]\r\n    // uses current view's range\r\n    Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {\r\n        var view = this._calendar.view;\r\n        var businessHourGenerator = view.get('businessHourGenerator');\r\n        var unzonedRange = view.dateProfile.activeUnzonedRange;\r\n        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);\r\n        if (eventInstanceGroup) {\r\n            return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n    // conversion util\r\n    Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {\r\n        var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventRanges);\r\n        return eventFootprints.map(util_1.eventFootprintToComponentFootprint);\r\n    };\r\n    // Overlap\r\n    // ------------------------------------------------------------------------------------------------\r\n    Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {\r\n        var overlapEventFootprints = [];\r\n        var i;\r\n        for (i = 0; i < peerEventFootprints.length; i++) {\r\n            if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {\r\n                overlapEventFootprints.push(peerEventFootprints[i]);\r\n            }\r\n        }\r\n        return overlapEventFootprints;\r\n    };\r\n    // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints\r\n    // ------------------------------------------------------------------------------------------------\r\n    // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to\r\n    // constraints whereas the Grid code is related to rendering. Each approach might want to convert\r\n    // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make\r\n    // this more DRY.\r\n    /*\r\n    Returns false on invalid input.\r\n    */\r\n    Constraints.prototype.parseEventDefToInstances = function (eventInput) {\r\n        var eventManager = this.eventManager;\r\n        var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));\r\n        if (!eventDef) {\r\n            return false;\r\n        }\r\n        return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);\r\n    };\r\n    Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {\r\n        var i;\r\n        var eventFootprints = [];\r\n        for (i = 0; i < eventRanges.length; i++) {\r\n            eventFootprints.push.apply(// footprints\r\n            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));\r\n        }\r\n        return eventFootprints;\r\n    };\r\n    Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {\r\n        return [util_1.eventRangeToEventFootprint(eventRange)];\r\n    };\r\n    /*\r\n    Parses footprints directly.\r\n    Very similar to EventDateProfile::parse :(\r\n    */\r\n    Constraints.prototype.parseFootprints = function (rawInput) {\r\n        var start;\r\n        var end;\r\n        if (rawInput.start) {\r\n            start = this._calendar.moment(rawInput.start);\r\n            if (!start.isValid()) {\r\n                start = null;\r\n            }\r\n        }\r\n        if (rawInput.end) {\r\n            end = this._calendar.moment(rawInput.end);\r\n            if (!end.isValid()) {\r\n                end = null;\r\n            }\r\n        }\r\n        return [\r\n            new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay\r\n            )\r\n        ];\r\n    };\r\n    // Footprint Utils\r\n    // ----------------------------------------------------------------------------------------\r\n    Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {\r\n        return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);\r\n    };\r\n    Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {\r\n        return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);\r\n    };\r\n    return Constraints;\r\n}());\r\nexports.default = Constraints;\r\n// optional subjectEventInstance\r\nfunction isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {\r\n    var i;\r\n    for (i = 0; i < overlapEventFootprints.length; i++) {\r\n        if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {\r\n    var subjectLegacyInstance = subjectEventInstance.toLegacy();\r\n    var i;\r\n    var overlapEventInstance;\r\n    var overlapEventDef;\r\n    var overlapVal;\r\n    for (i = 0; i < overlapEventFootprints.length; i++) {\r\n        overlapEventInstance = overlapEventFootprints[i].eventInstance;\r\n        overlapEventDef = overlapEventInstance.def;\r\n        // don't need to pass in calendar, because don't want to consider global eventOverlap property,\r\n        // because we already considered that earlier in the process.\r\n        overlapVal = overlapEventDef.getOverlap();\r\n        if (overlapVal === false) {\r\n            return false;\r\n        }\r\n        else if (typeof overlapVal === 'function') {\r\n            if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\r\nUSAGE:\r\n  import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'\r\nin class:\r\n  applyProps: ParsableModelInterface['applyProps']\r\n  applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']\r\n  applyMiscProps: ParsableModelInterface['applyMiscProps']\r\n  isStandardProp: ParsableModelInterface['isStandardProp']\r\n  static defineStandardProps = ParsableModelMixin.defineStandardProps\r\n  static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps\r\nafter class:\r\n  ParsableModelMixin.mixInto(TheClass)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar ParsableModelMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParsableModelMixin, _super);\r\n    function ParsableModelMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ParsableModelMixin.defineStandardProps = function (propDefs) {\r\n        var proto = this.prototype;\r\n        if (!proto.hasOwnProperty('standardPropMap')) {\r\n            proto.standardPropMap = Object.create(proto.standardPropMap);\r\n        }\r\n        util_1.copyOwnProps(propDefs, proto.standardPropMap);\r\n    };\r\n    ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {\r\n        var map = this.prototype.standardPropMap;\r\n        var propName;\r\n        for (propName in map) {\r\n            if (src[propName] != null && // in the src object?\r\n                map[propName] === true // false means \"copy verbatim\"\r\n            ) {\r\n                dest[propName] = src[propName];\r\n            }\r\n        }\r\n    };\r\n    /*\r\n    Returns true/false for success.\r\n    Meant to be only called ONCE, at object creation.\r\n    */\r\n    ParsableModelMixin.prototype.applyProps = function (rawProps) {\r\n        var standardPropMap = this.standardPropMap;\r\n        var manualProps = {};\r\n        var miscProps = {};\r\n        var propName;\r\n        for (propName in rawProps) {\r\n            if (standardPropMap[propName] === true) {\r\n                this[propName] = rawProps[propName];\r\n            }\r\n            else if (standardPropMap[propName] === false) {\r\n                manualProps[propName] = rawProps[propName];\r\n            }\r\n            else {\r\n                miscProps[propName] = rawProps[propName];\r\n            }\r\n        }\r\n        this.applyMiscProps(miscProps);\r\n        return this.applyManualStandardProps(manualProps);\r\n    };\r\n    /*\r\n    If subclasses override, they must call this supermethod and return the boolean response.\r\n    Meant to be only called ONCE, at object creation.\r\n    */\r\n    ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {\r\n        return true;\r\n    };\r\n    /*\r\n    Can be called even after initial object creation.\r\n    */\r\n    ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {\r\n        // subclasses can implement\r\n    };\r\n    /*\r\n    TODO: why is this a method when defineStandardProps is static\r\n    */\r\n    ParsableModelMixin.prototype.isStandardProp = function (propName) {\r\n        return propName in this.standardPropMap;\r\n    };\r\n    return ParsableModelMixin;\r\n}(Mixin_1.default));\r\nexports.default = ParsableModelMixin;\r\nParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps\r\n\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventInstance = /** @class */ (function () {\r\n    function EventInstance(def, dateProfile) {\r\n        this.def = def;\r\n        this.dateProfile = dateProfile;\r\n    }\r\n    EventInstance.prototype.toLegacy = function () {\r\n        var dateProfile = this.dateProfile;\r\n        var obj = this.def.toLegacy();\r\n        obj.start = dateProfile.start.clone();\r\n        obj.end = dateProfile.end ? dateProfile.end.clone() : null;\r\n        return obj;\r\n    };\r\n    return EventInstance;\r\n}());\r\nexports.default = EventInstance;\r\n\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar EventDef_1 = __webpack_require__(34);\r\nvar EventInstance_1 = __webpack_require__(209);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar RecurringEventDef = /** @class */ (function (_super) {\r\n    tslib_1.__extends(RecurringEventDef, _super);\r\n    function RecurringEventDef() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RecurringEventDef.prototype.isAllDay = function () {\r\n        return !this.startTime && !this.endTime;\r\n    };\r\n    RecurringEventDef.prototype.buildInstances = function (unzonedRange) {\r\n        var calendar = this.source.calendar;\r\n        var unzonedDate = unzonedRange.getStart();\r\n        var unzonedEnd = unzonedRange.getEnd();\r\n        var zonedDayStart;\r\n        var instanceStart;\r\n        var instanceEnd;\r\n        var instances = [];\r\n        while (unzonedDate.isBefore(unzonedEnd)) {\r\n            // if everyday, or this particular day-of-week\r\n            if (!this.dowHash || this.dowHash[unzonedDate.day()]) {\r\n                zonedDayStart = calendar.applyTimezone(unzonedDate);\r\n                instanceStart = zonedDayStart.clone();\r\n                instanceEnd = null;\r\n                if (this.startTime) {\r\n                    instanceStart.time(this.startTime);\r\n                }\r\n                else {\r\n                    instanceStart.stripTime();\r\n                }\r\n                if (this.endTime) {\r\n                    instanceEnd = zonedDayStart.clone().time(this.endTime);\r\n                }\r\n                instances.push(new EventInstance_1.default(this, // definition\r\n                new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));\r\n            }\r\n            unzonedDate.add(1, 'days');\r\n        }\r\n        return instances;\r\n    };\r\n    RecurringEventDef.prototype.setDow = function (dowNumbers) {\r\n        if (!this.dowHash) {\r\n            this.dowHash = {};\r\n        }\r\n        for (var i = 0; i < dowNumbers.length; i++) {\r\n            this.dowHash[dowNumbers[i]] = true;\r\n        }\r\n    };\r\n    RecurringEventDef.prototype.clone = function () {\r\n        var def = _super.prototype.clone.call(this);\r\n        if (def.startTime) {\r\n            def.startTime = moment.duration(this.startTime);\r\n        }\r\n        if (def.endTime) {\r\n            def.endTime = moment.duration(this.endTime);\r\n        }\r\n        if (this.dowHash) {\r\n            def.dowHash = $.extend({}, this.dowHash);\r\n        }\r\n        return def;\r\n    };\r\n    return RecurringEventDef;\r\n}(EventDef_1.default));\r\nexports.default = RecurringEventDef;\r\n/*\r\nHACK to work with TypeScript mixins\r\nNOTE: if super-method fails, should still attempt to apply\r\n*/\r\nRecurringEventDef.prototype.applyProps = function (rawProps) {\r\n    var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);\r\n    if (rawProps.start) {\r\n        this.startTime = moment.duration(rawProps.start);\r\n    }\r\n    if (rawProps.end) {\r\n        this.endTime = moment.duration(rawProps.end);\r\n    }\r\n    if (rawProps.dow) {\r\n        this.setDow(rawProps.dow);\r\n    }\r\n    return superSuccess;\r\n};\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nRecurringEventDef.defineStandardProps({\r\n    start: false,\r\n    end: false,\r\n    dow: false\r\n});\r\n\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventRange = /** @class */ (function () {\r\n    function EventRange(unzonedRange, eventDef, eventInstance) {\r\n        this.unzonedRange = unzonedRange;\r\n        this.eventDef = eventDef;\r\n        if (eventInstance) {\r\n            this.eventInstance = eventInstance;\r\n        }\r\n    }\r\n    return EventRange;\r\n}());\r\nexports.default = EventRange;\r\n\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(35);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar RecurringEventDef_1 = __webpack_require__(210);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar BUSINESS_HOUR_EVENT_DEFAULTS = {\r\n    start: '09:00',\r\n    end: '17:00',\r\n    dow: [1, 2, 3, 4, 5],\r\n    rendering: 'inverse-background'\r\n    // classNames are defined in businessHoursSegClasses\r\n};\r\nvar BusinessHourGenerator = /** @class */ (function () {\r\n    function BusinessHourGenerator(rawComplexDef, calendar) {\r\n        this.rawComplexDef = rawComplexDef;\r\n        this.calendar = calendar;\r\n    }\r\n    BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {\r\n        var eventDefs = this.buildEventDefs(isAllDay);\r\n        var eventInstanceGroup;\r\n        if (eventDefs.length) {\r\n            eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));\r\n            // so that inverse-background rendering can happen even when no eventRanges in view\r\n            eventInstanceGroup.explicitEventDef = eventDefs[0];\r\n            return eventInstanceGroup;\r\n        }\r\n    };\r\n    BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {\r\n        var rawComplexDef = this.rawComplexDef;\r\n        var rawDefs = [];\r\n        var requireDow = false;\r\n        var i;\r\n        var defs = [];\r\n        if (rawComplexDef === true) {\r\n            rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim\r\n        }\r\n        else if ($.isPlainObject(rawComplexDef)) {\r\n            rawDefs = [rawComplexDef];\r\n        }\r\n        else if ($.isArray(rawComplexDef)) {\r\n            rawDefs = rawComplexDef;\r\n            requireDow = true; // every sub-definition NEEDS a day-of-week\r\n        }\r\n        for (i = 0; i < rawDefs.length; i++) {\r\n            if (!requireDow || rawDefs[i].dow) {\r\n                defs.push(this.buildEventDef(isAllDay, rawDefs[i]));\r\n            }\r\n        }\r\n        return defs;\r\n    };\r\n    BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {\r\n        var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);\r\n        if (isAllDay) {\r\n            fullRawDef.start = null;\r\n            fullRawDef.end = null;\r\n        }\r\n        return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source\r\n        );\r\n    };\r\n    return BusinessHourGenerator;\r\n}());\r\nexports.default = BusinessHourGenerator;\r\n\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar StandardTheme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StandardTheme, _super);\r\n    function StandardTheme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return StandardTheme;\r\n}(Theme_1.default));\r\nexports.default = StandardTheme;\r\nStandardTheme.prototype.classes = {\r\n    widget: 'fc-unthemed',\r\n    widgetHeader: 'fc-widget-header',\r\n    widgetContent: 'fc-widget-content',\r\n    buttonGroup: 'fc-button-group',\r\n    button: 'fc-button',\r\n    cornerLeft: 'fc-corner-left',\r\n    cornerRight: 'fc-corner-right',\r\n    stateDefault: 'fc-state-default',\r\n    stateActive: 'fc-state-active',\r\n    stateDisabled: 'fc-state-disabled',\r\n    stateHover: 'fc-state-hover',\r\n    stateDown: 'fc-state-down',\r\n    popoverHeader: 'fc-widget-header',\r\n    popoverContent: 'fc-widget-content',\r\n    // day grid\r\n    headerRow: 'fc-widget-header',\r\n    dayRow: 'fc-widget-content',\r\n    // list view\r\n    listView: 'fc-widget-content'\r\n};\r\nStandardTheme.prototype.baseIconClass = 'fc-icon';\r\nStandardTheme.prototype.iconClasses = {\r\n    close: 'fc-icon-x',\r\n    prev: 'fc-icon-left-single-arrow',\r\n    next: 'fc-icon-right-single-arrow',\r\n    prevYear: 'fc-icon-left-double-arrow',\r\n    nextYear: 'fc-icon-right-double-arrow'\r\n};\r\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons';\r\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\r\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\r\n\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar JqueryUiTheme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JqueryUiTheme, _super);\r\n    function JqueryUiTheme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JqueryUiTheme;\r\n}(Theme_1.default));\r\nexports.default = JqueryUiTheme;\r\nJqueryUiTheme.prototype.classes = {\r\n    widget: 'ui-widget',\r\n    widgetHeader: 'ui-widget-header',\r\n    widgetContent: 'ui-widget-content',\r\n    buttonGroup: 'fc-button-group',\r\n    button: 'ui-button',\r\n    cornerLeft: 'ui-corner-left',\r\n    cornerRight: 'ui-corner-right',\r\n    stateDefault: 'ui-state-default',\r\n    stateActive: 'ui-state-active',\r\n    stateDisabled: 'ui-state-disabled',\r\n    stateHover: 'ui-state-hover',\r\n    stateDown: 'ui-state-down',\r\n    today: 'ui-state-highlight',\r\n    popoverHeader: 'ui-widget-header',\r\n    popoverContent: 'ui-widget-content',\r\n    // day grid\r\n    headerRow: 'ui-widget-header',\r\n    dayRow: 'ui-widget-content',\r\n    // list view\r\n    listView: 'ui-widget-content'\r\n};\r\nJqueryUiTheme.prototype.baseIconClass = 'ui-icon';\r\nJqueryUiTheme.prototype.iconClasses = {\r\n    close: 'ui-icon-closethick',\r\n    prev: 'ui-icon-circle-triangle-w',\r\n    next: 'ui-icon-circle-triangle-e',\r\n    prevYear: 'ui-icon-seek-prev',\r\n    nextYear: 'ui-icon-seek-next'\r\n};\r\nJqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';\r\nJqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';\r\nJqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';\r\n\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar FuncEventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FuncEventSource, _super);\r\n    function FuncEventSource() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FuncEventSource.parse = function (rawInput, calendar) {\r\n        var rawProps;\r\n        // normalize raw input\r\n        if ($.isFunction(rawInput.events)) {\r\n            rawProps = rawInput;\r\n        }\r\n        else if ($.isFunction(rawInput)) {\r\n            rawProps = { events: rawInput };\r\n        }\r\n        if (rawProps) {\r\n            return EventSource_1.default.parse.call(this, rawProps, calendar);\r\n        }\r\n        return false;\r\n    };\r\n    FuncEventSource.prototype.fetch = function (start, end, timezone) {\r\n        var _this = this;\r\n        this.calendar.pushLoading();\r\n        return Promise_1.default.construct(function (onResolve) {\r\n            _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {\r\n                _this.calendar.popLoading();\r\n                onResolve(_this.parseEventDefs(rawEventDefs));\r\n            });\r\n        });\r\n    };\r\n    FuncEventSource.prototype.getPrimitive = function () {\r\n        return this.func;\r\n    };\r\n    FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {\r\n        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\r\n        this.func = rawProps.events;\r\n        return superSuccess;\r\n    };\r\n    return FuncEventSource;\r\n}(EventSource_1.default));\r\nexports.default = FuncEventSource;\r\nFuncEventSource.defineStandardProps({\r\n    events: false // don't automatically transfer\r\n});\r\n\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar JsonFeedEventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsonFeedEventSource, _super);\r\n    function JsonFeedEventSource() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    JsonFeedEventSource.parse = function (rawInput, calendar) {\r\n        var rawProps;\r\n        // normalize raw input\r\n        if (typeof rawInput.url === 'string') {\r\n            rawProps = rawInput;\r\n        }\r\n        else if (typeof rawInput === 'string') {\r\n            rawProps = { url: rawInput };\r\n        }\r\n        if (rawProps) {\r\n            return EventSource_1.default.parse.call(this, rawProps, calendar);\r\n        }\r\n        return false;\r\n    };\r\n    JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {\r\n        var _this = this;\r\n        var ajaxSettings = this.ajaxSettings;\r\n        var onSuccess = ajaxSettings.success;\r\n        var onError = ajaxSettings.error;\r\n        var requestParams = this.buildRequestParams(start, end, timezone);\r\n        // todo: eventually handle the promise's then,\r\n        // don't intercept success/error\r\n        // tho will be a breaking API change\r\n        this.calendar.pushLoading();\r\n        return Promise_1.default.construct(function (onResolve, onReject) {\r\n            $.ajax($.extend({}, // destination\r\n            JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {\r\n                url: _this.url,\r\n                data: requestParams,\r\n                success: function (rawEventDefs, status, xhr) {\r\n                    var callbackRes;\r\n                    _this.calendar.popLoading();\r\n                    if (rawEventDefs) {\r\n                        callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`\r\n                        if ($.isArray(callbackRes)) {\r\n                            rawEventDefs = callbackRes;\r\n                        }\r\n                        onResolve(_this.parseEventDefs(rawEventDefs));\r\n                    }\r\n                    else {\r\n                        onReject();\r\n                    }\r\n                },\r\n                error: function (xhr, statusText, errorThrown) {\r\n                    _this.calendar.popLoading();\r\n                    util_1.applyAll(onError, _this, [xhr, statusText, errorThrown]); // redirect `this`\r\n                    onReject();\r\n                }\r\n            }));\r\n        });\r\n    };\r\n    JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {\r\n        var calendar = this.calendar;\r\n        var ajaxSettings = this.ajaxSettings;\r\n        var startParam;\r\n        var endParam;\r\n        var timezoneParam;\r\n        var customRequestParams;\r\n        var params = {};\r\n        startParam = this.startParam;\r\n        if (startParam == null) {\r\n            startParam = calendar.opt('startParam');\r\n        }\r\n        endParam = this.endParam;\r\n        if (endParam == null) {\r\n            endParam = calendar.opt('endParam');\r\n        }\r\n        timezoneParam = this.timezoneParam;\r\n        if (timezoneParam == null) {\r\n            timezoneParam = calendar.opt('timezoneParam');\r\n        }\r\n        // retrieve any outbound GET/POST $.ajax data from the options\r\n        if ($.isFunction(ajaxSettings.data)) {\r\n            // supplied as a function that returns a key/value object\r\n            customRequestParams = ajaxSettings.data();\r\n        }\r\n        else {\r\n            // probably supplied as a straight key/value object\r\n            customRequestParams = ajaxSettings.data || {};\r\n        }\r\n        $.extend(params, customRequestParams);\r\n        params[startParam] = start.format();\r\n        params[endParam] = end.format();\r\n        if (timezone && timezone !== 'local') {\r\n            params[timezoneParam] = timezone;\r\n        }\r\n        return params;\r\n    };\r\n    JsonFeedEventSource.prototype.getPrimitive = function () {\r\n        return this.url;\r\n    };\r\n    JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {\r\n        this.ajaxSettings = rawProps;\r\n    };\r\n    JsonFeedEventSource.AJAX_DEFAULTS = {\r\n        dataType: 'json',\r\n        cache: false\r\n    };\r\n    return JsonFeedEventSource;\r\n}(EventSource_1.default));\r\nexports.default = JsonFeedEventSource;\r\nJsonFeedEventSource.defineStandardProps({\r\n    // automatically transfer (true)...\r\n    url: true,\r\n    startParam: true,\r\n    endParam: true,\r\n    timezoneParam: true\r\n});\r\n\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar TaskQueue = /** @class */ (function () {\r\n    function TaskQueue() {\r\n        this.q = [];\r\n        this.isPaused = false;\r\n        this.isRunning = false;\r\n    }\r\n    TaskQueue.prototype.queue = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this.q.push.apply(this.q, args); // append\r\n        this.tryStart();\r\n    };\r\n    TaskQueue.prototype.pause = function () {\r\n        this.isPaused = true;\r\n    };\r\n    TaskQueue.prototype.resume = function () {\r\n        this.isPaused = false;\r\n        this.tryStart();\r\n    };\r\n    TaskQueue.prototype.getIsIdle = function () {\r\n        return !this.isRunning && !this.isPaused;\r\n    };\r\n    TaskQueue.prototype.tryStart = function () {\r\n        if (!this.isRunning && this.canRunNext()) {\r\n            this.isRunning = true;\r\n            this.trigger('start');\r\n            this.runRemaining();\r\n        }\r\n    };\r\n    TaskQueue.prototype.canRunNext = function () {\r\n        return !this.isPaused && this.q.length;\r\n    };\r\n    TaskQueue.prototype.runRemaining = function () {\r\n        var _this = this;\r\n        var task;\r\n        var res;\r\n        do {\r\n            task = this.q.shift(); // always freshly reference q. might have been reassigned.\r\n            res = this.runTask(task);\r\n            if (res && res.then) {\r\n                res.then(function () {\r\n                    if (_this.canRunNext()) {\r\n                        _this.runRemaining();\r\n                    }\r\n                });\r\n                return; // prevent marking as stopped\r\n            }\r\n        } while (this.canRunNext());\r\n        this.trigger('stop'); // not really a 'stop' ... more of a 'drained'\r\n        this.isRunning = false;\r\n        // if 'stop' handler added more tasks.... TODO: write test for this\r\n        this.tryStart();\r\n    };\r\n    TaskQueue.prototype.runTask = function (task) {\r\n        return task(); // task *is* the function, but subclasses can change the format of a task\r\n    };\r\n    return TaskQueue;\r\n}());\r\nexports.default = TaskQueue;\r\nEmitterMixin_1.default.mixInto(TaskQueue);\r\n\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar TaskQueue_1 = __webpack_require__(217);\r\nvar RenderQueue = /** @class */ (function (_super) {\r\n    tslib_1.__extends(RenderQueue, _super);\r\n    function RenderQueue(waitsByNamespace) {\r\n        var _this = _super.call(this) || this;\r\n        _this.waitsByNamespace = waitsByNamespace || {};\r\n        return _this;\r\n    }\r\n    RenderQueue.prototype.queue = function (taskFunc, namespace, type) {\r\n        var task = {\r\n            func: taskFunc,\r\n            namespace: namespace,\r\n            type: type\r\n        };\r\n        var waitMs;\r\n        if (namespace) {\r\n            waitMs = this.waitsByNamespace[namespace];\r\n        }\r\n        if (this.waitNamespace) {\r\n            if (namespace === this.waitNamespace && waitMs != null) {\r\n                this.delayWait(waitMs);\r\n            }\r\n            else {\r\n                this.clearWait();\r\n                this.tryStart();\r\n            }\r\n        }\r\n        if (this.compoundTask(task)) {\r\n            if (!this.waitNamespace && waitMs != null) {\r\n                this.startWait(namespace, waitMs);\r\n            }\r\n            else {\r\n                this.tryStart();\r\n            }\r\n        }\r\n    };\r\n    RenderQueue.prototype.startWait = function (namespace, waitMs) {\r\n        this.waitNamespace = namespace;\r\n        this.spawnWait(waitMs);\r\n    };\r\n    RenderQueue.prototype.delayWait = function (waitMs) {\r\n        clearTimeout(this.waitId);\r\n        this.spawnWait(waitMs);\r\n    };\r\n    RenderQueue.prototype.spawnWait = function (waitMs) {\r\n        var _this = this;\r\n        this.waitId = setTimeout(function () {\r\n            _this.waitNamespace = null;\r\n            _this.tryStart();\r\n        }, waitMs);\r\n    };\r\n    RenderQueue.prototype.clearWait = function () {\r\n        if (this.waitNamespace) {\r\n            clearTimeout(this.waitId);\r\n            this.waitId = null;\r\n            this.waitNamespace = null;\r\n        }\r\n    };\r\n    RenderQueue.prototype.canRunNext = function () {\r\n        if (!_super.prototype.canRunNext.call(this)) {\r\n            return false;\r\n        }\r\n        // waiting for a certain namespace to stop receiving tasks?\r\n        if (this.waitNamespace) {\r\n            var q = this.q;\r\n            // if there was a different namespace task in the meantime,\r\n            // that forces all previously-waiting tasks to suddenly execute.\r\n            // TODO: find a way to do this in constant time.\r\n            for (var i = 0; i < q.length; i++) {\r\n                if (q[i].namespace !== this.waitNamespace) {\r\n                    return true; // allow execution\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    RenderQueue.prototype.runTask = function (task) {\r\n        task.func();\r\n    };\r\n    RenderQueue.prototype.compoundTask = function (newTask) {\r\n        var q = this.q;\r\n        var shouldAppend = true;\r\n        var i;\r\n        var task;\r\n        if (newTask.namespace && newTask.type === 'destroy') {\r\n            // remove all init/add/remove ops with same namespace, regardless of order\r\n            for (i = q.length - 1; i >= 0; i--) {\r\n                task = q[i];\r\n                switch (task.type) {\r\n                    case 'init':\r\n                        shouldAppend = false;\r\n                    // the latest destroy is cancelled out by not doing the init\r\n                    /* falls through */\r\n                    case 'add':\r\n                    /* falls through */\r\n                    case 'remove':\r\n                        q.splice(i, 1); // remove task\r\n                }\r\n            }\r\n        }\r\n        if (shouldAppend) {\r\n            q.push(newTask);\r\n        }\r\n        return shouldAppend;\r\n    };\r\n    return RenderQueue;\r\n}(TaskQueue_1.default));\r\nexports.default = RenderQueue;\r\n\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar date_formatting_1 = __webpack_require__(47);\r\nvar Component_1 = __webpack_require__(237);\r\nvar util_2 = __webpack_require__(35);\r\nvar DateComponent = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DateComponent, _super);\r\n    function DateComponent(_view, _options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.isRTL = false; // frequently accessed options\r\n        _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits\r\n        _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?\r\n        _this.isDatesRendered = false;\r\n        // hack to set options prior to the this.opt calls\r\n        if (_view) {\r\n            _this['view'] = _view;\r\n        }\r\n        if (_options) {\r\n            _this['options'] = _options;\r\n        }\r\n        _this.uid = String(DateComponent.guid++);\r\n        _this.childrenByUid = {};\r\n        _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));\r\n        _this.isRTL = _this.opt('isRTL');\r\n        if (_this.fillRendererClass) {\r\n            _this.fillRenderer = new _this.fillRendererClass(_this);\r\n        }\r\n        if (_this.eventRendererClass) {\r\n            _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);\r\n        }\r\n        if (_this.helperRendererClass && _this.eventRenderer) {\r\n            _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);\r\n        }\r\n        if (_this.businessHourRendererClass && _this.fillRenderer) {\r\n            _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);\r\n        }\r\n        return _this;\r\n    }\r\n    DateComponent.prototype.addChild = function (child) {\r\n        if (!this.childrenByUid[child.uid]) {\r\n            this.childrenByUid[child.uid] = child;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    DateComponent.prototype.removeChild = function (child) {\r\n        if (this.childrenByUid[child.uid]) {\r\n            delete this.childrenByUid[child.uid];\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    // TODO: only do if isInDom?\r\n    // TODO: make part of Component, along with children/batch-render system?\r\n    DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        this.callChildren('updateSize', arguments);\r\n    };\r\n    // Options\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.opt = function (name) {\r\n        return this._getView().opt(name); // default implementation\r\n    };\r\n    DateComponent.prototype.publiclyTrigger = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var calendar = this._getCalendar();\r\n        return calendar.publiclyTrigger.apply(calendar, args);\r\n    };\r\n    DateComponent.prototype.hasPublicHandlers = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var calendar = this._getCalendar();\r\n        return calendar.hasPublicHandlers.apply(calendar, args);\r\n    };\r\n    // Date\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.executeDateRender = function (dateProfile) {\r\n        this.dateProfile = dateProfile; // for rendering\r\n        this.renderDates(dateProfile);\r\n        this.isDatesRendered = true;\r\n        this.callChildren('executeDateRender', arguments);\r\n    };\r\n    DateComponent.prototype.executeDateUnrender = function () {\r\n        this.callChildren('executeDateUnrender', arguments);\r\n        this.dateProfile = null;\r\n        this.unrenderDates();\r\n        this.isDatesRendered = false;\r\n    };\r\n    // date-cell content only\r\n    DateComponent.prototype.renderDates = function (dateProfile) {\r\n        // subclasses should implement\r\n    };\r\n    // date-cell content only\r\n    DateComponent.prototype.unrenderDates = function () {\r\n        // subclasses should override\r\n    };\r\n    // Now-Indicator\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\r\n    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.\r\n    DateComponent.prototype.getNowIndicatorUnit = function () {\r\n        // subclasses should implement\r\n    };\r\n    // Renders a current time indicator at the given datetime\r\n    DateComponent.prototype.renderNowIndicator = function (date) {\r\n        this.callChildren('renderNowIndicator', arguments);\r\n    };\r\n    // Undoes the rendering actions from renderNowIndicator\r\n    DateComponent.prototype.unrenderNowIndicator = function () {\r\n        this.callChildren('unrenderNowIndicator', arguments);\r\n    };\r\n    // Business Hours\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {\r\n        if (this.businessHourRenderer) {\r\n            this.businessHourRenderer.render(businessHourGenerator);\r\n        }\r\n        this.callChildren('renderBusinessHours', arguments);\r\n    };\r\n    // Unrenders previously-rendered business-hours\r\n    DateComponent.prototype.unrenderBusinessHours = function () {\r\n        this.callChildren('unrenderBusinessHours', arguments);\r\n        if (this.businessHourRenderer) {\r\n            this.businessHourRenderer.unrender();\r\n        }\r\n    };\r\n    // Event Displaying\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.executeEventRender = function (eventsPayload) {\r\n        if (this.eventRenderer) {\r\n            this.eventRenderer.rangeUpdated(); // poorly named now\r\n            this.eventRenderer.render(eventsPayload);\r\n        }\r\n        else if (this['renderEvents']) {\r\n            this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));\r\n        }\r\n        this.callChildren('executeEventRender', arguments);\r\n    };\r\n    DateComponent.prototype.executeEventUnrender = function () {\r\n        this.callChildren('executeEventUnrender', arguments);\r\n        if (this.eventRenderer) {\r\n            this.eventRenderer.unrender();\r\n        }\r\n        else if (this['destroyEvents']) {\r\n            this['destroyEvents']();\r\n        }\r\n    };\r\n    DateComponent.prototype.getBusinessHourSegs = function () {\r\n        var segs = this.getOwnBusinessHourSegs();\r\n        this.iterChildren(function (child) {\r\n            segs.push.apply(segs, child.getBusinessHourSegs());\r\n        });\r\n        return segs;\r\n    };\r\n    DateComponent.prototype.getOwnBusinessHourSegs = function () {\r\n        if (this.businessHourRenderer) {\r\n            return this.businessHourRenderer.getSegs();\r\n        }\r\n        return [];\r\n    };\r\n    DateComponent.prototype.getEventSegs = function () {\r\n        var segs = this.getOwnEventSegs();\r\n        this.iterChildren(function (child) {\r\n            segs.push.apply(segs, child.getEventSegs());\r\n        });\r\n        return segs;\r\n    };\r\n    DateComponent.prototype.getOwnEventSegs = function () {\r\n        if (this.eventRenderer) {\r\n            return this.eventRenderer.getSegs();\r\n        }\r\n        return [];\r\n    };\r\n    // Event Rendering Triggering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.triggerAfterEventsRendered = function () {\r\n        this.triggerAfterEventSegsRendered(this.getEventSegs());\r\n        this.publiclyTrigger('eventAfterAllRender', {\r\n            context: this,\r\n            args: [this]\r\n        });\r\n    };\r\n    DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {\r\n        var _this = this;\r\n        // an optimization, because getEventLegacy is expensive\r\n        if (this.hasPublicHandlers('eventAfterRender')) {\r\n            segs.forEach(function (seg) {\r\n                var legacy;\r\n                if (seg.el) {\r\n                    legacy = seg.footprint.getEventLegacy();\r\n                    _this.publiclyTrigger('eventAfterRender', {\r\n                        context: legacy,\r\n                        args: [legacy, seg.el, _this]\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    };\r\n    DateComponent.prototype.triggerBeforeEventsDestroyed = function () {\r\n        this.triggerBeforeEventSegsDestroyed(this.getEventSegs());\r\n    };\r\n    DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {\r\n        var _this = this;\r\n        if (this.hasPublicHandlers('eventDestroy')) {\r\n            segs.forEach(function (seg) {\r\n                var legacy;\r\n                if (seg.el) {\r\n                    legacy = seg.footprint.getEventLegacy();\r\n                    _this.publiclyTrigger('eventDestroy', {\r\n                        context: legacy,\r\n                        args: [legacy, seg.el, _this]\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    };\r\n    // Event Rendering Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Hides all rendered event segments linked to the given event\r\n    // RECURSIVE with subcomponents\r\n    DateComponent.prototype.showEventsWithId = function (eventDefId) {\r\n        this.getEventSegs().forEach(function (seg) {\r\n            if (seg.footprint.eventDef.id === eventDefId &&\r\n                seg.el // necessary?\r\n            ) {\r\n                seg.el.css('visibility', '');\r\n            }\r\n        });\r\n        this.callChildren('showEventsWithId', arguments);\r\n    };\r\n    // Shows all rendered event segments linked to the given event\r\n    // RECURSIVE with subcomponents\r\n    DateComponent.prototype.hideEventsWithId = function (eventDefId) {\r\n        this.getEventSegs().forEach(function (seg) {\r\n            if (seg.footprint.eventDef.id === eventDefId &&\r\n                seg.el // necessary?\r\n            ) {\r\n                seg.el.css('visibility', 'hidden');\r\n            }\r\n        });\r\n        this.callChildren('hideEventsWithId', arguments);\r\n    };\r\n    // Drag-n-Drop Rendering (for both events and external elements)\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders a visual indication of a event or external-element drag over the given drop zone.\r\n    // If an external-element, seg will be `null`.\r\n    // Must return elements used for any mock events.\r\n    DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var renderedHelper = false;\r\n        this.iterChildren(function (child) {\r\n            if (child.renderDrag(eventFootprints, seg, isTouch)) {\r\n                renderedHelper = true;\r\n            }\r\n        });\r\n        return renderedHelper;\r\n    };\r\n    // Unrenders a visual indication of an event or external-element being dragged.\r\n    DateComponent.prototype.unrenderDrag = function () {\r\n        this.callChildren('unrenderDrag', arguments);\r\n    };\r\n    // Event Resizing\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders a visual indication of an event being resized.\r\n    DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        this.callChildren('renderEventResize', arguments);\r\n    };\r\n    // Unrenders a visual indication of an event being resized.\r\n    DateComponent.prototype.unrenderEventResize = function () {\r\n        this.callChildren('unrenderEventResize', arguments);\r\n    };\r\n    // Selection\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders a visual indication of the selection\r\n    // TODO: rename to `renderSelection` after legacy is gone\r\n    DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {\r\n        this.renderHighlight(componentFootprint);\r\n        this.callChildren('renderSelectionFootprint', arguments);\r\n    };\r\n    // Unrenders a visual indication of selection\r\n    DateComponent.prototype.unrenderSelection = function () {\r\n        this.unrenderHighlight();\r\n        this.callChildren('unrenderSelection', arguments);\r\n    };\r\n    // Highlight\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\r\n    DateComponent.prototype.renderHighlight = function (componentFootprint) {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.renderFootprint('highlight', componentFootprint, {\r\n                getClasses: function () {\r\n                    return ['fc-highlight'];\r\n                }\r\n            });\r\n        }\r\n        this.callChildren('renderHighlight', arguments);\r\n    };\r\n    // Unrenders the emphasis on a date range\r\n    DateComponent.prototype.unrenderHighlight = function () {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.unrender('highlight');\r\n        }\r\n        this.callChildren('unrenderHighlight', arguments);\r\n    };\r\n    // Hit Areas\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // just because all DateComponents support this interface\r\n    // doesn't mean they need to have their own internal coord system. they can defer to sub-components.\r\n    DateComponent.prototype.hitsNeeded = function () {\r\n        if (!(this.hitsNeededDepth++)) {\r\n            this.prepareHits();\r\n        }\r\n        this.callChildren('hitsNeeded', arguments);\r\n    };\r\n    DateComponent.prototype.hitsNotNeeded = function () {\r\n        if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {\r\n            this.releaseHits();\r\n        }\r\n        this.callChildren('hitsNotNeeded', arguments);\r\n    };\r\n    DateComponent.prototype.prepareHits = function () {\r\n        // subclasses can implement\r\n    };\r\n    DateComponent.prototype.releaseHits = function () {\r\n        // subclasses can implement\r\n    };\r\n    // Given coordinates from the topleft of the document, return data about the date-related area underneath.\r\n    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\r\n    // Must have a `grid` property, a reference to this current grid. TODO: avoid this\r\n    // The returned object will be processed by getHitFootprint and getHitEl.\r\n    DateComponent.prototype.queryHit = function (leftOffset, topOffset) {\r\n        var childrenByUid = this.childrenByUid;\r\n        var uid;\r\n        var hit;\r\n        for (uid in childrenByUid) {\r\n            hit = childrenByUid[uid].queryHit(leftOffset, topOffset);\r\n            if (hit) {\r\n                break;\r\n            }\r\n        }\r\n        return hit;\r\n    };\r\n    DateComponent.prototype.getSafeHitFootprint = function (hit) {\r\n        var footprint = this.getHitFootprint(hit);\r\n        if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {\r\n            return null;\r\n        }\r\n        return footprint;\r\n    };\r\n    DateComponent.prototype.getHitFootprint = function (hit) {\r\n        // what about being abstract!?\r\n    };\r\n    // Given position-level information about a date-related area within the grid,\r\n    // should return a jQuery element that best represents it. passed to dayClick callback.\r\n    DateComponent.prototype.getHitEl = function (hit) {\r\n        // what about being abstract!?\r\n    };\r\n    /* Converting eventRange -> eventFootprint\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {\r\n        var eventFootprints = [];\r\n        var i;\r\n        for (i = 0; i < eventRanges.length; i++) {\r\n            eventFootprints.push.apply(// append\r\n            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));\r\n        }\r\n        return eventFootprints;\r\n    };\r\n    DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {\r\n        return [util_2.eventRangeToEventFootprint(eventRange)];\r\n    };\r\n    /* Converting componentFootprint/eventFootprint -> segs\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {\r\n        var segs = [];\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));\r\n        }\r\n        return segs;\r\n    };\r\n    // Given an event's span (unzoned start/end and other misc data), and the event itself,\r\n    // slices into segments and attaches event-derived properties to them.\r\n    // eventSpan - { start, end, isStart, isEnd, otherthings... }\r\n    DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {\r\n        var unzonedRange = eventFootprint.componentFootprint.unzonedRange;\r\n        var segs;\r\n        var i;\r\n        var seg;\r\n        segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            if (!unzonedRange.isStart) {\r\n                seg.isStart = false;\r\n            }\r\n            if (!unzonedRange.isEnd) {\r\n                seg.isEnd = false;\r\n            }\r\n            seg.footprint = eventFootprint;\r\n            // TODO: rename to seg.eventFootprint\r\n        }\r\n        return segs;\r\n    };\r\n    DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {\r\n        return [];\r\n    };\r\n    // Utils\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.callChildren = function (methodName, args) {\r\n        this.iterChildren(function (child) {\r\n            child[methodName].apply(child, args);\r\n        });\r\n    };\r\n    DateComponent.prototype.iterChildren = function (func) {\r\n        var childrenByUid = this.childrenByUid;\r\n        var uid;\r\n        for (uid in childrenByUid) {\r\n            func(childrenByUid[uid]);\r\n        }\r\n    };\r\n    DateComponent.prototype._getCalendar = function () {\r\n        var t = this;\r\n        return t.calendar || t.view.calendar;\r\n    };\r\n    DateComponent.prototype._getView = function () {\r\n        return this.view;\r\n    };\r\n    DateComponent.prototype._getDateProfile = function () {\r\n        return this._getView().get('dateProfile');\r\n    };\r\n    // Generates HTML for an anchor to another view into the calendar.\r\n    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\r\n    // `gotoOptions` can either be a moment input, or an object with the form:\r\n    // { date, type, forceOff }\r\n    // `type` is a view-type like \"day\" or \"week\". default value is \"day\".\r\n    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\r\n    DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {\r\n        var date;\r\n        var type;\r\n        var forceOff;\r\n        var finalOptions;\r\n        if ($.isPlainObject(gotoOptions)) {\r\n            date = gotoOptions.date;\r\n            type = gotoOptions.type;\r\n            forceOff = gotoOptions.forceOff;\r\n        }\r\n        else {\r\n            date = gotoOptions; // a single moment input\r\n        }\r\n        date = moment_ext_1.default(date); // if a string, parse it\r\n        finalOptions = {\r\n            date: date.format('YYYY-MM-DD'),\r\n            type: type || 'day'\r\n        };\r\n        if (typeof attrs === 'string') {\r\n            innerHtml = attrs;\r\n            attrs = null;\r\n        }\r\n        attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space\r\n        innerHtml = innerHtml || '';\r\n        if (!forceOff && this.opt('navLinks')) {\r\n            return '<a' + attrs +\r\n                ' data-goto=\"' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '\">' +\r\n                innerHtml +\r\n                '</a>';\r\n        }\r\n        else {\r\n            return '<span' + attrs + '>' +\r\n                innerHtml +\r\n                '</span>';\r\n        }\r\n    };\r\n    DateComponent.prototype.getAllDayHtml = function () {\r\n        return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));\r\n    };\r\n    // Computes HTML classNames for a single-day element\r\n    DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {\r\n        var view = this._getView();\r\n        var classes = [];\r\n        var today;\r\n        if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {\r\n            classes.push('fc-disabled-day'); // TODO: jQuery UI theme?\r\n        }\r\n        else {\r\n            classes.push('fc-' + util_1.dayIDs[date.day()]);\r\n            if (view.isDateInOtherMonth(date, this.dateProfile)) {\r\n                classes.push('fc-other-month');\r\n            }\r\n            today = view.calendar.getNow();\r\n            if (date.isSame(today, 'day')) {\r\n                classes.push('fc-today');\r\n                if (noThemeHighlight !== true) {\r\n                    classes.push(view.calendar.theme.getClass('today'));\r\n                }\r\n            }\r\n            else if (date < today) {\r\n                classes.push('fc-past');\r\n            }\r\n            else {\r\n                classes.push('fc-future');\r\n            }\r\n        }\r\n        return classes;\r\n    };\r\n    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\r\n    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\r\n    // The timezones of the dates within `range` will be respected.\r\n    DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {\r\n        var end = range.end;\r\n        if (isAllDay) {\r\n            end = end.clone().subtract(1); // convert to inclusive. last ms of previous day\r\n        }\r\n        return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);\r\n    };\r\n    // Compute the number of the give units in the \"current\" range.\r\n    // Will return a floating-point number. Won't round.\r\n    DateComponent.prototype.currentRangeAs = function (unit) {\r\n        return this._getDateProfile().currentUnzonedRange.as(unit);\r\n    };\r\n    // Returns the date range of the full days the given range visually appears to occupy.\r\n    // Returns a plain object with start/end, NOT an UnzonedRange!\r\n    DateComponent.prototype.computeDayRange = function (unzonedRange) {\r\n        var calendar = this._getCalendar();\r\n        var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts\r\n        var end = calendar.msToUtcMoment(unzonedRange.endMs);\r\n        var endTimeMS = +end.time(); // # of milliseconds into `endDay`\r\n        var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\r\n        // If the end time is actually inclusively part of the next day and is equal to or\r\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\r\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\r\n        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {\r\n            endDay.add(1, 'days');\r\n        }\r\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\r\n        if (endDay <= startDay) {\r\n            endDay = startDay.clone().add(1, 'days');\r\n        }\r\n        return { start: startDay, end: endDay };\r\n    };\r\n    // Does the given range visually appear to occupy more than one day?\r\n    DateComponent.prototype.isMultiDayRange = function (unzonedRange) {\r\n        var dayRange = this.computeDayRange(unzonedRange);\r\n        return dayRange.end.diff(dayRange.start, 'days') > 1;\r\n    };\r\n    DateComponent.guid = 0; // TODO: better system for this?\r\n    return DateComponent;\r\n}(Component_1.default));\r\nexports.default = DateComponent;\r\n// legacy\r\nfunction convertEventsPayloadToLegacyArray(eventsPayload) {\r\n    var eventDefId;\r\n    var eventInstances;\r\n    var legacyEvents = [];\r\n    var i;\r\n    for (eventDefId in eventsPayload) {\r\n        eventInstances = eventsPayload[eventDefId].eventInstances;\r\n        for (i = 0; i < eventInstances.length; i++) {\r\n            legacyEvents.push(eventInstances[i].toLegacy());\r\n        }\r\n    }\r\n    return legacyEvents;\r\n}\r\n\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar options_1 = __webpack_require__(32);\r\nvar Iterator_1 = __webpack_require__(238);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar Toolbar_1 = __webpack_require__(239);\r\nvar OptionsManager_1 = __webpack_require__(240);\r\nvar ViewSpecManager_1 = __webpack_require__(241);\r\nvar Constraints_1 = __webpack_require__(207);\r\nvar locale_1 = __webpack_require__(31);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar EventManager_1 = __webpack_require__(242);\r\nvar BusinessHourGenerator_1 = __webpack_require__(212);\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nvar EventDefParser_1 = __webpack_require__(49);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar ThemeRegistry_1 = __webpack_require__(51);\r\nvar Calendar = /** @class */ (function () {\r\n    function Calendar(el, overrides) {\r\n        this.loadingLevel = 0; // number of simultaneous loading tasks\r\n        this.ignoreUpdateViewSize = 0;\r\n        this.freezeContentHeightDepth = 0;\r\n        // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.\r\n        // unneeded() is called in destroy.\r\n        GlobalEmitter_1.default.needed();\r\n        this.el = el;\r\n        this.viewsByType = {};\r\n        this.optionsManager = new OptionsManager_1.default(this, overrides);\r\n        this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);\r\n        this.initMomentInternals(); // needs to happen after options hash initialized\r\n        this.initCurrentDate();\r\n        this.initEventManager();\r\n        this.constraints = new Constraints_1.default(this.eventManager, this);\r\n        this.constructed();\r\n    }\r\n    Calendar.prototype.constructed = function () {\r\n        // useful for monkeypatching. used?\r\n    };\r\n    Calendar.prototype.getView = function () {\r\n        return this.view;\r\n    };\r\n    Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {\r\n        var optHandler = this.opt(name);\r\n        var context;\r\n        var args;\r\n        if ($.isPlainObject(triggerInfo)) {\r\n            context = triggerInfo.context;\r\n            args = triggerInfo.args;\r\n        }\r\n        else if ($.isArray(triggerInfo)) {\r\n            args = triggerInfo;\r\n        }\r\n        if (context == null) {\r\n            context = this.el[0]; // fallback context\r\n        }\r\n        if (!args) {\r\n            args = [];\r\n        }\r\n        this.triggerWith(name, context, args); // Emitter's method\r\n        if (optHandler) {\r\n            return optHandler.apply(context, args);\r\n        }\r\n    };\r\n    Calendar.prototype.hasPublicHandlers = function (name) {\r\n        return this.hasHandlers(name) ||\r\n            this.opt(name); // handler specified in options\r\n    };\r\n    // Options Public API\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // public getter/setter\r\n    Calendar.prototype.option = function (name, value) {\r\n        var newOptionHash;\r\n        if (typeof name === 'string') {\r\n            if (value === undefined) {\r\n                return this.optionsManager.get(name);\r\n            }\r\n            else {\r\n                newOptionHash = {};\r\n                newOptionHash[name] = value;\r\n                this.optionsManager.add(newOptionHash);\r\n            }\r\n        }\r\n        else if (typeof name === 'object') {\r\n            this.optionsManager.add(name);\r\n        }\r\n    };\r\n    // private getter\r\n    Calendar.prototype.opt = function (name) {\r\n        return this.optionsManager.get(name);\r\n    };\r\n    // View\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Given a view name for a custom view or a standard view, creates a ready-to-go View object\r\n    Calendar.prototype.instantiateView = function (viewType) {\r\n        var spec = this.viewSpecManager.getViewSpec(viewType);\r\n        if (!spec) {\r\n            throw new Error(\"View type \\\"\" + viewType + \"\\\" is not valid\");\r\n        }\r\n        return new spec['class'](this, spec);\r\n    };\r\n    // Returns a boolean about whether the view is okay to instantiate at some point\r\n    Calendar.prototype.isValidViewType = function (viewType) {\r\n        return Boolean(this.viewSpecManager.getViewSpec(viewType));\r\n    };\r\n    Calendar.prototype.changeView = function (viewName, dateOrRange) {\r\n        if (dateOrRange) {\r\n            if (dateOrRange.start && dateOrRange.end) {\r\n                this.optionsManager.recordOverrides({\r\n                    visibleRange: dateOrRange\r\n                });\r\n            }\r\n            else {\r\n                this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate\r\n            }\r\n        }\r\n        this.renderView(viewName);\r\n    };\r\n    // Forces navigation to a view for the given date.\r\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\r\n    Calendar.prototype.zoomTo = function (newDate, viewType) {\r\n        var spec;\r\n        viewType = viewType || 'day'; // day is default zoom\r\n        spec = this.viewSpecManager.getViewSpec(viewType) ||\r\n            this.viewSpecManager.getUnitViewSpec(viewType);\r\n        this.currentDate = newDate.clone();\r\n        this.renderView(spec ? spec.type : null);\r\n    };\r\n    // Current Date\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initCurrentDate = function () {\r\n        var defaultDateInput = this.opt('defaultDate');\r\n        // compute the initial ambig-timezone date\r\n        if (defaultDateInput != null) {\r\n            this.currentDate = this.moment(defaultDateInput).stripZone();\r\n        }\r\n        else {\r\n            this.currentDate = this.getNow(); // getNow already returns unzoned\r\n        }\r\n    };\r\n    Calendar.prototype.prev = function () {\r\n        var view = this.view;\r\n        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));\r\n        if (prevInfo.isValid) {\r\n            this.currentDate = prevInfo.date;\r\n            this.renderView();\r\n        }\r\n    };\r\n    Calendar.prototype.next = function () {\r\n        var view = this.view;\r\n        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));\r\n        if (nextInfo.isValid) {\r\n            this.currentDate = nextInfo.date;\r\n            this.renderView();\r\n        }\r\n    };\r\n    Calendar.prototype.prevYear = function () {\r\n        this.currentDate.add(-1, 'years');\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.nextYear = function () {\r\n        this.currentDate.add(1, 'years');\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.today = function () {\r\n        this.currentDate = this.getNow(); // should deny like prev/next?\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.gotoDate = function (zonedDateInput) {\r\n        this.currentDate = this.moment(zonedDateInput).stripZone();\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.incrementDate = function (delta) {\r\n        this.currentDate.add(moment.duration(delta));\r\n        this.renderView();\r\n    };\r\n    // for external API\r\n    Calendar.prototype.getDate = function () {\r\n        return this.applyTimezone(this.currentDate); // infuse the calendar's timezone\r\n    };\r\n    // Loading Triggering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Should be called when any type of async data fetching begins\r\n    Calendar.prototype.pushLoading = function () {\r\n        if (!(this.loadingLevel++)) {\r\n            this.publiclyTrigger('loading', [true, this.view]);\r\n        }\r\n    };\r\n    // Should be called when any type of async data fetching completes\r\n    Calendar.prototype.popLoading = function () {\r\n        if (!(--this.loadingLevel)) {\r\n            this.publiclyTrigger('loading', [false, this.view]);\r\n        }\r\n    };\r\n    // High-level Rendering\r\n    // -----------------------------------------------------------------------------------\r\n    Calendar.prototype.render = function () {\r\n        if (!this.contentEl) {\r\n            this.initialRender();\r\n        }\r\n        else if (this.elementVisible()) {\r\n            // mainly for the public API\r\n            this.calcSize();\r\n            this.updateViewSize();\r\n        }\r\n    };\r\n    Calendar.prototype.initialRender = function () {\r\n        var _this = this;\r\n        var el = this.el;\r\n        el.addClass('fc');\r\n        // event delegation for nav links\r\n        el.on('click.fc', 'a[data-goto]', function (ev) {\r\n            var anchorEl = $(ev.currentTarget);\r\n            var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\r\n            var date = _this.moment(gotoOptions.date);\r\n            var viewType = gotoOptions.type;\r\n            // property like \"navLinkDayClick\". might be a string or a function\r\n            var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');\r\n            if (typeof customAction === 'function') {\r\n                customAction(date, ev);\r\n            }\r\n            else {\r\n                if (typeof customAction === 'string') {\r\n                    viewType = customAction;\r\n                }\r\n                _this.zoomTo(date, viewType);\r\n            }\r\n        });\r\n        // called immediately, and upon option change\r\n        this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {\r\n            var themeClass = ThemeRegistry_1.getThemeSystemClass(opts.themeSystem || opts.theme);\r\n            var theme = new themeClass(_this.optionsManager);\r\n            var widgetClass = theme.getClass('widget');\r\n            _this.theme = theme;\r\n            if (widgetClass) {\r\n                el.addClass(widgetClass);\r\n            }\r\n        }, function () {\r\n            var widgetClass = _this.theme.getClass('widget');\r\n            _this.theme = null;\r\n            if (widgetClass) {\r\n                el.removeClass(widgetClass);\r\n            }\r\n        });\r\n        this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {\r\n            _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);\r\n            if (_this.view) {\r\n                _this.view.set('businessHourGenerator', _this.businessHourGenerator);\r\n            }\r\n        }, function () {\r\n            _this.businessHourGenerator = null;\r\n        });\r\n        // called immediately, and upon option change.\r\n        // HACK: locale often affects isRTL, so we explicitly listen to that too.\r\n        this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {\r\n            el.toggleClass('fc-ltr', !opts.isRTL);\r\n            el.toggleClass('fc-rtl', opts.isRTL);\r\n        });\r\n        this.contentEl = $(\"<div class='fc-view-container'/>\").prependTo(el);\r\n        this.initToolbars();\r\n        this.renderHeader();\r\n        this.renderFooter();\r\n        this.renderView(this.opt('defaultView'));\r\n        if (this.opt('handleWindowResize')) {\r\n            $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls\r\n            this.windowResize.bind(this), this.opt('windowResizeDelay')));\r\n        }\r\n    };\r\n    Calendar.prototype.destroy = function () {\r\n        if (this.view) {\r\n            this.clearView();\r\n        }\r\n        this.toolbarsManager.proxyCall('removeElement');\r\n        this.contentEl.remove();\r\n        this.el.removeClass('fc fc-ltr fc-rtl');\r\n        // removes theme-related root className\r\n        this.optionsManager.unwatch('settingTheme');\r\n        this.optionsManager.unwatch('settingBusinessHourGenerator');\r\n        this.el.off('.fc'); // unbind nav link handlers\r\n        if (this.windowResizeProxy) {\r\n            $(window).unbind('resize', this.windowResizeProxy);\r\n            this.windowResizeProxy = null;\r\n        }\r\n        GlobalEmitter_1.default.unneeded();\r\n    };\r\n    Calendar.prototype.elementVisible = function () {\r\n        return this.el.is(':visible');\r\n    };\r\n    // Render Queue\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.bindViewHandlers = function (view) {\r\n        var _this = this;\r\n        view.watch('titleForCalendar', ['title'], function (deps) {\r\n            if (view === _this.view) {\r\n                _this.setToolbarsTitle(deps.title);\r\n            }\r\n        });\r\n        view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {\r\n            if (view === _this.view) {\r\n                _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates\r\n                _this.updateToolbarButtons(deps.dateProfile);\r\n            }\r\n        });\r\n    };\r\n    Calendar.prototype.unbindViewHandlers = function (view) {\r\n        view.unwatch('titleForCalendar');\r\n        view.unwatch('dateProfileForCalendar');\r\n    };\r\n    // View Rendering\r\n    // -----------------------------------------------------------------------------------\r\n    // Renders a view because of a date change, view-type change, or for the first time.\r\n    // If not given a viewType, keep the current view but render different dates.\r\n    // Accepts an optional scroll state to restore to.\r\n    Calendar.prototype.renderView = function (viewType) {\r\n        var oldView = this.view;\r\n        var newView;\r\n        this.freezeContentHeight();\r\n        if (oldView && viewType && oldView.type !== viewType) {\r\n            this.clearView();\r\n        }\r\n        // if viewType changed, or the view was never created, create a fresh view\r\n        if (!this.view && viewType) {\r\n            newView = this.view =\r\n                this.viewsByType[viewType] ||\r\n                    (this.viewsByType[viewType] = this.instantiateView(viewType));\r\n            this.bindViewHandlers(newView);\r\n            newView.startBatchRender(); // so that setElement+setDate rendering are joined\r\n            newView.setElement($(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(this.contentEl));\r\n            this.toolbarsManager.proxyCall('activateButton', viewType);\r\n        }\r\n        if (this.view) {\r\n            // prevent unnecessary change firing\r\n            if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {\r\n                this.view.set('businessHourGenerator', this.businessHourGenerator);\r\n            }\r\n            this.view.setDate(this.currentDate);\r\n            if (newView) {\r\n                newView.stopBatchRender();\r\n            }\r\n        }\r\n        this.thawContentHeight();\r\n    };\r\n    // Unrenders the current view and reflects this change in the Header.\r\n    // Unregsiters the `view`, but does not remove from viewByType hash.\r\n    Calendar.prototype.clearView = function () {\r\n        var currentView = this.view;\r\n        this.toolbarsManager.proxyCall('deactivateButton', currentView.type);\r\n        this.unbindViewHandlers(currentView);\r\n        currentView.removeElement();\r\n        currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time\r\n        this.view = null;\r\n    };\r\n    // Destroys the view, including the view object. Then, re-instantiates it and renders it.\r\n    // Maintains the same scroll state.\r\n    // TODO: maintain any other user-manipulated state.\r\n    Calendar.prototype.reinitView = function () {\r\n        var oldView = this.view;\r\n        var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll\r\n        this.freezeContentHeight();\r\n        this.clearView();\r\n        this.calcSize();\r\n        this.renderView(oldView.type); // needs the type to freshly render\r\n        this.view.applyScroll(scroll);\r\n        this.thawContentHeight();\r\n    };\r\n    // Resizing\r\n    // -----------------------------------------------------------------------------------\r\n    Calendar.prototype.getSuggestedViewHeight = function () {\r\n        if (this.suggestedViewHeight == null) {\r\n            this.calcSize();\r\n        }\r\n        return this.suggestedViewHeight;\r\n    };\r\n    Calendar.prototype.isHeightAuto = function () {\r\n        return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';\r\n    };\r\n    Calendar.prototype.updateViewSize = function (isResize) {\r\n        if (isResize === void 0) { isResize = false; }\r\n        var view = this.view;\r\n        var scroll;\r\n        if (!this.ignoreUpdateViewSize && view) {\r\n            if (isResize) {\r\n                this.calcSize();\r\n                scroll = view.queryScroll();\r\n            }\r\n            this.ignoreUpdateViewSize++;\r\n            view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);\r\n            this.ignoreUpdateViewSize--;\r\n            if (isResize) {\r\n                view.applyScroll(scroll);\r\n            }\r\n            return true; // signal success\r\n        }\r\n    };\r\n    Calendar.prototype.calcSize = function () {\r\n        if (this.elementVisible()) {\r\n            this._calcSize();\r\n        }\r\n    };\r\n    Calendar.prototype._calcSize = function () {\r\n        var contentHeightInput = this.opt('contentHeight');\r\n        var heightInput = this.opt('height');\r\n        if (typeof contentHeightInput === 'number') {\r\n            this.suggestedViewHeight = contentHeightInput;\r\n        }\r\n        else if (typeof contentHeightInput === 'function') {\r\n            this.suggestedViewHeight = contentHeightInput();\r\n        }\r\n        else if (typeof heightInput === 'number') {\r\n            this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();\r\n        }\r\n        else if (typeof heightInput === 'function') {\r\n            this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();\r\n        }\r\n        else if (heightInput === 'parent') {\r\n            this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();\r\n        }\r\n        else {\r\n            this.suggestedViewHeight = Math.round(this.contentEl.width() /\r\n                Math.max(this.opt('aspectRatio'), .5));\r\n        }\r\n    };\r\n    Calendar.prototype.windowResize = function (ev) {\r\n        if (\r\n        // the purpose: so we don't process jqui \"resize\" events that have bubbled up\r\n        // cast to any because .target, which is Element, can't be compared to window for some reason.\r\n        ev.target === window &&\r\n            this.view &&\r\n            this.view.isDatesRendered) {\r\n            if (this.updateViewSize(true)) {\r\n                this.publiclyTrigger('windowResize', [this.view]);\r\n            }\r\n        }\r\n    };\r\n    /* Height \"Freezing\"\r\n    -----------------------------------------------------------------------------*/\r\n    Calendar.prototype.freezeContentHeight = function () {\r\n        if (!(this.freezeContentHeightDepth++)) {\r\n            this.forceFreezeContentHeight();\r\n        }\r\n    };\r\n    Calendar.prototype.forceFreezeContentHeight = function () {\r\n        this.contentEl.css({\r\n            width: '100%',\r\n            height: this.contentEl.height(),\r\n            overflow: 'hidden'\r\n        });\r\n    };\r\n    Calendar.prototype.thawContentHeight = function () {\r\n        this.freezeContentHeightDepth--;\r\n        // always bring back to natural height\r\n        this.contentEl.css({\r\n            width: '',\r\n            height: '',\r\n            overflow: ''\r\n        });\r\n        // but if there are future thaws, re-freeze\r\n        if (this.freezeContentHeightDepth) {\r\n            this.forceFreezeContentHeight();\r\n        }\r\n    };\r\n    // Toolbar\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initToolbars = function () {\r\n        this.header = new Toolbar_1.default(this, this.computeHeaderOptions());\r\n        this.footer = new Toolbar_1.default(this, this.computeFooterOptions());\r\n        this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);\r\n    };\r\n    Calendar.prototype.computeHeaderOptions = function () {\r\n        return {\r\n            extraClasses: 'fc-header-toolbar',\r\n            layout: this.opt('header')\r\n        };\r\n    };\r\n    Calendar.prototype.computeFooterOptions = function () {\r\n        return {\r\n            extraClasses: 'fc-footer-toolbar',\r\n            layout: this.opt('footer')\r\n        };\r\n    };\r\n    // can be called repeatedly and Header will rerender\r\n    Calendar.prototype.renderHeader = function () {\r\n        var header = this.header;\r\n        header.setToolbarOptions(this.computeHeaderOptions());\r\n        header.render();\r\n        if (header.el) {\r\n            this.el.prepend(header.el);\r\n        }\r\n    };\r\n    // can be called repeatedly and Footer will rerender\r\n    Calendar.prototype.renderFooter = function () {\r\n        var footer = this.footer;\r\n        footer.setToolbarOptions(this.computeFooterOptions());\r\n        footer.render();\r\n        if (footer.el) {\r\n            this.el.append(footer.el);\r\n        }\r\n    };\r\n    Calendar.prototype.setToolbarsTitle = function (title) {\r\n        this.toolbarsManager.proxyCall('updateTitle', title);\r\n    };\r\n    Calendar.prototype.updateToolbarButtons = function (dateProfile) {\r\n        var now = this.getNow();\r\n        var view = this.view;\r\n        var todayInfo = view.dateProfileGenerator.build(now);\r\n        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));\r\n        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));\r\n        this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?\r\n            'enableButton' :\r\n            'disableButton', 'today');\r\n        this.toolbarsManager.proxyCall(prevInfo.isValid ?\r\n            'enableButton' :\r\n            'disableButton', 'prev');\r\n        this.toolbarsManager.proxyCall(nextInfo.isValid ?\r\n            'enableButton' :\r\n            'disableButton', 'next');\r\n    };\r\n    Calendar.prototype.queryToolbarsHeight = function () {\r\n        return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {\r\n            var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin\r\n            return accumulator + toolbarHeight;\r\n        }, 0);\r\n    };\r\n    // Selection\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // this public method receives start/end dates in any format, with any timezone\r\n    Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {\r\n        this.view.select(this.buildSelectFootprint.apply(this, arguments));\r\n    };\r\n    Calendar.prototype.unselect = function () {\r\n        if (this.view) {\r\n            this.view.unselect();\r\n        }\r\n    };\r\n    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\r\n    Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {\r\n        var start = this.moment(zonedStartInput).stripZone();\r\n        var end;\r\n        if (zonedEndInput) {\r\n            end = this.moment(zonedEndInput).stripZone();\r\n        }\r\n        else if (start.hasTime()) {\r\n            end = start.clone().add(this.defaultTimedEventDuration);\r\n        }\r\n        else {\r\n            end = start.clone().add(this.defaultAllDayEventDuration);\r\n        }\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());\r\n    };\r\n    // Date Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initMomentInternals = function () {\r\n        var _this = this;\r\n        this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));\r\n        this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));\r\n        // Called immediately, and when any of the options change.\r\n        // Happens before any internal objects rebuild or rerender, because this is very core.\r\n        this.optionsManager.watch('buildingMomentLocale', [\r\n            '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',\r\n            '?firstDay', '?weekNumberCalculation'\r\n        ], function (opts) {\r\n            var weekNumberCalculation = opts.weekNumberCalculation;\r\n            var firstDay = opts.firstDay;\r\n            var _week;\r\n            // normalize\r\n            if (weekNumberCalculation === 'iso') {\r\n                weekNumberCalculation = 'ISO'; // normalize\r\n            }\r\n            var localeData = Object.create(// make a cheap copy\r\n            locale_1.getMomentLocaleData(opts.locale) // will fall back to en\r\n            );\r\n            if (opts.monthNames) {\r\n                localeData._months = opts.monthNames;\r\n            }\r\n            if (opts.monthNamesShort) {\r\n                localeData._monthsShort = opts.monthNamesShort;\r\n            }\r\n            if (opts.dayNames) {\r\n                localeData._weekdays = opts.dayNames;\r\n            }\r\n            if (opts.dayNamesShort) {\r\n                localeData._weekdaysShort = opts.dayNamesShort;\r\n            }\r\n            if (firstDay == null && weekNumberCalculation === 'ISO') {\r\n                firstDay = 1;\r\n            }\r\n            if (firstDay != null) {\r\n                _week = Object.create(localeData._week); // _week: { dow: # }\r\n                _week.dow = firstDay;\r\n                localeData._week = _week;\r\n            }\r\n            if (weekNumberCalculation === 'ISO' ||\r\n                weekNumberCalculation === 'local' ||\r\n                typeof weekNumberCalculation === 'function') {\r\n                localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\r\n            }\r\n            _this.localeData = localeData;\r\n            // If the internal current date object already exists, move to new locale.\r\n            // We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\r\n            if (_this.currentDate) {\r\n                _this.localizeMoment(_this.currentDate); // sets to localeData\r\n            }\r\n        });\r\n    };\r\n    // Builds a moment using the settings of the current calendar: timezone and locale.\r\n    // Accepts anything the vanilla moment() constructor accepts.\r\n    Calendar.prototype.moment = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var mom;\r\n        if (this.opt('timezone') === 'local') {\r\n            mom = moment_ext_1.default.apply(null, args);\r\n            // Force the moment to be local, because momentExt doesn't guarantee it.\r\n            if (mom.hasTime()) {\r\n                mom.local();\r\n            }\r\n        }\r\n        else if (this.opt('timezone') === 'UTC') {\r\n            mom = moment_ext_1.default.utc.apply(null, args); // process as UTC\r\n        }\r\n        else {\r\n            mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone\r\n        }\r\n        this.localizeMoment(mom); // TODO\r\n        return mom;\r\n    };\r\n    Calendar.prototype.msToMoment = function (ms, forceAllDay) {\r\n        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC\r\n        if (forceAllDay) {\r\n            mom.stripTime();\r\n        }\r\n        else {\r\n            mom = this.applyTimezone(mom); // may or may not apply locale\r\n        }\r\n        this.localizeMoment(mom);\r\n        return mom;\r\n    };\r\n    Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {\r\n        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC\r\n        if (forceAllDay) {\r\n            mom.stripTime();\r\n        }\r\n        this.localizeMoment(mom);\r\n        return mom;\r\n    };\r\n    // Updates the given moment's locale settings to the current calendar locale settings.\r\n    Calendar.prototype.localizeMoment = function (mom) {\r\n        mom._locale = this.localeData;\r\n    };\r\n    // Returns a boolean about whether or not the calendar knows how to calculate\r\n    // the timezone offset of arbitrary dates in the current timezone.\r\n    Calendar.prototype.getIsAmbigTimezone = function () {\r\n        return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';\r\n    };\r\n    // Returns a copy of the given date in the current timezone. Has no effect on dates without times.\r\n    Calendar.prototype.applyTimezone = function (date) {\r\n        if (!date.hasTime()) {\r\n            return date.clone();\r\n        }\r\n        var zonedDate = this.moment(date.toArray());\r\n        var timeAdjust = date.time().asMilliseconds() - zonedDate.time().asMilliseconds();\r\n        var adjustedZonedDate;\r\n        // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\r\n        if (timeAdjust) {\r\n            adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\r\n            if (date.time().asMilliseconds() - adjustedZonedDate.time().asMilliseconds() === 0) {\r\n                zonedDate = adjustedZonedDate;\r\n            }\r\n        }\r\n        return zonedDate;\r\n    };\r\n    /*\r\n    Assumes the footprint is non-open-ended.\r\n    */\r\n    Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {\r\n        if (ignoreEnd === void 0) { ignoreEnd = false; }\r\n        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);\r\n        var end;\r\n        if (!ignoreEnd) {\r\n            end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);\r\n        }\r\n        if (componentFootprint.isAllDay) {\r\n            start.stripTime();\r\n            if (end) {\r\n                end.stripTime();\r\n            }\r\n        }\r\n        else {\r\n            start = this.applyTimezone(start);\r\n            if (end) {\r\n                end = this.applyTimezone(end);\r\n            }\r\n        }\r\n        return new EventDateProfile_1.default(start, end, this);\r\n    };\r\n    // Returns a moment for the current date, as defined by the client's computer or from the `now` option.\r\n    // Will return an moment with an ambiguous timezone.\r\n    Calendar.prototype.getNow = function () {\r\n        var now = this.opt('now');\r\n        if (typeof now === 'function') {\r\n            now = now();\r\n        }\r\n        return this.moment(now).stripZone();\r\n    };\r\n    // Produces a human-readable string for the given duration.\r\n    // Side-effect: changes the locale of the given duration.\r\n    Calendar.prototype.humanizeDuration = function (duration) {\r\n        return duration.locale(this.opt('locale')).humanize();\r\n    };\r\n    // will return `null` if invalid range\r\n    Calendar.prototype.parseUnzonedRange = function (rangeInput) {\r\n        var start = null;\r\n        var end = null;\r\n        if (rangeInput.start) {\r\n            start = this.moment(rangeInput.start).stripZone();\r\n        }\r\n        if (rangeInput.end) {\r\n            end = this.moment(rangeInput.end).stripZone();\r\n        }\r\n        if (!start && !end) {\r\n            return null;\r\n        }\r\n        if (start && end && end.isBefore(start)) {\r\n            return null;\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    // Event-Date Utilities\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initEventManager = function () {\r\n        var _this = this;\r\n        var eventManager = new EventManager_1.default(this);\r\n        var rawSources = this.opt('eventSources') || [];\r\n        var singleRawSource = this.opt('events');\r\n        this.eventManager = eventManager;\r\n        if (singleRawSource) {\r\n            rawSources.unshift(singleRawSource);\r\n        }\r\n        eventManager.on('release', function (eventsPayload) {\r\n            _this.trigger('eventsReset', eventsPayload);\r\n        });\r\n        eventManager.freeze();\r\n        rawSources.forEach(function (rawSource) {\r\n            var source = EventSourceParser_1.default.parse(rawSource, _this);\r\n            if (source) {\r\n                eventManager.addSource(source);\r\n            }\r\n        });\r\n        eventManager.thaw();\r\n    };\r\n    Calendar.prototype.requestEvents = function (start, end) {\r\n        return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));\r\n    };\r\n    // Get an event's normalized end date. If not present, calculate it from the defaults.\r\n    Calendar.prototype.getEventEnd = function (event) {\r\n        if (event.end) {\r\n            return event.end.clone();\r\n        }\r\n        else {\r\n            return this.getDefaultEventEnd(event.allDay, event.start);\r\n        }\r\n    };\r\n    // Given an event's allDay status and start date, return what its fallback end date should be.\r\n    // TODO: rename to computeDefaultEventEnd\r\n    Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {\r\n        var end = zonedStart.clone();\r\n        if (allDay) {\r\n            end.stripTime().add(this.defaultAllDayEventDuration);\r\n        }\r\n        else {\r\n            end.add(this.defaultTimedEventDuration);\r\n        }\r\n        if (this.getIsAmbigTimezone()) {\r\n            end.stripZone(); // we don't know what the tzo should be\r\n        }\r\n        return end;\r\n    };\r\n    // Public Events API\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.rerenderEvents = function () {\r\n        this.view.flash('displayingEvents');\r\n    };\r\n    Calendar.prototype.refetchEvents = function () {\r\n        this.eventManager.refetchAllSources();\r\n    };\r\n    Calendar.prototype.renderEvents = function (eventInputs, isSticky) {\r\n        this.eventManager.freeze();\r\n        for (var i = 0; i < eventInputs.length; i++) {\r\n            this.renderEvent(eventInputs[i], isSticky);\r\n        }\r\n        this.eventManager.thaw();\r\n    };\r\n    Calendar.prototype.renderEvent = function (eventInput, isSticky) {\r\n        if (isSticky === void 0) { isSticky = false; }\r\n        var eventManager = this.eventManager;\r\n        var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);\r\n        if (eventDef) {\r\n            eventManager.addEventDef(eventDef, isSticky);\r\n        }\r\n    };\r\n    // legacyQuery operates on legacy event instance objects\r\n    Calendar.prototype.removeEvents = function (legacyQuery) {\r\n        var eventManager = this.eventManager;\r\n        var legacyInstances = [];\r\n        var idMap = {};\r\n        var eventDef;\r\n        var i;\r\n        if (legacyQuery == null) {\r\n            eventManager.removeAllEventDefs(); // persist=true\r\n        }\r\n        else {\r\n            eventManager.getEventInstances().forEach(function (eventInstance) {\r\n                legacyInstances.push(eventInstance.toLegacy());\r\n            });\r\n            legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);\r\n            // compute unique IDs\r\n            for (i = 0; i < legacyInstances.length; i++) {\r\n                eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);\r\n                idMap[eventDef.id] = true;\r\n            }\r\n            eventManager.freeze();\r\n            for (i in idMap) {\r\n                eventManager.removeEventDefsById(i); // persist=true\r\n            }\r\n            eventManager.thaw();\r\n        }\r\n    };\r\n    // legacyQuery operates on legacy event instance objects\r\n    Calendar.prototype.clientEvents = function (legacyQuery) {\r\n        var legacyEventInstances = [];\r\n        this.eventManager.getEventInstances().forEach(function (eventInstance) {\r\n            legacyEventInstances.push(eventInstance.toLegacy());\r\n        });\r\n        return filterLegacyEventInstances(legacyEventInstances, legacyQuery);\r\n    };\r\n    Calendar.prototype.updateEvents = function (eventPropsArray) {\r\n        this.eventManager.freeze();\r\n        for (var i = 0; i < eventPropsArray.length; i++) {\r\n            this.updateEvent(eventPropsArray[i]);\r\n        }\r\n        this.eventManager.thaw();\r\n    };\r\n    Calendar.prototype.updateEvent = function (eventProps) {\r\n        var eventDef = this.eventManager.getEventDefByUid(eventProps._id);\r\n        var eventInstance;\r\n        var eventDefMutation;\r\n        if (eventDef instanceof SingleEventDef_1.default) {\r\n            eventInstance = eventDef.buildInstance();\r\n            eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props\r\n            null // largeUnit -- who uses it?\r\n            );\r\n            this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release\r\n        }\r\n    };\r\n    // Public Event Sources API\r\n    // ------------------------------------------------------------------------------------\r\n    Calendar.prototype.getEventSources = function () {\r\n        return this.eventManager.otherSources.slice(); // clone\r\n    };\r\n    Calendar.prototype.getEventSourceById = function (id) {\r\n        return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));\r\n    };\r\n    Calendar.prototype.addEventSource = function (sourceInput) {\r\n        var source = EventSourceParser_1.default.parse(sourceInput, this);\r\n        if (source) {\r\n            this.eventManager.addSource(source);\r\n        }\r\n    };\r\n    Calendar.prototype.removeEventSources = function (sourceMultiQuery) {\r\n        var eventManager = this.eventManager;\r\n        var sources;\r\n        var i;\r\n        if (sourceMultiQuery == null) {\r\n            this.eventManager.removeAllSources();\r\n        }\r\n        else {\r\n            sources = eventManager.multiQuerySources(sourceMultiQuery);\r\n            eventManager.freeze();\r\n            for (i = 0; i < sources.length; i++) {\r\n                eventManager.removeSource(sources[i]);\r\n            }\r\n            eventManager.thaw();\r\n        }\r\n    };\r\n    Calendar.prototype.removeEventSource = function (sourceQuery) {\r\n        var eventManager = this.eventManager;\r\n        var sources = eventManager.querySources(sourceQuery);\r\n        var i;\r\n        eventManager.freeze();\r\n        for (i = 0; i < sources.length; i++) {\r\n            eventManager.removeSource(sources[i]);\r\n        }\r\n        eventManager.thaw();\r\n    };\r\n    Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {\r\n        var eventManager = this.eventManager;\r\n        var sources = eventManager.multiQuerySources(sourceMultiQuery);\r\n        var i;\r\n        eventManager.freeze();\r\n        for (i = 0; i < sources.length; i++) {\r\n            eventManager.refetchSource(sources[i]);\r\n        }\r\n        eventManager.thaw();\r\n    };\r\n    // not for internal use. use options module directly instead.\r\n    Calendar.defaults = options_1.globalDefaults;\r\n    Calendar.englishDefaults = options_1.englishDefaults;\r\n    Calendar.rtlDefaults = options_1.rtlDefaults;\r\n    return Calendar;\r\n}());\r\nexports.default = Calendar;\r\nEmitterMixin_1.default.mixInto(Calendar);\r\nListenerMixin_1.default.mixInto(Calendar);\r\nfunction filterLegacyEventInstances(legacyEventInstances, legacyQuery) {\r\n    if (legacyQuery == null) {\r\n        return legacyEventInstances;\r\n    }\r\n    else if ($.isFunction(legacyQuery)) {\r\n        return legacyEventInstances.filter(legacyQuery);\r\n    }\r\n    else {\r\n        legacyQuery += ''; // normalize to string\r\n        return legacyEventInstances.filter(function (legacyEventInstance) {\r\n            // soft comparison because id not be normalized to string\r\n            // tslint:disable-next-line\r\n            return legacyEventInstance.id == legacyQuery ||\r\n                legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match\r\n        });\r\n    }\r\n}\r\n\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar DateProfileGenerator = /** @class */ (function () {\r\n    function DateProfileGenerator(_view) {\r\n        this._view = _view;\r\n    }\r\n    DateProfileGenerator.prototype.opt = function (name) {\r\n        return this._view.opt(name);\r\n    };\r\n    DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {\r\n        return this._view.trimHiddenDays(unzonedRange);\r\n    };\r\n    DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {\r\n        return this._view.calendar.msToUtcMoment(ms, forceAllDay);\r\n    };\r\n    /* Date Range Computation\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\r\n    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {\r\n        var prevDate = currentDateProfile.date.clone()\r\n            .startOf(currentDateProfile.currentRangeUnit)\r\n            .subtract(currentDateProfile.dateIncrement);\r\n        return this.build(prevDate, -1);\r\n    };\r\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\r\n    DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {\r\n        var nextDate = currentDateProfile.date.clone()\r\n            .startOf(currentDateProfile.currentRangeUnit)\r\n            .add(currentDateProfile.dateIncrement);\r\n        return this.build(nextDate, 1);\r\n    };\r\n    // Builds a structure holding dates/ranges for rendering around the given date.\r\n    // Optional direction param indicates whether the date is being incremented/decremented\r\n    // from its previous value. decremented = -1, incremented = 1 (default).\r\n    DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {\r\n        if (forceToValid === void 0) { forceToValid = false; }\r\n        var isDateAllDay = !date.hasTime();\r\n        var validUnzonedRange;\r\n        var minTime = null;\r\n        var maxTime = null;\r\n        var currentInfo;\r\n        var isRangeAllDay;\r\n        var renderUnzonedRange;\r\n        var activeUnzonedRange;\r\n        var isValid;\r\n        validUnzonedRange = this.buildValidRange();\r\n        validUnzonedRange = this.trimHiddenDays(validUnzonedRange);\r\n        if (forceToValid) {\r\n            date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS\r\n            isDateAllDay);\r\n        }\r\n        currentInfo = this.buildCurrentRangeInfo(date, direction);\r\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\r\n        renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);\r\n        renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);\r\n        activeUnzonedRange = renderUnzonedRange.clone();\r\n        if (!this.opt('showNonCurrentDates')) {\r\n            activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);\r\n        }\r\n        minTime = moment.duration(this.opt('minTime'));\r\n        maxTime = moment.duration(this.opt('maxTime'));\r\n        activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);\r\n        activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null\r\n        if (activeUnzonedRange) {\r\n            date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS\r\n            isDateAllDay);\r\n        }\r\n        // it's invalid if the originally requested date is not contained,\r\n        // or if the range is completely outside of the valid range.\r\n        isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);\r\n        return {\r\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\r\n            // an object with optional start and end properties.\r\n            validUnzonedRange: validUnzonedRange,\r\n            // range the view is formally responsible for.\r\n            // for example, a month view might have 1st-31st, excluding padded dates\r\n            currentUnzonedRange: currentInfo.unzonedRange,\r\n            // name of largest unit being displayed, like \"month\" or \"week\"\r\n            currentRangeUnit: currentInfo.unit,\r\n            isRangeAllDay: isRangeAllDay,\r\n            // dates that display events and accept drag-n-drop\r\n            // will be `null` if no dates accept events\r\n            activeUnzonedRange: activeUnzonedRange,\r\n            // date range with a rendered skeleton\r\n            // includes not-active days that need some sort of DOM\r\n            renderUnzonedRange: renderUnzonedRange,\r\n            // Duration object that denotes the first visible time of any given day\r\n            minTime: minTime,\r\n            // Duration object that denotes the exclusive visible end time of any given day\r\n            maxTime: maxTime,\r\n            isValid: isValid,\r\n            date: date,\r\n            // how far the current date will move for a prev/next operation\r\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\r\n            // pass a fallback (might be null) ^\r\n        };\r\n    };\r\n    // Builds an object with optional start/end properties.\r\n    // Indicates the minimum/maximum dates to display.\r\n    // not responsible for trimming hidden days.\r\n    DateProfileGenerator.prototype.buildValidRange = function () {\r\n        return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||\r\n            new UnzonedRange_1.default(); // completely open-ended\r\n    };\r\n    // Builds a structure with info about the \"current\" range, the range that is\r\n    // highlighted as being the current month for example.\r\n    // See build() for a description of `direction`.\r\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\r\n        var viewSpec = this._view.viewSpec;\r\n        var duration = null;\r\n        var unit = null;\r\n        var unzonedRange = null;\r\n        var dayCount;\r\n        if (viewSpec.duration) {\r\n            duration = viewSpec.duration;\r\n            unit = viewSpec.durationUnit;\r\n            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\r\n        }\r\n        else if ((dayCount = this.opt('dayCount'))) {\r\n            unit = 'day';\r\n            unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);\r\n        }\r\n        else if ((unzonedRange = this.buildCustomVisibleRange(date))) {\r\n            unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());\r\n        }\r\n        else {\r\n            duration = this.getFallbackDuration();\r\n            unit = util_1.computeGreatestUnit(duration);\r\n            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\r\n        }\r\n        return { duration: duration, unit: unit, unzonedRange: unzonedRange };\r\n    };\r\n    DateProfileGenerator.prototype.getFallbackDuration = function () {\r\n        return moment.duration({ days: 1 });\r\n    };\r\n    // Returns a new activeUnzonedRange to have time values (un-ambiguate)\r\n    // minTime or maxTime causes the range to expand.\r\n    DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {\r\n        var start = unzonedRange.getStart();\r\n        var end = unzonedRange.getEnd();\r\n        if (this._view.usesMinMaxTime) {\r\n            if (minTime < 0) {\r\n                start.time(0).add(minTime);\r\n            }\r\n            if (maxTime > 24 * 60 * 60 * 1000) {\r\n                end.time(maxTime - (24 * 60 * 60 * 1000));\r\n            }\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    // Builds the \"current\" range when it is specified as an explicit duration.\r\n    // `unit` is the already-computed computeGreatestUnit value of duration.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\r\n        var alignment = this.opt('dateAlignment');\r\n        var dateIncrementInput;\r\n        var dateIncrementDuration;\r\n        var start;\r\n        var end;\r\n        var res;\r\n        // compute what the alignment should be\r\n        if (!alignment) {\r\n            dateIncrementInput = this.opt('dateIncrement');\r\n            if (dateIncrementInput) {\r\n                dateIncrementDuration = moment.duration(dateIncrementInput);\r\n                // use the smaller of the two units\r\n                if (dateIncrementDuration < duration) {\r\n                    alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);\r\n                }\r\n                else {\r\n                    alignment = unit;\r\n                }\r\n            }\r\n            else {\r\n                alignment = unit;\r\n            }\r\n        }\r\n        // if the view displays a single day or smaller\r\n        if (duration.as('days') <= 1) {\r\n            if (this._view.isHiddenDay(start)) {\r\n                start = this._view.skipHiddenDays(start, direction);\r\n                start.startOf('day');\r\n            }\r\n        }\r\n        function computeRes() {\r\n            start = date.clone().startOf(alignment);\r\n            end = start.clone().add(duration);\r\n            res = new UnzonedRange_1.default(start, end);\r\n        }\r\n        computeRes();\r\n        // if range is completely enveloped by hidden days, go past the hidden days\r\n        if (!this.trimHiddenDays(res)) {\r\n            date = this._view.skipHiddenDays(date, direction);\r\n            computeRes();\r\n        }\r\n        return res;\r\n    };\r\n    // Builds the \"current\" range when a dayCount is specified.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\r\n        var customAlignment = this.opt('dateAlignment');\r\n        var runningCount = 0;\r\n        var start = date.clone();\r\n        var end;\r\n        if (customAlignment) {\r\n            start.startOf(customAlignment);\r\n        }\r\n        start.startOf('day');\r\n        start = this._view.skipHiddenDays(start, direction);\r\n        end = start.clone();\r\n        do {\r\n            end.add(1, 'day');\r\n            if (!this._view.isHiddenDay(end)) {\r\n                runningCount++;\r\n            }\r\n        } while (runningCount < dayCount);\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    // Builds a normalized range object for the \"visible\" range,\r\n    // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\r\n        var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations\r\n        );\r\n        if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {\r\n            return null;\r\n        }\r\n        return visibleUnzonedRange;\r\n    };\r\n    // Computes the range that will represent the element/cells for *rendering*,\r\n    // but which may have voided days/times.\r\n    // not responsible for trimming hidden days.\r\n    DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n        return currentUnzonedRange.clone();\r\n    };\r\n    // Compute the duration value that should be added/substracted to the current date\r\n    // when a prev/next operation happens.\r\n    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\r\n        var dateIncrementInput = this.opt('dateIncrement');\r\n        var customAlignment;\r\n        if (dateIncrementInput) {\r\n            return moment.duration(dateIncrementInput);\r\n        }\r\n        else if ((customAlignment = this.opt('dateAlignment'))) {\r\n            return moment.duration(1, customAlignment);\r\n        }\r\n        else if (fallback) {\r\n            return fallback;\r\n        }\r\n        else {\r\n            return moment.duration({ days: 1 });\r\n        }\r\n    };\r\n    return DateProfileGenerator;\r\n}());\r\nexports.default = DateProfileGenerator;\r\n\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar exportHooks = __webpack_require__(16);\r\nvar util_1 = __webpack_require__(4);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar ExternalDropping = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExternalDropping, _super);\r\n    function ExternalDropping() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.isDragging = false; // jqui-dragging an external element? boolean\r\n        return _this;\r\n    }\r\n    /*\r\n    component impements:\r\n      - eventRangesToEventFootprints\r\n      - isEventInstanceGroupAllowed\r\n      - isExternalInstanceGroupAllowed\r\n      - renderDrag\r\n      - unrenderDrag\r\n    */\r\n    ExternalDropping.prototype.end = function () {\r\n        if (this.dragListener) {\r\n            this.dragListener.endInteraction();\r\n        }\r\n    };\r\n    ExternalDropping.prototype.bindToDocument = function () {\r\n        this.listenTo($(document), {\r\n            dragstart: this.handleDragStart,\r\n            sortstart: this.handleDragStart // jqui\r\n        });\r\n    };\r\n    ExternalDropping.prototype.unbindFromDocument = function () {\r\n        this.stopListeningTo($(document));\r\n    };\r\n    // Called when a jQuery UI drag is initiated anywhere in the DOM\r\n    ExternalDropping.prototype.handleDragStart = function (ev, ui) {\r\n        var el;\r\n        var accept;\r\n        if (this.opt('droppable')) {\r\n            el = $((ui ? ui.item : null) || ev.target);\r\n            // Test that the dragged element passes the dropAccept selector or filter function.\r\n            // FYI, the default is \"*\" (matches all)\r\n            accept = this.opt('dropAccept');\r\n            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\r\n                if (!this.isDragging) {\r\n                    this.listenToExternalDrag(el, ev, ui);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Called when a jQuery UI drag starts and it needs to be monitored for dropping\r\n    ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var view = this.view;\r\n        var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\r\n        var singleEventDef; // a null value signals an unsuccessful drag\r\n        // listener that tracks mouse movement over date-associated pixel regions\r\n        var dragListener = this.dragListener = new HitDragListener_1.default(component, {\r\n            interactionStart: function () {\r\n                _this.isDragging = true;\r\n            },\r\n            hitOver: function (hit) {\r\n                var isAllowed = true;\r\n                var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid\r\n                var mutatedEventInstanceGroup;\r\n                if (hitFootprint) {\r\n                    singleEventDef = _this.computeExternalDrop(hitFootprint, meta);\r\n                    if (singleEventDef) {\r\n                        mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());\r\n                        isAllowed = meta.eventProps ? // isEvent?\r\n                            component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :\r\n                            component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n                    }\r\n                    else {\r\n                        isAllowed = false;\r\n                    }\r\n                }\r\n                else {\r\n                    isAllowed = false;\r\n                }\r\n                if (!isAllowed) {\r\n                    singleEventDef = null;\r\n                    util_1.disableCursor();\r\n                }\r\n                if (singleEventDef) {\r\n                    component.renderDrag(// called without a seg parameter\r\n                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                singleEventDef = null; // signal unsuccessful\r\n            },\r\n            hitDone: function () {\r\n                util_1.enableCursor();\r\n                component.unrenderDrag();\r\n            },\r\n            interactionEnd: function (ev) {\r\n                if (singleEventDef) {\r\n                    view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent\r\n                    Boolean(meta.stick), // isSticky\r\n                    el, ev, ui);\r\n                }\r\n                _this.isDragging = false;\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        dragListener.startDrag(ev); // start listening immediately\r\n    };\r\n    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\r\n    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\r\n    // Returning a null value signals an invalid drop hit.\r\n    // DOES NOT consider overlap/constraint.\r\n    // Assumes both footprints are non-open-ended.\r\n    ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {\r\n        var calendar = this.view.calendar;\r\n        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();\r\n        var end;\r\n        var eventDef;\r\n        if (componentFootprint.isAllDay) {\r\n            // if dropped on an all-day span, and element's metadata specified a time, set it\r\n            if (meta.startTime) {\r\n                start.time(meta.startTime);\r\n            }\r\n            else {\r\n                start.stripTime();\r\n            }\r\n        }\r\n        if (meta.duration) {\r\n            end = start.clone().add(meta.duration);\r\n        }\r\n        start = calendar.applyTimezone(start);\r\n        if (end) {\r\n            end = calendar.applyTimezone(end);\r\n        }\r\n        eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {\r\n            start: start,\r\n            end: end\r\n        }), new EventSource_1.default(calendar));\r\n        return eventDef;\r\n    };\r\n    return ExternalDropping;\r\n}(Interaction_1.default));\r\nexports.default = ExternalDropping;\r\nListenerMixin_1.default.mixInto(ExternalDropping);\r\n/* External-Dragging-Element Data\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\r\n// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\r\nexportHooks.dataAttrPrefix = '';\r\n// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\r\n// to be used for Event Object creation.\r\n// A defined `.eventProps`, even when empty, indicates that an event should be created.\r\nfunction getDraggedElMeta(el) {\r\n    var prefix = exportHooks.dataAttrPrefix;\r\n    var eventProps; // properties for creating the event, not related to date/time\r\n    var startTime; // a Duration\r\n    var duration;\r\n    var stick;\r\n    if (prefix) {\r\n        prefix += '-';\r\n    }\r\n    eventProps = el.data(prefix + 'event') || null;\r\n    if (eventProps) {\r\n        if (typeof eventProps === 'object') {\r\n            eventProps = $.extend({}, eventProps); // make a copy\r\n        }\r\n        else {\r\n            eventProps = {};\r\n        }\r\n        // pluck special-cased date/time properties\r\n        startTime = eventProps.start;\r\n        if (startTime == null) {\r\n            startTime = eventProps.time;\r\n        } // accept 'time' as well\r\n        duration = eventProps.duration;\r\n        stick = eventProps.stick;\r\n        delete eventProps.start;\r\n        delete eventProps.time;\r\n        delete eventProps.duration;\r\n        delete eventProps.stick;\r\n    }\r\n    // fallback to standalone attribute values for each of the date/time properties\r\n    if (startTime == null) {\r\n        startTime = el.data(prefix + 'start');\r\n    }\r\n    if (startTime == null) {\r\n        startTime = el.data(prefix + 'time');\r\n    } // accept 'time' as well\r\n    if (duration == null) {\r\n        duration = el.data(prefix + 'duration');\r\n    }\r\n    if (stick == null) {\r\n        stick = el.data(prefix + 'stick');\r\n    }\r\n    // massage into correct data types\r\n    startTime = startTime != null ? moment.duration(startTime) : null;\r\n    duration = duration != null ? moment.duration(duration) : null;\r\n    stick = Boolean(stick);\r\n    return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\r\n}\r\n\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nvar EventDefDateMutation_1 = __webpack_require__(50);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar EventResizing = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventResizing, _super);\r\n    /*\r\n    component impements:\r\n      - bindSegHandlerToEl\r\n      - publiclyTrigger\r\n      - diffDates\r\n      - eventRangesToEventFootprints\r\n      - isEventInstanceGroupAllowed\r\n      - getSafeHitFootprint\r\n    */\r\n    function EventResizing(component, eventPointing) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.isResizing = false;\r\n        _this.eventPointing = eventPointing;\r\n        return _this;\r\n    }\r\n    EventResizing.prototype.end = function () {\r\n        if (this.dragListener) {\r\n            this.dragListener.endInteraction();\r\n        }\r\n    };\r\n    EventResizing.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));\r\n        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\r\n    };\r\n    EventResizing.prototype.handleMouseDown = function (seg, ev) {\r\n        if (this.component.canStartResize(seg, ev)) {\r\n            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\r\n                .startInteraction(ev, { distance: 5 });\r\n        }\r\n    };\r\n    EventResizing.prototype.handleTouchStart = function (seg, ev) {\r\n        if (this.component.canStartResize(seg, ev)) {\r\n            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\r\n                .startInteraction(ev);\r\n        }\r\n    };\r\n    // Creates a listener that tracks the user as they resize an event segment.\r\n    // Generic enough to work with any type of Grid.\r\n    EventResizing.prototype.buildDragListener = function (seg, isStart) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var eventManager = calendar.eventManager;\r\n        var el = seg.el;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var eventInstance = seg.footprint.eventInstance;\r\n        var isDragging;\r\n        var resizeMutation; // zoned event date properties. falsy if invalid resize\r\n        // Tracks mouse movement over the *grid's* coordinate map\r\n        var dragListener = this.dragListener = new HitDragListener_1.default(component, {\r\n            scroll: this.opt('dragScroll'),\r\n            subjectEl: el,\r\n            interactionStart: function () {\r\n                isDragging = false;\r\n            },\r\n            dragStart: function (ev) {\r\n                isDragging = true;\r\n                // ensure a mouseout on the manipulated event has been reported\r\n                _this.eventPointing.handleMouseout(seg, ev);\r\n                _this.segResizeStart(seg, ev);\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                var isAllowed = true;\r\n                var origHitFootprint = component.getSafeHitFootprint(origHit);\r\n                var hitFootprint = component.getSafeHitFootprint(hit);\r\n                var mutatedEventInstanceGroup;\r\n                if (origHitFootprint && hitFootprint) {\r\n                    resizeMutation = isStart ?\r\n                        _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :\r\n                        _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);\r\n                    if (resizeMutation) {\r\n                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);\r\n                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n                    }\r\n                    else {\r\n                        isAllowed = false;\r\n                    }\r\n                }\r\n                else {\r\n                    isAllowed = false;\r\n                }\r\n                if (!isAllowed) {\r\n                    resizeMutation = null;\r\n                    util_1.disableCursor();\r\n                }\r\n                else if (resizeMutation.isEmpty()) {\r\n                    // no change. (FYI, event dates might have zones)\r\n                    resizeMutation = null;\r\n                }\r\n                if (resizeMutation) {\r\n                    view.hideEventsWithId(seg.footprint.eventDef.id);\r\n                    view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                resizeMutation = null;\r\n            },\r\n            hitDone: function () {\r\n                view.unrenderEventResize(seg);\r\n                view.showEventsWithId(seg.footprint.eventDef.id);\r\n                util_1.enableCursor();\r\n            },\r\n            interactionEnd: function (ev) {\r\n                if (isDragging) {\r\n                    _this.segResizeStop(seg, ev);\r\n                }\r\n                if (resizeMutation) {\r\n                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\r\n                    view.reportEventResize(eventInstance, resizeMutation, el, ev);\r\n                }\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Called before event segment resizing starts\r\n    EventResizing.prototype.segResizeStart = function (seg, ev) {\r\n        this.isResizing = true;\r\n        this.component.publiclyTrigger('eventResizeStart', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // Called after event segment resizing stops\r\n    EventResizing.prototype.segResizeStop = function (seg, ev) {\r\n        this.isResizing = false;\r\n        this.component.publiclyTrigger('eventResizeStop', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // Returns new date-information for an event segment being resized from its start\r\n    EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\r\n        var origRange = origEventFootprint.componentFootprint.unzonedRange;\r\n        var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());\r\n        var dateMutation;\r\n        var eventDefMutation;\r\n        if (origRange.getStart().add(startDelta) < origRange.getEnd()) {\r\n            dateMutation = new EventDefDateMutation_1.default();\r\n            dateMutation.setStartDelta(startDelta);\r\n            eventDefMutation = new EventDefMutation_1.default();\r\n            eventDefMutation.setDateMutation(dateMutation);\r\n            return eventDefMutation;\r\n        }\r\n        return false;\r\n    };\r\n    // Returns new date-information for an event segment being resized from its end\r\n    EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\r\n        var origRange = origEventFootprint.componentFootprint.unzonedRange;\r\n        var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());\r\n        var dateMutation;\r\n        var eventDefMutation;\r\n        if (origRange.getEnd().add(endDelta) > origRange.getStart()) {\r\n            dateMutation = new EventDefDateMutation_1.default();\r\n            dateMutation.setEndDelta(endDelta);\r\n            eventDefMutation = new EventDefMutation_1.default();\r\n            eventDefMutation.setDateMutation(dateMutation);\r\n            return eventDefMutation;\r\n        }\r\n        return false;\r\n    };\r\n    return EventResizing;\r\n}(Interaction_1.default));\r\nexports.default = EventResizing;\r\n\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nvar EventDefDateMutation_1 = __webpack_require__(50);\r\nvar DragListener_1 = __webpack_require__(54);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar MouseFollower_1 = __webpack_require__(244);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar EventDragging = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventDragging, _super);\r\n    /*\r\n    component implements:\r\n      - bindSegHandlerToEl\r\n      - publiclyTrigger\r\n      - diffDates\r\n      - eventRangesToEventFootprints\r\n      - isEventInstanceGroupAllowed\r\n    */\r\n    function EventDragging(component, eventPointing) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.isDragging = false;\r\n        _this.eventPointing = eventPointing;\r\n        return _this;\r\n    }\r\n    EventDragging.prototype.end = function () {\r\n        if (this.dragListener) {\r\n            this.dragListener.endInteraction();\r\n        }\r\n    };\r\n    EventDragging.prototype.getSelectionDelay = function () {\r\n        var delay = this.opt('eventLongPressDelay');\r\n        if (delay == null) {\r\n            delay = this.opt('longPressDelay'); // fallback\r\n        }\r\n        return delay;\r\n    };\r\n    EventDragging.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));\r\n        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\r\n    };\r\n    EventDragging.prototype.handleMousedown = function (seg, ev) {\r\n        if (!this.component.shouldIgnoreMouse() &&\r\n            this.component.canStartDrag(seg, ev)) {\r\n            this.buildDragListener(seg).startInteraction(ev, { distance: 5 });\r\n        }\r\n    };\r\n    EventDragging.prototype.handleTouchStart = function (seg, ev) {\r\n        var component = this.component;\r\n        var settings = {\r\n            delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?\r\n                0 : this.getSelectionDelay()\r\n        };\r\n        if (component.canStartDrag(seg, ev)) {\r\n            this.buildDragListener(seg).startInteraction(ev, settings);\r\n        }\r\n        else if (component.canStartSelection(seg, ev)) {\r\n            this.buildSelectListener(seg).startInteraction(ev, settings);\r\n        }\r\n    };\r\n    // seg isn't draggable, but let's use a generic DragListener\r\n    // simply for the delay, so it can be selected.\r\n    // Has side effect of setting/unsetting `dragListener`\r\n    EventDragging.prototype.buildSelectListener = function (seg) {\r\n        var _this = this;\r\n        var view = this.view;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events\r\n        if (this.dragListener) {\r\n            return this.dragListener;\r\n        }\r\n        var dragListener = this.dragListener = new DragListener_1.default({\r\n            dragStart: function (ev) {\r\n                if (dragListener.isTouch &&\r\n                    !view.isEventDefSelected(eventDef) &&\r\n                    eventInstance) {\r\n                    // if not previously selected, will fire after a delay. then, select the event\r\n                    view.selectEventInstance(eventInstance);\r\n                }\r\n            },\r\n            interactionEnd: function (ev) {\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Builds a listener that will track user-dragging on an event segment.\r\n    // Generic enough to work with any type of Grid.\r\n    // Has side effect of setting/unsetting `dragListener`\r\n    EventDragging.prototype.buildDragListener = function (seg) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var eventManager = calendar.eventManager;\r\n        var el = seg.el;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events\r\n        var isDragging;\r\n        var mouseFollower; // A clone of the original element that will move with the mouse\r\n        var eventDefMutation;\r\n        if (this.dragListener) {\r\n            return this.dragListener;\r\n        }\r\n        // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\r\n        // of the view.\r\n        var dragListener = this.dragListener = new HitDragListener_1.default(view, {\r\n            scroll: this.opt('dragScroll'),\r\n            subjectEl: el,\r\n            subjectCenter: true,\r\n            interactionStart: function (ev) {\r\n                seg.component = component; // for renderDrag\r\n                isDragging = false;\r\n                mouseFollower = new MouseFollower_1.default(seg.el, {\r\n                    additionalClass: 'fc-dragging',\r\n                    parentEl: view.el,\r\n                    opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),\r\n                    revertDuration: _this.opt('dragRevertDuration'),\r\n                    zIndex: 2 // one above the .fc-view\r\n                });\r\n                mouseFollower.hide(); // don't show until we know this is a real drag\r\n                mouseFollower.start(ev);\r\n            },\r\n            dragStart: function (ev) {\r\n                if (dragListener.isTouch &&\r\n                    !view.isEventDefSelected(eventDef) &&\r\n                    eventInstance) {\r\n                    // if not previously selected, will fire after a delay. then, select the event\r\n                    view.selectEventInstance(eventInstance);\r\n                }\r\n                isDragging = true;\r\n                // ensure a mouseout on the manipulated event has been reported\r\n                _this.eventPointing.handleMouseout(seg, ev);\r\n                _this.segDragStart(seg, ev);\r\n                view.hideEventsWithId(seg.footprint.eventDef.id);\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                var isAllowed = true;\r\n                var origFootprint;\r\n                var footprint;\r\n                var mutatedEventInstanceGroup;\r\n                // starting hit could be forced (DayGrid.limit)\r\n                if (seg.hit) {\r\n                    origHit = seg.hit;\r\n                }\r\n                // hit might not belong to this grid, so query origin grid\r\n                origFootprint = origHit.component.getSafeHitFootprint(origHit);\r\n                footprint = hit.component.getSafeHitFootprint(hit);\r\n                if (origFootprint && footprint) {\r\n                    eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);\r\n                    if (eventDefMutation) {\r\n                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);\r\n                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n                    }\r\n                    else {\r\n                        isAllowed = false;\r\n                    }\r\n                }\r\n                else {\r\n                    isAllowed = false;\r\n                }\r\n                if (!isAllowed) {\r\n                    eventDefMutation = null;\r\n                    util_1.disableCursor();\r\n                }\r\n                // if a valid drop location, have the subclass render a visual indication\r\n                if (eventDefMutation &&\r\n                    view.renderDrag(// truthy if rendered something\r\n                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {\r\n                    mouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\r\n                }\r\n                else {\r\n                    mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\r\n                }\r\n                if (isOrig) {\r\n                    // needs to have moved hits to be a valid drop\r\n                    eventDefMutation = null;\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                view.unrenderDrag(seg); // unrender whatever was done in renderDrag\r\n                mouseFollower.show(); // show in case we are moving out of all hits\r\n                eventDefMutation = null;\r\n            },\r\n            hitDone: function () {\r\n                util_1.enableCursor();\r\n            },\r\n            interactionEnd: function (ev) {\r\n                delete seg.component; // prevent side effects\r\n                // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\r\n                mouseFollower.stop(!eventDefMutation, function () {\r\n                    if (isDragging) {\r\n                        view.unrenderDrag(seg);\r\n                        _this.segDragStop(seg, ev);\r\n                    }\r\n                    view.showEventsWithId(seg.footprint.eventDef.id);\r\n                    if (eventDefMutation) {\r\n                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\r\n                        view.reportEventDrop(eventInstance, eventDefMutation, el, ev);\r\n                    }\r\n                });\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Called before event segment dragging starts\r\n    EventDragging.prototype.segDragStart = function (seg, ev) {\r\n        this.isDragging = true;\r\n        this.component.publiclyTrigger('eventDragStart', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // Called after event segment dragging stops\r\n    EventDragging.prototype.segDragStop = function (seg, ev) {\r\n        this.isDragging = false;\r\n        this.component.publiclyTrigger('eventDragStop', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // DOES NOT consider overlap/constraint\r\n    EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {\r\n        var eventDefMutation = new EventDefMutation_1.default();\r\n        eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));\r\n        return eventDefMutation;\r\n    };\r\n    EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {\r\n        var date0 = startFootprint.unzonedRange.getStart();\r\n        var date1 = endFootprint.unzonedRange.getStart();\r\n        var clearEnd = false;\r\n        var forceTimed = false;\r\n        var forceAllDay = false;\r\n        var dateDelta;\r\n        var dateMutation;\r\n        if (startFootprint.isAllDay !== endFootprint.isAllDay) {\r\n            clearEnd = true;\r\n            if (endFootprint.isAllDay) {\r\n                forceAllDay = true;\r\n                date0.stripTime();\r\n            }\r\n            else {\r\n                forceTimed = true;\r\n            }\r\n        }\r\n        dateDelta = this.component.diffDates(date1, date0);\r\n        dateMutation = new EventDefDateMutation_1.default();\r\n        dateMutation.clearEnd = clearEnd;\r\n        dateMutation.forceTimed = forceTimed;\r\n        dateMutation.forceAllDay = forceAllDay;\r\n        dateMutation.setDateDelta(dateDelta);\r\n        return dateMutation;\r\n    };\r\n    return EventDragging;\r\n}(Interaction_1.default));\r\nexports.default = EventDragging;\r\n\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar DateSelecting = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DateSelecting, _super);\r\n    /*\r\n    component must implement:\r\n      - bindDateHandlerToEl\r\n      - getSafeHitFootprint\r\n      - renderHighlight\r\n      - unrenderHighlight\r\n    */\r\n    function DateSelecting(component) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.dragListener = _this.buildDragListener();\r\n        return _this;\r\n    }\r\n    DateSelecting.prototype.end = function () {\r\n        this.dragListener.endInteraction();\r\n    };\r\n    DateSelecting.prototype.getDelay = function () {\r\n        var delay = this.opt('selectLongPressDelay');\r\n        if (delay == null) {\r\n            delay = this.opt('longPressDelay'); // fallback\r\n        }\r\n        return delay;\r\n    };\r\n    DateSelecting.prototype.bindToEl = function (el) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var dragListener = this.dragListener;\r\n        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {\r\n            if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {\r\n                dragListener.startInteraction(ev, {\r\n                    distance: _this.opt('selectMinDistance')\r\n                });\r\n            }\r\n        });\r\n        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {\r\n            if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {\r\n                dragListener.startInteraction(ev, {\r\n                    delay: _this.getDelay()\r\n                });\r\n            }\r\n        });\r\n        util_1.preventSelection(el);\r\n    };\r\n    // Creates a listener that tracks the user's drag across day elements, for day selecting.\r\n    DateSelecting.prototype.buildDragListener = function () {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var selectionFootprint; // null if invalid selection\r\n        var dragListener = new HitDragListener_1.default(component, {\r\n            scroll: this.opt('dragScroll'),\r\n            interactionStart: function () {\r\n                selectionFootprint = null;\r\n            },\r\n            dragStart: function (ev) {\r\n                _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                var origHitFootprint;\r\n                var hitFootprint;\r\n                if (origHit) {\r\n                    origHitFootprint = component.getSafeHitFootprint(origHit);\r\n                    hitFootprint = component.getSafeHitFootprint(hit);\r\n                    if (origHitFootprint && hitFootprint) {\r\n                        selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);\r\n                    }\r\n                    else {\r\n                        selectionFootprint = null;\r\n                    }\r\n                    if (selectionFootprint) {\r\n                        component.renderSelectionFootprint(selectionFootprint);\r\n                    }\r\n                    else if (selectionFootprint === false) {\r\n                        util_1.disableCursor();\r\n                    }\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                selectionFootprint = null;\r\n                component.unrenderSelection();\r\n            },\r\n            hitDone: function () {\r\n                util_1.enableCursor();\r\n            },\r\n            interactionEnd: function (ev, isCancelled) {\r\n                if (!isCancelled && selectionFootprint) {\r\n                    // the selection will already have been rendered. just report it\r\n                    _this.view.reportSelection(selectionFootprint, ev);\r\n                }\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Given the first and last date-spans of a selection, returns another date-span object.\r\n    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().\r\n    // Will return false if the selection is invalid and this should be indicated to the user.\r\n    // Will return null/undefined if a selection invalid but no error should be reported.\r\n    DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {\r\n        var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);\r\n        if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {\r\n            return false;\r\n        }\r\n        return wholeFootprint;\r\n    };\r\n    // Given two spans, must return the combination of the two.\r\n    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\r\n    // Assumes both footprints are non-open-ended.\r\n    DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {\r\n        var ms = [\r\n            footprint0.unzonedRange.startMs,\r\n            footprint0.unzonedRange.endMs,\r\n            footprint1.unzonedRange.startMs,\r\n            footprint1.unzonedRange.endMs\r\n        ];\r\n        ms.sort(util_1.compareNumbers);\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);\r\n    };\r\n    DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {\r\n        return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&\r\n            this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);\r\n    };\r\n    return DateSelecting;\r\n}(Interaction_1.default));\r\nexports.default = DateSelecting;\r\n\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Scroller_1 = __webpack_require__(39);\r\nvar View_1 = __webpack_require__(41);\r\nvar TimeGrid_1 = __webpack_require__(227);\r\nvar DayGrid_1 = __webpack_require__(61);\r\nvar AGENDA_ALL_DAY_EVENT_LIMIT = 5;\r\nvar agendaTimeGridMethods;\r\nvar agendaDayGridMethods;\r\n/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\r\n// Responsible for managing width/height.\r\nvar AgendaView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AgendaView, _super);\r\n    function AgendaView(calendar, viewSpec) {\r\n        var _this = _super.call(this, calendar, viewSpec) || this;\r\n        _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering\r\n        _this.timeGrid = _this.instantiateTimeGrid();\r\n        _this.addChild(_this.timeGrid);\r\n        if (_this.opt('allDaySlot')) {\r\n            _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view\r\n            _this.addChild(_this.dayGrid);\r\n        }\r\n        _this.scroller = new Scroller_1.default({\r\n            overflowX: 'hidden',\r\n            overflowY: 'auto'\r\n        });\r\n        return _this;\r\n    }\r\n    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\r\n    AgendaView.prototype.instantiateTimeGrid = function () {\r\n        var timeGrid = new this.timeGridClass(this);\r\n        util_1.copyOwnProps(agendaTimeGridMethods, timeGrid);\r\n        return timeGrid;\r\n    };\r\n    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\r\n    AgendaView.prototype.instantiateDayGrid = function () {\r\n        var dayGrid = new this.dayGridClass(this);\r\n        util_1.copyOwnProps(agendaDayGridMethods, dayGrid);\r\n        return dayGrid;\r\n    };\r\n    /* Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    AgendaView.prototype.renderSkeleton = function () {\r\n        var timeGridWrapEl;\r\n        var timeGridEl;\r\n        this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\r\n        this.scroller.render();\r\n        timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\r\n        timeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\r\n        this.el.find('.fc-body > tr > td').append(timeGridWrapEl);\r\n        this.timeGrid.headContainerEl = this.el.find('.fc-head-container');\r\n        this.timeGrid.setElement(timeGridEl);\r\n        if (this.dayGrid) {\r\n            this.dayGrid.setElement(this.el.find('.fc-day-grid'));\r\n            // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\r\n            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\r\n        }\r\n    };\r\n    AgendaView.prototype.unrenderSkeleton = function () {\r\n        this.timeGrid.removeElement();\r\n        if (this.dayGrid) {\r\n            this.dayGrid.removeElement();\r\n        }\r\n        this.scroller.destroy();\r\n    };\r\n    // Builds the HTML skeleton for the view.\r\n    // The day-grid and time-grid components will render inside containers defined by this HTML.\r\n    AgendaView.prototype.renderSkeletonHtml = function () {\r\n        var theme = this.calendar.theme;\r\n        return '' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            (this.opt('columnHeader') ?\r\n                '<thead class=\"fc-head\">' +\r\n                    '<tr>' +\r\n                    '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\r\n                    '</tr>' +\r\n                    '</thead>' :\r\n                '') +\r\n            '<tbody class=\"fc-body\">' +\r\n            '<tr>' +\r\n            '<td class=\"' + theme.getClass('widgetContent') + '\">' +\r\n            (this.dayGrid ?\r\n                '<div class=\"fc-day-grid\"/>' +\r\n                    '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\"/>' :\r\n                '') +\r\n            '</td>' +\r\n            '</tr>' +\r\n            '</tbody>' +\r\n            '</table>';\r\n    };\r\n    // Generates an HTML attribute string for setting the width of the axis, if it is known\r\n    AgendaView.prototype.axisStyleAttr = function () {\r\n        if (this.axisWidth != null) {\r\n            return 'style=\"width:' + this.axisWidth + 'px\"';\r\n        }\r\n        return '';\r\n    };\r\n    /* Now Indicator\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    AgendaView.prototype.getNowIndicatorUnit = function () {\r\n        return this.timeGrid.getNowIndicatorUnit();\r\n    };\r\n    /* Dimensions\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Adjusts the vertical dimensions of the view to the specified values\r\n    AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        var eventLimit;\r\n        var scrollerHeight;\r\n        var scrollbarWidths;\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        // make all axis cells line up, and record the width so newly created axis cells will have it\r\n        this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));\r\n        // hack to give the view some height prior to timeGrid's columns being rendered\r\n        // TODO: separate setting height from scroller VS timeGrid.\r\n        if (!this.timeGrid.colEls) {\r\n            if (!isAuto) {\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            return;\r\n        }\r\n        // set of fake row elements that must compensate when scroller has scrollbars\r\n        var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');\r\n        // reset all dimensions back to the original state\r\n        this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\r\n        this.scroller.clear(); // sets height to 'auto' and clears overflow\r\n        util_1.uncompensateScroll(noScrollRowEls);\r\n        // limit number of events in the all-day area\r\n        if (this.dayGrid) {\r\n            this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\r\n            eventLimit = this.opt('eventLimit');\r\n            if (eventLimit && typeof eventLimit !== 'number') {\r\n                eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\r\n            }\r\n            if (eventLimit) {\r\n                this.dayGrid.limitRows(eventLimit);\r\n            }\r\n        }\r\n        if (!isAuto) {\r\n            scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n            this.scroller.setHeight(scrollerHeight);\r\n            scrollbarWidths = this.scroller.getScrollbarWidths();\r\n            if (scrollbarWidths.left || scrollbarWidths.right) {\r\n                // make the all-day and header rows lines up\r\n                util_1.compensateScroll(noScrollRowEls, scrollbarWidths);\r\n                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\r\n                // and reapply the desired height to the scroller.\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            // guarantees the same scrollbar widths\r\n            this.scroller.lockOverflow(scrollbarWidths);\r\n            // if there's any space below the slats, show the horizontal rule.\r\n            // this won't cause any new overflow, because lockOverflow already called.\r\n            if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\r\n                this.timeGrid.bottomRuleEl.show();\r\n            }\r\n        }\r\n    };\r\n    // given a desired total height of the view, returns what the height of the scroller should be\r\n    AgendaView.prototype.computeScrollerHeight = function (totalHeight) {\r\n        return totalHeight -\r\n            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n    };\r\n    /* Scroll\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Computes the initial pre-configured scroll state prior to allowing the user to change it\r\n    AgendaView.prototype.computeInitialDateScroll = function () {\r\n        var scrollTime = moment.duration(this.opt('scrollTime'));\r\n        var top = this.timeGrid.computeTimeTop(scrollTime);\r\n        // zoom can give weird floating-point values. rather scroll a little bit further\r\n        top = Math.ceil(top);\r\n        if (top) {\r\n            top++; // to overcome top border that slots beyond the first have. looks better\r\n        }\r\n        return { top: top };\r\n    };\r\n    AgendaView.prototype.queryDateScroll = function () {\r\n        return { top: this.scroller.getScrollTop() };\r\n    };\r\n    AgendaView.prototype.applyDateScroll = function (scroll) {\r\n        if (scroll.top !== undefined) {\r\n            this.scroller.setScrollTop(scroll.top);\r\n        }\r\n    };\r\n    /* Hit Areas\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // forward all hit-related method calls to the grids (dayGrid might not be defined)\r\n    AgendaView.prototype.getHitFootprint = function (hit) {\r\n        // TODO: hit.component is set as a hack to identify where the hit came from\r\n        return hit.component.getHitFootprint(hit);\r\n    };\r\n    AgendaView.prototype.getHitEl = function (hit) {\r\n        // TODO: hit.component is set as a hack to identify where the hit came from\r\n        return hit.component.getHitEl(hit);\r\n    };\r\n    /* Event Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    AgendaView.prototype.executeEventRender = function (eventsPayload) {\r\n        var dayEventsPayload = {};\r\n        var timedEventsPayload = {};\r\n        var id;\r\n        var eventInstanceGroup;\r\n        // separate the events into all-day and timed\r\n        for (id in eventsPayload) {\r\n            eventInstanceGroup = eventsPayload[id];\r\n            if (eventInstanceGroup.getEventDef().isAllDay()) {\r\n                dayEventsPayload[id] = eventInstanceGroup;\r\n            }\r\n            else {\r\n                timedEventsPayload[id] = eventInstanceGroup;\r\n            }\r\n        }\r\n        this.timeGrid.executeEventRender(timedEventsPayload);\r\n        if (this.dayGrid) {\r\n            this.dayGrid.executeEventRender(dayEventsPayload);\r\n        }\r\n    };\r\n    /* Dragging/Resizing Routing\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\r\n    AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var groups = groupEventFootprintsByAllDay(eventFootprints);\r\n        var renderedHelper = false;\r\n        renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);\r\n        if (this.dayGrid) {\r\n            renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;\r\n        }\r\n        return renderedHelper;\r\n    };\r\n    AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        var groups = groupEventFootprintsByAllDay(eventFootprints);\r\n        this.timeGrid.renderEventResize(groups.timed, seg, isTouch);\r\n        if (this.dayGrid) {\r\n            this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);\r\n        }\r\n    };\r\n    /* Selection\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of a selection\r\n    AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {\r\n        if (!componentFootprint.isAllDay) {\r\n            this.timeGrid.renderSelectionFootprint(componentFootprint);\r\n        }\r\n        else if (this.dayGrid) {\r\n            this.dayGrid.renderSelectionFootprint(componentFootprint);\r\n        }\r\n    };\r\n    return AgendaView;\r\n}(View_1.default));\r\nexports.default = AgendaView;\r\nAgendaView.prototype.timeGridClass = TimeGrid_1.default;\r\nAgendaView.prototype.dayGridClass = DayGrid_1.default;\r\n// Will customize the rendering behavior of the AgendaView's timeGrid\r\nagendaTimeGridMethods = {\r\n    // Generates the HTML that will go before the day-of week header cells\r\n    renderHeadIntroHtml: function () {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);\r\n        var weekText;\r\n        if (this.opt('weekNumbers')) {\r\n            weekText = weekStart.format(this.opt('smallWeekFormat'));\r\n            return '' +\r\n                '<th class=\"fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '>' +\r\n                view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\r\n                { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML\r\n                ) +\r\n                '</th>';\r\n        }\r\n        else {\r\n            return '<th class=\"fc-axis ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '></th>';\r\n        }\r\n    },\r\n    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\r\n    renderBgIntroHtml: function () {\r\n        var view = this.view;\r\n        return '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '></td>';\r\n    },\r\n    // Generates the HTML that goes before all other types of cells.\r\n    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\r\n    renderIntroHtml: function () {\r\n        var view = this.view;\r\n        return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\r\n    }\r\n};\r\n// Will customize the rendering behavior of the AgendaView's dayGrid\r\nagendaDayGridMethods = {\r\n    // Generates the HTML that goes before the all-day cells\r\n    renderBgIntroHtml: function () {\r\n        var view = this.view;\r\n        return '' +\r\n            '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\r\n            '<span>' + // needed for matchCellWidths\r\n            view.getAllDayHtml() +\r\n            '</span>' +\r\n            '</td>';\r\n    },\r\n    // Generates the HTML that goes before all other types of cells.\r\n    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\r\n    renderIntroHtml: function () {\r\n        var view = this.view;\r\n        return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\r\n    }\r\n};\r\nfunction groupEventFootprintsByAllDay(eventFootprints) {\r\n    var allDay = [];\r\n    var timed = [];\r\n    var i;\r\n    for (i = 0; i < eventFootprints.length; i++) {\r\n        if (eventFootprints[i].componentFootprint.isAllDay) {\r\n            allDay.push(eventFootprints[i]);\r\n        }\r\n        else {\r\n            timed.push(eventFootprints[i]);\r\n        }\r\n    }\r\n    return { allDay: allDay, timed: timed };\r\n}\r\n\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nvar BusinessHourRenderer_1 = __webpack_require__(56);\r\nvar StandardInteractionsMixin_1 = __webpack_require__(60);\r\nvar DayTableMixin_1 = __webpack_require__(55);\r\nvar CoordCache_1 = __webpack_require__(53);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar TimeGridEventRenderer_1 = __webpack_require__(246);\r\nvar TimeGridHelperRenderer_1 = __webpack_require__(247);\r\nvar TimeGridFillRenderer_1 = __webpack_require__(248);\r\n/* A component that renders one or more columns of vertical time slots\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// We mixin DayTable, even though there is only a single row of days\r\n// potential nice values for the slot-duration and interval-duration\r\n// from largest to smallest\r\nvar AGENDA_STOCK_SUB_DURATIONS = [\r\n    { hours: 1 },\r\n    { minutes: 30 },\r\n    { minutes: 15 },\r\n    { seconds: 30 },\r\n    { seconds: 15 }\r\n];\r\nvar TimeGrid = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGrid, _super);\r\n    function TimeGrid(view) {\r\n        var _this = _super.call(this, view) || this;\r\n        _this.processOptions();\r\n        return _this;\r\n    }\r\n    // Slices up the given span (unzoned start/end with other misc data) into an array of segments\r\n    TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\r\n        var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);\r\n        var i;\r\n        for (i = 0; i < segs.length; i++) {\r\n            if (this.isRTL) {\r\n                segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\r\n            }\r\n            else {\r\n                segs[i].col = segs[i].dayIndex;\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Date Handling\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {\r\n        var segs = [];\r\n        var segRange;\r\n        var dayIndex;\r\n        for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\r\n            segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);\r\n            if (segRange) {\r\n                segs.push({\r\n                    startMs: segRange.startMs,\r\n                    endMs: segRange.endMs,\r\n                    isStart: segRange.isStart,\r\n                    isEnd: segRange.isEnd,\r\n                    dayIndex: dayIndex\r\n                });\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Options\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Parses various options into properties of this object\r\n    TimeGrid.prototype.processOptions = function () {\r\n        var slotDuration = this.opt('slotDuration');\r\n        var snapDuration = this.opt('snapDuration');\r\n        var input;\r\n        slotDuration = moment.duration(slotDuration);\r\n        snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\r\n        this.slotDuration = slotDuration;\r\n        this.snapDuration = snapDuration;\r\n        this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\r\n        // might be an array value (for TimelineView).\r\n        // if so, getting the most granular entry (the last one probably).\r\n        input = this.opt('slotLabelFormat');\r\n        if ($.isArray(input)) {\r\n            input = input[input.length - 1];\r\n        }\r\n        this.labelFormat = input ||\r\n            this.opt('smallTimeFormat'); // the computed default\r\n        input = this.opt('slotLabelInterval');\r\n        this.labelInterval = input ?\r\n            moment.duration(input) :\r\n            this.computeLabelInterval(slotDuration);\r\n    };\r\n    // Computes an automatic value for slotLabelInterval\r\n    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {\r\n        var i;\r\n        var labelInterval;\r\n        var slotsPerLabel;\r\n        // find the smallest stock label interval that results in more than one slots-per-label\r\n        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\r\n            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\r\n            slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);\r\n            if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {\r\n                return labelInterval;\r\n            }\r\n        }\r\n        return moment.duration(slotDuration); // fall back. clone\r\n    };\r\n    /* Date Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.renderDates = function (dateProfile) {\r\n        this.dateProfile = dateProfile;\r\n        this.updateDayTable();\r\n        this.renderSlats();\r\n        this.renderColumns();\r\n    };\r\n    TimeGrid.prototype.unrenderDates = function () {\r\n        // this.unrenderSlats(); // don't need this because repeated .html() calls clear\r\n        this.unrenderColumns();\r\n    };\r\n    TimeGrid.prototype.renderSkeleton = function () {\r\n        var theme = this.view.calendar.theme;\r\n        this.el.html('<div class=\"fc-bg\"></div>' +\r\n            '<div class=\"fc-slats\"></div>' +\r\n            '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" style=\"display:none\" />');\r\n        this.bottomRuleEl = this.el.find('hr');\r\n    };\r\n    TimeGrid.prototype.renderSlats = function () {\r\n        var theme = this.view.calendar.theme;\r\n        this.slatContainerEl = this.el.find('> .fc-slats')\r\n            .html(// avoids needing ::unrenderSlats()\r\n        '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            this.renderSlatRowHtml() +\r\n            '</table>');\r\n        this.slatEls = this.slatContainerEl.find('tr');\r\n        this.slatCoordCache = new CoordCache_1.default({\r\n            els: this.slatEls,\r\n            isVertical: true\r\n        });\r\n    };\r\n    // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\r\n    TimeGrid.prototype.renderSlatRowHtml = function () {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var theme = calendar.theme;\r\n        var isRTL = this.isRTL;\r\n        var dateProfile = this.dateProfile;\r\n        var html = '';\r\n        var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations\r\n        var slotIterator = moment.duration(0);\r\n        var slotDate; // will be on the view's first day, but we only care about its time\r\n        var isLabeled;\r\n        var axisHtml;\r\n        // Calculate the time for each slot\r\n        while (slotTime < dateProfile.maxTime) {\r\n            slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);\r\n            isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));\r\n            axisHtml =\r\n                '<td class=\"fc-axis fc-time ' + theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\r\n                    (isLabeled ?\r\n                        '<span>' + // for matchCellWidths\r\n                            util_1.htmlEscape(slotDate.format(this.labelFormat)) +\r\n                            '</span>' :\r\n                        '') +\r\n                    '</td>';\r\n            html +=\r\n                '<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' +\r\n                    (isLabeled ? '' : ' class=\"fc-minor\"') +\r\n                    '>' +\r\n                    (!isRTL ? axisHtml : '') +\r\n                    '<td class=\"' + theme.getClass('widgetContent') + '\"/>' +\r\n                    (isRTL ? axisHtml : '') +\r\n                    '</tr>';\r\n            slotTime.add(this.slotDuration);\r\n            slotIterator.add(this.slotDuration);\r\n        }\r\n        return html;\r\n    };\r\n    TimeGrid.prototype.renderColumns = function () {\r\n        var dateProfile = this.dateProfile;\r\n        var theme = this.view.calendar.theme;\r\n        this.dayRanges = this.dayDates.map(function (dayDate) {\r\n            return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));\r\n        });\r\n        if (this.headContainerEl) {\r\n            this.headContainerEl.html(this.renderHeadHtml());\r\n        }\r\n        this.el.find('> .fc-bg').html('<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            this.renderBgTrHtml(0) + // row=0\r\n            '</table>');\r\n        this.colEls = this.el.find('.fc-day, .fc-disabled-day');\r\n        this.colCoordCache = new CoordCache_1.default({\r\n            els: this.colEls,\r\n            isHorizontal: true\r\n        });\r\n        this.renderContentSkeleton();\r\n    };\r\n    TimeGrid.prototype.unrenderColumns = function () {\r\n        this.unrenderContentSkeleton();\r\n    };\r\n    /* Content Skeleton\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders the DOM that the view's content will live in\r\n    TimeGrid.prototype.renderContentSkeleton = function () {\r\n        var cellHtml = '';\r\n        var i;\r\n        var skeletonEl;\r\n        for (i = 0; i < this.colCnt; i++) {\r\n            cellHtml +=\r\n                '<td>' +\r\n                    '<div class=\"fc-content-col\">' +\r\n                    '<div class=\"fc-event-container fc-helper-container\"></div>' +\r\n                    '<div class=\"fc-event-container\"></div>' +\r\n                    '<div class=\"fc-highlight-container\"></div>' +\r\n                    '<div class=\"fc-bgevent-container\"></div>' +\r\n                    '<div class=\"fc-business-container\"></div>' +\r\n                    '</div>' +\r\n                    '</td>';\r\n        }\r\n        skeletonEl = this.contentSkeletonEl = $('<div class=\"fc-content-skeleton\">' +\r\n            '<table>' +\r\n            '<tr>' + cellHtml + '</tr>' +\r\n            '</table>' +\r\n            '</div>');\r\n        this.colContainerEls = skeletonEl.find('.fc-content-col');\r\n        this.helperContainerEls = skeletonEl.find('.fc-helper-container');\r\n        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\r\n        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\r\n        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\r\n        this.businessContainerEls = skeletonEl.find('.fc-business-container');\r\n        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\r\n        this.el.append(skeletonEl);\r\n    };\r\n    TimeGrid.prototype.unrenderContentSkeleton = function () {\r\n        if (this.contentSkeletonEl) {\r\n            this.contentSkeletonEl.remove();\r\n            this.contentSkeletonEl = null;\r\n            this.colContainerEls = null;\r\n            this.helperContainerEls = null;\r\n            this.fgContainerEls = null;\r\n            this.bgContainerEls = null;\r\n            this.highlightContainerEls = null;\r\n            this.businessContainerEls = null;\r\n        }\r\n    };\r\n    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\r\n    TimeGrid.prototype.groupSegsByCol = function (segs) {\r\n        var segsByCol = [];\r\n        var i;\r\n        for (i = 0; i < this.colCnt; i++) {\r\n            segsByCol.push([]);\r\n        }\r\n        for (i = 0; i < segs.length; i++) {\r\n            segsByCol[segs[i].col].push(segs[i]);\r\n        }\r\n        return segsByCol;\r\n    };\r\n    // Given segments grouped by column, insert the segments' elements into a parallel array of container\r\n    // elements, each living within a column.\r\n    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {\r\n        var col;\r\n        var segs;\r\n        var i;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            segs = segsByCol[col];\r\n            for (i = 0; i < segs.length; i++) {\r\n                containerEls.eq(col).append(segs[i].el);\r\n            }\r\n        }\r\n    };\r\n    /* Now Indicator\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.getNowIndicatorUnit = function () {\r\n        return 'minute'; // will refresh on the minute\r\n    };\r\n    TimeGrid.prototype.renderNowIndicator = function (date) {\r\n        // HACK: if date columns not ready for some reason (scheduler)\r\n        if (!this.colContainerEls) {\r\n            return;\r\n        }\r\n        // seg system might be overkill, but it handles scenario where line needs to be rendered\r\n        //  more than once because of columns with the same date (resources columns for example)\r\n        var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range\r\n        false // all-day\r\n        ));\r\n        var top = this.computeDateTop(date, date);\r\n        var nodes = [];\r\n        var i;\r\n        // render lines within the columns\r\n        for (i = 0; i < segs.length; i++) {\r\n            nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>')\r\n                .css('top', top)\r\n                .appendTo(this.colContainerEls.eq(segs[i].col))[0]);\r\n        }\r\n        // render an arrow over the axis\r\n        if (segs.length > 0) {\r\n            nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>')\r\n                .css('top', top)\r\n                .appendTo(this.el.find('.fc-content-skeleton'))[0]);\r\n        }\r\n        this.nowIndicatorEls = $(nodes);\r\n    };\r\n    TimeGrid.prototype.unrenderNowIndicator = function () {\r\n        if (this.nowIndicatorEls) {\r\n            this.nowIndicatorEls.remove();\r\n            this.nowIndicatorEls = null;\r\n        }\r\n    };\r\n    /* Coordinates\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        this.slatCoordCache.build();\r\n        if (isResize) {\r\n            this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));\r\n        }\r\n    };\r\n    TimeGrid.prototype.getTotalSlatHeight = function () {\r\n        return this.slatContainerEl.outerHeight();\r\n    };\r\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\r\n    // `ms` can be a millisecond UTC time OR a UTC moment.\r\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\r\n    TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {\r\n        return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));\r\n    };\r\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\r\n    TimeGrid.prototype.computeTimeTop = function (time) {\r\n        var len = this.slatEls.length;\r\n        var dateProfile = this.dateProfile;\r\n        var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered\r\n        var slatIndex;\r\n        var slatRemainder;\r\n        // compute a floating-point number for how many slats should be progressed through.\r\n        // from 0 to number of slats (inclusive)\r\n        // constrained because minTime/maxTime might be customized.\r\n        slatCoverage = Math.max(0, slatCoverage);\r\n        slatCoverage = Math.min(len, slatCoverage);\r\n        // an integer index of the furthest whole slat\r\n        // from 0 to number slats (*exclusive*, so len-1)\r\n        slatIndex = Math.floor(slatCoverage);\r\n        slatIndex = Math.min(slatIndex, len - 1);\r\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\r\n        // could be 1.0 if slatCoverage is covering *all* the slots\r\n        slatRemainder = slatCoverage - slatIndex;\r\n        return this.slatCoordCache.getTopPosition(slatIndex) +\r\n            this.slatCoordCache.getHeight(slatIndex) * slatRemainder;\r\n    };\r\n    // Refreshes the CSS top/bottom coordinates for each segment element.\r\n    // Works when called after initial render, after a window resize/zoom for example.\r\n    TimeGrid.prototype.updateSegVerticals = function (segs) {\r\n        this.computeSegVerticals(segs);\r\n        this.assignSegVerticals(segs);\r\n    };\r\n    // For each segment in an array, computes and assigns its top and bottom properties\r\n    TimeGrid.prototype.computeSegVerticals = function (segs) {\r\n        var eventMinHeight = this.opt('agendaEventMinHeight');\r\n        var i;\r\n        var seg;\r\n        var dayDate;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            dayDate = this.dayDates[seg.dayIndex];\r\n            seg.top = this.computeDateTop(seg.startMs, dayDate);\r\n            seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));\r\n        }\r\n    };\r\n    // Given segments that already have their top/bottom properties computed, applies those values to\r\n    // the segments' elements.\r\n    TimeGrid.prototype.assignSegVerticals = function (segs) {\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            seg.el.css(this.generateSegVerticalCss(seg));\r\n        }\r\n    };\r\n    // Generates an object with CSS properties for the top/bottom coordinates of a segment element\r\n    TimeGrid.prototype.generateSegVerticalCss = function (seg) {\r\n        return {\r\n            top: seg.top,\r\n            bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\r\n        };\r\n    };\r\n    /* Hit System\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.prepareHits = function () {\r\n        this.colCoordCache.build();\r\n        this.slatCoordCache.build();\r\n    };\r\n    TimeGrid.prototype.releaseHits = function () {\r\n        this.colCoordCache.clear();\r\n        // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\r\n    };\r\n    TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {\r\n        var snapsPerSlot = this.snapsPerSlot;\r\n        var colCoordCache = this.colCoordCache;\r\n        var slatCoordCache = this.slatCoordCache;\r\n        if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\r\n            var colIndex = colCoordCache.getHorizontalIndex(leftOffset);\r\n            var slatIndex = slatCoordCache.getVerticalIndex(topOffset);\r\n            if (colIndex != null && slatIndex != null) {\r\n                var slatTop = slatCoordCache.getTopOffset(slatIndex);\r\n                var slatHeight = slatCoordCache.getHeight(slatIndex);\r\n                var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\r\n                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\r\n                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\r\n                var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\r\n                var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\r\n                return {\r\n                    col: colIndex,\r\n                    snap: snapIndex,\r\n                    component: this,\r\n                    left: colCoordCache.getLeftOffset(colIndex),\r\n                    right: colCoordCache.getRightOffset(colIndex),\r\n                    top: snapTop,\r\n                    bottom: snapBottom\r\n                };\r\n            }\r\n        }\r\n    };\r\n    TimeGrid.prototype.getHitFootprint = function (hit) {\r\n        var start = this.getCellDate(0, hit.col); // row=0\r\n        var time = this.computeSnapTime(hit.snap); // pass in the snap-index\r\n        var end;\r\n        start.time(time);\r\n        end = start.clone().add(this.snapDuration);\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?\r\n        );\r\n    };\r\n    // Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\r\n    TimeGrid.prototype.computeSnapTime = function (snapIndex) {\r\n        return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);\r\n    };\r\n    TimeGrid.prototype.getHitEl = function (hit) {\r\n        return this.colEls.eq(hit.col);\r\n    };\r\n    /* Event Drag Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event being dragged over the specified date(s).\r\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\r\n    TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var i;\r\n        if (seg) {\r\n            if (eventFootprints.length) {\r\n                this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\r\n                // signal that a helper has been rendered\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0; i < eventFootprints.length; i++) {\r\n                this.renderHighlight(eventFootprints[i].componentFootprint);\r\n            }\r\n        }\r\n    };\r\n    // Unrenders any visual indication of an event being dragged\r\n    TimeGrid.prototype.unrenderDrag = function () {\r\n        this.unrenderHighlight();\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* Event Resize Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event being resized\r\n    TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\r\n    };\r\n    // Unrenders any visual indication of an event being resized\r\n    TimeGrid.prototype.unrenderEventResize = function () {\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* Selection\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\r\n    TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {\r\n        if (this.opt('selectHelper')) {\r\n            this.helperRenderer.renderComponentFootprint(componentFootprint);\r\n        }\r\n        else {\r\n            this.renderHighlight(componentFootprint);\r\n        }\r\n    };\r\n    // Unrenders any visual indication of a selection\r\n    TimeGrid.prototype.unrenderSelection = function () {\r\n        this.helperRenderer.unrender();\r\n        this.unrenderHighlight();\r\n    };\r\n    return TimeGrid;\r\n}(InteractiveDateComponent_1.default));\r\nexports.default = TimeGrid;\r\nTimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;\r\nTimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;\r\nTimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;\r\nTimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;\r\nStandardInteractionsMixin_1.default.mixInto(TimeGrid);\r\nDayTableMixin_1.default.mixInto(TimeGrid);\r\n\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar DateProfileGenerator_1 = __webpack_require__(221);\r\nvar BasicViewDateProfileGenerator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BasicViewDateProfileGenerator, _super);\r\n    function BasicViewDateProfileGenerator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Computes the date range that will be rendered.\r\n    BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange\r\n        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\r\n        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\r\n        // year and month views should be aligned with weeks. this is already done for week\r\n        if (/^(year|month)$/.test(currentRangeUnit)) {\r\n            start.startOf('week');\r\n            // make end-of-week if not already\r\n            if (end.weekday()) {\r\n                end.add(1, 'week').startOf('week'); // exclusively move backwards\r\n            }\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    return BasicViewDateProfileGenerator;\r\n}(DateProfileGenerator_1.default));\r\nexports.default = BasicViewDateProfileGenerator;\r\n\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar BasicView_1 = __webpack_require__(62);\r\nvar MonthViewDateProfileGenerator_1 = __webpack_require__(253);\r\n/* A month view with day cells running in rows (one-per-week) and columns\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar MonthView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MonthView, _super);\r\n    function MonthView() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Overrides the default BasicView behavior to have special multi-week auto-height logic\r\n    MonthView.prototype.setGridHeight = function (height, isAuto) {\r\n        // if auto, make the height of each row the height that it would be if there were 6 weeks\r\n        if (isAuto) {\r\n            height *= this.dayGrid.rowCnt / 6;\r\n        }\r\n        util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\r\n    };\r\n    MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {\r\n        return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize\r\n    };\r\n    return MonthView;\r\n}(BasicView_1.default));\r\nexports.default = MonthView;\r\nMonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator_1.default;\r\n\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar View_1 = __webpack_require__(41);\r\nvar Scroller_1 = __webpack_require__(39);\r\nvar ListEventRenderer_1 = __webpack_require__(254);\r\nvar ListEventPointing_1 = __webpack_require__(255);\r\n/*\r\nResponsible for the scroller, and forwarding event-related actions into the \"grid\".\r\n*/\r\nvar ListView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListView, _super);\r\n    function ListView(calendar, viewSpec) {\r\n        var _this = _super.call(this, calendar, viewSpec) || this;\r\n        _this.segSelector = '.fc-list-item'; // which elements accept event actions\r\n        _this.scroller = new Scroller_1.default({\r\n            overflowX: 'hidden',\r\n            overflowY: 'auto'\r\n        });\r\n        return _this;\r\n    }\r\n    ListView.prototype.renderSkeleton = function () {\r\n        this.el.addClass('fc-list-view ' +\r\n            this.calendar.theme.getClass('listView'));\r\n        this.scroller.render();\r\n        this.scroller.el.appendTo(this.el);\r\n        this.contentEl = this.scroller.scrollEl; // shortcut\r\n    };\r\n    ListView.prototype.unrenderSkeleton = function () {\r\n        this.scroller.destroy(); // will remove the Grid too\r\n    };\r\n    ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        this.scroller.clear(); // sets height to 'auto' and clears overflow\r\n        if (!isAuto) {\r\n            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));\r\n        }\r\n    };\r\n    ListView.prototype.computeScrollerHeight = function (totalHeight) {\r\n        return totalHeight -\r\n            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n    };\r\n    ListView.prototype.renderDates = function (dateProfile) {\r\n        var calendar = this.calendar;\r\n        var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);\r\n        var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);\r\n        var dayDates = [];\r\n        var dayRanges = [];\r\n        while (dayStart < viewEnd) {\r\n            dayDates.push(dayStart.clone());\r\n            dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));\r\n            dayStart.add(1, 'day');\r\n        }\r\n        this.dayDates = dayDates;\r\n        this.dayRanges = dayRanges;\r\n        // all real rendering happens in EventRenderer\r\n    };\r\n    // slices by day\r\n    ListView.prototype.componentFootprintToSegs = function (footprint) {\r\n        var dayRanges = this.dayRanges;\r\n        var dayIndex;\r\n        var segRange;\r\n        var seg;\r\n        var segs = [];\r\n        for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {\r\n            segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);\r\n            if (segRange) {\r\n                seg = {\r\n                    startMs: segRange.startMs,\r\n                    endMs: segRange.endMs,\r\n                    isStart: segRange.isStart,\r\n                    isEnd: segRange.isEnd,\r\n                    dayIndex: dayIndex\r\n                };\r\n                segs.push(seg);\r\n                // detect when footprint won't go fully into the next day,\r\n                // and mutate the latest seg to the be the end.\r\n                if (!seg.isEnd && !footprint.isAllDay &&\r\n                    dayIndex + 1 < dayRanges.length &&\r\n                    footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {\r\n                    seg.endMs = footprint.unzonedRange.endMs;\r\n                    seg.isEnd = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    ListView.prototype.renderEmptyMessage = function () {\r\n        this.contentEl.html('<div class=\"fc-list-empty-wrap2\">' + // TODO: try less wraps\r\n            '<div class=\"fc-list-empty-wrap1\">' +\r\n            '<div class=\"fc-list-empty\">' +\r\n            util_1.htmlEscape(this.opt('noEventsMessage')) +\r\n            '</div>' +\r\n            '</div>' +\r\n            '</div>');\r\n    };\r\n    // render the event segments in the view\r\n    ListView.prototype.renderSegList = function (allSegs) {\r\n        var segsByDay = this.groupSegsByDay(allSegs); // sparse array\r\n        var dayIndex;\r\n        var daySegs;\r\n        var i;\r\n        var tableEl = $('<table class=\"fc-list-table ' + this.calendar.theme.getClass('tableList') + '\"><tbody/></table>');\r\n        var tbodyEl = tableEl.find('tbody');\r\n        for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\r\n            daySegs = segsByDay[dayIndex];\r\n            if (daySegs) {\r\n                // append a day header\r\n                tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));\r\n                this.eventRenderer.sortEventSegs(daySegs);\r\n                for (i = 0; i < daySegs.length; i++) {\r\n                    tbodyEl.append(daySegs[i].el); // append event row\r\n                }\r\n            }\r\n        }\r\n        this.contentEl.empty().append(tableEl);\r\n    };\r\n    // Returns a sparse array of arrays, segs grouped by their dayIndex\r\n    ListView.prototype.groupSegsByDay = function (segs) {\r\n        var segsByDay = []; // sparse array\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\r\n                .push(seg);\r\n        }\r\n        return segsByDay;\r\n    };\r\n    // generates the HTML for the day headers that live amongst the event rows\r\n    ListView.prototype.dayHeaderHtml = function (dayDate) {\r\n        var mainFormat = this.opt('listDayFormat');\r\n        var altFormat = this.opt('listDayAltFormat');\r\n        return '<tr class=\"fc-list-heading\" data-date=\"' + dayDate.format('YYYY-MM-DD') + '\">' +\r\n            '<td class=\"' + (this.calendar.theme.getClass('tableListHeading') ||\r\n            this.calendar.theme.getClass('widgetHeader')) + '\" colspan=\"3\">' +\r\n            (mainFormat ?\r\n                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML\r\n                ) :\r\n                '') +\r\n            (altFormat ?\r\n                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML\r\n                ) :\r\n                '') +\r\n            '</td>' +\r\n            '</tr>';\r\n    };\r\n    return ListView;\r\n}(View_1.default));\r\nexports.default = ListView;\r\nListView.prototype.eventRendererClass = ListEventRenderer_1.default;\r\nListView.prototype.eventPointingClass = ListEventPointing_1.default;\r\n\n\n/***/ }),\n/* 231 */,\n/* 232 */,\n/* 233 */,\n/* 234 */,\n/* 235 */,\n/* 236 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(3);\r\nvar exportHooks = __webpack_require__(16);\r\nvar util_1 = __webpack_require__(4);\r\nvar Calendar_1 = __webpack_require__(220);\r\n// for intentional side-effects\r\n__webpack_require__(10);\r\n__webpack_require__(47);\r\n__webpack_require__(256);\r\n__webpack_require__(257);\r\n__webpack_require__(260);\r\n__webpack_require__(261);\r\n__webpack_require__(262);\r\n__webpack_require__(263);\r\n$.fullCalendar = exportHooks;\r\n$.fn.fullCalendar = function (options) {\r\n    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call\r\n    var res = this; // what this function will return (this jQuery object by default)\r\n    this.each(function (i, _element) {\r\n        var element = $(_element);\r\n        var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\r\n        var singleRes; // the returned value of this single method call\r\n        // a method call\r\n        if (typeof options === 'string') {\r\n            if (options === 'getCalendar') {\r\n                if (!i) {\r\n                    res = calendar;\r\n                }\r\n            }\r\n            else if (options === 'destroy') {\r\n                if (calendar) {\r\n                    calendar.destroy();\r\n                    element.removeData('fullCalendar');\r\n                }\r\n            }\r\n            else if (!calendar) {\r\n                util_1.warn('Attempting to call a FullCalendar method on an element with no calendar.');\r\n            }\r\n            else if ($.isFunction(calendar[options])) {\r\n                singleRes = calendar[options].apply(calendar, args);\r\n                if (!i) {\r\n                    res = singleRes; // record the first method call result\r\n                }\r\n                if (options === 'destroy') {\r\n                    element.removeData('fullCalendar');\r\n                }\r\n            }\r\n            else {\r\n                util_1.warn(\"'\" + options + \"' is an unknown FullCalendar method.\");\r\n            }\r\n        }\r\n        else if (!calendar) {\r\n            calendar = new Calendar_1.default(element, options);\r\n            element.data('fullCalendar', calendar);\r\n            calendar.render();\r\n        }\r\n    });\r\n    return res;\r\n};\r\nmodule.exports = exportHooks;\r\n\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Model_1 = __webpack_require__(48);\r\nvar Component = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Component, _super);\r\n    function Component() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Component.prototype.setElement = function (el) {\r\n        this.el = el;\r\n        this.bindGlobalHandlers();\r\n        this.renderSkeleton();\r\n        this.set('isInDom', true);\r\n    };\r\n    Component.prototype.removeElement = function () {\r\n        this.unset('isInDom');\r\n        this.unrenderSkeleton();\r\n        this.unbindGlobalHandlers();\r\n        this.el.remove();\r\n        // NOTE: don't null-out this.el in case the View was destroyed within an API callback.\r\n        // We don't null-out the View's other jQuery element references upon destroy,\r\n        //  so we shouldn't kill this.el either.\r\n    };\r\n    Component.prototype.bindGlobalHandlers = function () {\r\n        // subclasses can override\r\n    };\r\n    Component.prototype.unbindGlobalHandlers = function () {\r\n        // subclasses can override\r\n    };\r\n    /*\r\n    NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender\r\n    */\r\n    // Renders the basic structure of the view before any content is rendered\r\n    Component.prototype.renderSkeleton = function () {\r\n        // subclasses should implement\r\n    };\r\n    // Unrenders the basic structure of the view\r\n    Component.prototype.unrenderSkeleton = function () {\r\n        // subclasses should implement\r\n    };\r\n    return Component;\r\n}(Model_1.default));\r\nexports.default = Component;\r\n\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Iterator = /** @class */ (function () {\r\n    function Iterator(items) {\r\n        this.items = items || [];\r\n    }\r\n    /* Calls a method on every item passing the arguments through */\r\n    Iterator.prototype.proxyCall = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var results = [];\r\n        this.items.forEach(function (item) {\r\n            results.push(item[methodName].apply(item, args));\r\n        });\r\n        return results;\r\n    };\r\n    return Iterator;\r\n}());\r\nexports.default = Iterator;\r\n\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\n/* Toolbar with buttons and title\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar Toolbar = /** @class */ (function () {\r\n    function Toolbar(calendar, toolbarOptions) {\r\n        this.el = null; // mirrors local `el`\r\n        this.viewsWithButtons = [];\r\n        this.calendar = calendar;\r\n        this.toolbarOptions = toolbarOptions;\r\n    }\r\n    // method to update toolbar-specific options, not calendar-wide options\r\n    Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {\r\n        this.toolbarOptions = newToolbarOptions;\r\n    };\r\n    // can be called repeatedly and will rerender\r\n    Toolbar.prototype.render = function () {\r\n        var sections = this.toolbarOptions.layout;\r\n        var el = this.el;\r\n        if (sections) {\r\n            if (!el) {\r\n                el = this.el = $(\"<div class='fc-toolbar \" + this.toolbarOptions.extraClasses + \"'/>\");\r\n            }\r\n            else {\r\n                el.empty();\r\n            }\r\n            el.append(this.renderSection('left'))\r\n                .append(this.renderSection('right'))\r\n                .append(this.renderSection('center'))\r\n                .append('<div class=\"fc-clear\"/>');\r\n        }\r\n        else {\r\n            this.removeElement();\r\n        }\r\n    };\r\n    Toolbar.prototype.removeElement = function () {\r\n        if (this.el) {\r\n            this.el.remove();\r\n            this.el = null;\r\n        }\r\n    };\r\n    Toolbar.prototype.renderSection = function (position) {\r\n        var _this = this;\r\n        var calendar = this.calendar;\r\n        var theme = calendar.theme;\r\n        var optionsManager = calendar.optionsManager;\r\n        var viewSpecManager = calendar.viewSpecManager;\r\n        var sectionEl = $('<div class=\"fc-' + position + '\"/>');\r\n        var buttonStr = this.toolbarOptions.layout[position];\r\n        var calendarCustomButtons = optionsManager.get('customButtons') || {};\r\n        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};\r\n        var calendarButtonText = optionsManager.get('buttonText') || {};\r\n        if (buttonStr) {\r\n            $.each(buttonStr.split(' '), function (i, buttonGroupStr) {\r\n                var groupChildren = $();\r\n                var isOnlyButtons = true;\r\n                var groupEl;\r\n                $.each(buttonGroupStr.split(','), function (j, buttonName) {\r\n                    var customButtonProps;\r\n                    var viewSpec;\r\n                    var buttonClick;\r\n                    var buttonIcon; // only one of these will be set\r\n                    var buttonText; // \"\r\n                    var buttonInnerHtml;\r\n                    var buttonClasses;\r\n                    var buttonEl;\r\n                    var buttonAriaAttr;\r\n                    if (buttonName === 'title') {\r\n                        groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\r\n                        isOnlyButtons = false;\r\n                    }\r\n                    else {\r\n                        if ((customButtonProps = calendarCustomButtons[buttonName])) {\r\n                            buttonClick = function (ev) {\r\n                                if (customButtonProps.click) {\r\n                                    customButtonProps.click.call(buttonEl[0], ev);\r\n                                }\r\n                            };\r\n                            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\r\n                                (buttonIcon = theme.getIconClass(buttonName)) ||\r\n                                (buttonText = customButtonProps.text);\r\n                        }\r\n                        else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {\r\n                            _this.viewsWithButtons.push(buttonName);\r\n                            buttonClick = function () {\r\n                                calendar.changeView(buttonName);\r\n                            };\r\n                            (buttonText = viewSpec.buttonTextOverride) ||\r\n                                (buttonIcon = theme.getIconClass(buttonName)) ||\r\n                                (buttonText = viewSpec.buttonTextDefault);\r\n                        }\r\n                        else if (calendar[buttonName]) {\r\n                            buttonClick = function () {\r\n                                calendar[buttonName]();\r\n                            };\r\n                            (buttonText = calendarButtonTextOverrides[buttonName]) ||\r\n                                (buttonIcon = theme.getIconClass(buttonName)) ||\r\n                                (buttonText = calendarButtonText[buttonName]);\r\n                            //            ^ everything else is considered default\r\n                        }\r\n                        if (buttonClick) {\r\n                            buttonClasses = [\r\n                                'fc-' + buttonName + '-button',\r\n                                theme.getClass('button'),\r\n                                theme.getClass('stateDefault')\r\n                            ];\r\n                            if (buttonText) {\r\n                                buttonInnerHtml = util_1.htmlEscape(buttonText);\r\n                                buttonAriaAttr = '';\r\n                            }\r\n                            else if (buttonIcon) {\r\n                                buttonInnerHtml = \"<span class='\" + buttonIcon + \"'></span>\";\r\n                                buttonAriaAttr = ' aria-label=\"' + buttonName + '\"';\r\n                            }\r\n                            buttonEl = $(// type=\"button\" so that it doesn't submit a form\r\n                            '<button type=\"button\" class=\"' + buttonClasses.join(' ') + '\"' +\r\n                                buttonAriaAttr +\r\n                                '>' + buttonInnerHtml + '</button>')\r\n                                .click(function (ev) {\r\n                                // don't process clicks for disabled buttons\r\n                                if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {\r\n                                    buttonClick(ev);\r\n                                    // after the click action, if the button becomes the \"active\" tab, or disabled,\r\n                                    // it should never have a hover class, so remove it now.\r\n                                    if (buttonEl.hasClass(theme.getClass('stateActive')) ||\r\n                                        buttonEl.hasClass(theme.getClass('stateDisabled'))) {\r\n                                        buttonEl.removeClass(theme.getClass('stateHover'));\r\n                                    }\r\n                                }\r\n                            })\r\n                                .mousedown(function () {\r\n                                // the *down* effect (mouse pressed in).\r\n                                // only on buttons that are not the \"active\" tab, or disabled\r\n                                buttonEl\r\n                                    .not('.' + theme.getClass('stateActive'))\r\n                                    .not('.' + theme.getClass('stateDisabled'))\r\n                                    .addClass(theme.getClass('stateDown'));\r\n                            })\r\n                                .mouseup(function () {\r\n                                // undo the *down* effect\r\n                                buttonEl.removeClass(theme.getClass('stateDown'));\r\n                            })\r\n                                .hover(function () {\r\n                                // the *hover* effect.\r\n                                // only on buttons that are not the \"active\" tab, or disabled\r\n                                buttonEl\r\n                                    .not('.' + theme.getClass('stateActive'))\r\n                                    .not('.' + theme.getClass('stateDisabled'))\r\n                                    .addClass(theme.getClass('stateHover'));\r\n                            }, function () {\r\n                                // undo the *hover* effect\r\n                                buttonEl\r\n                                    .removeClass(theme.getClass('stateHover'))\r\n                                    .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup\r\n                            });\r\n                            groupChildren = groupChildren.add(buttonEl);\r\n                        }\r\n                    }\r\n                });\r\n                if (isOnlyButtons) {\r\n                    groupChildren\r\n                        .first().addClass(theme.getClass('cornerLeft')).end()\r\n                        .last().addClass(theme.getClass('cornerRight')).end();\r\n                }\r\n                if (groupChildren.length > 1) {\r\n                    groupEl = $('<div/>');\r\n                    if (isOnlyButtons) {\r\n                        groupEl.addClass(theme.getClass('buttonGroup'));\r\n                    }\r\n                    groupEl.append(groupChildren);\r\n                    sectionEl.append(groupEl);\r\n                }\r\n                else {\r\n                    sectionEl.append(groupChildren); // 1 or 0 children\r\n                }\r\n            });\r\n        }\r\n        return sectionEl;\r\n    };\r\n    Toolbar.prototype.updateTitle = function (text) {\r\n        if (this.el) {\r\n            this.el.find('h2').text(text);\r\n        }\r\n    };\r\n    Toolbar.prototype.activateButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .addClass(this.calendar.theme.getClass('stateActive'));\r\n        }\r\n    };\r\n    Toolbar.prototype.deactivateButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .removeClass(this.calendar.theme.getClass('stateActive'));\r\n        }\r\n    };\r\n    Toolbar.prototype.disableButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .prop('disabled', true)\r\n                .addClass(this.calendar.theme.getClass('stateDisabled'));\r\n        }\r\n    };\r\n    Toolbar.prototype.enableButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .prop('disabled', false)\r\n                .removeClass(this.calendar.theme.getClass('stateDisabled'));\r\n        }\r\n    };\r\n    Toolbar.prototype.getViewsWithButtons = function () {\r\n        return this.viewsWithButtons;\r\n    };\r\n    return Toolbar;\r\n}());\r\nexports.default = Toolbar;\r\n\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar options_1 = __webpack_require__(32);\r\nvar locale_1 = __webpack_require__(31);\r\nvar Model_1 = __webpack_require__(48);\r\nvar OptionsManager = /** @class */ (function (_super) {\r\n    tslib_1.__extends(OptionsManager, _super);\r\n    function OptionsManager(_calendar, overrides) {\r\n        var _this = _super.call(this) || this;\r\n        _this._calendar = _calendar;\r\n        _this.overrides = $.extend({}, overrides); // make a copy\r\n        _this.dynamicOverrides = {};\r\n        _this.compute();\r\n        return _this;\r\n    }\r\n    OptionsManager.prototype.add = function (newOptionHash) {\r\n        var optionCnt = 0;\r\n        var optionName;\r\n        this.recordOverrides(newOptionHash); // will trigger this model's watchers\r\n        for (optionName in newOptionHash) {\r\n            optionCnt++;\r\n        }\r\n        // special-case handling of single option change.\r\n        // if only one option change, `optionName` will be its name.\r\n        if (optionCnt === 1) {\r\n            if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\r\n                this._calendar.updateViewSize(true); // isResize=true\r\n                return;\r\n            }\r\n            else if (optionName === 'defaultDate') {\r\n                return; // can't change date this way. use gotoDate instead\r\n            }\r\n            else if (optionName === 'businessHours') {\r\n                return; // this model already reacts to this\r\n            }\r\n            else if (/^(event|select)(Overlap|Constraint|Allow)$/.test(optionName)) {\r\n                return; // doesn't affect rendering. only interactions.\r\n            }\r\n            else if (optionName === 'timezone') {\r\n                this._calendar.view.flash('initialEvents');\r\n                return;\r\n            }\r\n        }\r\n        // catch-all. rerender the header and footer and rebuild/rerender the current view\r\n        this._calendar.renderHeader();\r\n        this._calendar.renderFooter();\r\n        // even non-current views will be affected by this option change. do before rerender\r\n        // TODO: detangle\r\n        this._calendar.viewsByType = {};\r\n        this._calendar.reinitView();\r\n    };\r\n    // Computes the flattened options hash for the calendar and assigns to `this.options`.\r\n    // Assumes this.overrides and this.dynamicOverrides have already been initialized.\r\n    OptionsManager.prototype.compute = function () {\r\n        var locale;\r\n        var localeDefaults;\r\n        var isRTL;\r\n        var dirDefaults;\r\n        var rawOptions;\r\n        locale = util_1.firstDefined(// explicit locale option given?\r\n        this.dynamicOverrides.locale, this.overrides.locale);\r\n        localeDefaults = locale_1.localeOptionHash[locale];\r\n        if (!localeDefaults) {\r\n            locale = options_1.globalDefaults.locale;\r\n            localeDefaults = locale_1.localeOptionHash[locale] || {};\r\n        }\r\n        isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?\r\n        this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);\r\n        dirDefaults = isRTL ? options_1.rtlDefaults : {};\r\n        this.dirDefaults = dirDefaults;\r\n        this.localeDefaults = localeDefaults;\r\n        rawOptions = options_1.mergeOptions([\r\n            options_1.globalDefaults,\r\n            dirDefaults,\r\n            localeDefaults,\r\n            this.overrides,\r\n            this.dynamicOverrides\r\n        ]);\r\n        locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options\r\n        this.reset(rawOptions);\r\n    };\r\n    // stores the new options internally, but does not rerender anything.\r\n    OptionsManager.prototype.recordOverrides = function (newOptionHash) {\r\n        var optionName;\r\n        for (optionName in newOptionHash) {\r\n            this.dynamicOverrides[optionName] = newOptionHash[optionName];\r\n        }\r\n        this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it\r\n        this.compute(); // this.options needs to be recomputed after the dynamic override\r\n    };\r\n    return OptionsManager;\r\n}(Model_1.default));\r\nexports.default = OptionsManager;\r\n\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar util_1 = __webpack_require__(4);\r\nvar options_1 = __webpack_require__(32);\r\nvar locale_1 = __webpack_require__(31);\r\nvar ViewSpecManager = /** @class */ (function () {\r\n    function ViewSpecManager(optionsManager, _calendar) {\r\n        this.optionsManager = optionsManager;\r\n        this._calendar = _calendar;\r\n        this.clearCache();\r\n    }\r\n    ViewSpecManager.prototype.clearCache = function () {\r\n        this.viewSpecCache = {};\r\n    };\r\n    // Gets information about how to create a view. Will use a cache.\r\n    ViewSpecManager.prototype.getViewSpec = function (viewType) {\r\n        var cache = this.viewSpecCache;\r\n        return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\r\n    };\r\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\r\n    // Preference is given to views that have corresponding buttons.\r\n    ViewSpecManager.prototype.getUnitViewSpec = function (unit) {\r\n        var viewTypes;\r\n        var i;\r\n        var spec;\r\n        if ($.inArray(unit, util_1.unitsDesc) !== -1) {\r\n            // put views that have buttons first. there will be duplicates, but oh well\r\n            viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?\r\n            $.each(ViewRegistry_1.viewHash, function (viewType) {\r\n                viewTypes.push(viewType);\r\n            });\r\n            for (i = 0; i < viewTypes.length; i++) {\r\n                spec = this.getViewSpec(viewTypes[i]);\r\n                if (spec) {\r\n                    if (spec.singleUnit === unit) {\r\n                        return spec;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Builds an object with information on how to create a given view\r\n    ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {\r\n        var viewOverrides = this.optionsManager.overrides.views || {};\r\n        var specChain = []; // for the view. lowest to highest priority\r\n        var defaultsChain = []; // for the view. lowest to highest priority\r\n        var overridesChain = []; // for the view. lowest to highest priority\r\n        var viewType = requestedViewType;\r\n        var spec; // for the view\r\n        var overrides; // for the view\r\n        var durationInput;\r\n        var duration;\r\n        var unit;\r\n        // iterate from the specific view definition to a more general one until we hit an actual View class\r\n        while (viewType) {\r\n            spec = ViewRegistry_1.viewHash[viewType];\r\n            overrides = viewOverrides[viewType];\r\n            viewType = null; // clear. might repopulate for another iteration\r\n            if (typeof spec === 'function') {\r\n                spec = { 'class': spec };\r\n            }\r\n            if (spec) {\r\n                specChain.unshift(spec);\r\n                defaultsChain.unshift(spec.defaults || {});\r\n                durationInput = durationInput || spec.duration;\r\n                viewType = viewType || spec.type;\r\n            }\r\n            if (overrides) {\r\n                overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\r\n                durationInput = durationInput || overrides.duration;\r\n                viewType = viewType || overrides.type;\r\n            }\r\n        }\r\n        spec = util_1.mergeProps(specChain);\r\n        spec.type = requestedViewType;\r\n        if (!spec['class']) {\r\n            return false;\r\n        }\r\n        // fall back to top-level `duration` option\r\n        durationInput = durationInput ||\r\n            this.optionsManager.dynamicOverrides.duration ||\r\n            this.optionsManager.overrides.duration;\r\n        if (durationInput) {\r\n            duration = moment.duration(durationInput);\r\n            if (duration.valueOf()) {\r\n                unit = util_1.computeDurationGreatestUnit(duration, durationInput);\r\n                spec.duration = duration;\r\n                spec.durationUnit = unit;\r\n                // view is a single-unit duration, like \"week\" or \"day\"\r\n                // incorporate options for this. lowest priority\r\n                if (duration.as(unit) === 1) {\r\n                    spec.singleUnit = unit;\r\n                    overridesChain.unshift(viewOverrides[unit] || {});\r\n                }\r\n            }\r\n        }\r\n        spec.defaults = options_1.mergeOptions(defaultsChain);\r\n        spec.overrides = options_1.mergeOptions(overridesChain);\r\n        this.buildViewSpecOptions(spec);\r\n        this.buildViewSpecButtonText(spec, requestedViewType);\r\n        return spec;\r\n    };\r\n    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides\r\n    ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {\r\n        var optionsManager = this.optionsManager;\r\n        spec.options = options_1.mergeOptions([\r\n            options_1.globalDefaults,\r\n            spec.defaults,\r\n            optionsManager.dirDefaults,\r\n            optionsManager.localeDefaults,\r\n            optionsManager.overrides,\r\n            spec.overrides,\r\n            optionsManager.dynamicOverrides // dynamically set via setter. highest precedence\r\n        ]);\r\n        locale_1.populateInstanceComputableOptions(spec.options);\r\n    };\r\n    // Computes and assigns a view spec's buttonText-related options\r\n    ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {\r\n        var optionsManager = this.optionsManager;\r\n        // given an options object with a possible `buttonText` hash, lookup the buttonText for the\r\n        // requested view, falling back to a generic unit entry like \"week\" or \"day\"\r\n        function queryButtonText(options) {\r\n            var buttonText = options.buttonText || {};\r\n            return buttonText[requestedViewType] ||\r\n                // view can decide to look up a certain key\r\n                (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\r\n                // a key like \"month\"\r\n                (spec.singleUnit ? buttonText[spec.singleUnit] : null);\r\n        }\r\n        // highest to lowest priority\r\n        spec.buttonTextOverride =\r\n            queryButtonText(optionsManager.dynamicOverrides) ||\r\n                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence\r\n                spec.overrides.buttonText; // `buttonText` for view-specific options is a string\r\n        // highest to lowest priority. mirrors buildViewSpecOptions\r\n        spec.buttonTextDefault =\r\n            queryButtonText(optionsManager.localeDefaults) ||\r\n                queryButtonText(optionsManager.dirDefaults) ||\r\n                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults\r\n                queryButtonText(options_1.globalDefaults) ||\r\n                (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like \"3 days\"\r\n                requestedViewType; // fall back to given view name\r\n    };\r\n    return ViewSpecManager;\r\n}());\r\nexports.default = ViewSpecManager;\r\n\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventPeriod_1 = __webpack_require__(243);\r\nvar ArrayEventSource_1 = __webpack_require__(52);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar EventManager = /** @class */ (function () {\r\n    function EventManager(calendar) {\r\n        this.calendar = calendar;\r\n        this.stickySource = new ArrayEventSource_1.default(calendar);\r\n        this.otherSources = [];\r\n    }\r\n    EventManager.prototype.requestEvents = function (start, end, timezone, force) {\r\n        if (force ||\r\n            !this.currentPeriod ||\r\n            !this.currentPeriod.isWithinRange(start, end) ||\r\n            timezone !== this.currentPeriod.timezone) {\r\n            this.setPeriod(// will change this.currentPeriod\r\n            new EventPeriod_1.default(start, end, timezone));\r\n        }\r\n        return this.currentPeriod.whenReleased();\r\n    };\r\n    // Source Adding/Removing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.addSource = function (eventSource) {\r\n        this.otherSources.push(eventSource);\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.requestSource(eventSource); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeSource = function (doomedSource) {\r\n        util_1.removeExact(this.otherSources, doomedSource);\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.purgeSource(doomedSource); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeAllSources = function () {\r\n        this.otherSources = [];\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.purgeAllSources(); // might release\r\n        }\r\n    };\r\n    // Source Refetching\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.refetchSource = function (eventSource) {\r\n        var currentPeriod = this.currentPeriod;\r\n        if (currentPeriod) {\r\n            currentPeriod.freeze();\r\n            currentPeriod.purgeSource(eventSource);\r\n            currentPeriod.requestSource(eventSource);\r\n            currentPeriod.thaw();\r\n        }\r\n    };\r\n    EventManager.prototype.refetchAllSources = function () {\r\n        var currentPeriod = this.currentPeriod;\r\n        if (currentPeriod) {\r\n            currentPeriod.freeze();\r\n            currentPeriod.purgeAllSources();\r\n            currentPeriod.requestSources(this.getSources());\r\n            currentPeriod.thaw();\r\n        }\r\n    };\r\n    // Source Querying\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.getSources = function () {\r\n        return [this.stickySource].concat(this.otherSources);\r\n    };\r\n    // like querySources, but accepts multple match criteria (like multiple IDs)\r\n    EventManager.prototype.multiQuerySources = function (matchInputs) {\r\n        // coerce into an array\r\n        if (!matchInputs) {\r\n            matchInputs = [];\r\n        }\r\n        else if (!$.isArray(matchInputs)) {\r\n            matchInputs = [matchInputs];\r\n        }\r\n        var matchingSources = [];\r\n        var i;\r\n        // resolve raw inputs to real event source objects\r\n        for (i = 0; i < matchInputs.length; i++) {\r\n            matchingSources.push.apply(// append\r\n            matchingSources, this.querySources(matchInputs[i]));\r\n        }\r\n        return matchingSources;\r\n    };\r\n    // matchInput can either by a real event source object, an ID, or the function/URL for the source.\r\n    // returns an array of matching source objects.\r\n    EventManager.prototype.querySources = function (matchInput) {\r\n        var sources = this.otherSources;\r\n        var i;\r\n        var source;\r\n        // given a proper event source object\r\n        for (i = 0; i < sources.length; i++) {\r\n            source = sources[i];\r\n            if (source === matchInput) {\r\n                return [source];\r\n            }\r\n        }\r\n        // an ID match\r\n        source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));\r\n        if (source) {\r\n            return [source];\r\n        }\r\n        // parse as an event source\r\n        matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);\r\n        if (matchInput) {\r\n            return $.grep(sources, function (source) {\r\n                return isSourcesEquivalent(matchInput, source);\r\n            });\r\n        }\r\n    };\r\n    /*\r\n    ID assumed to already be normalized\r\n    */\r\n    EventManager.prototype.getSourceById = function (id) {\r\n        return $.grep(this.otherSources, function (source) {\r\n            return source.id && source.id === id;\r\n        })[0];\r\n    };\r\n    // Event-Period\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.setPeriod = function (eventPeriod) {\r\n        if (this.currentPeriod) {\r\n            this.unbindPeriod(this.currentPeriod);\r\n            this.currentPeriod = null;\r\n        }\r\n        this.currentPeriod = eventPeriod;\r\n        this.bindPeriod(eventPeriod);\r\n        eventPeriod.requestSources(this.getSources());\r\n    };\r\n    EventManager.prototype.bindPeriod = function (eventPeriod) {\r\n        this.listenTo(eventPeriod, 'release', function (eventsPayload) {\r\n            this.trigger('release', eventsPayload);\r\n        });\r\n    };\r\n    EventManager.prototype.unbindPeriod = function (eventPeriod) {\r\n        this.stopListeningTo(eventPeriod);\r\n    };\r\n    // Event Getting/Adding/Removing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.getEventDefByUid = function (uid) {\r\n        if (this.currentPeriod) {\r\n            return this.currentPeriod.getEventDefByUid(uid);\r\n        }\r\n    };\r\n    EventManager.prototype.addEventDef = function (eventDef, isSticky) {\r\n        if (isSticky) {\r\n            this.stickySource.addEventDef(eventDef);\r\n        }\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.addEventDef(eventDef); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeEventDefsById = function (eventId) {\r\n        this.getSources().forEach(function (eventSource) {\r\n            eventSource.removeEventDefsById(eventId);\r\n        });\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.removeEventDefsById(eventId); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeAllEventDefs = function () {\r\n        this.getSources().forEach(function (eventSource) {\r\n            eventSource.removeAllEventDefs();\r\n        });\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.removeAllEventDefs();\r\n        }\r\n    };\r\n    // Event Mutating\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /*\r\n    Returns an undo function.\r\n    */\r\n    EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {\r\n        var currentPeriod = this.currentPeriod;\r\n        var eventDefs;\r\n        var undoFuncs = [];\r\n        if (currentPeriod) {\r\n            currentPeriod.freeze();\r\n            eventDefs = currentPeriod.getEventDefsById(eventDefId);\r\n            eventDefs.forEach(function (eventDef) {\r\n                // add/remove esp because id might change\r\n                currentPeriod.removeEventDef(eventDef);\r\n                undoFuncs.push(eventDefMutation.mutateSingle(eventDef));\r\n                currentPeriod.addEventDef(eventDef);\r\n            });\r\n            currentPeriod.thaw();\r\n            return function () {\r\n                currentPeriod.freeze();\r\n                for (var i = 0; i < eventDefs.length; i++) {\r\n                    currentPeriod.removeEventDef(eventDefs[i]);\r\n                    undoFuncs[i]();\r\n                    currentPeriod.addEventDef(eventDefs[i]);\r\n                }\r\n                currentPeriod.thaw();\r\n            };\r\n        }\r\n        return function () { };\r\n    };\r\n    /*\r\n    copies and then mutates\r\n    */\r\n    EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {\r\n        var eventDefs = this.getEventDefsById(eventDefId);\r\n        var i;\r\n        var defCopy;\r\n        var allInstances = [];\r\n        for (i = 0; i < eventDefs.length; i++) {\r\n            defCopy = eventDefs[i].clone();\r\n            if (defCopy instanceof SingleEventDef_1.default) {\r\n                eventDefMutation.mutateSingle(defCopy);\r\n                allInstances.push.apply(allInstances, // append\r\n                defCopy.buildInstances());\r\n            }\r\n        }\r\n        return new EventInstanceGroup_1.default(allInstances);\r\n    };\r\n    // Freezing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.freeze = function () {\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.freeze();\r\n        }\r\n    };\r\n    EventManager.prototype.thaw = function () {\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.thaw();\r\n        }\r\n    };\r\n    // methods that simply forward to EventPeriod\r\n    EventManager.prototype.getEventDefsById = function (eventDefId) {\r\n        return this.currentPeriod.getEventDefsById(eventDefId);\r\n    };\r\n    EventManager.prototype.getEventInstances = function () {\r\n        return this.currentPeriod.getEventInstances();\r\n    };\r\n    EventManager.prototype.getEventInstancesWithId = function (eventDefId) {\r\n        return this.currentPeriod.getEventInstancesWithId(eventDefId);\r\n    };\r\n    EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {\r\n        return this.currentPeriod.getEventInstancesWithoutId(eventDefId);\r\n    };\r\n    return EventManager;\r\n}());\r\nexports.default = EventManager;\r\nEmitterMixin_1.default.mixInto(EventManager);\r\nListenerMixin_1.default.mixInto(EventManager);\r\nfunction isSourcesEquivalent(source0, source1) {\r\n    return source0.getPrimitive() === source1.getPrimitive();\r\n}\r\n\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar EventPeriod = /** @class */ (function () {\r\n    function EventPeriod(start, end, timezone) {\r\n        this.pendingCnt = 0;\r\n        this.freezeDepth = 0;\r\n        this.stuntedReleaseCnt = 0;\r\n        this.releaseCnt = 0;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.timezone = timezone;\r\n        this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());\r\n        this.requestsByUid = {};\r\n        this.eventDefsByUid = {};\r\n        this.eventDefsById = {};\r\n        this.eventInstanceGroupsById = {};\r\n    }\r\n    EventPeriod.prototype.isWithinRange = function (start, end) {\r\n        // TODO: use a range util function?\r\n        return !start.isBefore(this.start) && !end.isAfter(this.end);\r\n    };\r\n    // Requesting and Purging\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.requestSources = function (sources) {\r\n        this.freeze();\r\n        for (var i = 0; i < sources.length; i++) {\r\n            this.requestSource(sources[i]);\r\n        }\r\n        this.thaw();\r\n    };\r\n    EventPeriod.prototype.requestSource = function (source) {\r\n        var _this = this;\r\n        var request = { source: source, status: 'pending', eventDefs: null };\r\n        this.requestsByUid[source.uid] = request;\r\n        this.pendingCnt += 1;\r\n        source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {\r\n            if (request.status !== 'cancelled') {\r\n                request.status = 'completed';\r\n                request.eventDefs = eventDefs;\r\n                _this.addEventDefs(eventDefs);\r\n                _this.pendingCnt--;\r\n                _this.tryRelease();\r\n            }\r\n        }, function () {\r\n            if (request.status !== 'cancelled') {\r\n                request.status = 'failed';\r\n                _this.pendingCnt--;\r\n                _this.tryRelease();\r\n            }\r\n        });\r\n    };\r\n    EventPeriod.prototype.purgeSource = function (source) {\r\n        var request = this.requestsByUid[source.uid];\r\n        if (request) {\r\n            delete this.requestsByUid[source.uid];\r\n            if (request.status === 'pending') {\r\n                request.status = 'cancelled';\r\n                this.pendingCnt--;\r\n                this.tryRelease();\r\n            }\r\n            else if (request.status === 'completed') {\r\n                request.eventDefs.forEach(this.removeEventDef.bind(this));\r\n            }\r\n        }\r\n    };\r\n    EventPeriod.prototype.purgeAllSources = function () {\r\n        var requestsByUid = this.requestsByUid;\r\n        var uid;\r\n        var request;\r\n        var completedCnt = 0;\r\n        for (uid in requestsByUid) {\r\n            request = requestsByUid[uid];\r\n            if (request.status === 'pending') {\r\n                request.status = 'cancelled';\r\n            }\r\n            else if (request.status === 'completed') {\r\n                completedCnt++;\r\n            }\r\n        }\r\n        this.requestsByUid = {};\r\n        this.pendingCnt = 0;\r\n        if (completedCnt) {\r\n            this.removeAllEventDefs(); // might release\r\n        }\r\n    };\r\n    // Event Definitions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {\r\n        return this.eventDefsByUid[eventDefUid];\r\n    };\r\n    EventPeriod.prototype.getEventDefsById = function (eventDefId) {\r\n        var a = this.eventDefsById[eventDefId];\r\n        if (a) {\r\n            return a.slice(); // clone\r\n        }\r\n        return [];\r\n    };\r\n    EventPeriod.prototype.addEventDefs = function (eventDefs) {\r\n        for (var i = 0; i < eventDefs.length; i++) {\r\n            this.addEventDef(eventDefs[i]);\r\n        }\r\n    };\r\n    EventPeriod.prototype.addEventDef = function (eventDef) {\r\n        var eventDefsById = this.eventDefsById;\r\n        var eventDefId = eventDef.id;\r\n        var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);\r\n        var eventInstances = eventDef.buildInstances(this.unzonedRange);\r\n        var i;\r\n        eventDefs.push(eventDef);\r\n        this.eventDefsByUid[eventDef.uid] = eventDef;\r\n        for (i = 0; i < eventInstances.length; i++) {\r\n            this.addEventInstance(eventInstances[i], eventDefId);\r\n        }\r\n    };\r\n    EventPeriod.prototype.removeEventDefsById = function (eventDefId) {\r\n        var _this = this;\r\n        this.getEventDefsById(eventDefId).forEach(function (eventDef) {\r\n            _this.removeEventDef(eventDef);\r\n        });\r\n    };\r\n    EventPeriod.prototype.removeAllEventDefs = function () {\r\n        var isEmpty = $.isEmptyObject(this.eventDefsByUid);\r\n        this.eventDefsByUid = {};\r\n        this.eventDefsById = {};\r\n        this.eventInstanceGroupsById = {};\r\n        if (!isEmpty) {\r\n            this.tryRelease();\r\n        }\r\n    };\r\n    EventPeriod.prototype.removeEventDef = function (eventDef) {\r\n        var eventDefsById = this.eventDefsById;\r\n        var eventDefs = eventDefsById[eventDef.id];\r\n        delete this.eventDefsByUid[eventDef.uid];\r\n        if (eventDefs) {\r\n            util_1.removeExact(eventDefs, eventDef);\r\n            if (!eventDefs.length) {\r\n                delete eventDefsById[eventDef.id];\r\n            }\r\n            this.removeEventInstancesForDef(eventDef);\r\n        }\r\n    };\r\n    // Event Instances\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.getEventInstances = function () {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var eventInstances = [];\r\n        var id;\r\n        for (id in eventInstanceGroupsById) {\r\n            eventInstances.push.apply(eventInstances, // append\r\n            eventInstanceGroupsById[id].eventInstances);\r\n        }\r\n        return eventInstances;\r\n    };\r\n    EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {\r\n        var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];\r\n        if (eventInstanceGroup) {\r\n            return eventInstanceGroup.eventInstances.slice(); // clone\r\n        }\r\n        return [];\r\n    };\r\n    EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var matchingInstances = [];\r\n        var id;\r\n        for (id in eventInstanceGroupsById) {\r\n            if (id !== eventDefId) {\r\n                matchingInstances.push.apply(matchingInstances, // append\r\n                eventInstanceGroupsById[id].eventInstances);\r\n            }\r\n        }\r\n        return matchingInstances;\r\n    };\r\n    EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||\r\n            (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());\r\n        eventInstanceGroup.eventInstances.push(eventInstance);\r\n        this.tryRelease();\r\n    };\r\n    EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];\r\n        var removeCnt;\r\n        if (eventInstanceGroup) {\r\n            removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {\r\n                return currentEventInstance.def === eventDef;\r\n            });\r\n            if (!eventInstanceGroup.eventInstances.length) {\r\n                delete eventInstanceGroupsById[eventDef.id];\r\n            }\r\n            if (removeCnt) {\r\n                this.tryRelease();\r\n            }\r\n        }\r\n    };\r\n    // Releasing and Freezing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.tryRelease = function () {\r\n        if (!this.pendingCnt) {\r\n            if (!this.freezeDepth) {\r\n                this.release();\r\n            }\r\n            else {\r\n                this.stuntedReleaseCnt++;\r\n            }\r\n        }\r\n    };\r\n    EventPeriod.prototype.release = function () {\r\n        this.releaseCnt++;\r\n        this.trigger('release', this.eventInstanceGroupsById);\r\n    };\r\n    EventPeriod.prototype.whenReleased = function () {\r\n        var _this = this;\r\n        if (this.releaseCnt) {\r\n            return Promise_1.default.resolve(this.eventInstanceGroupsById);\r\n        }\r\n        else {\r\n            return Promise_1.default.construct(function (onResolve) {\r\n                _this.one('release', onResolve);\r\n            });\r\n        }\r\n    };\r\n    EventPeriod.prototype.freeze = function () {\r\n        if (!(this.freezeDepth++)) {\r\n            this.stuntedReleaseCnt = 0;\r\n        }\r\n    };\r\n    EventPeriod.prototype.thaw = function () {\r\n        if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {\r\n            this.release();\r\n        }\r\n    };\r\n    return EventPeriod;\r\n}());\r\nexports.default = EventPeriod;\r\nEmitterMixin_1.default.mixInto(EventPeriod);\r\n\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\n/* Creates a clone of an element and lets it track the mouse as it moves\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar MouseFollower = /** @class */ (function () {\r\n    function MouseFollower(sourceEl, options) {\r\n        this.isFollowing = false;\r\n        this.isHidden = false;\r\n        this.isAnimating = false; // doing the revert animation?\r\n        this.options = options = options || {};\r\n        this.sourceEl = sourceEl;\r\n        this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\r\n    }\r\n    // Causes the element to start following the mouse\r\n    MouseFollower.prototype.start = function (ev) {\r\n        if (!this.isFollowing) {\r\n            this.isFollowing = true;\r\n            this.y0 = util_1.getEvY(ev);\r\n            this.x0 = util_1.getEvX(ev);\r\n            this.topDelta = 0;\r\n            this.leftDelta = 0;\r\n            if (!this.isHidden) {\r\n                this.updatePosition();\r\n            }\r\n            if (util_1.getEvIsTouch(ev)) {\r\n                this.listenTo($(document), 'touchmove', this.handleMove);\r\n            }\r\n            else {\r\n                this.listenTo($(document), 'mousemove', this.handleMove);\r\n            }\r\n        }\r\n    };\r\n    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\r\n    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\r\n    MouseFollower.prototype.stop = function (shouldRevert, callback) {\r\n        var _this = this;\r\n        var revertDuration = this.options.revertDuration;\r\n        var complete = function () {\r\n            _this.isAnimating = false;\r\n            _this.removeElement();\r\n            _this.top0 = _this.left0 = null; // reset state for future updatePosition calls\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        };\r\n        if (this.isFollowing && !this.isAnimating) {\r\n            this.isFollowing = false;\r\n            this.stopListeningTo($(document));\r\n            if (shouldRevert && revertDuration && !this.isHidden) {\r\n                this.isAnimating = true;\r\n                this.el.animate({\r\n                    top: this.top0,\r\n                    left: this.left0\r\n                }, {\r\n                    duration: revertDuration,\r\n                    complete: complete\r\n                });\r\n            }\r\n            else {\r\n                complete();\r\n            }\r\n        }\r\n    };\r\n    // Gets the tracking element. Create it if necessary\r\n    MouseFollower.prototype.getEl = function () {\r\n        var el = this.el;\r\n        if (!el) {\r\n            el = this.el = this.sourceEl.clone()\r\n                .addClass(this.options.additionalClass || '')\r\n                .css({\r\n                position: 'absolute',\r\n                visibility: '',\r\n                display: this.isHidden ? 'none' : '',\r\n                margin: 0,\r\n                right: 'auto',\r\n                bottom: 'auto',\r\n                width: this.sourceEl.width(),\r\n                height: this.sourceEl.height(),\r\n                opacity: this.options.opacity || '',\r\n                zIndex: this.options.zIndex\r\n            });\r\n            // we don't want long taps or any mouse interaction causing selection/menus.\r\n            // would use preventSelection(), but that prevents selectstart, causing problems.\r\n            el.addClass('fc-unselectable');\r\n            el.appendTo(this.parentEl);\r\n        }\r\n        return el;\r\n    };\r\n    // Removes the tracking element if it has already been created\r\n    MouseFollower.prototype.removeElement = function () {\r\n        if (this.el) {\r\n            this.el.remove();\r\n            this.el = null;\r\n        }\r\n    };\r\n    // Update the CSS position of the tracking element\r\n    MouseFollower.prototype.updatePosition = function () {\r\n        var sourceOffset;\r\n        var origin;\r\n        this.getEl(); // ensure this.el\r\n        // make sure origin info was computed\r\n        if (this.top0 == null) {\r\n            sourceOffset = this.sourceEl.offset();\r\n            origin = this.el.offsetParent().offset();\r\n            this.top0 = sourceOffset.top - origin.top;\r\n            this.left0 = sourceOffset.left - origin.left;\r\n        }\r\n        this.el.css({\r\n            top: this.top0 + this.topDelta,\r\n            left: this.left0 + this.leftDelta\r\n        });\r\n    };\r\n    // Gets called when the user moves the mouse\r\n    MouseFollower.prototype.handleMove = function (ev) {\r\n        this.topDelta = util_1.getEvY(ev) - this.y0;\r\n        this.leftDelta = util_1.getEvX(ev) - this.x0;\r\n        if (!this.isHidden) {\r\n            this.updatePosition();\r\n        }\r\n    };\r\n    // Temporarily makes the tracking element invisible. Can be called before following starts\r\n    MouseFollower.prototype.hide = function () {\r\n        if (!this.isHidden) {\r\n            this.isHidden = true;\r\n            if (this.el) {\r\n                this.el.hide();\r\n            }\r\n        }\r\n    };\r\n    // Show the tracking element after it has been temporarily hidden\r\n    MouseFollower.prototype.show = function () {\r\n        if (this.isHidden) {\r\n            this.isHidden = false;\r\n            this.updatePosition();\r\n            this.getEl().show();\r\n        }\r\n    };\r\n    return MouseFollower;\r\n}());\r\nexports.default = MouseFollower;\r\nListenerMixin_1.default.mixInto(MouseFollower);\r\n\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar DateClicking = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DateClicking, _super);\r\n    /*\r\n    component must implement:\r\n      - bindDateHandlerToEl\r\n      - getSafeHitFootprint\r\n      - getHitEl\r\n    */\r\n    function DateClicking(component) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.dragListener = _this.buildDragListener();\r\n        return _this;\r\n    }\r\n    DateClicking.prototype.end = function () {\r\n        this.dragListener.endInteraction();\r\n    };\r\n    DateClicking.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        var dragListener = this.dragListener;\r\n        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {\r\n            if (!component.shouldIgnoreMouse()) {\r\n                dragListener.startInteraction(ev);\r\n            }\r\n        });\r\n        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {\r\n            if (!component.shouldIgnoreTouch()) {\r\n                dragListener.startInteraction(ev);\r\n            }\r\n        });\r\n    };\r\n    // Creates a listener that tracks the user's drag across day elements, for day clicking.\r\n    DateClicking.prototype.buildDragListener = function () {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var dayClickHit; // null if invalid dayClick\r\n        var dragListener = new HitDragListener_1.default(component, {\r\n            scroll: this.opt('dragScroll'),\r\n            interactionStart: function () {\r\n                dayClickHit = dragListener.origHit;\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                // if user dragged to another cell at any point, it can no longer be a dayClick\r\n                if (!isOrig) {\r\n                    dayClickHit = null;\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                dayClickHit = null;\r\n            },\r\n            interactionEnd: function (ev, isCancelled) {\r\n                var componentFootprint;\r\n                if (!isCancelled && dayClickHit) {\r\n                    componentFootprint = component.getSafeHitFootprint(dayClickHit);\r\n                    if (componentFootprint) {\r\n                        _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        // because dragListener won't be called with any time delay, \"dragging\" will begin immediately,\r\n        // which will kill any touchmoving/scrolling. Prevent this.\r\n        dragListener.shouldCancelTouchScroll = false;\r\n        dragListener.scrollAlwaysKills = true;\r\n        return dragListener;\r\n    };\r\n    return DateClicking;\r\n}(Interaction_1.default));\r\nexports.default = DateClicking;\r\n\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer_1 = __webpack_require__(42);\r\n/*\r\nOnly handles foreground segs.\r\nDoes not own rendering. Use for low-level util methods by TimeGrid.\r\n*/\r\nvar TimeGridEventRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGridEventRenderer, _super);\r\n    function TimeGridEventRenderer(timeGrid, fillRenderer) {\r\n        var _this = _super.call(this, timeGrid, fillRenderer) || this;\r\n        _this.timeGrid = timeGrid;\r\n        return _this;\r\n    }\r\n    TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {\r\n        this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);\r\n    };\r\n    // Given an array of foreground segments, render a DOM element for each, computes position,\r\n    // and attaches to the column inner-container elements.\r\n    TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {\r\n        var segsByCol;\r\n        var col;\r\n        segsByCol = this.timeGrid.groupSegsByCol(segs);\r\n        for (col = 0; col < this.timeGrid.colCnt; col++) {\r\n            this.updateFgSegCoords(segsByCol[col]);\r\n        }\r\n        this.timeGrid.attachSegsByCol(segsByCol, containerEls);\r\n    };\r\n    TimeGridEventRenderer.prototype.unrenderFgSegs = function () {\r\n        if (this.fgSegs) {\r\n            this.fgSegs.forEach(function (seg) {\r\n                seg.el.remove();\r\n            });\r\n        }\r\n    };\r\n    // Computes a default event time formatting string if `timeFormat` is not explicitly defined\r\n    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\r\n    };\r\n    // Computes a default `displayEventEnd` value if one is not expliclty defined\r\n    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {\r\n        return true;\r\n    };\r\n    // Renders the HTML for a single event segment's default rendering\r\n    TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var componentFootprint = seg.footprint.componentFootprint;\r\n        var isAllDay = componentFootprint.isAllDay;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var isDraggable = view.isEventDefDraggable(eventDef);\r\n        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);\r\n        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\r\n        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\r\n        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));\r\n        var timeText;\r\n        var fullTimeText; // more verbose time text. for the print stylesheet\r\n        var startTimeText; // just the start time text\r\n        classes.unshift('fc-time-grid-event', 'fc-v-event');\r\n        // if the event appears to span more than one day...\r\n        if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\r\n            // Don't display time text on segments that run entirely through a day.\r\n            // That would appear as midnight-midnight and would look dumb.\r\n            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\r\n            if (seg.isStart || seg.isEnd) {\r\n                var zonedStart = calendar.msToMoment(seg.startMs);\r\n                var zonedEnd = calendar.msToMoment(seg.endMs);\r\n                timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);\r\n                fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');\r\n                startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false\r\n            }\r\n        }\r\n        else {\r\n            // Display the normal time text for the *event's* times\r\n            timeText = this.getTimeText(seg.footprint);\r\n            fullTimeText = this.getTimeText(seg.footprint, 'LT');\r\n            startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false\r\n        }\r\n        return '<a class=\"' + classes.join(' ') + '\"' +\r\n            (eventDef.url ?\r\n                ' href=\"' + util_1.htmlEscape(eventDef.url) + '\"' :\r\n                '') +\r\n            (skinCss ?\r\n                ' style=\"' + skinCss + '\"' :\r\n                '') +\r\n            '>' +\r\n            '<div class=\"fc-content\">' +\r\n            (timeText ?\r\n                '<div class=\"fc-time\"' +\r\n                    ' data-start=\"' + util_1.htmlEscape(startTimeText) + '\"' +\r\n                    ' data-full=\"' + util_1.htmlEscape(fullTimeText) + '\"' +\r\n                    '>' +\r\n                    '<span>' + util_1.htmlEscape(timeText) + '</span>' +\r\n                    '</div>' :\r\n                '') +\r\n            (eventDef.title ?\r\n                '<div class=\"fc-title\">' +\r\n                    util_1.htmlEscape(eventDef.title) +\r\n                    '</div>' :\r\n                '') +\r\n            '</div>' +\r\n            '<div class=\"fc-bg\"/>' +\r\n            /* TODO: write CSS for this\r\n            (isResizableFromStart ?\r\n              '<div class=\"fc-resizer fc-start-resizer\" />' :\r\n              ''\r\n              ) +\r\n            */\r\n            (isResizableFromEnd ?\r\n                '<div class=\"fc-resizer fc-end-resizer\" />' :\r\n                '') +\r\n            '</a>';\r\n    };\r\n    // Given segments that are assumed to all live in the *same column*,\r\n    // compute their verical/horizontal coordinates and assign to their elements.\r\n    TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {\r\n        this.timeGrid.computeSegVerticals(segs); // horizontals relies on this\r\n        this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\r\n        this.timeGrid.assignSegVerticals(segs);\r\n        this.assignFgSegHorizontals(segs);\r\n    };\r\n    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\r\n    // NOTE: Also reorders the given array by date!\r\n    TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {\r\n        var levels;\r\n        var level0;\r\n        var i;\r\n        this.sortEventSegs(segs); // order by certain criteria\r\n        levels = buildSlotSegLevels(segs);\r\n        computeForwardSlotSegs(levels);\r\n        if ((level0 = levels[0])) {\r\n            for (i = 0; i < level0.length; i++) {\r\n                computeSlotSegPressures(level0[i]);\r\n            }\r\n            for (i = 0; i < level0.length; i++) {\r\n                this.computeFgSegForwardBack(level0[i], 0, 0);\r\n            }\r\n        }\r\n    };\r\n    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\r\n    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\r\n    // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\r\n    //\r\n    // The segment might be part of a \"series\", which means consecutive segments with the same pressure\r\n    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\r\n    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\r\n    // coordinate of the first segment in the series.\r\n    TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {\r\n        var forwardSegs = seg.forwardSegs;\r\n        var i;\r\n        if (seg.forwardCoord === undefined) {\r\n            if (!forwardSegs.length) {\r\n                // if there are no forward segments, this segment should butt up against the edge\r\n                seg.forwardCoord = 1;\r\n            }\r\n            else {\r\n                // sort highest pressure first\r\n                this.sortForwardSegs(forwardSegs);\r\n                // this segment's forwardCoord will be calculated from the backwardCoord of the\r\n                // highest-pressure forward segment.\r\n                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\r\n                seg.forwardCoord = forwardSegs[0].backwardCoord;\r\n            }\r\n            // calculate the backwardCoord from the forwardCoord. consider the series\r\n            seg.backwardCoord = seg.forwardCoord -\r\n                (seg.forwardCoord - seriesBackwardCoord) / // available width for series\r\n                    (seriesBackwardPressure + 1); // # of segments in the series\r\n            // use this segment's coordinates to computed the coordinates of the less-pressurized\r\n            // forward segments\r\n            for (i = 0; i < forwardSegs.length; i++) {\r\n                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\r\n            }\r\n        }\r\n    };\r\n    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {\r\n        forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));\r\n    };\r\n    // A cmp function for determining which forward segment to rely on more when computing coordinates.\r\n    TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {\r\n        // put higher-pressure first\r\n        return seg2.forwardPressure - seg1.forwardPressure ||\r\n            // put segments that are closer to initial edge first (and favor ones with no coords yet)\r\n            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\r\n            // do normal sorting...\r\n            this.compareEventSegs(seg1, seg2);\r\n    };\r\n    // Given foreground event segments that have already had their position coordinates computed,\r\n    // assigns position-related CSS values to their elements.\r\n    TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            seg.el.css(this.generateFgSegHorizontalCss(seg));\r\n            // if the height is short, add a className for alternate styling\r\n            if (seg.bottom - seg.top < 30) {\r\n                seg.el.addClass('fc-short');\r\n            }\r\n        }\r\n    };\r\n    // Generates an object with CSS properties/values that should be applied to an event segment element.\r\n    // Contains important positioning-related properties that should be applied to any event element, customized or not.\r\n    TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {\r\n        var shouldOverlap = this.opt('slotEventOverlap');\r\n        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\r\n        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\r\n        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first\r\n        var isRTL = this.timeGrid.isRTL;\r\n        var left; // amount of space from left edge, a fraction of the total width\r\n        var right; // amount of space from right edge, a fraction of the total width\r\n        if (shouldOverlap) {\r\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\r\n            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\r\n        }\r\n        if (isRTL) {\r\n            left = 1 - forwardCoord;\r\n            right = backwardCoord;\r\n        }\r\n        else {\r\n            left = backwardCoord;\r\n            right = 1 - forwardCoord;\r\n        }\r\n        props.zIndex = seg.level + 1; // convert from 0-base to 1-based\r\n        props.left = left * 100 + '%';\r\n        props.right = right * 100 + '%';\r\n        if (shouldOverlap && seg.forwardPressure) {\r\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\r\n            props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\r\n        }\r\n        return props;\r\n    };\r\n    return TimeGridEventRenderer;\r\n}(EventRenderer_1.default));\r\nexports.default = TimeGridEventRenderer;\r\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\r\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\r\nfunction buildSlotSegLevels(segs) {\r\n    var levels = [];\r\n    var i;\r\n    var seg;\r\n    var j;\r\n    for (i = 0; i < segs.length; i++) {\r\n        seg = segs[i];\r\n        // go through all the levels and stop on the first level where there are no collisions\r\n        for (j = 0; j < levels.length; j++) {\r\n            if (!computeSlotSegCollisions(seg, levels[j]).length) {\r\n                break;\r\n            }\r\n        }\r\n        seg.level = j;\r\n        (levels[j] || (levels[j] = [])).push(seg);\r\n    }\r\n    return levels;\r\n}\r\n// For every segment, figure out the other segments that are in subsequent\r\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\r\nfunction computeForwardSlotSegs(levels) {\r\n    var i;\r\n    var level;\r\n    var j;\r\n    var seg;\r\n    var k;\r\n    for (i = 0; i < levels.length; i++) {\r\n        level = levels[i];\r\n        for (j = 0; j < level.length; j++) {\r\n            seg = level[j];\r\n            seg.forwardSegs = [];\r\n            for (k = i + 1; k < levels.length; k++) {\r\n                computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\r\n            }\r\n        }\r\n    }\r\n}\r\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\r\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\r\nfunction computeSlotSegPressures(seg) {\r\n    var forwardSegs = seg.forwardSegs;\r\n    var forwardPressure = 0;\r\n    var i;\r\n    var forwardSeg;\r\n    if (seg.forwardPressure === undefined) {\r\n        for (i = 0; i < forwardSegs.length; i++) {\r\n            forwardSeg = forwardSegs[i];\r\n            // figure out the child's maximum forward path\r\n            computeSlotSegPressures(forwardSeg);\r\n            // either use the existing maximum, or use the child's forward pressure\r\n            // plus one (for the forwardSeg itself)\r\n            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\r\n        }\r\n        seg.forwardPressure = forwardPressure;\r\n    }\r\n}\r\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\r\n// Append into an optionally-supplied `results` array and return.\r\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\r\n    if (results === void 0) { results = []; }\r\n    for (var i = 0; i < otherSegs.length; i++) {\r\n        if (isSlotSegCollision(seg, otherSegs[i])) {\r\n            results.push(otherSegs[i]);\r\n        }\r\n    }\r\n    return results;\r\n}\r\n// Do these segments occupy the same vertical space?\r\nfunction isSlotSegCollision(seg1, seg2) {\r\n    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\r\n}\r\n\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar HelperRenderer_1 = __webpack_require__(58);\r\nvar TimeGridHelperRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGridHelperRenderer, _super);\r\n    function TimeGridHelperRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\r\n        var helperNodes = [];\r\n        var i;\r\n        var seg;\r\n        var sourceEl;\r\n        // TODO: not good to call eventRenderer this way\r\n        this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);\r\n        // Try to make the segment that is in the same row as sourceSeg look the same\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            if (sourceSeg && sourceSeg.col === seg.col) {\r\n                sourceEl = sourceSeg.el;\r\n                seg.el.css({\r\n                    left: sourceEl.css('left'),\r\n                    right: sourceEl.css('right'),\r\n                    'margin-left': sourceEl.css('margin-left'),\r\n                    'margin-right': sourceEl.css('margin-right')\r\n                });\r\n            }\r\n            helperNodes.push(seg.el[0]);\r\n        }\r\n        return $(helperNodes); // must return the elements rendered\r\n    };\r\n    return TimeGridHelperRenderer;\r\n}(HelperRenderer_1.default));\r\nexports.default = TimeGridHelperRenderer;\r\n\n\n/***/ }),\n/* 248 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar FillRenderer_1 = __webpack_require__(57);\r\nvar TimeGridFillRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGridFillRenderer, _super);\r\n    function TimeGridFillRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {\r\n        var timeGrid = this.component;\r\n        var containerEls;\r\n        // TODO: more efficient lookup\r\n        if (type === 'bgEvent') {\r\n            containerEls = timeGrid.bgContainerEls;\r\n        }\r\n        else if (type === 'businessHours') {\r\n            containerEls = timeGrid.businessContainerEls;\r\n        }\r\n        else if (type === 'highlight') {\r\n            containerEls = timeGrid.highlightContainerEls;\r\n        }\r\n        timeGrid.updateSegVerticals(segs);\r\n        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);\r\n        return segs.map(function (seg) {\r\n            return seg.el[0];\r\n        });\r\n    };\r\n    return TimeGridFillRenderer;\r\n}(FillRenderer_1.default));\r\nexports.default = TimeGridFillRenderer;\r\n\n\n/***/ }),\n/* 249 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* A rectangular panel that is absolutely positioned over other content\r\n------------------------------------------------------------------------------------------------------------------------\r\nOptions:\r\n  - className (string)\r\n  - content (HTML string or jQuery element set)\r\n  - parentEl\r\n  - top\r\n  - left\r\n  - right (the x coord of where the right edge should be. not a \"CSS\" right)\r\n  - autoHide (boolean)\r\n  - show (callback)\r\n  - hide (callback)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar Popover = /** @class */ (function () {\r\n    function Popover(options) {\r\n        this.isHidden = true;\r\n        this.margin = 10; // the space required between the popover and the edges of the scroll container\r\n        this.options = options || {};\r\n    }\r\n    // Shows the popover on the specified position. Renders it if not already\r\n    Popover.prototype.show = function () {\r\n        if (this.isHidden) {\r\n            if (!this.el) {\r\n                this.render();\r\n            }\r\n            this.el.show();\r\n            this.position();\r\n            this.isHidden = false;\r\n            this.trigger('show');\r\n        }\r\n    };\r\n    // Hides the popover, through CSS, but does not remove it from the DOM\r\n    Popover.prototype.hide = function () {\r\n        if (!this.isHidden) {\r\n            this.el.hide();\r\n            this.isHidden = true;\r\n            this.trigger('hide');\r\n        }\r\n    };\r\n    // Creates `this.el` and renders content inside of it\r\n    Popover.prototype.render = function () {\r\n        var _this = this;\r\n        var options = this.options;\r\n        this.el = $('<div class=\"fc-popover\"/>')\r\n            .addClass(options.className || '')\r\n            .css({\r\n            // position initially to the top left to avoid creating scrollbars\r\n            top: 0,\r\n            left: 0\r\n        })\r\n            .append(options.content)\r\n            .appendTo(options.parentEl);\r\n        // when a click happens on anything inside with a 'fc-close' className, hide the popover\r\n        this.el.on('click', '.fc-close', function () {\r\n            _this.hide();\r\n        });\r\n        if (options.autoHide) {\r\n            this.listenTo($(document), 'mousedown', this.documentMousedown);\r\n        }\r\n    };\r\n    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\r\n    Popover.prototype.documentMousedown = function (ev) {\r\n        // only hide the popover if the click happened outside the popover\r\n        if (this.el && !$(ev.target).closest(this.el).length) {\r\n            this.hide();\r\n        }\r\n    };\r\n    // Hides and unregisters any handlers\r\n    Popover.prototype.removeElement = function () {\r\n        this.hide();\r\n        if (this.el) {\r\n            this.el.remove();\r\n            this.el = null;\r\n        }\r\n        this.stopListeningTo($(document), 'mousedown');\r\n    };\r\n    // Positions the popover optimally, using the top/left/right options\r\n    Popover.prototype.position = function () {\r\n        var options = this.options;\r\n        var origin = this.el.offsetParent().offset();\r\n        var width = this.el.outerWidth();\r\n        var height = this.el.outerHeight();\r\n        var windowEl = $(window);\r\n        var viewportEl = util_1.getScrollParent(this.el);\r\n        var viewportTop;\r\n        var viewportLeft;\r\n        var viewportOffset;\r\n        var top; // the \"position\" (not \"offset\") values for the popover\r\n        var left; //\r\n        // compute top and left\r\n        top = options.top || 0;\r\n        if (options.left !== undefined) {\r\n            left = options.left;\r\n        }\r\n        else if (options.right !== undefined) {\r\n            left = options.right - width; // derive the left value from the right value\r\n        }\r\n        else {\r\n            left = 0;\r\n        }\r\n        if (viewportEl.is(window) || viewportEl.is(document)) {\r\n            viewportEl = windowEl;\r\n            viewportTop = 0; // the window is always at the top left\r\n            viewportLeft = 0; // (and .offset() won't work if called here)\r\n        }\r\n        else {\r\n            viewportOffset = viewportEl.offset();\r\n            viewportTop = viewportOffset.top;\r\n            viewportLeft = viewportOffset.left;\r\n        }\r\n        // if the window is scrolled, it causes the visible area to be further down\r\n        viewportTop += windowEl.scrollTop();\r\n        viewportLeft += windowEl.scrollLeft();\r\n        // constrain to the view port. if constrained by two edges, give precedence to top/left\r\n        if (options.viewportConstrain !== false) {\r\n            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\r\n            top = Math.max(top, viewportTop + this.margin);\r\n            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\r\n            left = Math.max(left, viewportLeft + this.margin);\r\n        }\r\n        this.el.css({\r\n            top: top - origin.top,\r\n            left: left - origin.left\r\n        });\r\n    };\r\n    // Triggers a callback. Calls a function in the option hash of the same name.\r\n    // Arguments beyond the first `name` are forwarded on.\r\n    // TODO: better code reuse for this. Repeat code\r\n    Popover.prototype.trigger = function (name) {\r\n        if (this.options[name]) {\r\n            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\r\n        }\r\n    };\r\n    return Popover;\r\n}());\r\nexports.default = Popover;\r\nListenerMixin_1.default.mixInto(Popover);\r\n\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer_1 = __webpack_require__(42);\r\n/* Event-rendering methods for the DayGrid class\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar DayGridEventRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGridEventRenderer, _super);\r\n    function DayGridEventRenderer(dayGrid, fillRenderer) {\r\n        var _this = _super.call(this, dayGrid, fillRenderer) || this;\r\n        _this.dayGrid = dayGrid;\r\n        return _this;\r\n    }\r\n    DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {\r\n        // don't render timed background events\r\n        eventRanges = $.grep(eventRanges, function (eventRange) {\r\n            return eventRange.eventDef.isAllDay();\r\n        });\r\n        _super.prototype.renderBgRanges.call(this, eventRanges);\r\n    };\r\n    // Renders the given foreground event segments onto the grid\r\n    DayGridEventRenderer.prototype.renderFgSegs = function (segs) {\r\n        var rowStructs = this.rowStructs = this.renderSegRows(segs);\r\n        // append to each row's content skeleton\r\n        this.dayGrid.rowEls.each(function (i, rowNode) {\r\n            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);\r\n        });\r\n    };\r\n    // Unrenders all currently rendered foreground event segments\r\n    DayGridEventRenderer.prototype.unrenderFgSegs = function () {\r\n        var rowStructs = this.rowStructs || [];\r\n        var rowStruct;\r\n        while ((rowStruct = rowStructs.pop())) {\r\n            rowStruct.tbodyEl.remove();\r\n        }\r\n        this.rowStructs = null;\r\n    };\r\n    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\r\n    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\r\n    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\r\n    DayGridEventRenderer.prototype.renderSegRows = function (segs) {\r\n        var rowStructs = [];\r\n        var segRows;\r\n        var row;\r\n        segRows = this.groupSegRows(segs); // group into nested arrays\r\n        // iterate each row of segment groupings\r\n        for (row = 0; row < segRows.length; row++) {\r\n            rowStructs.push(this.renderSegRow(row, segRows[row]));\r\n        }\r\n        return rowStructs;\r\n    };\r\n    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\r\n    // the segments. Returns object with a bunch of internal data about how the render was calculated.\r\n    // NOTE: modifies rowSegs\r\n    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {\r\n        var colCnt = this.dayGrid.colCnt;\r\n        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\r\n        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\r\n        var tbody = $('<tbody/>');\r\n        var segMatrix = []; // lookup for which segments are rendered into which level+col cells\r\n        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\r\n        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\r\n        var i;\r\n        var levelSegs;\r\n        var col;\r\n        var tr;\r\n        var j;\r\n        var seg;\r\n        var td;\r\n        // populates empty cells from the current column (`col`) to `endCol`\r\n        function emptyCellsUntil(endCol) {\r\n            while (col < endCol) {\r\n                // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\r\n                td = (loneCellMatrix[i - 1] || [])[col];\r\n                if (td) {\r\n                    td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);\r\n                }\r\n                else {\r\n                    td = $('<td/>');\r\n                    tr.append(td);\r\n                }\r\n                cellMatrix[i][col] = td;\r\n                loneCellMatrix[i][col] = td;\r\n                col++;\r\n            }\r\n        }\r\n        for (i = 0; i < levelCnt; i++) {\r\n            levelSegs = segLevels[i];\r\n            col = 0;\r\n            tr = $('<tr/>');\r\n            segMatrix.push([]);\r\n            cellMatrix.push([]);\r\n            loneCellMatrix.push([]);\r\n            // levelCnt might be 1 even though there are no actual levels. protect against this.\r\n            // this single empty row is useful for styling.\r\n            if (levelSegs) {\r\n                for (j = 0; j < levelSegs.length; j++) {\r\n                    seg = levelSegs[j];\r\n                    emptyCellsUntil(seg.leftCol);\r\n                    // create a container that occupies or more columns. append the event element.\r\n                    td = $('<td class=\"fc-event-container\"/>').append(seg.el);\r\n                    if (seg.leftCol !== seg.rightCol) {\r\n                        td.attr('colspan', seg.rightCol - seg.leftCol + 1);\r\n                    }\r\n                    else {\r\n                        loneCellMatrix[i][col] = td;\r\n                    }\r\n                    while (col <= seg.rightCol) {\r\n                        cellMatrix[i][col] = td;\r\n                        segMatrix[i][col] = seg;\r\n                        col++;\r\n                    }\r\n                    tr.append(td);\r\n                }\r\n            }\r\n            emptyCellsUntil(colCnt); // finish off the row\r\n            this.dayGrid.bookendCells(tr);\r\n            tbody.append(tr);\r\n        }\r\n        return {\r\n            row: row,\r\n            tbodyEl: tbody,\r\n            cellMatrix: cellMatrix,\r\n            segMatrix: segMatrix,\r\n            segLevels: segLevels,\r\n            segs: rowSegs\r\n        };\r\n    };\r\n    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\r\n    // NOTE: modifies segs\r\n    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {\r\n        var levels = [];\r\n        var i;\r\n        var seg;\r\n        var j;\r\n        // Give preference to elements with certain criteria, so they have\r\n        // a chance to be closer to the top.\r\n        this.sortEventSegs(segs);\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\r\n            for (j = 0; j < levels.length; j++) {\r\n                if (!isDaySegCollision(seg, levels[j])) {\r\n                    break;\r\n                }\r\n            }\r\n            // `j` now holds the desired subrow index\r\n            seg.level = j;\r\n            // create new level array if needed and append segment\r\n            (levels[j] || (levels[j] = [])).push(seg);\r\n        }\r\n        // order segments left-to-right. very important if calendar is RTL\r\n        for (j = 0; j < levels.length; j++) {\r\n            levels[j].sort(compareDaySegCols);\r\n        }\r\n        return levels;\r\n    };\r\n    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\r\n    DayGridEventRenderer.prototype.groupSegRows = function (segs) {\r\n        var segRows = [];\r\n        var i;\r\n        for (i = 0; i < this.dayGrid.rowCnt; i++) {\r\n            segRows.push([]);\r\n        }\r\n        for (i = 0; i < segs.length; i++) {\r\n            segRows[segs[i].row].push(segs[i]);\r\n        }\r\n        return segRows;\r\n    };\r\n    // Computes a default event time formatting string if `timeFormat` is not explicitly defined\r\n    DayGridEventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\r\n    };\r\n    // Computes a default `displayEventEnd` value if one is not expliclty defined\r\n    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\r\n        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\r\n    };\r\n    // Builds the HTML to be used for the default element for an individual segment\r\n    DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\r\n        var view = this.view;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var isAllDay = seg.footprint.componentFootprint.isAllDay;\r\n        var isDraggable = view.isEventDefDraggable(eventDef);\r\n        var isResizableFromStart = !disableResizing && isAllDay &&\r\n            seg.isStart && view.isEventDefResizableFromStart(eventDef);\r\n        var isResizableFromEnd = !disableResizing && isAllDay &&\r\n            seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\r\n        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\r\n        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));\r\n        var timeHtml = '';\r\n        var timeText;\r\n        var titleHtml;\r\n        classes.unshift('fc-day-grid-event', 'fc-h-event');\r\n        // Only display a timed events time if it is the starting segment\r\n        if (seg.isStart) {\r\n            timeText = this.getTimeText(seg.footprint);\r\n            if (timeText) {\r\n                timeHtml = '<span class=\"fc-time\">' + util_1.htmlEscape(timeText) + '</span>';\r\n            }\r\n        }\r\n        titleHtml =\r\n            '<span class=\"fc-title\">' +\r\n                (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height\r\n                '</span>';\r\n        return '<a class=\"' + classes.join(' ') + '\"' +\r\n            (eventDef.url ?\r\n                ' href=\"' + util_1.htmlEscape(eventDef.url) + '\"' :\r\n                '') +\r\n            (skinCss ?\r\n                ' style=\"' + skinCss + '\"' :\r\n                '') +\r\n            '>' +\r\n            '<div class=\"fc-content\">' +\r\n            (this.dayGrid.isRTL ?\r\n                titleHtml + ' ' + timeHtml : // put a natural space in between\r\n                timeHtml + ' ' + titleHtml //\r\n            ) +\r\n            '</div>' +\r\n            (isResizableFromStart ?\r\n                '<div class=\"fc-resizer fc-start-resizer\" />' :\r\n                '') +\r\n            (isResizableFromEnd ?\r\n                '<div class=\"fc-resizer fc-end-resizer\" />' :\r\n                '') +\r\n            '</a>';\r\n    };\r\n    return DayGridEventRenderer;\r\n}(EventRenderer_1.default));\r\nexports.default = DayGridEventRenderer;\r\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\r\nfunction isDaySegCollision(seg, otherSegs) {\r\n    var i;\r\n    var otherSeg;\r\n    for (i = 0; i < otherSegs.length; i++) {\r\n        otherSeg = otherSegs[i];\r\n        if (otherSeg.leftCol <= seg.rightCol &&\r\n            otherSeg.rightCol >= seg.leftCol) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// A cmp function for determining the leftmost event\r\nfunction compareDaySegCols(a, b) {\r\n    return a.leftCol - b.leftCol;\r\n}\r\n\n\n/***/ }),\n/* 251 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar HelperRenderer_1 = __webpack_require__(58);\r\nvar DayGridHelperRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGridHelperRenderer, _super);\r\n    function DayGridHelperRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\r\n    DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\r\n        var helperNodes = [];\r\n        var rowStructs;\r\n        // TODO: not good to call eventRenderer this way\r\n        rowStructs = this.eventRenderer.renderSegRows(segs);\r\n        // inject each new event skeleton into each associated row\r\n        this.component.rowEls.each(function (row, rowNode) {\r\n            var rowEl = $(rowNode); // the .fc-row\r\n            var skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\r\n            var skeletonTopEl;\r\n            var skeletonTop;\r\n            // If there is an original segment, match the top position. Otherwise, put it at the row's top level\r\n            if (sourceSeg && sourceSeg.row === row) {\r\n                skeletonTop = sourceSeg.el.position().top;\r\n            }\r\n            else {\r\n                skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');\r\n                if (!skeletonTopEl.length) {\r\n                    skeletonTopEl = rowEl.find('.fc-content-skeleton table');\r\n                }\r\n                skeletonTop = skeletonTopEl.position().top;\r\n            }\r\n            skeletonEl.css('top', skeletonTop)\r\n                .find('table')\r\n                .append(rowStructs[row].tbodyEl);\r\n            rowEl.append(skeletonEl);\r\n            helperNodes.push(skeletonEl[0]);\r\n        });\r\n        return $(helperNodes); // must return the elements rendered\r\n    };\r\n    return DayGridHelperRenderer;\r\n}(HelperRenderer_1.default));\r\nexports.default = DayGridHelperRenderer;\r\n\n\n/***/ }),\n/* 252 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar FillRenderer_1 = __webpack_require__(57);\r\nvar DayGridFillRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGridFillRenderer, _super);\r\n    function DayGridFillRenderer() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.fillSegTag = 'td'; // override the default tag name\r\n        return _this;\r\n    }\r\n    DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {\r\n        var nodes = [];\r\n        var i;\r\n        var seg;\r\n        var skeletonEl;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            skeletonEl = this.renderFillRow(type, seg);\r\n            this.component.rowEls.eq(seg.row).append(skeletonEl);\r\n            nodes.push(skeletonEl[0]);\r\n        }\r\n        return nodes;\r\n    };\r\n    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\r\n    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {\r\n        var colCnt = this.component.colCnt;\r\n        var startCol = seg.leftCol;\r\n        var endCol = seg.rightCol + 1;\r\n        var className;\r\n        var skeletonEl;\r\n        var trEl;\r\n        if (type === 'businessHours') {\r\n            className = 'bgevent';\r\n        }\r\n        else {\r\n            className = type.toLowerCase();\r\n        }\r\n        skeletonEl = $('<div class=\"fc-' + className + '-skeleton\">' +\r\n            '<table><tr/></table>' +\r\n            '</div>');\r\n        trEl = skeletonEl.find('tr');\r\n        if (startCol > 0) {\r\n            trEl.append('<td colspan=\"' + startCol + '\"/>');\r\n        }\r\n        trEl.append(seg.el.attr('colspan', endCol - startCol));\r\n        if (endCol < colCnt) {\r\n            trEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\r\n        }\r\n        this.component.bookendCells(trEl);\r\n        return skeletonEl;\r\n    };\r\n    return DayGridFillRenderer;\r\n}(FillRenderer_1.default));\r\nexports.default = DayGridFillRenderer;\r\n\n\n/***/ }),\n/* 253 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar BasicViewDateProfileGenerator_1 = __webpack_require__(228);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar MonthViewDateProfileGenerator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MonthViewDateProfileGenerator, _super);\r\n    function MonthViewDateProfileGenerator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Computes the date range that will be rendered.\r\n    MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);\r\n        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\r\n        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\r\n        var rowCnt;\r\n        // ensure 6 weeks\r\n        if (this.opt('fixedWeekCount')) {\r\n            rowCnt = Math.ceil(// could be partial weeks due to hiddenDays\r\n            end.diff(start, 'weeks', true) // dontRound=true\r\n            );\r\n            end.add(6 - rowCnt, 'weeks');\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    return MonthViewDateProfileGenerator;\r\n}(BasicViewDateProfileGenerator_1.default));\r\nexports.default = MonthViewDateProfileGenerator;\r\n\n\n/***/ }),\n/* 254 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer_1 = __webpack_require__(42);\r\nvar ListEventRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListEventRenderer, _super);\r\n    function ListEventRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ListEventRenderer.prototype.renderFgSegs = function (segs) {\r\n        if (!segs.length) {\r\n            this.component.renderEmptyMessage();\r\n        }\r\n        else {\r\n            this.component.renderSegList(segs);\r\n        }\r\n    };\r\n    // generates the HTML for a single event row\r\n    ListEventRenderer.prototype.fgSegHtml = function (seg) {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var theme = calendar.theme;\r\n        var eventFootprint = seg.footprint;\r\n        var eventDef = eventFootprint.eventDef;\r\n        var componentFootprint = eventFootprint.componentFootprint;\r\n        var url = eventDef.url;\r\n        var classes = ['fc-list-item'].concat(this.getClasses(eventDef));\r\n        var bgColor = this.getBgColor(eventDef);\r\n        var timeHtml;\r\n        if (componentFootprint.isAllDay) {\r\n            timeHtml = view.getAllDayHtml();\r\n        }\r\n        else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\r\n            if (seg.isStart || seg.isEnd) {\r\n                timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));\r\n            }\r\n            else {\r\n                timeHtml = view.getAllDayHtml();\r\n            }\r\n        }\r\n        else {\r\n            // Display the normal time text for the *event's* times\r\n            timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));\r\n        }\r\n        if (url) {\r\n            classes.push('fc-has-url');\r\n        }\r\n        return '<tr class=\"' + classes.join(' ') + '\">' +\r\n            (this.displayEventTime ?\r\n                '<td class=\"fc-list-item-time ' + theme.getClass('widgetContent') + '\">' +\r\n                    (timeHtml || '') +\r\n                    '</td>' :\r\n                '') +\r\n            '<td class=\"fc-list-item-marker ' + theme.getClass('widgetContent') + '\">' +\r\n            '<span class=\"fc-event-dot\"' +\r\n            (bgColor ?\r\n                ' style=\"background-color:' + bgColor + '\"' :\r\n                '') +\r\n            '></span>' +\r\n            '</td>' +\r\n            '<td class=\"fc-list-item-title ' + theme.getClass('widgetContent') + '\">' +\r\n            '<a' + (url ? ' href=\"' + util_1.htmlEscape(url) + '\"' : '') + '>' +\r\n            util_1.htmlEscape(eventDef.title || '') +\r\n            '</a>' +\r\n            '</td>' +\r\n            '</tr>';\r\n    };\r\n    // like \"4:00am\"\r\n    ListEventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('mediumTimeFormat');\r\n    };\r\n    return ListEventRenderer;\r\n}(EventRenderer_1.default));\r\nexports.default = ListEventRenderer;\r\n\n\n/***/ }),\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar EventPointing_1 = __webpack_require__(59);\r\nvar ListEventPointing = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListEventPointing, _super);\r\n    function ListEventPointing() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // for events with a url, the whole <tr> should be clickable,\r\n    // but it's impossible to wrap with an <a> tag. simulate this.\r\n    ListEventPointing.prototype.handleClick = function (seg, ev) {\r\n        var url;\r\n        _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action\r\n        // not clicking on or within an <a> with an href\r\n        if (!$(ev.target).closest('a[href]').length) {\r\n            url = seg.footprint.eventDef.url;\r\n            if (url && !ev.isDefaultPrevented()) {\r\n                window.location.href = url; // simulate link click\r\n            }\r\n        }\r\n    };\r\n    return ListEventPointing;\r\n}(EventPointing_1.default));\r\nexports.default = ListEventPointing;\r\n\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nvar ArrayEventSource_1 = __webpack_require__(52);\r\nvar FuncEventSource_1 = __webpack_require__(215);\r\nvar JsonFeedEventSource_1 = __webpack_require__(216);\r\nEventSourceParser_1.default.registerClass(ArrayEventSource_1.default);\r\nEventSourceParser_1.default.registerClass(FuncEventSource_1.default);\r\nEventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);\r\n\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ThemeRegistry_1 = __webpack_require__(51);\r\nvar StandardTheme_1 = __webpack_require__(213);\r\nvar JqueryUiTheme_1 = __webpack_require__(214);\r\nvar Bootstrap3Theme_1 = __webpack_require__(258);\r\nvar Bootstrap4Theme_1 = __webpack_require__(259);\r\nThemeRegistry_1.defineThemeSystem('standard', StandardTheme_1.default);\r\nThemeRegistry_1.defineThemeSystem('jquery-ui', JqueryUiTheme_1.default);\r\nThemeRegistry_1.defineThemeSystem('bootstrap3', Bootstrap3Theme_1.default);\r\nThemeRegistry_1.defineThemeSystem('bootstrap4', Bootstrap4Theme_1.default);\r\n\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar Bootstrap3Theme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Bootstrap3Theme, _super);\r\n    function Bootstrap3Theme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Bootstrap3Theme;\r\n}(Theme_1.default));\r\nexports.default = Bootstrap3Theme;\r\nBootstrap3Theme.prototype.classes = {\r\n    widget: 'fc-bootstrap3',\r\n    tableGrid: 'table-bordered',\r\n    tableList: 'table',\r\n    tableListHeading: 'active',\r\n    buttonGroup: 'btn-group',\r\n    button: 'btn btn-default',\r\n    stateActive: 'active',\r\n    stateDisabled: 'disabled',\r\n    today: 'alert alert-info',\r\n    popover: 'panel panel-default',\r\n    popoverHeader: 'panel-heading',\r\n    popoverContent: 'panel-body',\r\n    // day grid\r\n    // for left/right border color when border is inset from edges (all-day in agenda view)\r\n    // avoid `panel` class b/c don't want margins/radius. only border color.\r\n    headerRow: 'panel-default',\r\n    dayRow: 'panel-default',\r\n    // list view\r\n    listView: 'panel panel-default'\r\n};\r\nBootstrap3Theme.prototype.baseIconClass = 'glyphicon';\r\nBootstrap3Theme.prototype.iconClasses = {\r\n    close: 'glyphicon-remove',\r\n    prev: 'glyphicon-chevron-left',\r\n    next: 'glyphicon-chevron-right',\r\n    prevYear: 'glyphicon-backward',\r\n    nextYear: 'glyphicon-forward'\r\n};\r\nBootstrap3Theme.prototype.iconOverrideOption = 'bootstrapGlyphicons';\r\nBootstrap3Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';\r\nBootstrap3Theme.prototype.iconOverridePrefix = 'glyphicon-';\r\n\n\n/***/ }),\n/* 259 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar Bootstrap4Theme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Bootstrap4Theme, _super);\r\n    function Bootstrap4Theme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Bootstrap4Theme;\r\n}(Theme_1.default));\r\nexports.default = Bootstrap4Theme;\r\nBootstrap4Theme.prototype.classes = {\r\n    widget: 'fc-bootstrap4',\r\n    tableGrid: 'table-bordered',\r\n    tableList: 'table',\r\n    tableListHeading: 'table-active',\r\n    buttonGroup: 'btn-group',\r\n    button: 'btn btn-primary',\r\n    stateActive: 'active',\r\n    stateDisabled: 'disabled',\r\n    today: 'alert alert-info',\r\n    popover: 'card card-primary',\r\n    popoverHeader: 'card-header',\r\n    popoverContent: 'card-body',\r\n    // day grid\r\n    // for left/right border color when border is inset from edges (all-day in agenda view)\r\n    // avoid `table` class b/c don't want margins/padding/structure. only border color.\r\n    headerRow: 'table-bordered',\r\n    dayRow: 'table-bordered',\r\n    // list view\r\n    listView: 'card card-primary'\r\n};\r\nBootstrap4Theme.prototype.baseIconClass = 'fa';\r\nBootstrap4Theme.prototype.iconClasses = {\r\n    close: 'fa-times',\r\n    prev: 'fa-chevron-left',\r\n    next: 'fa-chevron-right',\r\n    prevYear: 'fa-angle-double-left',\r\n    nextYear: 'fa-angle-double-right'\r\n};\r\nBootstrap4Theme.prototype.iconOverrideOption = 'bootstrapFontAwesome';\r\nBootstrap4Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';\r\nBootstrap4Theme.prototype.iconOverridePrefix = 'fa-';\r\n\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar BasicView_1 = __webpack_require__(62);\r\nvar MonthView_1 = __webpack_require__(229);\r\nViewRegistry_1.defineView('basic', {\r\n    'class': BasicView_1.default\r\n});\r\nViewRegistry_1.defineView('basicDay', {\r\n    type: 'basic',\r\n    duration: { days: 1 }\r\n});\r\nViewRegistry_1.defineView('basicWeek', {\r\n    type: 'basic',\r\n    duration: { weeks: 1 }\r\n});\r\nViewRegistry_1.defineView('month', {\r\n    'class': MonthView_1.default,\r\n    duration: { months: 1 },\r\n    defaults: {\r\n        fixedWeekCount: true\r\n    }\r\n});\r\n\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar AgendaView_1 = __webpack_require__(226);\r\nViewRegistry_1.defineView('agenda', {\r\n    'class': AgendaView_1.default,\r\n    defaults: {\r\n        allDaySlot: true,\r\n        slotDuration: '00:30:00',\r\n        slotEventOverlap: true // a bad name. confused with overlap/constraint system\r\n    }\r\n});\r\nViewRegistry_1.defineView('agendaDay', {\r\n    type: 'agenda',\r\n    duration: { days: 1 }\r\n});\r\nViewRegistry_1.defineView('agendaWeek', {\r\n    type: 'agenda',\r\n    duration: { weeks: 1 }\r\n});\r\n\n\n/***/ }),\n/* 262 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar ListView_1 = __webpack_require__(230);\r\nViewRegistry_1.defineView('list', {\r\n    'class': ListView_1.default,\r\n    buttonTextKey: 'list',\r\n    defaults: {\r\n        buttonText: 'list',\r\n        listDayFormat: 'LL',\r\n        noEventsMessage: 'No events to display'\r\n    }\r\n});\r\nViewRegistry_1.defineView('listDay', {\r\n    type: 'list',\r\n    duration: { days: 1 },\r\n    defaults: {\r\n        listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\r\n    }\r\n});\r\nViewRegistry_1.defineView('listWeek', {\r\n    type: 'list',\r\n    duration: { weeks: 1 },\r\n    defaults: {\r\n        listDayFormat: 'dddd',\r\n        listDayAltFormat: 'LL'\r\n    }\r\n});\r\nViewRegistry_1.defineView('listMonth', {\r\n    type: 'list',\r\n    duration: { month: 1 },\r\n    defaults: {\r\n        listDayAltFormat: 'dddd' // day-of-week is nice-to-have\r\n    }\r\n});\r\nViewRegistry_1.defineView('listYear', {\r\n    type: 'list',\r\n    duration: { year: 1 },\r\n    defaults: {\r\n        listDayAltFormat: 'dddd' // day-of-week is nice-to-have\r\n    }\r\n});\r\n\n\n/***/ }),\n/* 263 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzP2EyNWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUMvRSxxQkFBcUI7QUFDckI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELGlGQUFpRjtBQUNqRixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseURBQXlEO0FBQ3pELGNBQWMseUJBQXlCLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDO0FBQ3hELGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhDQUE4QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QyxtQ0FBbUMsRUFBRTtBQUNyQywrQkFBK0I7QUFDL0I7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0JBQStCO0FBQ3RFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxnREFBZ0Q7QUFDaEQsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBbUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0MsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELDhFQUE4RTtBQUM5RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLDhEQUE4RDtBQUM5RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSx5QkFBeUI7QUFDakMsUUFBUSx5QkFBeUI7QUFDakMsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUSx3QkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0dBQXdHO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnR0FBZ0c7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNDQUFzQztBQUN0QztBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakUsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQixxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQ2pFLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdURBQXVEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixjQUFjO0FBQ25DLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCLEdBQUcsNEJBQTRCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwyQkFBMkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0MsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUE2RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsd0RBQXdEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0RBQWtEOzs7QUFHbEQsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0Esb0NBQW9DO0FBQ3BDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsU0FBUztBQUNUO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0M7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixxQ0FBcUM7QUFDckM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1Q0FBdUM7QUFDdkMscUNBQXFDO0FBQ3JDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0M7QUFDeEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQTJEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXO0FBQ2hCLEtBQUssY0FBYztBQUNuQixLQUFLLGNBQWM7QUFDbkIsS0FBSyxjQUFjO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQ0FBa0M7QUFDckY7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlDQUFpQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1Qyw4REFBOEQ7QUFDOUQ7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQ7QUFDQSwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZTtBQUNmLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7O0FBRzVELE9BQU87QUFDUDtBQUNBLENBQUMiLCJmaWxlIjoiMTMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGdWxsQ2FsZW5kYXIgdjMuOS4wXG4gKiBEb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4gKiAoYykgMjAxOCBBZGFtIFNoYXdcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibW9tZW50XCIpLCByZXF1aXJlKFwianF1ZXJ5XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIm1vbWVudFwiLCBcImpxdWVyeVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJGdWxsQ2FsZW5kYXJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJtb21lbnRcIiksIHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkZ1bGxDYWxlbmRhclwiXSA9IGZhY3Rvcnkocm9vdFtcIm1vbWVudFwiXSwgcm9vdFtcImpRdWVyeVwiXSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIzNik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cbi8qKiovIH0pLFxuLyogMSAqLyxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypcclxuZGVyaXZlZCBmcm9tOlxyXG5odHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L3RzbGliL2Jsb2IvdjEuNi4wL3RzbGliLmpzXHJcblxub25seSBpbmNsdWRlIHRoZSBoZWxwZXJzIHdlIG5lZWQsIHRvIGtlZXAgZG93biBmaWxlc2l6ZVxyXG4qL1xyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKVxyXG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKVxyXG4gICAgICAgICAgICBkW3BdID0gYltwXTsgfTtcclxuZXhwb3J0cy5fX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBHaXZlbiB0aGUgc2Nyb2xsYmFyIHdpZHRocyBvZiBzb21lIG90aGVyIGNvbnRhaW5lciwgY3JlYXRlIGJvcmRlcnMvbWFyZ2lucyBvbiByb3dFbHMgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIGxlZnRcclxuLy8gYW5kIHJpZ2h0IHNwYWNlIHRoYXQgd2FzIG9mZnNldCBieSB0aGUgc2Nyb2xsYmFycy4gQSAxLXBpeGVsIGJvcmRlciBmaXJzdCwgdGhlbiBtYXJnaW4gYmV5b25kIHRoYXQuXHJcbmZ1bmN0aW9uIGNvbXBlbnNhdGVTY3JvbGwocm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgIGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCkge1xyXG4gICAgICAgIHJvd0Vscy5jc3Moe1xyXG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnOiAxLFxyXG4gICAgICAgICAgICAnbWFyZ2luLWxlZnQnOiBzY3JvbGxiYXJXaWR0aHMubGVmdCAtIDFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHtcclxuICAgICAgICByb3dFbHMuY3NzKHtcclxuICAgICAgICAgICAgJ2JvcmRlci1yaWdodC13aWR0aCc6IDEsXHJcbiAgICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiBzY3JvbGxiYXJXaWR0aHMucmlnaHQgLSAxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb21wZW5zYXRlU2Nyb2xsID0gY29tcGVuc2F0ZVNjcm9sbDtcclxuLy8gVW5kb2VzIGNvbXBlbnNhdGVTY3JvbGwgYW5kIHJlc3RvcmVzIGFsbCBib3JkZXJzL21hcmdpbnNcclxuZnVuY3Rpb24gdW5jb21wZW5zYXRlU2Nyb2xsKHJvd0Vscykge1xyXG4gICAgcm93RWxzLmNzcyh7XHJcbiAgICAgICAgJ21hcmdpbi1sZWZ0JzogJycsXHJcbiAgICAgICAgJ21hcmdpbi1yaWdodCc6ICcnLFxyXG4gICAgICAgICdib3JkZXItbGVmdC13aWR0aCc6ICcnLFxyXG4gICAgICAgICdib3JkZXItcmlnaHQtd2lkdGgnOiAnJ1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy51bmNvbXBlbnNhdGVTY3JvbGwgPSB1bmNvbXBlbnNhdGVTY3JvbGw7XHJcbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxyXG5mdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xyXG4gICAgJCgnYm9keScpLmFkZENsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xyXG59XHJcbmV4cG9ydHMuZGlzYWJsZUN1cnNvciA9IGRpc2FibGVDdXJzb3I7XHJcbi8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xyXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XHJcbiAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2ZjLW5vdC1hbGxvd2VkJyk7XHJcbn1cclxuZXhwb3J0cy5lbmFibGVDdXJzb3IgPSBlbmFibGVDdXJzb3I7XHJcbi8vIEdpdmVuIGEgdG90YWwgYXZhaWxhYmxlIGhlaWdodCB0byBmaWxsLCBoYXZlIGBlbHNgIChlc3NlbnRpYWxseSBjaGlsZCByb3dzKSBleHBhbmQgdG8gYWNjb21vZGF0ZS5cclxuLy8gQnkgZGVmYXVsdCwgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHNob3J0ZXIgdGhhbiB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IGFyZSBleHBhbmRlZCB1bmlmb3JtbHksIG5vdCBjb25zaWRlcmluZ1xyXG4vLyBhbnkgb3RoZXIgZWxzIHRoYXQgYXJlIGFscmVhZHkgdG9vIHRhbGwuIGlmIGBzaG91bGRSZWRpc3RyaWJ1dGVgIGlzIG9uLCBpdCBjb25zaWRlcnMgdGhlc2UgdGFsbCByb3dzIGFuZFxyXG4vLyByZWR1Y2VzIHRoZSBhdmFpbGFibGUgaGVpZ2h0LlxyXG5mdW5jdGlvbiBkaXN0cmlidXRlSGVpZ2h0KGVscywgYXZhaWxhYmxlSGVpZ2h0LCBzaG91bGRSZWRpc3RyaWJ1dGUpIHtcclxuICAgIC8vICpGTE9PUklORyBOT1RFKjogd2UgZmxvb3IgaW4gY2VydGFpbiBwbGFjZXMgYmVjYXVzZSB6b29tIGNhbiBnaXZlIGluYWNjdXJhdGUgZmxvYXRpbmctcG9pbnQgZGltZW5zaW9ucyxcclxuICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgc2hvcnRlciB0aGFuIHRhbGxlciwgdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycy5cclxuICAgIHZhciBtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBlbHMubGVuZ3RoKTsgLy8gZm9yIG5vbi1sYXN0IGVsZW1lbnRcclxuICAgIHZhciBtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGVscy5sZW5ndGggLSAxKSk7IC8vIGZvciBsYXN0IGVsZW1lbnQgKkZMT09SSU5HIE5PVEUqXHJcbiAgICB2YXIgZmxleEVscyA9IFtdOyAvLyBlbGVtZW50cyB0aGF0IGFyZSBhbGxvd2VkIHRvIGV4cGFuZC4gYXJyYXkgb2YgRE9NIG5vZGVzXHJcbiAgICB2YXIgZmxleE9mZnNldHMgPSBbXTsgLy8gYW1vdW50IG9mIHZlcnRpY2FsIHNwYWNlIGl0IHRha2VzIHVwXHJcbiAgICB2YXIgZmxleEhlaWdodHMgPSBbXTsgLy8gYWN0dWFsIGNzcyBoZWlnaHRcclxuICAgIHZhciB1c2VkSGVpZ2h0ID0gMDtcclxuICAgIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpOyAvLyBnaXZlIGFsbCBlbGVtZW50cyB0aGVpciBuYXR1cmFsIGhlaWdodFxyXG4gICAgLy8gZmluZCBlbGVtZW50cyB0aGF0IGFyZSBiZWxvdyB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IChleHBhbmRhYmxlKS5cclxuICAgIC8vIGltcG9ydGFudCB0byBxdWVyeSBmb3IgaGVpZ2h0cyBpbiBhIHNpbmdsZSBmaXJzdCBwYXNzICh0byBhdm9pZCByZWZsb3cgb3NjaWxsYXRpb24pLlxyXG4gICAgZWxzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgdmFyIG1pbk9mZnNldCA9IGkgPT09IGVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XHJcbiAgICAgICAgdmFyIG5hdHVyYWxPZmZzZXQgPSAkKGVsKS5vdXRlckhlaWdodCh0cnVlKTtcclxuICAgICAgICBpZiAobmF0dXJhbE9mZnNldCA8IG1pbk9mZnNldCkge1xyXG4gICAgICAgICAgICBmbGV4RWxzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICBmbGV4T2Zmc2V0cy5wdXNoKG5hdHVyYWxPZmZzZXQpO1xyXG4gICAgICAgICAgICBmbGV4SGVpZ2h0cy5wdXNoKCQoZWwpLmhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBzdHJldGNoZXMgcGFzdCByZWNvbW1lbmRlZCBoZWlnaHQgKG5vbi1leHBhbmRhYmxlKS4gbWFyayB0aGUgc3BhY2UgYXMgb2NjdXBpZWQuXHJcbiAgICAgICAgICAgIHVzZWRIZWlnaHQgKz0gbmF0dXJhbE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIHJlYWRqdXN0IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgdG8gb25seSBjb25zaWRlciB0aGUgaGVpZ2h0IGF2YWlsYWJsZSB0byBub24tbWF4ZWQtb3V0IHJvd3MuXHJcbiAgICBpZiAoc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0IC09IHVzZWRIZWlnaHQ7XHJcbiAgICAgICAgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZmxleEVscy5sZW5ndGgpO1xyXG4gICAgICAgIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZmxleEVscy5sZW5ndGggLSAxKSk7IC8vICpGTE9PUklORyBOT1RFKlxyXG4gICAgfVxyXG4gICAgLy8gYXNzaWduIGhlaWdodHMgdG8gYWxsIGV4cGFuZGFibGUgZWxlbWVudHNcclxuICAgICQoZmxleEVscykuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcclxuICAgICAgICB2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZmxleEVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XHJcbiAgICAgICAgdmFyIG5hdHVyYWxPZmZzZXQgPSBmbGV4T2Zmc2V0c1tpXTtcclxuICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGZsZXhIZWlnaHRzW2ldO1xyXG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBtaW5PZmZzZXQgLSAobmF0dXJhbE9mZnNldCAtIG5hdHVyYWxIZWlnaHQpOyAvLyBzdWJ0cmFjdCB0aGUgbWFyZ2luL3BhZGRpbmdcclxuICAgICAgICBpZiAobmF0dXJhbE9mZnNldCA8IG1pbk9mZnNldCkge1xyXG4gICAgICAgICAgICAkKGVsKS5oZWlnaHQobmV3SGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpc3RyaWJ1dGVIZWlnaHQgPSBkaXN0cmlidXRlSGVpZ2h0O1xyXG4vLyBVbmRvZXMgZGlzdHJ1YnV0ZUhlaWdodCwgcmVzdG9yaW5nIGFsbCBlbHMgdG8gdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuZnVuY3Rpb24gdW5kaXN0cmlidXRlSGVpZ2h0KGVscykge1xyXG4gICAgZWxzLmhlaWdodCgnJyk7XHJcbn1cclxuZXhwb3J0cy51bmRpc3RyaWJ1dGVIZWlnaHQgPSB1bmRpc3RyaWJ1dGVIZWlnaHQ7XHJcbi8vIEdpdmVuIGBlbHNgLCBhIGpRdWVyeSBzZXQgb2YgPHRkPiBjZWxscywgZmluZCB0aGUgY2VsbCB3aXRoIHRoZSBsYXJnZXN0IG5hdHVyYWwgd2lkdGggYW5kIHNldCB0aGUgd2lkdGhzIG9mIGFsbCB0aGVcclxuLy8gY2VsbHMgdG8gYmUgdGhhdCB3aWR0aC5cclxuLy8gUFJFUkVRVUlTSVRFOiBpZiB5b3Ugd2FudCBhIGNlbGwgdG8gdGFrZSB1cCB3aWR0aCwgaXQgbmVlZHMgdG8gaGF2ZSBhIHNpbmdsZSBpbm5lciBlbGVtZW50IHcvIGRpc3BsYXk6aW5saW5lXHJcbmZ1bmN0aW9uIG1hdGNoQ2VsbFdpZHRocyhlbHMpIHtcclxuICAgIHZhciBtYXhJbm5lcldpZHRoID0gMDtcclxuICAgIGVscy5maW5kKCc+IConKS5lYWNoKGZ1bmN0aW9uIChpLCBpbm5lckVsKSB7XHJcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSAkKGlubmVyRWwpLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBpZiAoaW5uZXJXaWR0aCA+IG1heElubmVyV2lkdGgpIHtcclxuICAgICAgICAgICAgbWF4SW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBtYXhJbm5lcldpZHRoKys7IC8vIHNvbWV0aW1lcyBub3QgYWNjdXJhdGUgb2Ygd2lkdGggdGhlIHRleHQgbmVlZHMgdG8gc3RheSBvbiBvbmUgbGluZS4gaW5zdXJhbmNlXHJcbiAgICBlbHMud2lkdGgobWF4SW5uZXJXaWR0aCk7XHJcbiAgICByZXR1cm4gbWF4SW5uZXJXaWR0aDtcclxufVxyXG5leHBvcnRzLm1hdGNoQ2VsbFdpZHRocyA9IG1hdGNoQ2VsbFdpZHRocztcclxuLy8gR2l2ZW4gb25lIGVsZW1lbnQgdGhhdCByZXNpZGVzIGluc2lkZSBhbm90aGVyLFxyXG4vLyBTdWJ0cmFjdHMgdGhlIGhlaWdodCBvZiB0aGUgaW5uZXIgZWxlbWVudCBmcm9tIHRoZSBvdXRlciBlbGVtZW50LlxyXG5mdW5jdGlvbiBzdWJ0cmFjdElubmVyRWxIZWlnaHQob3V0ZXJFbCwgaW5uZXJFbCkge1xyXG4gICAgdmFyIGJvdGggPSBvdXRlckVsLmFkZChpbm5lckVsKTtcclxuICAgIHZhciBkaWZmO1xyXG4gICAgLy8gZWZmaW4nIElFOC85LzEwLzExIHNvbWV0aW1lcyByZXR1cm5zIDAgZm9yIGRpbWVuc2lvbnMuIHRoaXMgd2VpcmQgaGFjayB3YXMgdGhlIG9ubHkgdGhpbmcgdGhhdCB3b3JrZWRcclxuICAgIGJvdGguY3NzKHtcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICBsZWZ0OiAtMSAvLyBlbnN1cmUgcmVmbG93IGluIGNhc2UgdGhlIGVsIHdhcyBhbHJlYWR5IHJlbGF0aXZlLiBuZWdhdGl2ZSBpcyBsZXNzIGxpa2VseSB0byBjYXVzZSBuZXcgc2Nyb2xsXHJcbiAgICB9KTtcclxuICAgIGRpZmYgPSBvdXRlckVsLm91dGVySGVpZ2h0KCkgLSBpbm5lckVsLm91dGVySGVpZ2h0KCk7IC8vIGdyYWIgdGhlIGRpbWVuc2lvbnNcclxuICAgIGJvdGguY3NzKHsgcG9zaXRpb246ICcnLCBsZWZ0OiAnJyB9KTsgLy8gdW5kbyBoYWNrXHJcbiAgICByZXR1cm4gZGlmZjtcclxufVxyXG5leHBvcnRzLnN1YnRyYWN0SW5uZXJFbEhlaWdodCA9IHN1YnRyYWN0SW5uZXJFbEhlaWdodDtcclxuLyogRWxlbWVudCBHZW9tIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iLzEuMTEuMC91aS9jb3JlLmpzI0w1MVxyXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWwpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IGVsLmNzcygncG9zaXRpb24nKTtcclxuICAgIHZhciBzY3JvbGxQYXJlbnQgPSBlbC5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gJCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdChwYXJlbnQuY3NzKCdvdmVyZmxvdycpICsgcGFyZW50LmNzcygnb3ZlcmZsb3cteScpICsgcGFyZW50LmNzcygnb3ZlcmZsb3cteCcpKTtcclxuICAgIH0pLmVxKDApO1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChlbFswXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSA6IHNjcm9sbFBhcmVudDtcclxufVxyXG5leHBvcnRzLmdldFNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudDtcclxuLy8gUXVlcmllcyB0aGUgb3V0ZXIgYm91bmRpbmcgYXJlYSBvZiBhIGpRdWVyeSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cclxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxyXG5mdW5jdGlvbiBnZXRPdXRlclJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpO1xyXG4gICAgdmFyIGxlZnQgPSBvZmZzZXQubGVmdCAtIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xyXG4gICAgdmFyIHRvcCA9IG9mZnNldC50b3AgLSAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgZWwub3V0ZXJXaWR0aCgpLFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGJvdHRvbTogdG9wICsgZWwub3V0ZXJIZWlnaHQoKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldE91dGVyUmVjdCA9IGdldE91dGVyUmVjdDtcclxuLy8gUXVlcmllcyB0aGUgYXJlYSB3aXRoaW4gdGhlIG1hcmdpbi9ib3JkZXIvc2Nyb2xsYmFycyBvZiBhIGpRdWVyeSBlbGVtZW50LiBEb2VzIG5vdCBnbyB3aXRoaW4gdGhlIHBhZGRpbmcuXHJcbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxyXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXHJcbi8vIFdBUk5JTkc6IGdpdmVuIGVsZW1lbnQgY2FuJ3QgaGF2ZSBib3JkZXJzXHJcbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cclxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChlbCwgb3JpZ2luKSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7XHJcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKGVsKTtcclxuICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci1sZWZ0LXdpZHRoJykgKyBzY3JvbGxiYXJXaWR0aHMubGVmdCAtIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xyXG4gICAgdmFyIHRvcCA9IG9mZnNldC50b3AgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci10b3Atd2lkdGgnKSArIHNjcm9sbGJhcldpZHRocy50b3AgLSAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgZWxbMF0uY2xpZW50V2lkdGgsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgYm90dG9tOiB0b3AgKyBlbFswXS5jbGllbnRIZWlnaHQgLy8gY2xpZW50SGVpZ2h0IGluY2x1ZGVzIHBhZGRpbmcgYnV0IE5PVCBzY3JvbGxiYXJzXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3Q7XHJcbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3BhZGRpbmcgb2YgYSBqUXVlcnkgZWxlbWVudC4gQXNzdW1lZCBub3QgdG8gaGF2ZSBzY3JvbGxiYXJzLlxyXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cclxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdChlbCwgb3JpZ2luKSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7IC8vIGp1c3Qgb3V0c2lkZSBvZiBib3JkZXIsIG1hcmdpbiBub3QgaW5jbHVkZWRcclxuICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci1sZWZ0LXdpZHRoJykgKyBnZXRDc3NGbG9hdChlbCwgJ3BhZGRpbmctbGVmdCcpIC1cclxuICAgICAgICAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBnZXRDc3NGbG9hdChlbCwgJ3BhZGRpbmctdG9wJykgLVxyXG4gICAgICAgIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyBlbC53aWR0aCgpLFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGJvdHRvbTogdG9wICsgZWwuaGVpZ2h0KClcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRDb250ZW50UmVjdCA9IGdldENvbnRlbnRSZWN0O1xyXG4vLyBSZXR1cm5zIHRoZSBjb21wdXRlZCBsZWZ0L3JpZ2h0L3RvcC9ib3R0b20gc2Nyb2xsYmFyIHdpZHRocyBmb3IgdGhlIGdpdmVuIGpRdWVyeSBlbGVtZW50LlxyXG4vLyBXQVJOSU5HOiBnaXZlbiBlbGVtZW50IGNhbid0IGhhdmUgYm9yZGVycyAod2hpY2ggd2lsbCBjYXVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgdG8gYmUgbGFyZ2VyKS5cclxuLy8gTk9URTogc2hvdWxkIHVzZSBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IHZlcnkgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyLlxyXG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpIHtcclxuICAgIHZhciBsZWZ0UmlnaHRXaWR0aCA9IGVsWzBdLm9mZnNldFdpZHRoIC0gZWxbMF0uY2xpZW50V2lkdGg7XHJcbiAgICB2YXIgYm90dG9tV2lkdGggPSBlbFswXS5vZmZzZXRIZWlnaHQgLSBlbFswXS5jbGllbnRIZWlnaHQ7XHJcbiAgICB2YXIgd2lkdGhzO1xyXG4gICAgbGVmdFJpZ2h0V2lkdGggPSBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKGxlZnRSaWdodFdpZHRoKTtcclxuICAgIGJvdHRvbVdpZHRoID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChib3R0b21XaWR0aCk7XHJcbiAgICB3aWR0aHMgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogYm90dG9tV2lkdGggfTtcclxuICAgIGlmIChnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkgJiYgZWwuY3NzKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcpIHtcclxuICAgICAgICB3aWR0aHMubGVmdCA9IGxlZnRSaWdodFdpZHRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2lkdGhzLnJpZ2h0ID0gbGVmdFJpZ2h0V2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2lkdGhzO1xyXG59XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzO1xyXG4vLyBUaGUgc2Nyb2xsYmFyIHdpZHRoIGNvbXB1dGF0aW9ucyBpbiBnZXRTY3JvbGxiYXJXaWR0aHMgYXJlIHNvbWV0aW1lcyBmbGF3ZWQgd2hlbiBpdCBjb21lcyB0b1xyXG4vLyByZXRpbmEgZGlzcGxheXMsIHJvdW5kaW5nLCBhbmQgSUUxMS4gTWFzc2FnZSB0aGVtIGludG8gYSB1c2FibGUgdmFsdWUuXHJcbmZ1bmN0aW9uIHNhbml0aXplU2Nyb2xsYmFyV2lkdGgod2lkdGgpIHtcclxuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGgpOyAvLyBubyBuZWdhdGl2ZXNcclxuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbn1cclxuLy8gTG9naWMgZm9yIGRldGVybWluaW5nIGlmLCB3aGVuIHRoZSBlbGVtZW50IGlzIHJpZ2h0LXRvLWxlZnQsIHRoZSBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCBzaWRlXHJcbnZhciBfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSB7XHJcbiAgICBpZiAoX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPT09IG51bGwpIHtcclxuICAgICAgICBfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9IGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2lzTGVmdFJ0bFNjcm9sbGJhcnM7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUlzTGVmdFJ0bFNjcm9sbGJhcnMoKSB7XHJcbiAgICB2YXIgZWwgPSAkKCc8ZGl2PjxkaXYvPjwvZGl2PicpXHJcbiAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAtMTAwMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvcmRlcjogMCxcclxuICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcclxuICAgICAgICBkaXJlY3Rpb246ICdydGwnXHJcbiAgICB9KVxyXG4gICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xyXG4gICAgdmFyIGlubmVyRWwgPSBlbC5jaGlsZHJlbigpO1xyXG4gICAgdmFyIHJlcyA9IGlubmVyRWwub2Zmc2V0KCkubGVmdCA+IGVsLm9mZnNldCgpLmxlZnQ7IC8vIGlzIHRoZSBpbm5lciBkaXYgc2hpZnRlZCB0byBhY2NvbW1vZGF0ZSBhIGxlZnQgc2Nyb2xsYmFyP1xyXG4gICAgZWwucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIFJldHJpZXZlcyBhIGpRdWVyeSBlbGVtZW50J3MgY29tcHV0ZWQgQ1NTIHZhbHVlIGFzIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxyXG4vLyBJZiB0aGUgcXVlcmllZCB2YWx1ZSBpcyBub24tbnVtZXJpYyAoZXg6IElFIGNhbiByZXR1cm4gXCJtZWRpdW1cIiBmb3IgYm9yZGVyIHdpZHRoKSwgd2lsbCBqdXN0IHJldHVybiB6ZXJvLlxyXG5mdW5jdGlvbiBnZXRDc3NGbG9hdChlbCwgcHJvcCkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZWwuY3NzKHByb3ApKSB8fCAwO1xyXG59XHJcbi8qIE1vdXNlIC8gVG91Y2ggVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcclxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcclxuICAgIHJldHVybiBldi53aGljaCA9PT0gMSAmJiAhZXYuY3RybEtleTtcclxufVxyXG5leHBvcnRzLmlzUHJpbWFyeU1vdXNlQnV0dG9uID0gaXNQcmltYXJ5TW91c2VCdXR0b247XHJcbmZ1bmN0aW9uIGdldEV2WChldikge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldi5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XHJcbiAgICAvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcclxuICAgIC8vIHNvLCBsb29rIGF0IHRvdWNoIGNvb3JkaW5hdGVzIGZpcnN0LlxyXG4gICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdG91Y2hlc1swXS5wYWdlWDtcclxuICAgIH1cclxuICAgIHJldHVybiBldi5wYWdlWDtcclxufVxyXG5leHBvcnRzLmdldEV2WCA9IGdldEV2WDtcclxuZnVuY3Rpb24gZ2V0RXZZKGV2KSB7XHJcbiAgICB2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcclxuICAgIC8vIG9uIG1vYmlsZSBGRiwgcGFnZVggZm9yIHRvdWNoIGV2ZW50cyBpcyBwcmVzZW50LCBidXQgaW5jb3JyZWN0LFxyXG4gICAgLy8gc28sIGxvb2sgYXQgdG91Y2ggY29vcmRpbmF0ZXMgZmlyc3QuXHJcbiAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2LnBhZ2VZO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZZID0gZ2V0RXZZO1xyXG5mdW5jdGlvbiBnZXRFdklzVG91Y2goZXYpIHtcclxuICAgIHJldHVybiAvXnRvdWNoLy50ZXN0KGV2LnR5cGUpO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZJc1RvdWNoID0gZ2V0RXZJc1RvdWNoO1xyXG5mdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XHJcbiAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcclxuICAgICAgICAub24oJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG59XHJcbmV4cG9ydHMucHJldmVudFNlbGVjdGlvbiA9IHByZXZlbnRTZWxlY3Rpb247XHJcbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XHJcbiAgICBlbC5yZW1vdmVDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcclxuICAgICAgICAub2ZmKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5leHBvcnRzLmFsbG93U2VsZWN0aW9uID0gYWxsb3dTZWxlY3Rpb247XHJcbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxyXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XHJcbi8qIEdlbmVyYWwgR2VvbWV0cnkgVXRpbHNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXHJcbmZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xyXG4gICAgdmFyIHJlcyA9IHtcclxuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcclxuICAgICAgICByaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcclxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcclxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxyXG4gICAgfTtcclxuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IGludGVyc2VjdFJlY3RzO1xyXG4vLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXHJcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxyXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNvbnN0cmFpblBvaW50ID0gY29uc3RyYWluUG9pbnQ7XHJcbi8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMixcclxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDJcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gZ2V0UmVjdENlbnRlcjtcclxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXHJcbmZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcclxuICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGlmZlBvaW50cyA9IGRpZmZQb2ludHM7XHJcbi8qIE9iamVjdCBPcmRlcmluZyBieSBGaWVsZFxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XHJcbiAgICB2YXIgc3BlY3MgPSBbXTtcclxuICAgIHZhciB0b2tlbnMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIHRva2VucyA9IGlucHV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xyXG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XHJcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNwZWNzO1xyXG59XHJcbmV4cG9ydHMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xyXG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajEsIG9iajIsIGZpZWxkU3BlY3MsIG9iajFmYWxsYmFjaywgb2JqMmZhbGxiYWNrKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjbXA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzW2ldLCBvYmoxZmFsbGJhY2ssIG9iajJmYWxsYmFjayk7XHJcbiAgICAgICAgaWYgKGNtcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IGNvbXBhcmVCeUZpZWxkU3BlY3M7XHJcbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWMsIG9iajFmYWxsYmFjaywgb2JqMmZhbGxiYWNrKSB7XHJcbiAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMSwgb2JqMik7XHJcbiAgICB9XHJcbiAgICB2YXIgdmFsMSA9IG9iajFbZmllbGRTcGVjLmZpZWxkXTtcclxuICAgIHZhciB2YWwyID0gb2JqMltmaWVsZFNwZWMuZmllbGRdO1xyXG4gICAgaWYgKHZhbDEgPT0gbnVsbCAmJiBvYmoxZmFsbGJhY2spIHtcclxuICAgICAgICB2YWwxID0gb2JqMWZhbGxiYWNrW2ZpZWxkU3BlYy5maWVsZF07XHJcbiAgICB9XHJcbiAgICBpZiAodmFsMiA9PSBudWxsICYmIG9iajJmYWxsYmFjaykge1xyXG4gICAgICAgIHZhbDIgPSBvYmoyZmFsbGJhY2tbZmllbGRTcGVjLmZpZWxkXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUodmFsMSwgdmFsMikgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5mdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xyXG4gICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGEgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKCQudHlwZShhKSA9PT0gJ3N0cmluZycgfHwgJC50eXBlKGIpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcbmV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xyXG4vKiBEYXRlIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0cy5kYXlJRHMgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddO1xyXG5leHBvcnRzLnVuaXRzRGVzYyA9IFsneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTsgLy8gZGVzY2VuZGluZ1xyXG4vLyBEaWZmcyB0aGUgdHdvIG1vbWVudHMgaW50byBhIER1cmF0aW9uIHdoZXJlIGZ1bGwtZGF5cyBhcmUgcmVjb3JkZWQgZmlyc3QsIHRoZW4gdGhlIHJlbWFpbmluZyB0aW1lLlxyXG4vLyBNb21lbnRzIHdpbGwgaGF2ZSB0aGVpciB0aW1lem9uZXMgbm9ybWFsaXplZC5cclxuZnVuY3Rpb24gZGlmZkRheVRpbWUoYSwgYikge1xyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpLFxyXG4gICAgICAgIG1zOiBhLnRpbWUoKSAtIGIudGltZSgpIC8vIHRpbWUtb2YtZGF5IGZyb20gZGF5IHN0YXJ0LiBkaXNyZWdhcmRzIHRpbWV6b25lXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpZmZEYXlUaW1lID0gZGlmZkRheVRpbWU7XHJcbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyB2aWEgdGhlaXIgc3RhcnQtb2YtZGF5IChyZWdhcmRsZXNzIG9mIHRpbWV6b25lKS4gUHJvZHVjZXMgd2hvbGUtZGF5IGR1cmF0aW9ucy5cclxuZnVuY3Rpb24gZGlmZkRheShhLCBiKSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcclxuICAgICAgICBkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJylcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZGlmZkRheSA9IGRpZmZEYXk7XHJcbi8vIERpZmZzIHR3byBtb21lbnRzLCBwcm9kdWNpbmcgYSBkdXJhdGlvbiwgbWFkZSBvZiBhIHdob2xlLXVuaXQtaW5jcmVtZW50IG9mIHRoZSBnaXZlbiB1bml0LiBVc2VzIHJvdW5kaW5nLlxyXG5mdW5jdGlvbiBkaWZmQnlVbml0KGEsIGIsIHVuaXQpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oTWF0aC5yb3VuZChhLmRpZmYoYiwgdW5pdCwgdHJ1ZSkpLCAvLyByZXR1cm5GbG9hdD10cnVlXHJcbiAgICB1bml0KTtcclxufVxyXG5leHBvcnRzLmRpZmZCeVVuaXQgPSBkaWZmQnlVbml0O1xyXG4vLyBDb21wdXRlcyB0aGUgdW5pdCBuYW1lIG9mIHRoZSBsYXJnZXN0IHdob2xlLXVuaXQgcGVyaW9kIG9mIHRpbWUuXHJcbi8vIEZvciBleGFtcGxlLCA0OCBob3VycyB3aWxsIGJlIFwiZGF5c1wiIHdoZXJlYXMgNDkgaG91cnMgd2lsbCBiZSBcImhvdXJzXCIuXHJcbi8vIEFjY2VwdHMgc3RhcnQvZW5kLCBhIHJhbmdlIG9iamVjdCwgb3IgYW4gb3JpZ2luYWwgZHVyYXRpb24gb2JqZWN0LlxyXG5mdW5jdGlvbiBjb21wdXRlR3JlYXRlc3RVbml0KHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHVuaXQ7XHJcbiAgICB2YXIgdmFsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMudW5pdHNEZXNjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdW5pdCA9IGV4cG9ydHMudW5pdHNEZXNjW2ldO1xyXG4gICAgICAgIHZhbCA9IGNvbXB1dGVSYW5nZUFzKHVuaXQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGlmICh2YWwgPj0gMSAmJiBpc0ludCh2YWwpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bml0OyAvLyB3aWxsIGJlIFwibWlsbGlzZWNvbmRzXCIgaWYgbm90aGluZyBlbHNlIG1hdGNoZXNcclxufVxyXG5leHBvcnRzLmNvbXB1dGVHcmVhdGVzdFVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0O1xyXG4vLyBsaWtlIGNvbXB1dGVHcmVhdGVzdFVuaXQsIGJ1dCBoYXMgc3BlY2lhbCBhYmlsaXRpZXMgdG8gaW50ZXJwcmV0IHRoZSBzb3VyY2UgaW5wdXQgZm9yIGNsdWVzXHJcbmZ1bmN0aW9uIGNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkdXJhdGlvbiwgZHVyYXRpb25JbnB1dCkge1xyXG4gICAgdmFyIHVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcclxuICAgIC8vIHByZXZlbnQgZGF5czo3IGZyb20gYmVpbmcgaW50ZXJwcmV0ZWQgYXMgYSB3ZWVrXHJcbiAgICBpZiAodW5pdCA9PT0gJ3dlZWsnICYmIHR5cGVvZiBkdXJhdGlvbklucHV0ID09PSAnb2JqZWN0JyAmJiBkdXJhdGlvbklucHV0LmRheXMpIHtcclxuICAgICAgICB1bml0ID0gJ2RheSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5pdDtcclxufVxyXG5leHBvcnRzLmNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdCA9IGNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdDtcclxuLy8gQ29tcHV0ZXMgdGhlIG51bWJlciBvZiB1bml0cyAobGlrZSBcImhvdXJzXCIpIGluIHRoZSBnaXZlbiByYW5nZS5cclxuLy8gUmFuZ2UgY2FuIGJlIGEge3N0YXJ0LGVuZH0gb2JqZWN0LCBzZXBhcmF0ZSBzdGFydC9lbmQgYXJncywgb3IgYSBEdXJhdGlvbi5cclxuLy8gUmVzdWx0cyBhcmUgYmFzZWQgb24gTW9tZW50J3MgLmFzKCkgYW5kIC5kaWZmKCkgbWV0aG9kcywgc28gcmVzdWx0cyBjYW4gZGVwZW5kIG9uIGludGVybmFsIGhhbmRsaW5nXHJcbi8vIG9mIG1vbnRoLWRpZmZpbmcgbG9naWMgKHdoaWNoIHRlbmRzIHRvIHZhcnkgZnJvbSB2ZXJzaW9uIHRvIHZlcnNpb24pLlxyXG5mdW5jdGlvbiBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoZW5kICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobW9tZW50LmlzRHVyYXRpb24oc3RhcnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmFzKHVuaXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmVuZC5kaWZmKHN0YXJ0LnN0YXJ0LCB1bml0LCB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vLyBJbnRlbGxpZ2VudGx5IGRpdmlkZXMgYSByYW5nZSAoc3BlY2lmaWVkIGJ5IGEgc3RhcnQvZW5kIHBhcmFtcykgYnkgYSBkdXJhdGlvblxyXG5mdW5jdGlvbiBkaXZpZGVSYW5nZUJ5RHVyYXRpb24oc3RhcnQsIGVuZCwgZHVyKSB7XHJcbiAgICB2YXIgbW9udGhzO1xyXG4gICAgaWYgKGR1cmF0aW9uSGFzVGltZShkdXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXI7XHJcbiAgICB9XHJcbiAgICBtb250aHMgPSBkdXIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xyXG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgJ21vbnRocycsIHRydWUpIC8gbW9udGhzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnZGF5cycsIHRydWUpIC8gZHVyLmFzRGF5cygpO1xyXG59XHJcbmV4cG9ydHMuZGl2aWRlUmFuZ2VCeUR1cmF0aW9uID0gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uO1xyXG4vLyBJbnRlbGxpZ2VudGx5IGRpdmlkZXMgb25lIGR1cmF0aW9uIGJ5IGFub3RoZXJcclxuZnVuY3Rpb24gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKGR1cjEsIGR1cjIpIHtcclxuICAgIHZhciBtb250aHMxO1xyXG4gICAgdmFyIG1vbnRoczI7XHJcbiAgICBpZiAoZHVyYXRpb25IYXNUaW1lKGR1cjEpIHx8IGR1cmF0aW9uSGFzVGltZShkdXIyKSkge1xyXG4gICAgICAgIHJldHVybiBkdXIxIC8gZHVyMjtcclxuICAgIH1cclxuICAgIG1vbnRoczEgPSBkdXIxLmFzTW9udGhzKCk7XHJcbiAgICBtb250aHMyID0gZHVyMi5hc01vbnRocygpO1xyXG4gICAgaWYgKE1hdGguYWJzKG1vbnRoczEpID49IDEgJiYgaXNJbnQobW9udGhzMSkgJiZcclxuICAgICAgICBNYXRoLmFicyhtb250aHMyKSA+PSAxICYmIGlzSW50KG1vbnRoczIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbnRoczEgLyBtb250aHMyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGR1cjEuYXNEYXlzKCkgLyBkdXIyLmFzRGF5cygpO1xyXG59XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uO1xyXG4vLyBJbnRlbGxpZ2VudGx5IG11bHRpcGxpZXMgYSBkdXJhdGlvbiBieSBhIG51bWJlclxyXG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGR1ciwgbikge1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZHVyICogbik7XHJcbiAgICB9XHJcbiAgICBtb250aHMgPSBkdXIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBtb250aHM6IG1vbnRocyAqIG4gfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogZHVyLmFzRGF5cygpICogbiB9KTtcclxufVxyXG5leHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBkdXJhdGlvbiBoYXMgYW55IHRpbWUgcGFydHMgKGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcylcclxuZnVuY3Rpb24gZHVyYXRpb25IYXNUaW1lKGR1cikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZHVyLmhvdXJzKCkgfHwgZHVyLm1pbnV0ZXMoKSB8fCBkdXIuc2Vjb25kcygpIHx8IGR1ci5taWxsaXNlY29uZHMoKSk7XHJcbn1cclxuZXhwb3J0cy5kdXJhdGlvbkhhc1RpbWUgPSBkdXJhdGlvbkhhc1RpbWU7XHJcbmZ1bmN0aW9uIGlzTmF0aXZlRGF0ZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJyB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XHJcbn1cclxuZXhwb3J0cy5pc05hdGl2ZURhdGUgPSBpc05hdGl2ZURhdGU7XHJcbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgdGltZSBzdHJpbmcsIGxpa2UgXCIwNjo0MDowMFwiIG9yIFwiMDY6MDBcIlxyXG5mdW5jdGlvbiBpc1RpbWVTdHJpbmcoc3RyKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAvXlxcZCtcXDpcXGQrKD86XFw6XFxkK1xcLj8oPzpcXGR7M30pPyk/JC8udGVzdChzdHIpO1xyXG59XHJcbmV4cG9ydHMuaXNUaW1lU3RyaW5nID0gaXNUaW1lU3RyaW5nO1xyXG4vKiBMb2dnaW5nIGFuZCBEZWJ1Z1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gbG9nKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubG9nID0gbG9nO1xyXG5mdW5jdGlvbiB3YXJuKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9nLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMud2FybiA9IHdhcm47XHJcbi8qIEdlbmVyYWwgVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgaGFzT3duUHJvcE1ldGhvZCA9IHt9Lmhhc093blByb3BlcnR5O1xyXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cclxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wcykge1xyXG4gICAgdmFyIGRlc3QgPSB7fTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIG5hbWU7XHJcbiAgICB2YXIgY29tcGxleE9ianM7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciB2YWw7XHJcbiAgICB2YXIgcHJvcHM7XHJcbiAgICBpZiAoY29tcGxleFByb3BzKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXhQcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuYW1lID0gY29tcGxleFByb3BzW2ldO1xyXG4gICAgICAgICAgICBjb21wbGV4T2JqcyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXHJcbiAgICAgICAgICAgIGZvciAoaiA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwcm9wT2Jqc1tqXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSB0cmFpbGluZyB2YWx1ZXMgd2VyZSBvYmplY3RzLCB1c2UgdGhlIG1lcmdlZCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XHJcbiAgICBmb3IgKGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHByb3BzID0gcHJvcE9ianNbaV07XHJcbiAgICAgICAgZm9yIChuYW1lIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gZGVzdCkpIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZXN0O1xyXG59XHJcbmV4cG9ydHMubWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHM7XHJcbmZ1bmN0aW9uIGNvcHlPd25Qcm9wcyhzcmMsIGRlc3QpIHtcclxuICAgIGZvciAodmFyIG5hbWVfMSBpbiBzcmMpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcChzcmMsIG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgZGVzdFtuYW1lXzFdID0gc3JjW25hbWVfMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29weU93blByb3BzID0gY29weU93blByb3BzO1xyXG5mdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwgbmFtZSkge1xyXG4gICAgcmV0dXJuIGhhc093blByb3BNZXRob2QuY2FsbChvYmosIG5hbWUpO1xyXG59XHJcbmV4cG9ydHMuaGFzT3duUHJvcCA9IGhhc093blByb3A7XHJcbmZ1bmN0aW9uIGFwcGx5QWxsKGZ1bmN0aW9ucywgdGhpc09iaiwgYXJncykge1xyXG4gICAgaWYgKCQuaXNGdW5jdGlvbihmdW5jdGlvbnMpKSB7XHJcbiAgICAgICAgZnVuY3Rpb25zID0gW2Z1bmN0aW9uc107XHJcbiAgICB9XHJcbiAgICBpZiAoZnVuY3Rpb25zKSB7XHJcbiAgICAgICAgdmFyIGkgPSB2b2lkIDA7XHJcbiAgICAgICAgdmFyIHJldCA9IHZvaWQgMDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldCA9IGZ1bmN0aW9uc1tpXS5hcHBseSh0aGlzT2JqLCBhcmdzKSB8fCByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBseUFsbCA9IGFwcGx5QWxsO1xyXG5mdW5jdGlvbiByZW1vdmVNYXRjaGluZyhhcnJheSwgdGVzdEZ1bmMpIHtcclxuICAgIHZhciByZW1vdmVDbnQgPSAwO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAodGVzdEZ1bmMoYXJyYXlbaV0pKSB7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmVtb3ZlQ250Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZUNudDtcclxufVxyXG5leHBvcnRzLnJlbW92ZU1hdGNoaW5nID0gcmVtb3ZlTWF0Y2hpbmc7XHJcbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xyXG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcclxuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICByZW1vdmVDbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG59XHJcbmV4cG9ydHMucmVtb3ZlRXhhY3QgPSByZW1vdmVFeGFjdDtcclxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEpIHtcclxuICAgIHZhciBsZW4gPSBhMC5sZW5ndGg7XHJcbiAgICB2YXIgaTtcclxuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gIT09IGExLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChhMFtpXSAhPT0gYTFbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheXNFcXVhbCA9IGlzQXJyYXlzRXF1YWw7XHJcbmZ1bmN0aW9uIGZpcnN0RGVmaW5lZCgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhcmdzW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZmlyc3REZWZpbmVkID0gZmlyc3REZWZpbmVkO1xyXG5mdW5jdGlvbiBodG1sRXNjYXBlKHMpIHtcclxuICAgIHJldHVybiAocyArICcnKS5yZXBsYWNlKC8mL2csICcmYW1wOycpXHJcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcclxuICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7JylcclxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnPGJyIC8+Jyk7XHJcbn1cclxuZXhwb3J0cy5odG1sRXNjYXBlID0gaHRtbEVzY2FwZTtcclxuZnVuY3Rpb24gc3RyaXBIdG1sRW50aXRpZXModGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvJi4qPzsvZywgJycpO1xyXG59XHJcbmV4cG9ydHMuc3RyaXBIdG1sRW50aXRpZXMgPSBzdHJpcEh0bWxFbnRpdGllcztcclxuLy8gR2l2ZW4gYSBoYXNoIG9mIENTUyBwcm9wZXJ0aWVzLCByZXR1cm5zIGEgc3RyaW5nIG9mIENTUy5cclxuLy8gVXNlcyBwcm9wZXJ0eSBuYW1lcyBhcy1pcyAobm8gY2FtZWwtY2FzZSBjb252ZXJzaW9uKS4gV2lsbCBub3QgbWFrZSBzdGF0ZW1lbnRzIGZvciBudWxsL3VuZGVmaW5lZCB2YWx1ZXMuXHJcbmZ1bmN0aW9uIGNzc1RvU3RyKGNzc1Byb3BzKSB7XHJcbiAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xyXG4gICAgJC5lYWNoKGNzc1Byb3BzLCBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuYW1lICsgJzonICsgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdGF0ZW1lbnRzLmpvaW4oJzsnKTtcclxufVxyXG5leHBvcnRzLmNzc1RvU3RyID0gY3NzVG9TdHI7XHJcbi8vIEdpdmVuIGFuIG9iamVjdCBoYXNoIG9mIEhUTUwgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcyxcclxuLy8gZ2VuZXJhdGVzIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGluamVjdGVkIGJldHdlZW4gPCA+IGluIEhUTUxcclxuZnVuY3Rpb24gYXR0cnNUb1N0cihhdHRycykge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICAkLmVhY2goYXR0cnMsIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChuYW1lICsgJz1cIicgKyBodG1sRXNjYXBlKHZhbCkgKyAnXCInKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcgJyk7XHJcbn1cclxuZXhwb3J0cy5hdHRyc1RvU3RyID0gYXR0cnNUb1N0cjtcclxuZnVuY3Rpb24gY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxufVxyXG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IGNhcGl0YWxpc2VGaXJzdExldHRlcjtcclxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZU51bWJlcnMgPSBjb21wYXJlTnVtYmVycztcclxuZnVuY3Rpb24gaXNJbnQobikge1xyXG4gICAgcmV0dXJuIG4gJSAxID09PSAwO1xyXG59XHJcbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcclxuLy8gUmV0dXJucyBhIG1ldGhvZCBib3VuZCB0byB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnRleHQuXHJcbi8vIEp1c3QgbGlrZSBvbmUgb2YgdGhlIGpRdWVyeS5wcm94eSBzaWduYXR1cmVzLCBidXQgd2l0aG91dCB0aGUgdW5kZXNpcmVkIGJlaGF2aW9yIG9mIHRyZWF0aW5nIHRoZSBzYW1lIG1ldGhvZCB3aXRoXHJcbi8vIGRpZmZlcmVudCBjb250ZXh0cyBhcyBpZGVudGljYWwgd2hlbiBiaW5kaW5nL3VuYmluZGluZyBldmVudHMuXHJcbmZ1bmN0aW9uIHByb3h5KG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucHJveHkgPSBwcm94eTtcclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxyXG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXHJcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxyXG4vLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvYmxvYi8xLjYuMC91bmRlcnNjb3JlLmpzI0w3MTRcclxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XHJcbiAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cclxuICAgIHZhciB0aW1lb3V0O1xyXG4gICAgdmFyIGFyZ3M7XHJcbiAgICB2YXIgY29udGV4dDtcclxuICAgIHZhciB0aW1lc3RhbXA7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsYXN0ID0gK25ldyBEYXRlKCkgLSB0aW1lc3RhbXA7XHJcbiAgICAgICAgaWYgKGxhc3QgPCB3YWl0KSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHRpbWVzdGFtcCA9ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xyXG4gICAgICAgIGlmICghdGltZW91dCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsTm93KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxudmFyIFVuem9uZWRSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVuem9uZWRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCkge1xyXG4gICAgICAgIC8vIFRPRE86IG1vdmUgdGhlc2UgaW50byBmb290cHJpbnQuXHJcbiAgICAgICAgLy8gRXNwZWNpYWxseSwgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBudWxsIHN0YXJ0TXMvZW5kTXMuXHJcbiAgICAgICAgdGhpcy5pc1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KHN0YXJ0SW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5wdXQgPSBzdGFydElucHV0LmNsb25lKCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb21lbnQuaXNNb21lbnQoZW5kSW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGVuZElucHV0ID0gZW5kSW5wdXQuY2xvbmUoKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydE1zID0gc3RhcnRJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZE1zID0gZW5kSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBTSURFRUZGRUNUOiB3aWxsIG11dGF0ZSBldmVudFJhbmdlcy5cclxuICAgIFdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHJlc3VsdC5cclxuICAgIE9ubHkgd29ya3MgZm9yIG5vbi1vcGVuLWVuZGVkIHJhbmdlcy5cclxuICAgICovXHJcbiAgICBVbnpvbmVkUmFuZ2UuaW52ZXJ0UmFuZ2VzID0gZnVuY3Rpb24gKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIHN0YXJ0TXMgPSBjb25zdHJhaW50UmFuZ2Uuc3RhcnRNczsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRhdGVSYW5nZTtcclxuICAgICAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXHJcbiAgICAgICAgcmFuZ2VzLnNvcnQoY29tcGFyZVVuem9uZWRSYW5nZXMpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0ZVJhbmdlID0gcmFuZ2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBiZWZvcmUgdGhlIGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXHJcbiAgICAgICAgICAgIGlmIChkYXRlUmFuZ2Uuc3RhcnRNcyA+IHN0YXJ0TXMpIHtcclxuICAgICAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBkYXRlUmFuZ2Uuc3RhcnRNcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kTXMgPiBzdGFydE1zKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1zID0gZGF0ZVJhbmdlLmVuZE1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXHJcbiAgICAgICAgaWYgKHN0YXJ0TXMgPCBjb25zdHJhaW50UmFuZ2UuZW5kTXMpIHtcclxuICAgICAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaChuZXcgVW56b25lZFJhbmdlKHN0YXJ0TXMsIGNvbnN0cmFpbnRSYW5nZS5lbmRNcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW52ZXJ0ZWRSYW5nZXM7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiAob3RoZXJSYW5nZSkge1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgIHZhciBlbmRNcyA9IHRoaXMuZW5kTXM7XHJcbiAgICAgICAgdmFyIG5ld1JhbmdlID0gbnVsbDtcclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0TXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNcyA9IG90aGVyUmFuZ2Uuc3RhcnRNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TXMgPSBNYXRoLm1heChzdGFydE1zLCBvdGhlclJhbmdlLnN0YXJ0TXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGVuZE1zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGVuZE1zID0gb3RoZXJSYW5nZS5lbmRNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuZE1zID0gTWF0aC5taW4oZW5kTXMsIG90aGVyUmFuZ2UuZW5kTXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydE1zID09IG51bGwgfHwgZW5kTXMgPT0gbnVsbCB8fCBzdGFydE1zIDwgZW5kTXMpIHtcclxuICAgICAgICAgICAgbmV3UmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlKHN0YXJ0TXMsIGVuZE1zKTtcclxuICAgICAgICAgICAgbmV3UmFuZ2UuaXNTdGFydCA9IHRoaXMuaXNTdGFydCAmJiBzdGFydE1zID09PSB0aGlzLnN0YXJ0TXM7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlLmlzRW5kID0gdGhpcy5pc0VuZCAmJiBlbmRNcyA9PT0gdGhpcy5lbmRNcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1JhbmdlO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0c1dpdGggPSBmdW5jdGlvbiAob3RoZXJSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lbmRNcyA9PSBudWxsIHx8IG90aGVyUmFuZ2Uuc3RhcnRNcyA9PSBudWxsIHx8IHRoaXMuZW5kTXMgPiBvdGhlclJhbmdlLnN0YXJ0TXMpICYmXHJcbiAgICAgICAgICAgICh0aGlzLnN0YXJ0TXMgPT0gbnVsbCB8fCBvdGhlclJhbmdlLmVuZE1zID09IG51bGwgfHwgdGhpcy5zdGFydE1zIDwgb3RoZXJSYW5nZS5lbmRNcyk7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5jb250YWluc1JhbmdlID0gZnVuY3Rpb24gKGlubmVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRNcyA9PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0TXMgIT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0TXMgPj0gdGhpcy5zdGFydE1zKSkgJiZcclxuICAgICAgICAgICAgKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmRNcyAhPSBudWxsICYmIGlubmVyUmFuZ2UuZW5kTXMgPD0gdGhpcy5lbmRNcykpO1xyXG4gICAgfTtcclxuICAgIC8vIGBkYXRlYCBjYW4gYmUgYSBtb21lbnQsIGEgRGF0ZSwgb3IgYSBtaWxsaXNlY29uZCB0aW1lLlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5jb250YWluc0RhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBtcyA9IGRhdGUudmFsdWVPZigpO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydE1zID09IG51bGwgfHwgbXMgPj0gdGhpcy5zdGFydE1zKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5lbmRNcyA9PSBudWxsIHx8IG1zIDwgdGhpcy5lbmRNcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxyXG4gICAgLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXHJcbiAgICAvLyBgZGF0ZWAgY2FuIGJlIGEgbW9tZW50LCBhIERhdGUsIG9yIGEgbWlsbGlzZWNvbmQgdGltZS5cclxuICAgIC8vIFJldHVybnMgYSBNUy10aW1lLlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5jb25zdHJhaW5EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgbXMgPSBkYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICBpZiAodGhpcy5zdGFydE1zICE9IG51bGwgJiYgbXMgPCB0aGlzLnN0YXJ0TXMpIHtcclxuICAgICAgICAgICAgbXMgPSB0aGlzLnN0YXJ0TXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmVuZE1zICE9IG51bGwgJiYgbXMgPj0gdGhpcy5lbmRNcykge1xyXG4gICAgICAgICAgICBtcyA9IHRoaXMuZW5kTXMgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXM7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXJSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TXMgPT09IG90aGVyUmFuZ2Uuc3RhcnRNcyAmJiB0aGlzLmVuZE1zID09PSBvdGhlclJhbmdlLmVuZE1zO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFVuem9uZWRSYW5nZSh0aGlzLnN0YXJ0TXMsIHRoaXMuZW5kTXMpO1xyXG4gICAgICAgIHJhbmdlLmlzU3RhcnQgPSB0aGlzLmlzU3RhcnQ7XHJcbiAgICAgICAgcmFuZ2UuaXNFbmQgPSB0aGlzLmlzRW5kO1xyXG4gICAgICAgIHJldHVybiByYW5nZTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGFuIGFtYmlnLXpvbmVkIG1vbWVudCBmcm9tIHN0YXJ0TXMuXHJcbiAgICAvLyBCRVdBUkU6IHJldHVybmVkIG1vbWVudCBpcyBub3QgbG9jYWxpemVkLlxyXG4gICAgLy8gRm9ybWF0dGluZyBhbmQgc3RhcnQtb2Ytd2VlayB3aWxsIGJlIGRlZmF1bHQuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmdldFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKHRoaXMuc3RhcnRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYW4gYW1iaWctem9uZWQgbW9tZW50IGZyb20gc3RhcnRNcy5cclxuICAgIC8vIEJFV0FSRTogcmV0dXJuZWQgbW9tZW50IGlzIG5vdCBsb2NhbGl6ZWQuXHJcbiAgICAvLyBGb3JtYXR0aW5nIGFuZCBzdGFydC1vZi13ZWVrIHdpbGwgYmUgZGVmYXVsdC5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuZ2V0RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVuZE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyh0aGlzLmVuZE1zKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5hcyA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC51dGModGhpcy5lbmRNcykuZGlmZihtb21lbnQudXRjKHRoaXMuc3RhcnRNcyksIHVuaXQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVbnpvbmVkUmFuZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFVuem9uZWRSYW5nZTtcclxuLypcclxuT25seSB3b3JrcyBmb3Igbm9uLW9wZW4tZW5kZWQgcmFuZ2VzLlxyXG4qL1xyXG5mdW5jdGlvbiBjb21wYXJlVW56b25lZFJhbmdlcyhyYW5nZTEsIHJhbmdlMikge1xyXG4gICAgcmV0dXJuIHJhbmdlMS5zdGFydE1zIC0gcmFuZ2UyLnN0YXJ0TXM7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgUGFyc2FibGVNb2RlbE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOCk7XHJcbnZhciBDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbnZhciBFdmVudERlZlBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgLy8gY2FuIHdlIGRvIGF3YXkgd2l0aCBjYWxlbmRhcj8gYXQgbGVhc3QgZm9yIHRoZSBhYnN0cmFjdD9cclxuICAgIC8vIHVzZWZ1bCBmb3IgYnVpbGRFdmVudERlZlxyXG4gICAgZnVuY3Rpb24gRXZlbnRTb3VyY2UoY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMuY2xhc3NOYW1lID0gW107XHJcbiAgICAgICAgX3RoaXMudWlkID0gU3RyaW5nKEV2ZW50U291cmNlLnV1aWQrKyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIHJhd0lucHV0IGNhbiBiZSBhbnkgZGF0YSB0eXBlIVxyXG4gICAgKi9cclxuICAgIEV2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBuZXcgdGhpcyhjYWxlbmRhcik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXdJbnB1dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5hcHBseVByb3BzKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2Uubm9ybWFsaXplSWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQuIG11c3QgcmV0dXJuIGEgcHJvbWlzZS5cclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBvcHRpb25hbCBmb3Igc3ViY2xhc3NlcyB0byBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgRm9yIGNvbXBhaXJpbmcvbWF0Y2hpbmdcclxuICAgICovXHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJpbWl0aXZlID0gZnVuY3Rpb24gKG90aGVyU291cmNlKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5wYXJzZUV2ZW50RGVmcyA9IGZ1bmN0aW9uIChyYXdFdmVudERlZnMpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYXdFdmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnREZWYgPSB0aGlzLnBhcnNlRXZlbnREZWYocmF3RXZlbnREZWZzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZnMucHVzaChldmVudERlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50RGVmcztcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucGFyc2VFdmVudERlZiA9IGZ1bmN0aW9uIChyYXdJbnB1dCkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhclRyYW5zZm9ybSA9IHRoaXMuY2FsZW5kYXIub3B0KCdldmVudERhdGFUcmFuc2Zvcm0nKTtcclxuICAgICAgICB2YXIgc291cmNlVHJhbnNmb3JtID0gdGhpcy5ldmVudERhdGFUcmFuc2Zvcm07XHJcbiAgICAgICAgaWYgKGNhbGVuZGFyVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJhd0lucHV0ID0gY2FsZW5kYXJUcmFuc2Zvcm0ocmF3SW5wdXQsIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc291cmNlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJhd0lucHV0ID0gc291cmNlVHJhbnNmb3JtKHJhd0lucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEV2ZW50RGVmUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShyYXdJbnB1dCwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIGlmIChyYXdQcm9wcy5pZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudFNvdXJjZS5ub3JtYWxpemVJZChyYXdQcm9wcy5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGNvbnZlcmdlIHdpdGggRXZlbnREZWZcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd1Byb3BzLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByYXdQcm9wcy5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnV1aWQgPSAwO1xyXG4gICAgRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQuZGVmaW5lU3RhbmRhcmRQcm9wcztcclxuICAgIEV2ZW50U291cmNlLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICByZXR1cm4gRXZlbnRTb3VyY2U7XHJcbn0oQ2xhc3NfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50U291cmNlO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnRTb3VyY2UpO1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5FdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIC8vIG1hbnVhbGx5IHByb2Nlc3MuLi5cclxuICAgIGlkOiBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogZmFsc2UsXHJcbiAgICAvLyBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyLi4uXHJcbiAgICBjb2xvcjogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcclxuICAgIGJvcmRlckNvbG9yOiB0cnVlLFxyXG4gICAgdGV4dENvbG9yOiB0cnVlLFxyXG4gICAgZWRpdGFibGU6IHRydWUsXHJcbiAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxyXG4gICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcclxuICAgIHJlbmRlcmluZzogdHJ1ZSxcclxuICAgIG92ZXJsYXA6IHRydWUsXHJcbiAgICBjb25zdHJhaW50OiB0cnVlLFxyXG4gICAgYWxsRGF5RGVmYXVsdDogdHJ1ZSxcclxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogdHJ1ZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKlxyXG5VdGlsaXR5IG1ldGhvZHMgZm9yIGVhc2lseSBsaXN0ZW5pbmcgdG8gZXZlbnRzIG9uIGFub3RoZXIgb2JqZWN0LFxyXG5hbmQgbW9yZSBpbXBvcnRhbnRseSwgZWFzaWx5IHVubGlzdGVuaW5nIGZyb20gdGhlbS5cclxuXG5VU0FHRTpcclxuICBpbXBvcnQgeyBkZWZhdWx0IGFzIExpc3RlbmVyTWl4aW4sIExpc3RlbmVySW50ZXJmYWNlIH0gZnJvbSAnLi9MaXN0ZW5lck1peGluJ1xyXG5pbiBjbGFzczpcclxuICBsaXN0ZW5UbzogTGlzdGVuZXJJbnRlcmZhY2VbJ2xpc3RlblRvJ11cclxuICBzdG9wTGlzdGVuaW5nVG86IExpc3RlbmVySW50ZXJmYWNlWydzdG9wTGlzdGVuaW5nVG8nXVxyXG5hZnRlciBjbGFzczpcclxuICBMaXN0ZW5lck1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBndWlkID0gMDtcclxudmFyIExpc3RlbmVyTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0ZW5lck1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdGVuZXJNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgR2l2ZW4gYW4gYG90aGVyYCBvYmplY3QgdGhhdCBoYXMgb24vb2ZmIG1ldGhvZHMsIGJpbmQgdGhlIGdpdmVuIGBjYWxsYmFja2AgdG8gYW4gZXZlbnQgYnkgdGhlIGdpdmVuIG5hbWUuXHJcbiAgICBUaGUgYGNhbGxiYWNrYCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgb2JqZWN0IHRoYXQgLmxpc3RlblRvIGlzIGJlaW5nIGNhbGxlZCBvbi5cclxuICAgIENhbiBiZSBjYWxsZWQ6XHJcbiAgICAgIC5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBjYWxsYmFjaylcclxuICAgIE9SXHJcbiAgICAgIC5saXN0ZW5UbyhvdGhlciwge1xyXG4gICAgICAgIGV2ZW50TmFtZTE6IGNhbGxiYWNrMSxcclxuICAgICAgICBldmVudE5hbWUyOiBjYWxsYmFjazJcclxuICAgICAgfSlcclxuICAgICovXHJcbiAgICBMaXN0ZW5lck1peGluLnByb3RvdHlwZS5saXN0ZW5UbyA9IGZ1bmN0aW9uIChvdGhlciwgYXJnLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGFyZ1tldmVudE5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvdGhlci5vbihhcmcgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCksIC8vIHVzZSBldmVudCBuYW1lc3BhY2luZyB0byBpZGVudGlmeSB0aGlzIG9iamVjdFxyXG4gICAgICAgICAgICAkLnByb3h5KGNhbGxiYWNrLCB0aGlzKSAvLyBhbHdheXMgdXNlIGB0aGlzYCBjb250ZXh0XHJcbiAgICAgICAgICAgIC8vIHRoZSB1c3VhbGx5LXVuZGVzaXJlZCBqUXVlcnkgZ3VpZCBiZWhhdmlvciBkb2Vzbid0IG1hdHRlcixcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhbHdheXMgdW5iaW5kIHZpYSBuYW1lc3BhY2VcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIENhdXNlcyB0aGUgY3VycmVudCBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZXZlbnRzIG9uIHRoZSBgb3RoZXJgIG9iamVjdC5cclxuICAgIGBldmVudE5hbWVgIGlzIG9wdGlvbmFsLiBJZiBvbWl0dGVkLCB3aWxsIHN0b3AgbGlzdGVuaW5nIHRvIEFMTCBldmVudHMgb24gYG90aGVyYC5cclxuICAgICovXHJcbiAgICBMaXN0ZW5lck1peGluLnByb3RvdHlwZS5zdG9wTGlzdGVuaW5nVG8gPSBmdW5jdGlvbiAob3RoZXIsIGV2ZW50TmFtZSkge1xyXG4gICAgICAgIG90aGVyLm9mZigoZXZlbnROYW1lIHx8ICcnKSArICcuJyArIHRoaXMuZ2V0TGlzdGVuZXJOYW1lc3BhY2UoKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFJldHVybnMgYSBzdHJpbmcsIHVuaXF1ZSB0byB0aGlzIG9iamVjdCwgdG8gYmUgdXNlZCBmb3IgZXZlbnQgbmFtZXNwYWNpbmdcclxuICAgICovXHJcbiAgICBMaXN0ZW5lck1peGluLnByb3RvdHlwZS5nZXRMaXN0ZW5lck5hbWVzcGFjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcklkID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcklkID0gZ3VpZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ19saXN0ZW5lcicgKyB0aGlzLmxpc3RlbmVySWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RlbmVyTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RlbmVyTWl4aW47XHJcblxuXG4vKioqLyB9KSxcbi8qIDggKi8sXG4vKiA5ICovLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIGFtYmlnRGF0ZU9mTW9udGhSZWdleCA9IC9eXFxzKlxcZHs0fS1cXGRcXGQkLztcclxudmFyIGFtYmlnVGltZU9yWm9uZVJlZ2V4ID0gL15cXHMqXFxkezR9LSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KT8kLztcclxudmFyIG5ld01vbWVudFByb3RvID0gbW9tZW50LmZuOyAvLyB3aGVyZSB3ZSB3aWxsIGF0dGFjaCBvdXIgbmV3IG1ldGhvZHNcclxuZXhwb3J0cy5uZXdNb21lbnRQcm90byA9IG5ld01vbWVudFByb3RvO1xyXG52YXIgb2xkTW9tZW50UHJvdG8gPSAkLmV4dGVuZCh7fSwgbmV3TW9tZW50UHJvdG8pOyAvLyBjb3B5IG9mIG9yaWdpbmFsIG1vbWVudCBtZXRob2RzXHJcbmV4cG9ydHMub2xkTW9tZW50UHJvdG8gPSBvbGRNb21lbnRQcm90bztcclxuLy8gdGVsbCBtb21lbnRqcyB0byB0cmFuc2ZlciB0aGVzZSBwcm9wZXJ0aWVzIHVwb24gY2xvbmVcclxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBtb21lbnQubW9tZW50UHJvcGVydGllcztcclxubW9tZW50UHJvcGVydGllcy5wdXNoKCdfZnVsbENhbGVuZGFyJyk7XHJcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2FtYmlnVGltZScpO1xyXG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1pvbmUnKTtcclxuLypcclxuQ2FsbCB0aGlzIGlmIHlvdSB3YW50IE1vbWVudCdzIG9yaWdpbmFsIGZvcm1hdCBtZXRob2QgdG8gYmUgdXNlZFxyXG4qL1xyXG5mdW5jdGlvbiBvbGRNb21lbnRGb3JtYXQobW9tLCBmb3JtYXRTdHIpIHtcclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by5mb3JtYXQuY2FsbChtb20sIGZvcm1hdFN0cik7IC8vIG9sZE1vbWVudFByb3RvIGRlZmluZWQgaW4gbW9tZW50LWV4dC5qc1xyXG59XHJcbmV4cG9ydHMub2xkTW9tZW50Rm9ybWF0ID0gb2xkTW9tZW50Rm9ybWF0O1xyXG4vLyBDcmVhdGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENyZWF0ZXMgYSBuZXcgbW9tZW50LCBzaW1pbGFyIHRvIHRoZSB2YW5pbGxhIG1vbWVudCguLi4pIGNvbnN0cnVjdG9yLCBidXQgd2l0aFxyXG4vLyBleHRyYSBmZWF0dXJlcyAoYW1iaWd1b3VzIHRpbWUsIGVuaGFuY2VkIGZvcm1hdHRpbmcpLiBXaGVuIGdpdmVuIGFuIGV4aXN0aW5nIG1vbWVudCxcclxuLy8gaXQgd2lsbCBmdW5jdGlvbiBhcyBhIGNsb25lIChhbmQgcmV0YWluIHRoZSB6b25lIG9mIHRoZSBtb21lbnQpLiBBbnl0aGluZyBlbHNlIHdpbGxcclxuLy8gcmVzdWx0IGluIGEgbW9tZW50IGluIHRoZSBsb2NhbCB6b25lLlxyXG52YXIgbW9tZW50RXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1ha2VNb21lbnQoYXJndW1lbnRzKTtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gbW9tZW50RXh0O1xyXG4vLyBTYW1lcyBhcyBtb21lbnRFeHQsIGJ1dCBmb3JjZXMgdGhlIHJlc3VsdGluZyBtb21lbnQgdG8gYmUgaW4gdGhlIFVUQyB0aW1lem9uZS5cclxubW9tZW50RXh0LnV0YyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtb20gPSBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSk7XHJcbiAgICAvLyBGb3JjZSBpdCBpbnRvIFVUQyBiZWNhdXNlIG1ha2VNb21lbnQgZG9lc24ndCBndWFyYW50ZWUgaXRcclxuICAgIC8vIChpZiBnaXZlbiBhIHByZS1leGlzdGluZyBtb21lbnQgZm9yIGV4YW1wbGUpXHJcbiAgICBpZiAobW9tLmhhc1RpbWUoKSkge1xyXG4gICAgICAgIG1vbS51dGMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb207XHJcbn07XHJcbi8vIFNhbWUgYXMgbW9tZW50RXh0LCBidXQgd2hlbiBnaXZlbiBhbiBJU084NjAxIHN0cmluZywgdGhlIHRpbWV6b25lIG9mZnNldCBpcyBwcmVzZXJ2ZWQuXHJcbi8vIElTTzg2MDEgc3RyaW5ncyB3aXRoIG5vIHRpbWV6b25lIG9mZnNldCB3aWxsIGJlY29tZSBhbWJpZ3VvdXNseSB6b25lZC5cclxubW9tZW50RXh0LnBhcnNlWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSk7XHJcbn07XHJcbi8vIEJ1aWxkcyBhbiBlbmhhbmNlZCBtb21lbnQgZnJvbSBhcmdzLiBXaGVuIGdpdmVuIGFuIGV4aXN0aW5nIG1vbWVudCwgaXQgY2xvbmVzLiBXaGVuIGdpdmVuIGFcclxuLy8gbmF0aXZlIERhdGUsIG9yIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyAodGhlIGN1cnJlbnQgdGltZSksIHRoZSByZXN1bHRpbmcgbW9tZW50IHdpbGwgYmUgbG9jYWwuXHJcbi8vIEFueXRoaW5nIGVsc2UgbmVlZHMgdG8gYmUgXCJwYXJzZWRcIiAoYSBzdHJpbmcgb3IgYW4gYXJyYXkpLCBhbmQgd2lsbCBiZSBhZmZlY3RlZCBieTpcclxuLy8gICAgcGFyc2VBc1VUQyAtIGlmIHRoZXJlIGlzIG5vIHpvbmUgaW5mb3JtYXRpb24sIHNob3VsZCB3ZSBwYXJzZSB0aGUgaW5wdXQgaW4gVVRDP1xyXG4vLyAgICBwYXJzZVpvbmUgLSBpZiB0aGVyZSBpcyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgZm9yY2UgdGhlIHpvbmUgb2YgdGhlIG1vbWVudD9cclxuZnVuY3Rpb24gbWFrZU1vbWVudChhcmdzLCBwYXJzZUFzVVRDLCBwYXJzZVpvbmUpIHtcclxuICAgIGlmIChwYXJzZUFzVVRDID09PSB2b2lkIDApIHsgcGFyc2VBc1VUQyA9IGZhbHNlOyB9XHJcbiAgICBpZiAocGFyc2Vab25lID09PSB2b2lkIDApIHsgcGFyc2Vab25lID0gZmFsc2U7IH1cclxuICAgIHZhciBpbnB1dCA9IGFyZ3NbMF07XHJcbiAgICB2YXIgaXNTaW5nbGVTdHJpbmcgPSBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xyXG4gICAgdmFyIGlzQW1iaWdUaW1lO1xyXG4gICAgdmFyIGlzQW1iaWdab25lO1xyXG4gICAgdmFyIGFtYmlnTWF0Y2g7XHJcbiAgICB2YXIgbW9tO1xyXG4gICAgaWYgKG1vbWVudC5pc01vbWVudChpbnB1dCkgfHwgdXRpbF8xLmlzTmF0aXZlRGF0ZShpbnB1dCkgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG1vbSA9IG1vbWVudC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlzQW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgaXNBbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoaXNTaW5nbGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGFtYmlnRGF0ZU9mTW9udGhSZWdleC50ZXN0KGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYWNjZXB0IHN0cmluZ3MgbGlrZSAnMjAxNC0wNScsIGJ1dCBjb252ZXJ0IHRvIHRoZSBmaXJzdCBvZiB0aGUgbW9udGhcclxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICctMDEnO1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IFtpbnB1dF07IC8vIGZvciB3aGVuIHdlIHBhc3MgaXQgb24gdG8gbW9tZW50J3MgY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdUaW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoYW1iaWdNYXRjaCA9IGFtYmlnVGltZU9yWm9uZVJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xyXG4gICAgICAgICAgICAgICAgaXNBbWJpZ1RpbWUgPSAhYW1iaWdNYXRjaFs1XTsgLy8gbm8gdGltZSBwYXJ0P1xyXG4gICAgICAgICAgICAgICAgaXNBbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgLy8gYXJyYXlzIGhhdmUgbm8gdGltZXpvbmUgaW5mb3JtYXRpb24sIHNvIGFzc3VtZSBhbWJpZ3VvdXMgem9uZVxyXG4gICAgICAgICAgICBpc0FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSwgcHJvYmFibHkgYSBzdHJpbmcgd2l0aCBhIGZvcm1hdFxyXG4gICAgICAgIGlmIChwYXJzZUFzVVRDIHx8IGlzQW1iaWdUaW1lKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudC51dGMuYXBwbHkobW9tZW50LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQW1iaWdUaW1lKSB7XHJcbiAgICAgICAgICAgIG1vbS5fYW1iaWdUaW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgbW9tLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBhbWJpZ3VvdXMgdGltZSBhbHdheXMgbWVhbnMgYW1iaWd1b3VzIHpvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyc2Vab25lKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FtYmlnWm9uZSkge1xyXG4gICAgICAgICAgICAgICAgbW9tLl9hbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2luZ2xlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBtb20udXRjT2Zmc2V0KGlucHV0KTsgLy8gaWYgbm90IGEgdmFsaWQgem9uZSwgd2lsbCBhc3NpZ24gVVRDXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtb20uX2Z1bGxDYWxlbmRhciA9IHRydWU7IC8vIGZsYWcgZm9yIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHlcclxuICAgIHJldHVybiBtb207XHJcbn1cclxuLy8gV2VlayBOdW1iZXJcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBSZXR1cm5zIHRoZSB3ZWVrIG51bWJlciwgY29uc2lkZXJpbmcgdGhlIGxvY2FsZSdzIGN1c3RvbSB3ZWVrIG51bWJlciBjYWxjdWF0aW9uXHJcbi8vIGB3ZWVrc2AgaXMgYW4gYWxpYXMgZm9yIGB3ZWVrYFxyXG5uZXdNb21lbnRQcm90by53ZWVrID0gbmV3TW9tZW50UHJvdG8ud2Vla3MgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHZhciB3ZWVrQ2FsYyA9IHRoaXMuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjO1xyXG4gICAgaWYgKGlucHV0ID09IG51bGwgJiYgdHlwZW9mIHdlZWtDYWxjID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHdlZWtDYWxjKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2Vla0NhbGMgPT09ICdJU08nKSB7XHJcbiAgICAgICAgcmV0dXJuIG9sZE1vbWVudFByb3RvLmlzb1dlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gSVNPIGdldHRlci9zZXR0ZXJcclxuICAgIH1cclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by53ZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGxvY2FsIGdldHRlci9zZXR0ZXJcclxufTtcclxuLy8gVGltZS1vZi1kYXlcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBHRVRURVJcclxuLy8gUmV0dXJucyBhIER1cmF0aW9uIHdpdGggdGhlIGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcyB2YWx1ZXMgb2YgdGhlIG1vbWVudC5cclxuLy8gSWYgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGEgZHVyYXRpb24gb2YgMDA6MDAgd2lsbCBiZSByZXR1cm5lZC5cclxuLy9cclxuLy8gU0VUVEVSXHJcbi8vIFlvdSBjYW4gc3VwcGx5IGEgRHVyYXRpb24sIGEgTW9tZW50LCBvciBhIER1cmF0aW9uLWxpa2UgYXJndW1lbnQuXHJcbi8vIFdoZW4gc2V0dGluZyB0aGUgdGltZSwgYW5kIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBpdCB0aGVuIGJlY29tZXMgdW5hbWJpZ3VvdXMuXHJcbm5ld01vbWVudFByb3RvLnRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgLy8gRmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZCAoaWYgdGhlcmUgaXMgb25lKSBpZiB0aGlzIG1vbWVudCB3YXNuJ3QgY3JlYXRlZCB2aWEgRnVsbENhbGVuZGFyLlxyXG4gICAgLy8gYHRpbWVgIGlzIGEgZ2VuZXJpYyBlbm91Z2ggbWV0aG9kIG5hbWUgd2hlcmUgdGhpcyBwcmVjYXV0aW9uIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBjb2xsaXNpb25zIHcvIG90aGVyIHBsdWdpbnMuXHJcbiAgICBpZiAoIXRoaXMuX2Z1bGxDYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBvbGRNb21lbnRQcm90by50aW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgICAgIGhvdXJzOiB0aGlzLmhvdXJzKCksXHJcbiAgICAgICAgICAgIG1pbnV0ZXM6IHRoaXMubWludXRlcygpLFxyXG4gICAgICAgICAgICBzZWNvbmRzOiB0aGlzLnNlY29uZHMoKSxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiB0aGlzLm1pbGxpc2Vjb25kcygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTsgLy8gbWFyayB0aGF0IHRoZSBtb21lbnQgbm93IGhhcyBhIHRpbWVcclxuICAgICAgICBpZiAoIW1vbWVudC5pc0R1cmF0aW9uKHRpbWUpICYmICFtb21lbnQuaXNNb21lbnQodGltZSkpIHtcclxuICAgICAgICAgICAgdGltZSA9IG1vbWVudC5kdXJhdGlvbih0aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIGRheSB2YWx1ZSBzaG91bGQgY2F1c2Ugb3ZlcmZsb3cgKHNvIDI0IGhvdXJzIGJlY29tZXMgMDA6MDA6MDAgb2YgbmV4dCBkYXkpLlxyXG4gICAgICAgIC8vIE9ubHkgZm9yIER1cmF0aW9uIHRpbWVzLCBub3QgTW9tZW50IHRpbWVzLlxyXG4gICAgICAgIHZhciBkYXlIb3VycyA9IDA7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHRpbWUpKSB7XHJcbiAgICAgICAgICAgIGRheUhvdXJzID0gTWF0aC5mbG9vcih0aW1lLmFzRGF5cygpKSAqIDI0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGUgaW5kaXZpZHVhbCBmaWVsZHMuXHJcbiAgICAgICAgLy8gQ2FuJ3QgdXNlIHN0YXJ0T2YoJ2RheScpIHRoZW4gYWRkIGR1cmF0aW9uLiBJbiBjYXNlIG9mIERTVCBhdCBzdGFydCBvZiBkYXkuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoZGF5SG91cnMgKyB0aW1lLmhvdXJzKCkpXHJcbiAgICAgICAgICAgIC5taW51dGVzKHRpbWUubWludXRlcygpKVxyXG4gICAgICAgICAgICAuc2Vjb25kcyh0aW1lLnNlY29uZHMoKSlcclxuICAgICAgICAgICAgLm1pbGxpc2Vjb25kcyh0aW1lLm1pbGxpc2Vjb25kcygpKTtcclxuICAgIH1cclxufTtcclxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWUtb2YtZGF5IGFuZCB0aW1lem9uZSBvZmZzZXQsXHJcbi8vIGJ1dCBwcmVzZXJ2aW5nIGl0cyBZTUQuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lIHdpbGwgZGlzcGxheSBubyB0aW1lXHJcbi8vIG5vciB0aW1lem9uZSBvZmZzZXQgd2hlbiAuZm9ybWF0KCkgaXMgY2FsbGVkLlxyXG5uZXdNb21lbnRQcm90by5zdHJpcFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2FtYmlnVGltZSkge1xyXG4gICAgICAgIHRoaXMudXRjKHRydWUpOyAvLyBrZWVwTG9jYWxUaW1lPXRydWUgKGZvciBrZWVwaW5nICpkYXRlKiB2YWx1ZSlcclxuICAgICAgICAvLyBzZXQgdGltZSB0byB6ZXJvXHJcbiAgICAgICAgdGhpcy5zZXQoe1xyXG4gICAgICAgICAgICBob3VyczogMCxcclxuICAgICAgICAgICAgbWludXRlczogMCxcclxuICAgICAgICAgICAgc2Vjb25kczogMCxcclxuICAgICAgICAgICAgbXM6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBNYXJrIHRoZSB0aW1lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcclxuICAgICAgICAvLyB3aGljaCBjbGVhcnMgYWxsIGFtYmlnIGZsYWdzLlxyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fYW1iaWdab25lID0gdHJ1ZTsgLy8gaWYgYW1iaWd1b3VzIHRpbWUsIGFsc28gYW1iaWd1b3VzIHRpbWV6b25lIG9mZnNldFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG59O1xyXG4vLyBSZXR1cm5zIGlmIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lIChib29sZWFuKVxyXG5uZXdNb21lbnRQcm90by5oYXNUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLl9hbWJpZ1RpbWU7XHJcbn07XHJcbi8vIFRpbWV6b25lXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWV6b25lIG9mZnNldCwgYnV0IHByZXNlcnZpbmcgaXRzXHJcbi8vIFlNRCBhbmQgdGltZS1vZi1kYXkuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lem9uZSBvZmZzZXQgd2lsbCBkaXNwbGF5IG5vXHJcbi8vIHRpbWV6b25lIG9mZnNldCB3aGVuIC5mb3JtYXQoKSBpcyBjYWxsZWQuXHJcbm5ld01vbWVudFByb3RvLnN0cmlwWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3YXNBbWJpZ1RpbWU7XHJcbiAgICBpZiAoIXRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHdhc0FtYmlnVGltZSA9IHRoaXMuX2FtYmlnVGltZTtcclxuICAgICAgICB0aGlzLnV0Yyh0cnVlKTsgLy8ga2VlcExvY2FsVGltZT10cnVlIChmb3Iga2VlcGluZyBkYXRlIGFuZCB0aW1lIHZhbHVlcylcclxuICAgICAgICAvLyB0aGUgYWJvdmUgY2FsbCB0byAudXRjKCkvLnV0Y09mZnNldCgpIHVuZm9ydHVuYXRlbHkgbWlnaHQgY2xlYXIgdGhlIGFtYmlnIGZsYWdzLCBzbyByZXN0b3JlXHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gd2FzQW1iaWdUaW1lIHx8IGZhbHNlO1xyXG4gICAgICAgIC8vIE1hcmsgdGhlIHpvbmUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxyXG4gICAgICAgIC8vIHdoaWNoIGNsZWFycyB0aGUgYW1iaWcgZmxhZ3MuXHJcbiAgICAgICAgdGhpcy5fYW1iaWdab25lID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxufTtcclxuLy8gUmV0dXJucyBvZiB0aGUgbW9tZW50IGhhcyBhIG5vbi1hbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0IChib29sZWFuKVxyXG5uZXdNb21lbnRQcm90by5oYXNab25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLl9hbWJpZ1pvbmU7XHJcbn07XHJcbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXHJcbm5ld01vbWVudFByb3RvLmxvY2FsID0gZnVuY3Rpb24gKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgIC8vIGZvciB3aGVuIGNvbnZlcnRpbmcgZnJvbSBhbWJpZ3VvdXNseS16b25lZCB0byBsb2NhbCxcclxuICAgIC8vIGtlZXAgdGhlIHRpbWUgdmFsdWVzIHdoZW4gY29udmVydGluZyBmcm9tIFVUQyAtPiBsb2NhbFxyXG4gICAgb2xkTW9tZW50UHJvdG8ubG9jYWwuY2FsbCh0aGlzLCB0aGlzLl9hbWJpZ1pvbmUgfHwga2VlcExvY2FsVGltZSk7XHJcbiAgICAvLyBlbnN1cmUgbm9uLWFtYmlndW91c1xyXG4gICAgLy8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSBsb2NhbCgpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcclxuICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYW1iaWdab25lID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbn07XHJcbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXHJcbm5ld01vbWVudFByb3RvLnV0YyA9IGZ1bmN0aW9uIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICBvbGRNb21lbnRQcm90by51dGMuY2FsbCh0aGlzLCBrZWVwTG9jYWxUaW1lKTtcclxuICAgIC8vIGVuc3VyZSBub24tYW1iaWd1b3VzXHJcbiAgICAvLyB0aGlzIHByb2JhYmx5IGFscmVhZHkgaGFwcGVuZWQgdmlhIHV0YygpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcclxuICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYW1iaWdab25lID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmUgKHdpbGwgcHJvYmFibHkgZ2V0IGNhbGxlZCB1cG9uIC51dGMoKSBhbmQgLmxvY2FsKCkpXHJcbm5ld01vbWVudFByb3RvLnV0Y09mZnNldCA9IGZ1bmN0aW9uICh0em8pIHtcclxuICAgIGlmICh0em8gIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHRoZXNlIGFzc2lnbm1lbnRzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIG9yaWdpbmFsIHpvbmUgbWV0aG9kIGlzIGNhbGxlZC5cclxuICAgICAgICAvLyBJIGZvcmdldCB3aHksIHNvbWV0aGluZyB0byBkbyB3aXRoIGEgYnJvd3NlciBjcmFzaC5cclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypcclxuVVNBR0U6XHJcbiAgaW1wb3J0IHsgZGVmYXVsdCBhcyBFbWl0dGVyTWl4aW4sIEVtaXR0ZXJJbnRlcmZhY2UgfSBmcm9tICcuL0VtaXR0ZXJNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgb246IEVtaXR0ZXJJbnRlcmZhY2VbJ29uJ11cclxuICBvbmU6IEVtaXR0ZXJJbnRlcmZhY2VbJ29uZSddXHJcbiAgb2ZmOiBFbWl0dGVySW50ZXJmYWNlWydvZmYnXVxyXG4gIHRyaWdnZXI6IEVtaXR0ZXJJbnRlcmZhY2VbJ3RyaWdnZXInXVxyXG4gIHRyaWdnZXJXaXRoOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyV2l0aCddXHJcbiAgaGFzSGFuZGxlcnM6IEVtaXR0ZXJJbnRlcmZhY2VbJ2hhc0hhbmRsZXJzJ11cclxuYWZ0ZXIgY2xhc3M6XHJcbiAgRW1pdHRlck1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBFbWl0dGVyTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFbWl0dGVyTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFbWl0dGVyTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8galF1ZXJ5LWlmaWNhdGlvbiB2aWEgJCh0aGlzKSBhbGxvd3MgYSBub24tRE9NIG9iamVjdCB0byBoYXZlXHJcbiAgICAvLyB0aGUgc2FtZSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMgKGluY2x1ZGluZyBuYW1lc3BhY2VzKS5cclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZXMsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKHRoaXMpLm9uKHR5cGVzLCB0aGlzLl9wcmVwYXJlSW50ZXJjZXB0KGhhbmRsZXIpKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAodHlwZXMsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKHRoaXMpLm9uZSh0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUuX3ByZXBhcmVJbnRlcmNlcHQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIC8vIGhhbmRsZXJzIGFyZSBhbHdheXMgY2FsbGVkIHdpdGggYW4gXCJldmVudFwiIG9iamVjdCBhcyB0aGVpciBmaXJzdCBwYXJhbS5cclxuICAgICAgICAvLyBzbmVhayB0aGUgYHRoaXNgIGNvbnRleHQgYW5kIGFyZ3VtZW50cyBpbnRvIHRoZSBleHRyYSBwYXJhbWV0ZXIgb2JqZWN0XHJcbiAgICAgICAgLy8gYW5kIGZvcndhcmQgdGhlbSBvbiB0byB0aGUgb3JpZ2luYWwgaGFuZGxlci5cclxuICAgICAgICB2YXIgaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGV2LCBleHRyYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci5hcHBseShleHRyYS5jb250ZXh0IHx8IHRoaXMsIGV4dHJhLmFyZ3MgfHwgW10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbWltaWNrIGpRdWVyeSdzIGludGVybmFsIFwicHJveHlcIiBzeXN0ZW0gKHJpc2t5LCBJIGtub3cpXHJcbiAgICAgICAgLy8gY2F1c2luZyBhbGwgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgLmd1aWQgdG8gYXBwZWFyIHRvIGJlIHRoZSBzYW1lLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4yLjQvc3JjL2NvcmUuanMjTDQ0OFxyXG4gICAgICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciBjYWxsaW5nIC5vZmYgd2l0aCB0aGUgb3JpZ2luYWwgbm9uLWludGVyY2VwdCBoYW5kbGVyLlxyXG4gICAgICAgIGlmICghaGFuZGxlci5ndWlkKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIuZ3VpZCA9ICQuZ3VpZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcmNlcHQuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcclxuICAgICAgICByZXR1cm4gaW50ZXJjZXB0O1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vZmYodHlwZXMsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZXMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhc3MgaW4gXCJleHRyYVwiIGluZm8gdG8gdGhlIGludGVyY2VwdFxyXG4gICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIodHlwZXMsIHsgYXJnczogYXJncyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyV2l0aCA9IGZ1bmN0aW9uICh0eXBlcywgY29udGV4dCwgYXJncykge1xyXG4gICAgICAgIC8vIGB0cmlnZ2VySGFuZGxlcmAgaXMgbGVzcyByZWxpYW50IG9uIHRoZSBET00gY29tcGFyZWQgdG8gYHRyaWdnZXJgLlxyXG4gICAgICAgIC8vIHBhc3MgaW4gXCJleHRyYVwiIGluZm8gdG8gdGhlIGludGVyY2VwdC5cclxuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGNvbnRleHQ6IGNvbnRleHQsIGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUuaGFzSGFuZGxlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBoYXNoID0gJC5fZGF0YSh0aGlzLCAnZXZlbnRzJyk7IC8vIGh0dHA6Ly9ibG9nLmpxdWVyeS5jb20vMjAxMi8wOC8wOS9qcXVlcnktMS04LXJlbGVhc2VkL1xyXG4gICAgICAgIHJldHVybiBoYXNoICYmIGhhc2hbdHlwZV0gJiYgaGFzaFt0eXBlXS5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbWl0dGVyTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEVtaXR0ZXJNaXhpbjtcclxuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKlxyXG5NZWFudCB0byBiZSBpbW11dGFibGVcclxuKi9cclxudmFyIENvbXBvbmVudEZvb3RwcmludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZvb3RwcmludCh1bnpvbmVkUmFuZ2UsIGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdGhpcy5pc0FsbERheSA9IGZhbHNlOyAvLyBjb21wb25lbnQgY2FuIGNob29zZSB0byBpZ25vcmUgdGhpc1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdW56b25lZFJhbmdlO1xyXG4gICAgICAgIHRoaXMuaXNBbGxEYXkgPSBpc0FsbERheTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBPbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgQ29tcG9uZW50Rm9vdHByaW50LnByb3RvdHlwZS50b0xlZ2FjeSA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBjYWxlbmRhci5tc1RvTW9tZW50KHRoaXMudW56b25lZFJhbmdlLnN0YXJ0TXMsIHRoaXMuaXNBbGxEYXkpLFxyXG4gICAgICAgICAgICBlbmQ6IGNhbGVuZGFyLm1zVG9Nb21lbnQodGhpcy51bnpvbmVkUmFuZ2UuZW5kTXMsIHRoaXMuaXNBbGxEYXkpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50Rm9vdHByaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb25lbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG52YXIgRXZlbnRJbnN0YW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDkpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBTaW5nbGVFdmVudERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFNpbmdsZUV2ZW50RGVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2luZ2xlRXZlbnREZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFdpbGwgcmVjZWl2ZSBzdGFydC9lbmQgcGFyYW1zLCBidXQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gICAgKi9cclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5idWlsZEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuYnVpbGRJbnN0YW5jZSgpXTtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW5zdGFuY2VfMS5kZWZhdWx0KHRoaXMsIC8vIGRlZmluaXRpb25cclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlKTtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuaXNBbGxEYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVByb2ZpbGUuaXNBbGxEYXkoKTtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IF9zdXBlci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICBkZWYuZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLnJlem9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnNvdXJjZS5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBuZXcgRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQoY2FsZW5kYXIubW9tZW50KGRhdGVQcm9maWxlLnN0YXJ0KSwgZGF0ZVByb2ZpbGUuZW5kID8gY2FsZW5kYXIubW9tZW50KGRhdGVQcm9maWxlLmVuZCkgOiBudWxsLCBjYWxlbmRhcik7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5PVEU6IGlmIHN1cGVyLW1ldGhvZCBmYWlscywgc2hvdWxkIHN0aWxsIGF0dGVtcHQgdG8gYXBwbHlcclxuICAgICovXHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyU3VjY2VzcyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0LnBhcnNlKHJhd1Byb3BzLCB0aGlzLnNvdXJjZSk7IC8vIHJldHVybnMgbnVsbCBvbiBmYWlsdXJlXHJcbiAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGBkYXRlYCBzaG93cyB1cCBpbiB0aGUgbGVnYWN5IGV2ZW50IG9iamVjdHMgYXMtaXNcclxuICAgICAgICAgICAgaWYgKHJhd1Byb3BzLmRhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXNjUHJvcHMuZGF0ZSA9IHJhd1Byb3BzLmRhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyU3VjY2VzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNpbmdsZUV2ZW50RGVmO1xyXG59KEV2ZW50RGVmXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTaW5nbGVFdmVudERlZjtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuU2luZ2xlRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICBzdGFydDogZmFsc2UsXHJcbiAgICBkYXRlOiBmYWxzZSxcclxuICAgIGVuZDogZmFsc2UsXHJcbiAgICBhbGxEYXk6IGZhbHNlXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1peGluKCkge1xyXG4gICAgfVxyXG4gICAgTWl4aW4ubWl4SW50byA9IGZ1bmN0aW9uIChkZXN0Q2xhc3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVzdENsYXNzLnByb3RvdHlwZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgZGVzdENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IF90aGlzLnByb3RvdHlwZVtuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIG1ldGhvZHNcclxuICAgIFRPRE86IHJlbW92ZSEgbm90IHVzZWQgYW55bW9yZVxyXG4gICAgKi9cclxuICAgIE1peGluLm1peE92ZXIgPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBkZXN0Q2xhc3MucHJvdG90eXBlW25hbWVdID0gX3RoaXMucHJvdG90eXBlW25hbWVdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNaXhpbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTWl4aW47XHJcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEludGVyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnRlcmFjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJhY3Rpb247XHJcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy52ZXJzaW9uID0gJzMuOS4wJztcclxuLy8gV2hlbiBpbnRyb2R1Y2luZyBpbnRlcm5hbCBBUEkgaW5jb21wYXRpYmlsaXRpZXMgKHdoZXJlIGZ1bGxjYWxlbmRhciBwbHVnaW5zIHdvdWxkIGJyZWFrKSxcclxuLy8gdGhlIG1pbm9yIHZlcnNpb24gb2YgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSB1cHBlZCAoZXg6IDIuNy4yIC0+IDIuOC4wKVxyXG4vLyBhbmQgdGhlIGJlbG93IGludGVnZXIgc2hvdWxkIGJlIGluY3JlbWVudGVkLlxyXG5leHBvcnRzLmludGVybmFsQXBpVmVyc2lvbiA9IDEyO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuZXhwb3J0cy5hcHBseUFsbCA9IHV0aWxfMS5hcHBseUFsbDtcclxuZXhwb3J0cy5kZWJvdW5jZSA9IHV0aWxfMS5kZWJvdW5jZTtcclxuZXhwb3J0cy5pc0ludCA9IHV0aWxfMS5pc0ludDtcclxuZXhwb3J0cy5odG1sRXNjYXBlID0gdXRpbF8xLmh0bWxFc2NhcGU7XHJcbmV4cG9ydHMuY3NzVG9TdHIgPSB1dGlsXzEuY3NzVG9TdHI7XHJcbmV4cG9ydHMucHJveHkgPSB1dGlsXzEucHJveHk7XHJcbmV4cG9ydHMuY2FwaXRhbGlzZUZpcnN0TGV0dGVyID0gdXRpbF8xLmNhcGl0YWxpc2VGaXJzdExldHRlcjtcclxuZXhwb3J0cy5nZXRPdXRlclJlY3QgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0O1xyXG5leHBvcnRzLmdldENsaWVudFJlY3QgPSB1dGlsXzEuZ2V0Q2xpZW50UmVjdDtcclxuZXhwb3J0cy5nZXRDb250ZW50UmVjdCA9IHV0aWxfMS5nZXRDb250ZW50UmVjdDtcclxuZXhwb3J0cy5nZXRTY3JvbGxiYXJXaWR0aHMgPSB1dGlsXzEuZ2V0U2Nyb2xsYmFyV2lkdGhzO1xyXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gdXRpbF8xLnByZXZlbnREZWZhdWx0O1xyXG5leHBvcnRzLnBhcnNlRmllbGRTcGVjcyA9IHV0aWxfMS5wYXJzZUZpZWxkU3BlY3M7XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IHV0aWxfMS5jb21wYXJlQnlGaWVsZFNwZWNzO1xyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IHV0aWxfMS5jb21wYXJlQnlGaWVsZFNwZWM7XHJcbmV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gdXRpbF8xLmZsZXhpYmxlQ29tcGFyZTtcclxuZXhwb3J0cy5jb21wdXRlR3JlYXRlc3RVbml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQ7XHJcbmV4cG9ydHMuZGl2aWRlUmFuZ2VCeUR1cmF0aW9uID0gdXRpbF8xLmRpdmlkZVJhbmdlQnlEdXJhdGlvbjtcclxuZXhwb3J0cy5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24gPSB1dGlsXzEuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uO1xyXG5leHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSB1dGlsXzEubXVsdGlwbHlEdXJhdGlvbjtcclxuZXhwb3J0cy5kdXJhdGlvbkhhc1RpbWUgPSB1dGlsXzEuZHVyYXRpb25IYXNUaW1lO1xyXG5leHBvcnRzLmxvZyA9IHV0aWxfMS5sb2c7XHJcbmV4cG9ydHMud2FybiA9IHV0aWxfMS53YXJuO1xyXG5leHBvcnRzLnJlbW92ZUV4YWN0ID0gdXRpbF8xLnJlbW92ZUV4YWN0O1xyXG5leHBvcnRzLmludGVyc2VjdFJlY3RzID0gdXRpbF8xLmludGVyc2VjdFJlY3RzO1xyXG52YXIgZGF0ZV9mb3JtYXR0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZGF0ZV9mb3JtYXR0aW5nXzEuZm9ybWF0RGF0ZTtcclxuZXhwb3J0cy5mb3JtYXRSYW5nZSA9IGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdFJhbmdlO1xyXG5leHBvcnRzLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdCA9IGRhdGVfZm9ybWF0dGluZ18xLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdDtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbmV4cG9ydHMuZGF0ZXBpY2tlckxvY2FsZSA9IGxvY2FsZV8xLmRhdGVwaWNrZXJMb2NhbGU7XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlXzEubG9jYWxlO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbmV4cG9ydHMubW9tZW50ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQ7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5leHBvcnRzLkVtaXR0ZXJNaXhpbiA9IEVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5leHBvcnRzLkxpc3RlbmVyTWl4aW4gPSBMaXN0ZW5lck1peGluXzEuZGVmYXVsdDtcclxudmFyIE1vZGVsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcclxuZXhwb3J0cy5Nb2RlbCA9IE1vZGVsXzEuZGVmYXVsdDtcclxudmFyIENvbnN0cmFpbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNyk7XHJcbmV4cG9ydHMuQ29uc3RyYWludHMgPSBDb25zdHJhaW50c18xLmRlZmF1bHQ7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbmV4cG9ydHMuVW56b25lZFJhbmdlID0gVW56b25lZFJhbmdlXzEuZGVmYXVsdDtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbmV4cG9ydHMuQ29tcG9uZW50Rm9vdHByaW50ID0gQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdDtcclxudmFyIEJ1c2luZXNzSG91ckdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xyXG5leHBvcnRzLkJ1c2luZXNzSG91ckdlbmVyYXRvciA9IEJ1c2luZXNzSG91ckdlbmVyYXRvcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbmV4cG9ydHMuRXZlbnREZWYgPSBFdmVudERlZl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERlZk11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxuZXhwb3J0cy5FdmVudERlZk11dGF0aW9uID0gRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbmV4cG9ydHMuRXZlbnRTb3VyY2VQYXJzZXIgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuZXhwb3J0cy5FdmVudFNvdXJjZSA9IEV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIFRoZW1lUmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xyXG5leHBvcnRzLmRlZmluZVRoZW1lU3lzdGVtID0gVGhlbWVSZWdpc3RyeV8xLmRlZmluZVRoZW1lU3lzdGVtO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuZXhwb3J0cy5FdmVudEluc3RhbmNlR3JvdXAgPSBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0O1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XHJcbmV4cG9ydHMuQXJyYXlFdmVudFNvdXJjZSA9IEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgRnVuY0V2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNSk7XHJcbmV4cG9ydHMuRnVuY0V2ZW50U291cmNlID0gRnVuY0V2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEpzb25GZWVkRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE2KTtcclxuZXhwb3J0cy5Kc29uRmVlZEV2ZW50U291cmNlID0gSnNvbkZlZWRFdmVudFNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcbmV4cG9ydHMuRXZlbnRGb290cHJpbnQgPSBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQ7XHJcbnZhciBDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbmV4cG9ydHMuQ2xhc3MgPSBDbGFzc18xLmRlZmF1bHQ7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbmV4cG9ydHMuTWl4aW4gPSBNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBDb29yZENhY2hlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxuZXhwb3J0cy5Db29yZENhY2hlID0gQ29vcmRDYWNoZV8xLmRlZmF1bHQ7XHJcbnZhciBEcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG5leHBvcnRzLkRyYWdMaXN0ZW5lciA9IERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQ7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuZXhwb3J0cy5Qcm9taXNlID0gUHJvbWlzZV8xLmRlZmF1bHQ7XHJcbnZhciBUYXNrUXVldWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE3KTtcclxuZXhwb3J0cy5UYXNrUXVldWUgPSBUYXNrUXVldWVfMS5kZWZhdWx0O1xyXG52YXIgUmVuZGVyUXVldWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE4KTtcclxuZXhwb3J0cy5SZW5kZXJRdWV1ZSA9IFJlbmRlclF1ZXVlXzEuZGVmYXVsdDtcclxudmFyIFNjcm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuZXhwb3J0cy5TY3JvbGxlciA9IFNjcm9sbGVyXzEuZGVmYXVsdDtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuZXhwb3J0cy5UaGVtZSA9IFRoZW1lXzEuZGVmYXVsdDtcclxudmFyIERhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE5KTtcclxuZXhwb3J0cy5EYXRlQ29tcG9uZW50ID0gRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQ7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5leHBvcnRzLkludGVyYWN0aXZlRGF0ZUNvbXBvbmVudCA9IEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQ7XHJcbnZhciBDYWxlbmRhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjApO1xyXG5leHBvcnRzLkNhbGVuZGFyID0gQ2FsZW5kYXJfMS5kZWZhdWx0O1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbmV4cG9ydHMuVmlldyA9IFZpZXdfMS5kZWZhdWx0O1xyXG52YXIgVmlld1JlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuZXhwb3J0cy5kZWZpbmVWaWV3ID0gVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldztcclxuZXhwb3J0cy5nZXRWaWV3Q29uZmlnID0gVmlld1JlZ2lzdHJ5XzEuZ2V0Vmlld0NvbmZpZztcclxudmFyIERheVRhYmxlTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG5leHBvcnRzLkRheVRhYmxlTWl4aW4gPSBEYXlUYWJsZU1peGluXzEuZGVmYXVsdDtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcclxuZXhwb3J0cy5CdXNpbmVzc0hvdXJSZW5kZXJlciA9IEJ1c2luZXNzSG91clJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG5leHBvcnRzLkV2ZW50UmVuZGVyZXIgPSBFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XHJcbmV4cG9ydHMuRmlsbFJlbmRlcmVyID0gRmlsbFJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxuZXhwb3J0cy5IZWxwZXJSZW5kZXJlciA9IEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEV4dGVybmFsRHJvcHBpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIyKTtcclxuZXhwb3J0cy5FeHRlcm5hbERyb3BwaW5nID0gRXh0ZXJuYWxEcm9wcGluZ18xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFJlc2l6aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMyk7XHJcbmV4cG9ydHMuRXZlbnRSZXNpemluZyA9IEV2ZW50UmVzaXppbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XHJcbmV4cG9ydHMuRXZlbnRQb2ludGluZyA9IEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREcmFnZ2luZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQpO1xyXG5leHBvcnRzLkV2ZW50RHJhZ2dpbmcgPSBFdmVudERyYWdnaW5nXzEuZGVmYXVsdDtcclxudmFyIERhdGVTZWxlY3RpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI1KTtcclxuZXhwb3J0cy5EYXRlU2VsZWN0aW5nID0gRGF0ZVNlbGVjdGluZ18xLmRlZmF1bHQ7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxuZXhwb3J0cy5TdGFuZGFyZEludGVyYWN0aW9uc01peGluID0gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBBZ2VuZGFWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNik7XHJcbmV4cG9ydHMuQWdlbmRhVmlldyA9IEFnZW5kYVZpZXdfMS5kZWZhdWx0O1xyXG52YXIgVGltZUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI3KTtcclxuZXhwb3J0cy5UaW1lR3JpZCA9IFRpbWVHcmlkXzEuZGVmYXVsdDtcclxudmFyIERheUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5leHBvcnRzLkRheUdyaWQgPSBEYXlHcmlkXzEuZGVmYXVsdDtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcbmV4cG9ydHMuQmFzaWNWaWV3ID0gQmFzaWNWaWV3XzEuZGVmYXVsdDtcclxudmFyIE1vbnRoVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjkpO1xyXG5leHBvcnRzLk1vbnRoVmlldyA9IE1vbnRoVmlld18xLmRlZmF1bHQ7XHJcbnZhciBMaXN0Vmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzApO1xyXG5leHBvcnRzLkxpc3RWaWV3ID0gTGlzdFZpZXdfMS5kZWZhdWx0O1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbi8qXHJcbk1lYW50IHRvIGJlIGltbXV0YWJsZVxyXG4qL1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGF0ZVByb2ZpbGUoc3RhcnQsIGVuZCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLnVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRVbnpvbmVkUmFuZ2UoY2FsZW5kYXIpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIE5lZWRzIGFuIEV2ZW50U291cmNlIG9iamVjdFxyXG4gICAgKi9cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucGFyc2UgPSBmdW5jdGlvbiAocmF3UHJvcHMsIHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBzdGFydElucHV0ID0gcmF3UHJvcHMuc3RhcnQgfHwgcmF3UHJvcHMuZGF0ZTtcclxuICAgICAgICB2YXIgZW5kSW5wdXQgPSByYXdQcm9wcy5lbmQ7XHJcbiAgICAgICAgaWYgKCFzdGFydElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gc291cmNlLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBzdGFydCA9IGNhbGVuZGFyLm1vbWVudChzdGFydElucHV0KTtcclxuICAgICAgICB2YXIgZW5kID0gZW5kSW5wdXQgPyBjYWxlbmRhci5tb21lbnQoZW5kSW5wdXQpIDogbnVsbDtcclxuICAgICAgICB2YXIgZm9yY2VkQWxsRGF5ID0gcmF3UHJvcHMuYWxsRGF5O1xyXG4gICAgICAgIHZhciBmb3JjZUV2ZW50RHVyYXRpb24gPSBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpO1xyXG4gICAgICAgIGlmICghc3RhcnQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCAmJiAoIWVuZC5pc1ZhbGlkKCkgfHwgIWVuZC5pc0FmdGVyKHN0YXJ0KSkpIHtcclxuICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcmNlZEFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcmNlZEFsbERheSA9IHNvdXJjZS5hbGxEYXlEZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VkQWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlZEFsbERheSA9IGNhbGVuZGFyLm9wdCgnYWxsRGF5RGVmYXVsdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JjZWRBbGxEYXkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmb3JjZWRBbGxEYXkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC50aW1lKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZW5kICYmIGZvcmNlRXZlbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoIXN0YXJ0Lmhhc1RpbWUoKSwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGUoc3RhcnQsIGVuZCwgY2FsZW5kYXIpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUuaXNTdGFuZGFyZFByb3AgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcE5hbWUgPT09ICdzdGFydCcgfHwgcHJvcE5hbWUgPT09ICdkYXRlJyB8fCBwcm9wTmFtZSA9PT0gJ2VuZCcgfHwgcHJvcE5hbWUgPT09ICdhbGxEYXknO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMuc3RhcnQuaGFzVGltZSgpIHx8ICh0aGlzLmVuZCAmJiB0aGlzLmVuZC5oYXNUaW1lKCkpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTmVlZHMgYSBDYWxlbmRhciBvYmplY3RcclxuICAgICovXHJcbiAgICBFdmVudERhdGVQcm9maWxlLnByb3RvdHlwZS5idWlsZFVuem9uZWRSYW5nZSA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gdGhpcy5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICB2YXIgZW5kTXMgPSB0aGlzLmdldEVuZChjYWxlbmRhcikuc3RyaXBab25lKCkudmFsdWVPZigpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydE1zLCBlbmRNcyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGEgQ2FsZW5kYXIgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wcm90b3R5cGUuZ2V0RW5kID0gZnVuY3Rpb24gKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kID9cclxuICAgICAgICAgICAgdGhpcy5lbmQuY2xvbmUoKSA6XHJcbiAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgZW5kIGZyb20gdGhlIHN0YXJ0IGFuZCBhbGxEYXkuIGNvbXB1dGUgYWxsRGF5IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQodGhpcy5pc0FsbERheSgpLCB0aGlzLnN0YXJ0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREYXRlUHJvZmlsZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREYXRlUHJvZmlsZTtcclxuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcbnZhciBFdmVudFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMSk7XHJcbi8qXHJcbkl0J3MgZXhwZWN0ZWQgdGhhdCB0aGVyZSB3aWxsIGJlIGF0IGxlYXN0IG9uZSBFdmVudEluc3RhbmNlLFxyXG5PUiB0aGF0IGFuIGV4cGxpY2l0RXZlbnREZWYgaXMgYXNzaWduZWQuXHJcbiovXHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEluc3RhbmNlR3JvdXAoZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2VzID0gZXZlbnRJbnN0YW5jZXMgfHwgW107XHJcbiAgICB9XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmdldEFsbEV2ZW50UmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VOb3JtYWxSZW5kZXJSYW5nZXMoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuc2xpY2VSZW5kZXJSYW5nZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbnZlcnNlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VJbnZlcnNlUmVuZGVyUmFuZ2VzKGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZU5vcm1hbFJlbmRlclJhbmdlcyhjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlTm9ybWFsUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcyA9IHRoaXMuZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIHNsaWNlZFJhbmdlO1xyXG4gICAgICAgIHZhciBzbGljZWRFdmVudFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlID0gZXZlbnRJbnN0YW5jZXNbaV07XHJcbiAgICAgICAgICAgIHNsaWNlZFJhbmdlID0gZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2xpY2VkRXZlbnRSYW5nZXMucHVzaChuZXcgRXZlbnRSYW5nZV8xLmRlZmF1bHQoc2xpY2VkUmFuZ2UsIGV2ZW50SW5zdGFuY2UuZGVmLCBldmVudEluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsaWNlZEV2ZW50UmFuZ2VzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuc2xpY2VJbnZlcnNlUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2VzID0gdGhpcy5ldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIG93bmVyRGVmID0gdGhpcy5nZXRFdmVudERlZigpO1xyXG4gICAgICAgIHVuem9uZWRSYW5nZXMgPSBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0LmludmVydFJhbmdlcyh1bnpvbmVkUmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIHJldHVybiB1bnpvbmVkUmFuZ2VzLm1hcChmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRSYW5nZV8xLmRlZmF1bHQodW56b25lZFJhbmdlLCBvd25lckRlZik7IC8vIGRvbid0IGdpdmUgYW4gRXZlbnRJbnN0YW5jZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuaXNJbnZlcnNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50RGVmKCkuaGFzSW52ZXJzZVJlbmRlcmluZygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuZ2V0RXZlbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXRFdmVudERlZiB8fCB0aGlzLmV2ZW50SW5zdGFuY2VzWzBdLmRlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEluc3RhbmNlR3JvdXA7XHJcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUaGVtZShvcHRpb25zTWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIgPSBvcHRpb25zTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnByb2Nlc3NJY29uT3ZlcnJpZGUoKTtcclxuICAgIH1cclxuICAgIFRoZW1lLnByb3RvdHlwZS5wcm9jZXNzSWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldEljb25PdmVycmlkZSh0aGlzLm9wdGlvbnNNYW5hZ2VyLmdldCh0aGlzLmljb25PdmVycmlkZU9wdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuc2V0SWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICB2YXIgaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgIHZhciBidXR0b25OYW1lO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoaWNvbk92ZXJyaWRlSGFzaCkpIHtcclxuICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gJC5leHRlbmQoe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5pY29uT3ZlcnJpZGVQcmVmaXg7XHJcbiAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlc1trZXldIHx8ICcnO1xyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRJY29uQ2xhc3MgPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xyXG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArICcgJyArIGNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MgPSBmdW5jdGlvbiAoY3VzdG9tQnV0dG9uUHJvcHMpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaGVtZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGhlbWU7XHJcblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XHJcblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9O1xyXG5UaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xyXG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgUHJvbWlzZVN0dWIgPSB7XHJcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChleGVjdXRvcikge1xyXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfSxcclxuICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVzb2x2ZSh2YWwpO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xyXG4gICAgICAgIGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfSxcclxuICAgIHJlamVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKS5yZWplY3QoKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFByb21pc2VTdHViO1xyXG5mdW5jdGlvbiBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKSB7XHJcbiAgICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VTdHViLnJlc29sdmUob25SZXNvbHZlKHZhbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpIHtcclxuICAgIHByb21pc2UudGhlbiA9IGZ1bmN0aW9uIChvblJlc29sdmUsIG9uUmVqZWN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBvblJlamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbmV4cG9ydEhvb2tzLnRvdWNoTW91c2VJZ25vcmVXYWl0ID0gNTAwO1xyXG52YXIgZ2xvYmFsRW1pdHRlciA9IG51bGw7XHJcbnZhciBuZWVkZWRDb3VudCA9IDA7XHJcbi8qXHJcbkxpc3RlbnMgdG8gZG9jdW1lbnQgYW5kIHdpbmRvdy1sZXZlbCB1c2VyLWludGVyYWN0aW9uIGV2ZW50cywgbGlrZSB0b3VjaCBldmVudHMgYW5kIG1vdXNlIGV2ZW50cyxcclxuYW5kIGZpcmVzIHRoZXNlIGV2ZW50cyBhcy1pcyB0byB3aG9ldmVyIGlzIG9ic2VydmluZyBhIEdsb2JhbEVtaXR0ZXIuXHJcbkJlc3Qgd2hlbiB1c2VkIGFzIGEgc2luZ2xldG9uIHZpYSBHbG9iYWxFbWl0dGVyLmdldCgpXHJcblxuTm9ybWFsaXplcyBtb3VzZS90b3VjaCBldmVudHMuIEZvciBleGFtcGxlczpcclxuLSBpZ25vcmVzIHRoZSB0aGUgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB0aGF0IGhhcHBlbiBhZnRlciBhIHF1aWNrIHRhcDogbW91c2Vtb3ZlK21vdXNlZG93bittb3VzZXVwK2NsaWNrXHJcbi0gY29tcGVuc2F0ZXMgZm9yIHZhcmlvdXMgYnVnZ3kgc2NlbmFyaW9zIHdoZXJlIGEgdG91Y2hlbmQgZG9lcyBub3QgZmlyZVxyXG4qL1xyXG52YXIgR2xvYmFsRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdsb2JhbEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZUlnbm9yZURlcHRoID0gMDtcclxuICAgIH1cclxuICAgIC8vIGdldHMgdGhlIHNpbmdsZXRvblxyXG4gICAgR2xvYmFsRW1pdHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFnbG9iYWxFbWl0dGVyKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIgPSBuZXcgR2xvYmFsRW1pdHRlcigpO1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbEVtaXR0ZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gY2FsbGVkIHdoZW4gYW4gb2JqZWN0IGtub3dzIGl0IHdpbGwgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgaW4gdGhlIG5lYXIgZnV0dXJlLlxyXG4gICAgR2xvYmFsRW1pdHRlci5uZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgR2xvYmFsRW1pdHRlci5nZXQoKTsgLy8gZW5zdXJlcyBnbG9iYWxFbWl0dGVyXHJcbiAgICAgICAgbmVlZGVkQ291bnQrKztcclxuICAgIH07XHJcbiAgICAvLyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IHRoYXQgb3JpZ2luYWxseSBjYWxsZWQgbmVlZGVkKCkgZG9lc24ndCBuZWVkIGEgR2xvYmFsRW1pdHRlciBhbnltb3JlLlxyXG4gICAgR2xvYmFsRW1pdHRlci51bm5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBuZWVkZWRDb3VudC0tO1xyXG4gICAgICAgIGlmICghbmVlZGVkQ291bnQpIHtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlci51bmJpbmQoKTtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XHJcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcclxuICAgICAgICAgICAgdG91Y2hjYW5jZWw6IHRoaXMuaGFuZGxlVG91Y2hDYW5jZWwsXHJcbiAgICAgICAgICAgIHRvdWNoZW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kLFxyXG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxyXG4gICAgICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxyXG4gICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmhhbmRsZU1vdXNlVXAsXHJcbiAgICAgICAgICAgIGNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLFxyXG4gICAgICAgICAgICBzZWxlY3RzdGFydDogdGhpcy5oYW5kbGVTZWxlY3RTdGFydCxcclxuICAgICAgICAgICAgY29udGV4dG1lbnU6IHRoaXMuaGFuZGxlQ29udGV4dE1lbnVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCBwcmV2ZW50RGVmYXVsdFxyXG4gICAgICAgIC8vIGJlY2F1c2UgaHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlcy81MDkzNTY2MDA3MjE0MDgwXHJcbiAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgcGVyZm9ybWFuY2UgYmVjYXVzZSB0aGlzIGlzIGEgZ2xvYmFsIGhhbmRsZXJcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmVQcm94eSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVUb3VjaE1vdmUoJC5FdmVudChldikpO1xyXG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSAvLyBhbGxvd3MgcHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cclxuICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsUHJveHkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsKCQuRXZlbnQoZXYpKTtcclxuICAgICAgICB9LCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHkpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbFByb3h5LCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIC8vIFRvdWNoIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIGlmIGEgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24gbmV2ZXIgZW5kZWQgd2l0aCBhIHRvdWNoZW5kLCB0aGVuIGltcGxpY2l0bHkgZW5kIGl0LFxyXG4gICAgICAgIC8vIGJ1dCBzaW5jZSBhIG5ldyB0b3VjaCBpbnRlcmFjdGlvbiBpcyBhYm91dCB0byBiZWdpbiwgZG9uJ3Qgc3RhcnQgdGhlIG1vdXNlIGlnbm9yZSBwZXJpb2QuXHJcbiAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYsIHRydWUpOyAvLyBza2lwTW91c2VJZ25vcmU9dHJ1ZVxyXG4gICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaHN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaG1vdmUnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoQ2FuY2VsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RvdWNoY2FuY2VsJywgZXYpO1xyXG4gICAgICAgICAgICAvLyBIYXZlIHRvdWNoY2FuY2VsIGZpcmUgYW4gYXJ0aWZpY2lhbCB0b3VjaGVuZC4gVGhhdCB3YXksIGhhbmRsZXJzIHdvbid0IG5lZWQgdG8gbGlzdGVuIHRvIGJvdGguXHJcbiAgICAgICAgICAgIC8vIElmIHRvdWNoZW5kIGZpcmVzIGxhdGVyLCBpdCB3b24ndCBoYXZlIGFueSBlZmZlY3QgYi9jIGlzVG91Y2hpbmcgd2lsbCBiZSBmYWxzZS5cclxuICAgICAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaEVuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBNb3VzZSBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vkb3duJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2V1cCcsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NsaWNrJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBNaXNjIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlU2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdHN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250ZXh0bWVudScsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Njcm9sbCcsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnN0b3BUb3VjaCA9IGZ1bmN0aW9uIChldiwgc2tpcE1vdXNlSWdub3JlKSB7XHJcbiAgICAgICAgaWYgKHNraXBNb3VzZUlnbm9yZSA9PT0gdm9pZCAwKSB7IHNraXBNb3VzZUlnbm9yZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaGVuZCcsIGV2KTtcclxuICAgICAgICAgICAgaWYgKCFza2lwTW91c2VJZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUb3VjaE1vdXNlSWdub3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc3RhcnRUb3VjaE1vdXNlSWdub3JlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHdhaXQgPSBleHBvcnRIb29rcy50b3VjaE1vdXNlSWdub3JlV2FpdDtcclxuICAgICAgICBpZiAod2FpdCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlSWdub3JlRGVwdGgrKztcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3VzZUlnbm9yZURlcHRoLS07XHJcbiAgICAgICAgICAgIH0sIHdhaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5zaG91bGRJZ25vcmVNb3VzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1RvdWNoaW5nIHx8IEJvb2xlYW4odGhpcy5tb3VzZUlnbm9yZURlcHRoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2xvYmFsRW1pdHRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR2xvYmFsRW1pdHRlcjtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhHbG9iYWxFbWl0dGVyKTtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEdsb2JhbEVtaXR0ZXIpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5leHBvcnRzLnZpZXdIYXNoID0ge307XHJcbmV4cG9ydEhvb2tzLnZpZXdzID0gZXhwb3J0cy52aWV3SGFzaDtcclxuZnVuY3Rpb24gZGVmaW5lVmlldyh2aWV3TmFtZSwgdmlld0NvbmZpZykge1xyXG4gICAgZXhwb3J0cy52aWV3SGFzaFt2aWV3TmFtZV0gPSB2aWV3Q29uZmlnO1xyXG59XHJcbmV4cG9ydHMuZGVmaW5lVmlldyA9IGRlZmluZVZpZXc7XHJcbmZ1bmN0aW9uIGdldFZpZXdDb25maWcodmlld05hbWUpIHtcclxuICAgIHJldHVybiBleHBvcnRzLnZpZXdIYXNoW3ZpZXdOYW1lXTtcclxufVxyXG5leHBvcnRzLmdldFZpZXdDb25maWcgPSBnZXRWaWV3Q29uZmlnO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBEcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG4vKiBUcmFja3MgbW91c2UgbW92ZW1lbnRzIG92ZXIgYSBjb21wb25lbnQgYW5kIHJhaXNlcyBldmVudHMgYWJvdXQgd2hpY2ggaGl0IHRoZSBtb3VzZSBpcyBvdmVyLlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxub3B0aW9uczpcclxuLSBzdWJqZWN0RWxcclxuLSBzdWJqZWN0Q2VudGVyXHJcbiovXHJcbnZhciBIaXREcmFnTGlzdGVuZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIaXREcmFnTGlzdGVuZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIaXREcmFnTGlzdGVuZXIoY29tcG9uZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gQ2FsbGVkIHdoZW4gZHJhZyBsaXN0ZW5pbmcgc3RhcnRzIChidXQgYSByZWFsIGRyYWcgaGFzIG5vdCBuZWNlc3NhcmlseSBiZWdhbikuXHJcbiAgICAvLyBldiBtaWdodCBiZSB1bmRlZmluZWQgaWYgZHJhZ2dpbmcgd2FzIHN0YXJ0ZWQgbWFudWFsbHkuXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgc3ViamVjdEVsID0gdGhpcy5zdWJqZWN0RWw7XHJcbiAgICAgICAgdmFyIHN1YmplY3RSZWN0O1xyXG4gICAgICAgIHZhciBvcmlnUG9pbnQ7XHJcbiAgICAgICAgdmFyIHBvaW50O1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmhpdHNOZWVkZWQoKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVTY3JvbGxCb3VuZHMoKTsgLy8gZm9yIGF1dG9zY3JvbGxcclxuICAgICAgICBpZiAoZXYpIHtcclxuICAgICAgICAgICAgb3JpZ1BvaW50ID0geyBsZWZ0OiB1dGlsXzEuZ2V0RXZYKGV2KSwgdG9wOiB1dGlsXzEuZ2V0RXZZKGV2KSB9O1xyXG4gICAgICAgICAgICBwb2ludCA9IG9yaWdQb2ludDtcclxuICAgICAgICAgICAgLy8gY29uc3RyYWluIHRoZSBwb2ludCB0byBib3VuZHMgb2YgdGhlIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJqZWN0UmVjdCA9IHV0aWxfMS5nZXRPdXRlclJlY3Qoc3ViamVjdEVsKTsgLy8gdXNlZCBmb3IgY2VudGVyaW5nIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIHBvaW50ID0gdXRpbF8xLmNvbnN0cmFpblBvaW50KHBvaW50LCBzdWJqZWN0UmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcmlnSGl0ID0gdGhpcy5xdWVyeUhpdChwb2ludC5sZWZ0LCBwb2ludC50b3ApO1xyXG4gICAgICAgICAgICAvLyB0cmVhdCB0aGUgY2VudGVyIG9mIHRoZSBzdWJqZWN0IGFzIHRoZSBjb2xsaXNpb24gcG9pbnQ/XHJcbiAgICAgICAgICAgIGlmIChzdWJqZWN0RWwgJiYgdGhpcy5vcHRpb25zLnN1YmplY3RDZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgY29uc2lkZXIgdGhlIGFyZWEgdGhlIHN1YmplY3Qgb3ZlcmxhcHMgdGhlIGhpdC4gYmVzdCBmb3IgbGFyZ2Ugc3ViamVjdHMuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBza2lwIHRoaXMgaWYgaGl0IGRpZG4ndCBzdXBwbHkgbGVmdC9yaWdodC90b3AvYm90dG9tXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdFJlY3QgPSB1dGlsXzEuaW50ZXJzZWN0UmVjdHModGhpcy5vcmlnSGl0LCBzdWJqZWN0UmVjdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdFJlY3Q7IC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHV0aWxfMS5nZXRSZWN0Q2VudGVyKHN1YmplY3RSZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0gdXRpbF8xLmRpZmZQb2ludHMocG9pbnQsIG9yaWdQb2ludCk7IC8vIHBvaW50IC0gb3JpZ1BvaW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kLiBkbyBpdCBhZnRlciBvcmlnSGl0IGhhcyBiZWVuIGNvbXB1dGVkXHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0LmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBhY3R1YWwgZHJhZyBoYXMgc3RhcnRlZFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgaGl0O1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0LmNhbGwodGhpcywgZXYpO1xyXG4gICAgICAgIC8vIG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoaXMub3JpZ0hpdCBpZiB0aGUgbWluLWRpc3RhbmNlIGlzIGxhcmdlXHJcbiAgICAgICAgaGl0ID0gdGhpcy5xdWVyeUhpdCh1dGlsXzEuZ2V0RXZYKGV2KSwgdXRpbF8xLmdldEV2WShldikpO1xyXG4gICAgICAgIC8vIHJlcG9ydCB0aGUgaW5pdGlhbCBoaXQgdGhlIG1vdXNlIGlzIG92ZXJcclxuICAgICAgICAvLyBlc3BlY2lhbGx5IGltcG9ydGFudCBpZiBubyBtaW4tZGlzdGFuY2UgYW5kIGRyYWcgc3RhcnRzIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGRyYWcgbW92ZXNcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChkeCwgZHksIGV2KSB7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZURyYWcuY2FsbCh0aGlzLCBkeCwgZHksIGV2KTtcclxuICAgICAgICBoaXQgPSB0aGlzLnF1ZXJ5SGl0KHV0aWxfMS5nZXRFdlgoZXYpLCB1dGlsXzEuZ2V0RXZZKGV2KSk7XHJcbiAgICAgICAgaWYgKCFpc0hpdHNFcXVhbChoaXQsIHRoaXMuaGl0KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0T3V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgaGFzIGJlZW4gc3RvcHBlZFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVIaXREb25lKCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnRW5kLmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG92ZXIgYSBuZXcgaGl0XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUhpdE92ZXIgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgdmFyIGlzT3JpZyA9IGlzSGl0c0VxdWFsKGhpdCwgdGhpcy5vcmlnSGl0KTtcclxuICAgICAgICB0aGlzLmhpdCA9IGhpdDtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpdE92ZXInLCB0aGlzLmhpdCwgaXNPcmlnLCB0aGlzLm9yaWdIaXQpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBtb3VzZSBoYXMganVzdCBtb3ZlZCBvdXQgb2YgYSBoaXRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSGl0T3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpdE91dCcsIHRoaXMuaGl0KTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXREb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGEgaGl0T3V0LiBBbHNvIGNhbGxlZCBiZWZvcmUgYSBkcmFnU3RvcFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVIaXREb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpdERvbmUnLCB0aGlzLmhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBpbnRlcmFjdGlvbiBlbmRzLCB3aGV0aGVyIHRoZXJlIHdhcyBhIHJlYWwgZHJhZyBvciBub3RcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQgPSBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZC5jYWxsKHRoaXMsIGV2LCBpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgdGhpcy5vcmlnSGl0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhpdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaGl0c05vdE5lZWRlZCgpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kLmNhbGwodGhpcyk7XHJcbiAgICAgICAgLy8gaGl0cycgYWJzb2x1dGUgcG9zaXRpb25zIHdpbGwgYmUgaW4gbmV3IHBsYWNlcyBhZnRlciBhIHVzZXIncyBzY3JvbGwuXHJcbiAgICAgICAgLy8gSEFDSyBmb3IgcmVjb21wdXRpbmcuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZWxlYXNlSGl0cygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wcmVwYXJlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBoaXQgdW5kZXJuZWF0aCB0aGUgY29vcmRpbmF0ZXMgZm9yIHRoZSBnaXZlbiBtb3VzZSBldmVudFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0LCB0b3ApIHtcclxuICAgICAgICBpZiAodGhpcy5jb29yZEFkanVzdCkge1xyXG4gICAgICAgICAgICBsZWZ0ICs9IHRoaXMuY29vcmRBZGp1c3QubGVmdDtcclxuICAgICAgICAgICAgdG9wICs9IHRoaXMuY29vcmRBZGp1c3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQucXVlcnlIaXQobGVmdCwgdG9wKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSGl0RHJhZ0xpc3RlbmVyO1xyXG59KERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSGl0RHJhZ0xpc3RlbmVyO1xyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGl0cyBhcmUgaWRlbnRpY2FsbHkgZXF1YWwuIGBmYWxzZWAgb3RoZXJ3aXNlLiBNdXN0IGJlIGZyb20gdGhlIHNhbWUgY29tcG9uZW50LlxyXG4vLyBUd28gbnVsbCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGVxdWFsLCBhcyB0d28gXCJvdXQgb2YgdGhlIGNvbXBvbmVudFwiIHN0YXRlcyBhcmUgdGhlIHNhbWUuXHJcbmZ1bmN0aW9uIGlzSGl0c0VxdWFsKGhpdDAsIGhpdDEpIHtcclxuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGhpdDAgJiYgaGl0MSkge1xyXG4gICAgICAgIHJldHVybiBoaXQwLmNvbXBvbmVudCA9PT0gaGl0MS5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgaXNIaXRQcm9wc1dpdGhpbihoaXQwLCBoaXQxKSAmJlxyXG4gICAgICAgICAgICBpc0hpdFByb3BzV2l0aGluKGhpdDEsIGhpdDApOyAvLyBlbnN1cmVzIGFsbCBwcm9wcyBhcmUgaWRlbnRpY2FsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gUmV0dXJucyB0cnVlIGlmIGFsbCBvZiBzdWJIaXQncyBub24tc3RhbmRhcmQgcHJvcGVydGllcyBhcmUgd2l0aGluIHN1cGVySGl0XHJcbmZ1bmN0aW9uIGlzSGl0UHJvcHNXaXRoaW4oc3ViSGl0LCBzdXBlckhpdCkge1xyXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3ViSGl0KSB7XHJcbiAgICAgICAgaWYgKCEvXihjb21wb25lbnR8bGVmdHxyaWdodHx0b3B8Ym90dG9tKSQvLnRlc3QocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJIaXRbcHJvcE5hbWVdICE9PSBzdXBlckhpdFtwcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0ICovLFxuLyogMjUgKi8sXG4vKiAyNiAqLyxcbi8qIDI3ICovLFxuLyogMjggKi8sXG4vKiAyOSAqLyxcbi8qIDMwICovLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoID0ge307XHJcbmV4cG9ydEhvb2tzLmxvY2FsZXMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2g7XHJcbi8vIE5PVEU6IGNhbid0IGd1YXJhbnRlZSBhbnkgb2YgdGhlc2UgY29tcHV0YXRpb25zIHdpbGwgcnVuIGJlY2F1c2Ugbm90IGV2ZXJ5IGxvY2FsZSBoYXMgZGF0ZXBpY2tlclxyXG4vLyBjb25maWdzLCBzbyBtYWtlIHN1cmUgdGhlcmUgYXJlIEVuZ2xpc2ggZmFsbGJhY2tzIGZvciB0aGVzZSBpbiB0aGUgZGVmYXVsdHMgZmlsZS5cclxudmFyIGRwQ29tcHV0YWJsZU9wdGlvbnMgPSB7XHJcbiAgICBidXR0b25UZXh0OiBmdW5jdGlvbiAoZHBPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gdGhlIHRyYW5zbGF0aW9ucyBzb21ldGltZXMgd3JvbmdseSBjb250YWluIEhUTUwgZW50aXRpZXNcclxuICAgICAgICAgICAgcHJldjogdXRpbF8xLnN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5wcmV2VGV4dCksXHJcbiAgICAgICAgICAgIG5leHQ6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMubmV4dFRleHQpLFxyXG4gICAgICAgICAgICB0b2RheTogdXRpbF8xLnN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5jdXJyZW50VGV4dClcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJNTU1NIFlZWVlcIiAtPiBcIlNlcHRlbWJlciAyMDE0XCJcclxuICAgIG1vbnRoWWVhckZvcm1hdDogZnVuY3Rpb24gKGRwT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBkcE9wdGlvbnMuc2hvd01vbnRoQWZ0ZXJZZWFyID9cclxuICAgICAgICAgICAgJ1lZWVlbJyArIGRwT3B0aW9ucy55ZWFyU3VmZml4ICsgJ10gTU1NTScgOlxyXG4gICAgICAgICAgICAnTU1NTSBZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddJztcclxuICAgIH1cclxufTtcclxudmFyIG1vbUNvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImRkZCBNL0RcIiAtPiBcIkZyaSA5LzE1XCJcclxuICAgIGRheU9mTW9udGhGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zLCBmY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZm9ybWF0ID0gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnbCcpOyAvLyBmb3IgdGhlIGZvcm1hdCBsaWtlIFwiTS9EL1lZWVlcIlxyXG4gICAgICAgIC8vIHN0cmlwIHRoZSB5ZWFyIG9mZiB0aGUgZWRnZSwgYXMgd2VsbCBhcyBvdGhlciBtaXNjIG5vbi13aGl0ZXNwYWNlIGNoYXJzXHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL15ZK1teXFx3XFxzXSp8W15cXHdcXHNdKlkrJC9nLCAnJyk7XHJcbiAgICAgICAgaWYgKGZjT3B0aW9ucy5pc1JUTCkge1xyXG4gICAgICAgICAgICBmb3JtYXQgKz0gJyBkZGQnOyAvLyBmb3IgUlRMLCBhZGQgZGF5LW9mLXdlZWsgdG8gZW5kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSAnZGRkICcgKyBmb3JtYXQ7IC8vIGZvciBMVFIsIGFkZCBkYXktb2Ytd2VlayB0byBiZWdpbm5pbmdcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbWFcIiAtPiBcIjY6MDBwbVwiXHJcbiAgICBtZWRpdW1UaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaCg6bW0pYVwiIC0+IFwiNnBtXCIgLyBcIjY6MzBwbVwiXHJcbiAgICBzbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcoOm1tKScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxXbW0pJC8sICcoJDEpJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoKDptbSl0XCIgLT4gXCI2cFwiIC8gXCI2OjMwcFwiXHJcbiAgICBleHRyYVNtYWxsVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgnOm1tJywgJyg6bW0pJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXFdtbSkkLywgJygkMSknKSAvLyBsaWtlIGFib3ZlLCBidXQgZm9yIGZvcmVpZ24gbG9jYWxlc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICd0Jyk7IC8vIGNvbnZlcnQgdG8gQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlIG9uZS1sZXR0ZXIuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaGFcIiAvIFwiSFwiIC0+IFwiNnBtXCIgLyBcIjE4XCJcclxuICAgIGhvdXJGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcV21tKSQvLCAnJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoOm1tXCIgLT4gXCI2OjMwXCIgKHdpdGggbm8gQU0vUE0pXHJcbiAgICBub01lcmlkaWVtVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIEFNL1BNXHJcbiAgICB9XHJcbn07XHJcbi8vIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgY29tcHV0ZWQgb2ZmIGxpdmUgY2FsZW5kYXIgb3B0aW9ucyAoY29uc2lkZXJzIG92ZXJyaWRlIG9wdGlvbnMpXHJcbi8vIFRPRE86IGJlc3QgcGxhY2UgZm9yIHRoaXM/IHJlbGF0ZWQgdG8gbG9jYWxlP1xyXG4vLyBUT0RPOiBmbGlwcGluZyB0ZXh0IGJhc2VkIG9uIGlzUlRMIGlzIGEgYmFkIGlkZWEgYmVjYXVzZSB0aGUgQ1NTIGBkaXJlY3Rpb25gIG1pZ2h0IHdhbnQgdG8gaGFuZGxlIGl0XHJcbnZhciBpbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIk1vIDE2XCJcclxuICAgIHNtYWxsRGF5RGF0ZUZvcm1hdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5pc1JUTCA/XHJcbiAgICAgICAgICAgICdEIGRkJyA6XHJcbiAgICAgICAgICAgICdkZCBEJztcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2sgNVwiXHJcbiAgICB3ZWVrRm9ybWF0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmlzUlRMID9cclxuICAgICAgICAgICAgJ3dbICcgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICddJyA6XHJcbiAgICAgICAgICAgICdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJyBddyc7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIldrNVwiXHJcbiAgICBzbWFsbFdlZWtGb3JtYXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xyXG4gICAgICAgICAgICAnd1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxyXG4gICAgICAgICAgICAnWycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICdddyc7XHJcbiAgICB9XHJcbn07XHJcbi8vIFRPRE86IG1ha2UgdGhlc2UgY29tcHV0YWJsZSBwcm9wZXJ0aWVzIGluIG9wdGlvbnNNYW5hZ2VyXHJcbmZ1bmN0aW9uIHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAkLmVhY2goaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBmdW5jKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zID0gcG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zO1xyXG4vLyBJbml0aWFsaXplIGpRdWVyeSBVSSBkYXRlcGlja2VyIHRyYW5zbGF0aW9ucyB3aGlsZSB1c2luZyBzb21lIG9mIHRoZSB0cmFuc2xhdGlvbnNcclxuLy8gV2lsbCBzZXQgdGhpcyBhcyB0aGUgZGVmYXVsdCBsb2NhbGVzIGZvciBkYXRlcGlja2VyLlxyXG5mdW5jdGlvbiBkYXRlcGlja2VyTG9jYWxlKGxvY2FsZUNvZGUsIGRwTG9jYWxlQ29kZSwgZHBPcHRpb25zKSB7XHJcbiAgICAvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3NhcnlcclxuICAgIHZhciBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcclxuICAgIC8vIHRyYW5zZmVyIHNvbWUgc2ltcGxlIG9wdGlvbnMgZnJvbSBkYXRlcGlja2VyIHRvIGZjXHJcbiAgICBmY09wdGlvbnMuaXNSVEwgPSBkcE9wdGlvbnMuaXNSVEw7XHJcbiAgICBmY09wdGlvbnMud2Vla051bWJlclRpdGxlID0gZHBPcHRpb25zLndlZWtIZWFkZXI7XHJcbiAgICAvLyBjb21wdXRlIHNvbWUgbW9yZSBjb21wbGV4IG9wdGlvbnMgZnJvbSBkYXRlcGlja2VyXHJcbiAgICAkLmVhY2goZHBDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBmY09wdGlvbnNbbmFtZV0gPSBmdW5jKGRwT3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICAgIHZhciBqcURhdGVQaWNrZXIgPSAkLmRhdGVwaWNrZXI7XHJcbiAgICAvLyBpcyBqUXVlcnkgVUkgRGF0ZXBpY2tlciBpcyBvbiB0aGUgcGFnZT9cclxuICAgIGlmIChqcURhdGVQaWNrZXIpIHtcclxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbG9jYWxlIGRhdGEuXHJcbiAgICAgICAgLy8gRnVsbENhbGVuZGFyIGFuZCBNb21lbnRKUyB1c2UgbG9jYWxlIGNvZGVzIGxpa2UgXCJwdC1iclwiIGJ1dCBEYXRlcGlja2VyXHJcbiAgICAgICAgLy8gZG9lcyBpdCBsaWtlIFwicHQtQlJcIiBvciBpZiBpdCBkb2Vzbid0IGhhdmUgdGhlIGxvY2FsZSwgbWF5YmUganVzdCBcInB0XCIuXHJcbiAgICAgICAgLy8gTWFrZSBhbiBhbGlhcyBzbyB0aGUgbG9jYWxlIGNhbiBiZSByZWZlcmVuY2VkIGVpdGhlciB3YXkuXHJcbiAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsW2RwTG9jYWxlQ29kZV0gPVxyXG4gICAgICAgICAgICBqcURhdGVQaWNrZXIucmVnaW9uYWxbbG9jYWxlQ29kZV0gPSAvLyBhbGlhc1xyXG4gICAgICAgICAgICAgICAgZHBPcHRpb25zO1xyXG4gICAgICAgIC8vIEFsaWFzICdlbicgdG8gdGhlIGRlZmF1bHQgbG9jYWxlIGRhdGEuIERvIHRoaXMgZXZlcnkgdGltZS5cclxuICAgICAgICBqcURhdGVQaWNrZXIucmVnaW9uYWwuZW4gPSBqcURhdGVQaWNrZXIucmVnaW9uYWxbJyddO1xyXG4gICAgICAgIC8vIFNldCBhcyBEYXRlcGlja2VyJ3MgZ2xvYmFsIGRlZmF1bHRzLlxyXG4gICAgICAgIGpxRGF0ZVBpY2tlci5zZXREZWZhdWx0cyhkcE9wdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGF0ZXBpY2tlckxvY2FsZSA9IGRhdGVwaWNrZXJMb2NhbGU7XHJcbi8vIFNldHMgRnVsbENhbGVuZGFyLXNwZWNpZmljIHRyYW5zbGF0aW9ucy4gV2lsbCBzZXQgdGhlIGxvY2FsZXMgYXMgdGhlIGdsb2JhbCBkZWZhdWx0LlxyXG5mdW5jdGlvbiBsb2NhbGUobG9jYWxlQ29kZSwgbmV3RmNPcHRpb25zKSB7XHJcbiAgICB2YXIgZmNPcHRpb25zO1xyXG4gICAgdmFyIG1vbU9wdGlvbnM7XHJcbiAgICAvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3NhcnlcclxuICAgIGZjT3B0aW9ucyA9IGV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSB8fCAoZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0ge30pO1xyXG4gICAgLy8gcHJvdmlkZWQgbmV3IG9wdGlvbnMgZm9yIHRoaXMgbG9jYWxlcz8gbWVyZ2UgdGhlbSBpblxyXG4gICAgaWYgKG5ld0ZjT3B0aW9ucykge1xyXG4gICAgICAgIGZjT3B0aW9ucyA9IGV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW2ZjT3B0aW9ucywgbmV3RmNPcHRpb25zXSk7XHJcbiAgICB9XHJcbiAgICAvLyBjb21wdXRlIGxvY2FsZSBvcHRpb25zIHRoYXQgd2VyZW4ndCBkZWZpbmVkLlxyXG4gICAgLy8gYWx3YXlzIGRvIHRoaXMuIG5ld0ZjT3B0aW9ucyBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gaW5pdGlhbGl6aW5nIGZyb20gaTE4biBmaWxlLFxyXG4gICAgLy8gc28gbm8gd2F5IHRvIHRlbGwgaWYgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBvciBhIGRlZmF1bHQtc2V0dGluZy5cclxuICAgIG1vbU9wdGlvbnMgPSBnZXRNb21lbnRMb2NhbGVEYXRhKGxvY2FsZUNvZGUpOyAvLyB3aWxsIGZhbGwgYmFjayB0byBlblxyXG4gICAgJC5lYWNoKG1vbUNvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xyXG4gICAgICAgIGlmIChmY09wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmY09wdGlvbnNbbmFtZV0gPSAoZnVuYykobW9tT3B0aW9ucywgZmNPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIHNldCBpdCBhcyB0aGUgZGVmYXVsdCBsb2NhbGUgZm9yIEZ1bGxDYWxlbmRhclxyXG4gICAgb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzLmxvY2FsZSA9IGxvY2FsZUNvZGU7XHJcbn1cclxuZXhwb3J0cy5sb2NhbGUgPSBsb2NhbGU7XHJcbi8vIFJldHVybnMgbW9tZW50J3MgaW50ZXJuYWwgbG9jYWxlIGRhdGEuIElmIGRvZXNuJ3QgZXhpc3QsIHJldHVybnMgRW5nbGlzaC5cclxuZnVuY3Rpb24gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmxvY2FsZURhdGEobG9jYWxlQ29kZSkgfHwgbW9tZW50LmxvY2FsZURhdGEoJ2VuJyk7XHJcbn1cclxuZXhwb3J0cy5nZXRNb21lbnRMb2NhbGVEYXRhID0gZ2V0TW9tZW50TG9jYWxlRGF0YTtcclxuLy8gSW5pdGlhbGl6ZSBFbmdsaXNoIGJ5IGZvcmNpbmcgY29tcHV0YXRpb24gb2YgbW9tZW50LWRlcml2ZWQgb3B0aW9ucy5cclxuLy8gQWxzbywgc2V0cyBpdCBhcyB0aGUgZGVmYXVsdC5cclxubG9jYWxlKCdlbicsIG9wdGlvbnNfMS5lbmdsaXNoRGVmYXVsdHMpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5leHBvcnRzLmdsb2JhbERlZmF1bHRzID0ge1xyXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXHJcbiAgICBtb250aFllYXJGb3JtYXQ6ICdNTU1NIFlZWVknLFxyXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAyOjAwOjAwJyxcclxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgIGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXHJcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDk6MDA6MDAnLFxyXG4gICAgLy8gZGlzcGxheVxyXG4gICAgY29sdW1uSGVhZGVyOiB0cnVlLFxyXG4gICAgZGVmYXVsdFZpZXc6ICdtb250aCcsXHJcbiAgICBhc3BlY3RSYXRpbzogMS4zNSxcclxuICAgIGhlYWRlcjoge1xyXG4gICAgICAgIGxlZnQ6ICd0aXRsZScsXHJcbiAgICAgICAgY2VudGVyOiAnJyxcclxuICAgICAgICByaWdodDogJ3RvZGF5IHByZXYsbmV4dCdcclxuICAgIH0sXHJcbiAgICB3ZWVrZW5kczogdHJ1ZSxcclxuICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcclxuICAgIHdlZWtOdW1iZXJUaXRsZTogJ1cnLFxyXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxyXG4gICAgLy8gZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgLy8gbm93SW5kaWNhdG9yOiBmYWxzZSxcclxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXHJcbiAgICBtaW5UaW1lOiAnMDA6MDA6MDAnLFxyXG4gICAgbWF4VGltZTogJzI0OjAwOjAwJyxcclxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXHJcbiAgICAvLyBldmVudCBhamF4XHJcbiAgICBsYXp5RmV0Y2hpbmc6IHRydWUsXHJcbiAgICBzdGFydFBhcmFtOiAnc3RhcnQnLFxyXG4gICAgZW5kUGFyYW06ICdlbmQnLFxyXG4gICAgdGltZXpvbmVQYXJhbTogJ3RpbWV6b25lJyxcclxuICAgIHRpbWV6b25lOiBmYWxzZSxcclxuICAgIC8vIGFsbERheURlZmF1bHQ6IHVuZGVmaW5lZCxcclxuICAgIC8vIGxvY2FsZVxyXG4gICAgbG9jYWxlOiBudWxsLFxyXG4gICAgaXNSVEw6IGZhbHNlLFxyXG4gICAgYnV0dG9uVGV4dDoge1xyXG4gICAgICAgIHByZXY6ICdwcmV2JyxcclxuICAgICAgICBuZXh0OiAnbmV4dCcsXHJcbiAgICAgICAgcHJldlllYXI6ICdwcmV2IHllYXInLFxyXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcclxuICAgICAgICB5ZWFyOiAneWVhcicsXHJcbiAgICAgICAgdG9kYXk6ICd0b2RheScsXHJcbiAgICAgICAgbW9udGg6ICdtb250aCcsXHJcbiAgICAgICAgd2VlazogJ3dlZWsnLFxyXG4gICAgICAgIGRheTogJ2RheSdcclxuICAgIH0sXHJcbiAgICAvLyBidXR0b25JY29uczogbnVsbCxcclxuICAgIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcclxuICAgIC8vIGFsbG93cyBzZXR0aW5nIGEgbWluLWhlaWdodCB0byB0aGUgZXZlbnQgc2VnbWVudCB0byBwcmV2ZW50IHNob3J0IGV2ZW50cyBvdmVybGFwcGluZyBlYWNoIG90aGVyXHJcbiAgICBhZ2VuZGFFdmVudE1pbkhlaWdodDogMCxcclxuICAgIC8vIGpxdWVyeS11aSB0aGVtaW5nXHJcbiAgICB0aGVtZTogZmFsc2UsXHJcbiAgICAvLyB0aGVtZUJ1dHRvbkljb25zOiBudWxsLFxyXG4gICAgLy8gZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IGZhbHNlLFxyXG4gICAgZHJhZ09wYWNpdHk6IC43NSxcclxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxyXG4gICAgZHJhZ1Njcm9sbDogdHJ1ZSxcclxuICAgIC8vIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxyXG4gICAgLy8gc2VsZWN0TWluRGlzdGFuY2U6IDAsXHJcbiAgICBkcm9wQWNjZXB0OiAnKicsXHJcbiAgICBldmVudE9yZGVyOiAndGl0bGUnLFxyXG4gICAgLy8gZXZlbnRSZW5kZXJXYWl0OiBudWxsLFxyXG4gICAgZXZlbnRMaW1pdDogZmFsc2UsXHJcbiAgICBldmVudExpbWl0VGV4dDogJ21vcmUnLFxyXG4gICAgZXZlbnRMaW1pdENsaWNrOiAncG9wb3ZlcicsXHJcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiAnTEwnLFxyXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxyXG4gICAgd2luZG93UmVzaXplRGVsYXk6IDEwMCxcclxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwXHJcbn07XHJcbmV4cG9ydHMuZW5nbGlzaERlZmF1bHRzID0ge1xyXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogJ2RkZGQsIE1NTU0gRCdcclxufTtcclxuZXhwb3J0cy5ydGxEZWZhdWx0cyA9IHtcclxuICAgIGhlYWRlcjoge1xyXG4gICAgICAgIGxlZnQ6ICduZXh0LHByZXYgdG9kYXknLFxyXG4gICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgcmlnaHQ6ICd0aXRsZSdcclxuICAgIH0sXHJcbiAgICBidXR0b25JY29uczoge1xyXG4gICAgICAgIHByZXY6ICdyaWdodC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgICAgIG5leHQ6ICdsZWZ0LXNpbmdsZS1hcnJvdycsXHJcbiAgICAgICAgcHJldlllYXI6ICdyaWdodC1kb3VibGUtYXJyb3cnLFxyXG4gICAgICAgIG5leHRZZWFyOiAnbGVmdC1kb3VibGUtYXJyb3cnXHJcbiAgICB9LFxyXG4gICAgdGhlbWVCdXR0b25JY29uczoge1xyXG4gICAgICAgIHByZXY6ICdjaXJjbGUtdHJpYW5nbGUtZScsXHJcbiAgICAgICAgbmV4dDogJ2NpcmNsZS10cmlhbmdsZS13JyxcclxuICAgICAgICBuZXh0WWVhcjogJ3NlZWstcHJldicsXHJcbiAgICAgICAgcHJldlllYXI6ICdzZWVrLW5leHQnXHJcbiAgICB9XHJcbn07XHJcbnZhciBjb21wbGV4T3B0aW9ucyA9IFtcclxuICAgICdoZWFkZXInLFxyXG4gICAgJ2Zvb3RlcicsXHJcbiAgICAnYnV0dG9uVGV4dCcsXHJcbiAgICAnYnV0dG9uSWNvbnMnLFxyXG4gICAgJ3RoZW1lQnV0dG9uSWNvbnMnXHJcbl07XHJcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdFxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uT2Jqcykge1xyXG4gICAgcmV0dXJuIHV0aWxfMS5tZXJnZVByb3BzKG9wdGlvbk9ianMsIGNvbXBsZXhPcHRpb25zKTtcclxufVxyXG5leHBvcnRzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcclxuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vLyBDbGFzcyB0aGF0IGFsbCBvdGhlciBjbGFzc2VzIHdpbGwgaW5oZXJpdCBmcm9tXHJcbnZhciBDbGFzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge1xyXG4gICAgfVxyXG4gICAgLy8gQ2FsbGVkIG9uIGEgY2xhc3MgdG8gY3JlYXRlIGEgc3ViY2xhc3MuXHJcbiAgICAvLyBMSU1JVEFUSU9OOiBjYW5ub3QgcHJvdmlkZSBhIGNvbnN0cnVjdG9yIVxyXG4gICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKG1lbWJlcnMpIHtcclxuICAgICAgICB2YXIgU3ViQ2xhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIHRzbGliXzEuX19leHRlbmRzKFN1YkNsYXNzLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICAgICAgfSh0aGlzKSk7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhtZW1iZXJzLCBTdWJDbGFzcy5wcm90b3R5cGUpO1xyXG4gICAgICAgIHJldHVybiBTdWJDbGFzcztcclxuICAgIH07XHJcbiAgICAvLyBBZGRzIG5ldyBtZW1iZXIgdmFyaWFibGVzL21ldGhvZHMgdG8gdGhlIGNsYXNzJ3MgcHJvdG90eXBlLlxyXG4gICAgLy8gQ2FuIGJlIGNhbGxlZCB3aXRoIGFub3RoZXIgY2xhc3MsIG9yIGEgcGxhaW4gb2JqZWN0IGhhc2ggY29udGFpbmluZyBuZXcgbWVtYmVycy5cclxuICAgIENsYXNzLm1peGluID0gZnVuY3Rpb24gKG1lbWJlcnMpIHtcclxuICAgICAgICB1dGlsXzEuY29weU93blByb3BzKG1lbWJlcnMsIHRoaXMucHJvdG90eXBlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2xhc3M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENsYXNzO1xyXG5cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDgpO1xyXG52YXIgRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZihzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWlzY1Byb3BzID0ge307XHJcbiAgICB9XHJcbiAgICBFdmVudERlZi5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IG5ldyB0aGlzKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGRlZi5hcHBseVByb3BzKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYubm9ybWFsaXplSWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnX2ZjJyArIChFdmVudERlZi51dWlkKyspO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuc291cmNlKTtcclxuICAgICAgICBjb3B5LmlkID0gdGhpcy5pZDtcclxuICAgICAgICBjb3B5LnJhd0lkID0gdGhpcy5yYXdJZDtcclxuICAgICAgICBjb3B5LnVpZCA9IHRoaXMudWlkOyAvLyBub3QgcmVhbGx5IHVuaXF1ZSBhbnltb3JlIDooXHJcbiAgICAgICAgRXZlbnREZWYuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLCBjb3B5KTtcclxuICAgICAgICBjb3B5LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnNsaWNlKCk7IC8vIGNvcHlcclxuICAgICAgICBjb3B5Lm1pc2NQcm9wcyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmhhc0ludmVyc2VSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyaW5nKCkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5oYXNCZ1JlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVuZGVyaW5nID0gdGhpcy5nZXRSZW5kZXJpbmcoKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJyB8fCByZW5kZXJpbmcgPT09ICdiYWNrZ3JvdW5kJztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuZ2V0UmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmluZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnJlbmRlcmluZztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuZ2V0Q29uc3RyYWludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlLmNvbnN0cmFpbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY29uc3RyYWludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNhbGVuZGFyLm9wdCgnZXZlbnRDb25zdHJhaW50Jyk7IC8vIHdoYXQgYWJvdXQgVmlldyBvcHRpb24/XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldE92ZXJsYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZS5vdmVybGFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLm92ZXJsYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jYWxlbmRhci5vcHQoJ2V2ZW50T3ZlcmxhcCcpOyAvLyB3aGF0IGFib3V0IFZpZXcgb3B0aW9uP1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5pc1N0YXJ0RXhwbGljaXRseUVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydEVkaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3RhcnRFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaXNEdXJhdGlvbkV4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb25FZGl0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmlzRXhwbGljaXRseUVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5lZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9ICQuZXh0ZW5kKHt9LCB0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgb2JqLl9pZCA9IHRoaXMudWlkO1xyXG4gICAgICAgIG9iai5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICBvYmouY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUuc2xpY2UoKTsgLy8gY29weVxyXG4gICAgICAgIG9iai5hbGxEYXkgPSB0aGlzLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmF3SWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvYmouaWQgPSB0aGlzLnJhd0lkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERlZi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzKHRoaXMsIG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzLmlkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IEV2ZW50RGVmLm5vcm1hbGl6ZUlkKCh0aGlzLnJhd0lkID0gcmF3UHJvcHMuaWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudERlZi5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcy5faWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnVpZCA9IFN0cmluZyhyYXdQcm9wcy5faWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBFdmVudERlZi5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGNvbnZlcmdlIHdpdGggRXZlbnRTb3VyY2VcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd1Byb3BzLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICAkLmV4dGVuZCh0aGlzLm1pc2NQcm9wcywgcmF3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnV1aWQgPSAwO1xyXG4gICAgRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQuZGVmaW5lU3RhbmRhcmRQcm9wcztcclxuICAgIEV2ZW50RGVmLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICByZXR1cm4gRXZlbnREZWY7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnREZWYpO1xyXG5FdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIC8vIG5vdCBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIChgZmFsc2VgKVxyXG4gICAgX2lkOiBmYWxzZSxcclxuICAgIGlkOiBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogZmFsc2UsXHJcbiAgICBzb3VyY2U6IGZhbHNlLFxyXG4gICAgLy8gYXV0b21hdGljYWxseSBhc3NpZ25lZCAoYHRydWVgKVxyXG4gICAgdGl0bGU6IHRydWUsXHJcbiAgICB1cmw6IHRydWUsXHJcbiAgICByZW5kZXJpbmc6IHRydWUsXHJcbiAgICBjb25zdHJhaW50OiB0cnVlLFxyXG4gICAgb3ZlcmxhcDogdHJ1ZSxcclxuICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICBjb2xvcjogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcclxuICAgIGJvcmRlckNvbG9yOiB0cnVlLFxyXG4gICAgdGV4dENvbG9yOiB0cnVlXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMSk7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5mdW5jdGlvbiBldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzKGV2ZW50RGVmcywgdW56b25lZFJhbmdlKSB7XHJcbiAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VzLnB1c2guYXBwbHkoZXZlbnRJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgIGV2ZW50RGVmc1tpXS5idWlsZEluc3RhbmNlcyh1bnpvbmVkUmFuZ2UpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudEluc3RhbmNlcztcclxufVxyXG5leHBvcnRzLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMgPSBldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzO1xyXG5mdW5jdGlvbiBldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBuZXcgRXZlbnRSYW5nZV8xLmRlZmF1bHQoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS51bnpvbmVkUmFuZ2UsIGV2ZW50SW5zdGFuY2UuZGVmLCBldmVudEluc3RhbmNlKTtcclxufVxyXG5leHBvcnRzLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UgPSBldmVudEluc3RhbmNlVG9FdmVudFJhbmdlO1xyXG5mdW5jdGlvbiBldmVudFJhbmdlVG9FdmVudEZvb3RwcmludChldmVudFJhbmdlKSB7XHJcbiAgICByZXR1cm4gbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChldmVudFJhbmdlLnVuem9uZWRSYW5nZSwgZXZlbnRSYW5nZS5ldmVudERlZi5pc0FsbERheSgpKSwgZXZlbnRSYW5nZS5ldmVudERlZiwgZXZlbnRSYW5nZS5ldmVudEluc3RhbmNlIC8vIG1pZ2h0IG5vdCBleGlzdFxyXG4gICAgKTtcclxufVxyXG5leHBvcnRzLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50ID0gZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQ7XHJcbmZ1bmN0aW9uIGV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZShldmVudEluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS51bnpvbmVkUmFuZ2U7XHJcbn1cclxuZXhwb3J0cy5ldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UgPSBldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2U7XHJcbmZ1bmN0aW9uIGV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQoZXZlbnRGb290cHJpbnQpIHtcclxuICAgIHJldHVybiBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbn1cclxuZXhwb3J0cy5ldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50ID0gZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludDtcclxuXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRGb290cHJpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRGb290cHJpbnQgPSBjb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZiA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRXZlbnRGb290cHJpbnQucHJvdG90eXBlLmdldEV2ZW50TGVnYWN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ldmVudEluc3RhbmNlIHx8IHRoaXMuZXZlbnREZWYpLnRvTGVnYWN5KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50Rm9vdHByaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEZvb3RwcmludDtcclxuXG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVmTXV0YXRpb24oKSB7XHJcbiAgICB9XHJcbiAgICBFdmVudERlZk11dGF0aW9uLmNyZWF0ZUZyb21SYXdQcm9wcyA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCByYXdQcm9wcywgbGFyZ2VVbml0KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRJbnN0YW5jZS5kZWY7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIG1pc2NQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciB2ZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgZXZlbnREZWZJZCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIHZhciBkZWZNdXRhdGlvbjtcclxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdC5pc1N0YW5kYXJkUHJvcChwcm9wTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnREZWYuaXNTdGFuZGFyZFByb3AocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudERlZi5taXNjUHJvcHNbcHJvcE5hbWVdICE9PSByYXdQcm9wc1twcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIG1pc2NQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdC5wYXJzZShkYXRlUHJvcHMsIGV2ZW50RGVmLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbiA9IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdC5jcmVhdGVGcm9tRGlmZihldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZSwgbGFyZ2VVbml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YW5kYXJkUHJvcHMuaWQgIT09IGV2ZW50RGVmLmlkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmSWQgPSBzdGFuZGFyZFByb3BzLmlkOyAvLyBvbmx5IGFwcGx5IGlmIHRoZXJlJ3MgYSBjaGFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF1dGlsXzEuaXNBcnJheXNFcXVhbChzdGFuZGFyZFByb3BzLmNsYXNzTmFtZSwgZXZlbnREZWYuY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBzdGFuZGFyZFByb3BzLmNsYXNzTmFtZTsgLy8gb25seSBhcHBseSBpZiB0aGVyZSdzIGEgY2hhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50RGVmXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzKHN0YW5kYXJkUHJvcHMsIC8vIHNyY1xyXG4gICAgICAgIHZlcmJhdGltU3RhbmRhcmRQcm9wcyAvLyBkZXN0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBkZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uKCk7XHJcbiAgICAgICAgZGVmTXV0YXRpb24uZXZlbnREZWZJZCA9IGV2ZW50RGVmSWQ7XHJcbiAgICAgICAgZGVmTXV0YXRpb24uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLnZlcmJhdGltU3RhbmRhcmRQcm9wcyA9IHZlcmJhdGltU3RhbmRhcmRQcm9wcztcclxuICAgICAgICBkZWZNdXRhdGlvbi5taXNjUHJvcHMgPSBtaXNjUHJvcHM7XHJcbiAgICAgICAgaWYgKGRhdGVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBkZWZNdXRhdGlvbi5kYXRlTXV0YXRpb24gPSBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgZXZlbnREZWYgYXNzdW1lZCB0byBiZSBhIFNpbmdsZUV2ZW50RGVmLlxyXG4gICAgcmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50RGVmTXV0YXRpb24ucHJvdG90eXBlLm11dGF0ZVNpbmdsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvcmlnRGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIG9yaWdEYXRlUHJvZmlsZSA9IGV2ZW50RGVmLmRhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICBldmVudERlZi5kYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZU11dGF0aW9uLmJ1aWxkTmV3RGF0ZVByb2ZpbGUob3JpZ0RhdGVQcm9maWxlLCBldmVudERlZi5zb3VyY2UuY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBFdmVudERlZjo6YXBwbHlNYW51YWxTdGFuZGFyZFByb3BzXHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZWZJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmlkID0gRXZlbnREZWZfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKChldmVudERlZi5yYXdJZCA9IHRoaXMuZXZlbnREZWZJZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBFdmVudERlZjo6YXBwbHlNYW51YWxTdGFuZGFyZFByb3BzXHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgaWYgKHRoaXMudmVyYmF0aW1TdGFuZGFyZFByb3BzKSB7XHJcbiAgICAgICAgICAgIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzKHRoaXMudmVyYmF0aW1TdGFuZGFyZFByb3BzLCAvLyBzcmNcclxuICAgICAgICAgICAgZXZlbnREZWYgLy8gZGVzdFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgaWYgKHRoaXMubWlzY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmFwcGx5TWlzY1Byb3BzKHRoaXMubWlzY1Byb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdEYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWYuZGF0ZVByb2ZpbGUgPSBvcmlnRGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZk11dGF0aW9uLnByb3RvdHlwZS5zZXREYXRlTXV0YXRpb24gPSBmdW5jdGlvbiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRhdGVNdXRhdGlvbiAmJiAhZGF0ZU11dGF0aW9uLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVNdXRhdGlvbiA9IGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZGF0ZU11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudERlZk11dGF0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZk11dGF0aW9uO1xyXG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIHNvdXJjZUNsYXNzZXM6IFtdLFxyXG4gICAgcmVnaXN0ZXJDbGFzczogZnVuY3Rpb24gKEV2ZW50U291cmNlQ2xhc3MpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZUNsYXNzZXMudW5zaGlmdChFdmVudFNvdXJjZUNsYXNzKTsgLy8gZ2l2ZSBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICB9LFxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc291cmNlQ2xhc3NlcyA9IHRoaXMuc291cmNlQ2xhc3NlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZXZlbnRTb3VyY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VDbGFzc2VzW2ldLnBhcnNlKHJhd0lucHV0LCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxuLypcclxuRW1ib2RpZXMgYSBkaXYgdGhhdCBoYXMgcG90ZW50aWFsIHNjcm9sbGJhcnNcclxuKi9cclxudmFyIFNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Nyb2xsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTY3JvbGxlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBfdGhpcy5vdmVyZmxvd1ggPSBvcHRpb25zLm92ZXJmbG93WCB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcclxuICAgICAgICBfdGhpcy5vdmVyZmxvd1kgPSBvcHRpb25zLm92ZXJmbG93WSB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLnJlbmRlckVsKCk7XHJcbiAgICAgICAgdGhpcy5hcHBseU92ZXJmbG93KCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlckVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zY3JvbGxFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1zY3JvbGxlclwiPjwvZGl2PicpKTtcclxuICAgIH07XHJcbiAgICAvLyBzZXRzIHRvIG5hdHVyYWwgaGVpZ2h0LCB1bmxvY2tzIG92ZXJmbG93XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoJ2F1dG8nKTtcclxuICAgICAgICB0aGlzLmFwcGx5T3ZlcmZsb3coKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIE92ZXJmbG93XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmFwcGx5T3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5jc3Moe1xyXG4gICAgICAgICAgICAnb3ZlcmZsb3cteCc6IHRoaXMub3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAnb3ZlcmZsb3cteSc6IHRoaXMub3ZlcmZsb3dZXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2F1c2VzIGFueSAnYXV0bycgb3ZlcmZsb3cgdmFsdWVzIHRvIHJlc29sdmVzIHRvICdzY3JvbGwnIG9yICdoaWRkZW4nLlxyXG4gICAgLy8gVXNlZnVsIGZvciBwcmVzZXJ2aW5nIHNjcm9sbGJhciB3aWR0aHMgcmVnYXJkbGVzcyBvZiBmdXR1cmUgcmVzaXplcy5cclxuICAgIC8vIENhbiBwYXNzIGluIHNjcm9sbGJhcldpZHRocyBmb3Igb3B0aW1pemF0aW9uLlxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmxvY2tPdmVyZmxvdyA9IGZ1bmN0aW9uIChzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3dYID0gdGhpcy5vdmVyZmxvd1g7XHJcbiAgICAgICAgdmFyIG92ZXJmbG93WSA9IHRoaXMub3ZlcmZsb3dZO1xyXG4gICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHNjcm9sbGJhcldpZHRocyB8fCB0aGlzLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgIGlmIChvdmVyZmxvd1ggPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICBvdmVyZmxvd1ggPSAoc2Nyb2xsYmFyV2lkdGhzLnRvcCB8fCBzY3JvbGxiYXJXaWR0aHMuYm90dG9tIHx8IC8vIGhvcml6b250YWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsV2lkdGggLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aCkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3ZlcmZsb3dZID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dZID0gKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCB8fCAvLyB2ZXJ0aWNhbCBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgLy8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbFswXS5zY3JvbGxIZWlnaHQgLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRIZWlnaHQpID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5jc3MoeyAnb3ZlcmZsb3cteCc6IG92ZXJmbG93WCwgJ292ZXJmbG93LXknOiBvdmVyZmxvd1kgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0dGVycyAvIFNldHRlcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuaGVpZ2h0KGhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AoKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuc2Nyb2xsVG9wKHRvcCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldENsaWVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0O1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxiYXJXaWR0aHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRTY3JvbGxiYXJXaWR0aHModGhpcy5zY3JvbGxFbCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNjcm9sbGVyO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOSk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudChfdmlldywgX29wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfdmlldywgX29wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gc2VsZi1jb25maWcsIG92ZXJyaWRhYmxlIGJ5IHN1YmNsYXNzZXNcclxuICAgICAgICBfdGhpcy5zZWdTZWxlY3RvciA9ICcuZmMtZXZlbnQtY29udGFpbmVyID4gKic7IC8vIHdoYXQgY29uc3RpdHV0ZXMgYW4gZXZlbnQgZWxlbWVudD9cclxuICAgICAgICBpZiAoX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGVDbGlja2luZyA9IG5ldyBfdGhpcy5kYXRlQ2xpY2tpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5kYXRlU2VsZWN0aW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZGF0ZVNlbGVjdGluZyA9IG5ldyBfdGhpcy5kYXRlU2VsZWN0aW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnRQb2ludGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcgPSBuZXcgX3RoaXMuZXZlbnRQb2ludGluZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50RHJhZ2dpbmdDbGFzcyAmJiBfdGhpcy5ldmVudFBvaW50aW5nKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50RHJhZ2dpbmcgPSBuZXcgX3RoaXMuZXZlbnREcmFnZ2luZ0NsYXNzKF90aGlzLCBfdGhpcy5ldmVudFBvaW50aW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50UmVzaXppbmdDbGFzcyAmJiBfdGhpcy5ldmVudFBvaW50aW5nKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UmVzaXppbmcgPSBuZXcgX3RoaXMuZXZlbnRSZXNpemluZ0NsYXNzKF90aGlzLCBfdGhpcy5ldmVudFBvaW50aW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV4dGVybmFsRHJvcHBpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5leHRlcm5hbERyb3BwaW5nID0gbmV3IF90aGlzLmV4dGVybmFsRHJvcHBpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFNldHMgdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgdGhlIHZpZXcgc2hvdWxkIHJlbmRlciBpbnNpZGUgb2YsIGRvZXMgZ2xvYmFsIERPTS1yZWxhdGVkIGluaXRpYWxpemF0aW9ucyxcclxuICAgIC8vIGFuZCByZW5kZXJzIGFsbCB0aGUgbm9uLWRhdGUtcmVsYXRlZCBjb250ZW50IGluc2lkZS5cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0RWxlbWVudC5jYWxsKHRoaXMsIGVsKTtcclxuICAgICAgICBpZiAodGhpcy5kYXRlQ2xpY2tpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlQ2xpY2tpbmcuYmluZFRvRWwoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRlU2VsZWN0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVNlbGVjdGluZy5iaW5kVG9FbChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmluZEFsbFNlZ0hhbmRsZXJzVG9FbChlbCk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb25zKCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEludGVyYWN0aW9ucygpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsRHJvcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlcm5hbERyb3BwaW5nLmJpbmRUb0RvY3VtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsRHJvcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlcm5hbERyb3BwaW5nLnVuYmluZEZyb21Eb2N1bWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmJpbmREYXRlSGFuZGxlclRvRWwgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gdGhlIGdyaWQncyByb290IGVsZW1lbnQuXHJcbiAgICAgICAgLy8galF1ZXJ5IHdpbGwgdGFrZSBjYXJlIG9mIHVucmVnaXN0ZXJpbmcgdGhlbSB3aGVuIHJlbW92ZUVsZW1lbnQgZ2V0cyBjYWxsZWQuXHJcbiAgICAgICAgdGhpcy5lbC5vbihuYW1lLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKCEkKGV2LnRhcmdldCkuaXMoX3RoaXMuc2VnU2VsZWN0b3IgKyAnOm5vdCguZmMtaGVscGVyKSwnICsgLy8gZGlyZWN0bHkgb24gYW4gZXZlbnQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgKyAnOm5vdCguZmMtaGVscGVyKSAqLCcgKyAvLyB3aXRoaW4gYW4gZXZlbnQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgJy5mYy1tb3JlLCcgKyAvLyBhIFwibW9yZS4uXCIgbGlua1xyXG4gICAgICAgICAgICAgICAgJ2FbZGF0YS1nb3RvXScgLy8gYSBjbGlja2FibGUgbmF2IGxpbmtcclxuICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kQWxsU2VnSGFuZGxlcnNUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UG9pbnRpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREcmFnZ2luZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlc2l6aW5nXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudEludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudEludGVyYWN0aW9uLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZFNlZ0hhbmRsZXJUb0VsID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBlbC5vbihuYW1lLCB0aGlzLnNlZ1NlbGVjdG9yLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ0VsID0gJChldi5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKCFzZWdFbC5pcygnLmZjLWhlbHBlcicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2VnRWwuZGF0YSgnZmMtc2VnJyk7IC8vIGdyYWIgc2VnbWVudCBkYXRhLiBwdXQgdGhlcmUgYnkgVmlldzo6cmVuZGVyRXZlbnRzUGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlZyAmJiAhX3RoaXMuc2hvdWxkSWdub3JlRXZlbnRQb2ludGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgc2VnLCBldik7IC8vIGNvbnRleHQgd2lsbCBiZSB0aGUgR3JpZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRJZ25vcmVNb3VzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBIQUNLXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIHN0aWxsIHdvcmsgZXZlbiB0aG91Z2ggYmluZERhdGVIYW5kbGVyVG9FbCBkb2Vzbid0IHVzZSBHbG9iYWxFbWl0dGVyLlxyXG4gICAgICAgIHJldHVybiBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlVG91Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgLy8gT24gaU9TIChhbmQgQW5kcm9pZD8pIHdoZW4gYSBuZXcgc2VsZWN0aW9uIGlzIGluaXRpYXRlZCBvdmVydG9wIGFub3RoZXIgc2VsZWN0aW9uLFxyXG4gICAgICAgIC8vIHRoZSB0b3VjaGVuZCBuZXZlciBmaXJlcyBiZWNhdXNlIHRoZSBlbGVtZW50cyBnZXRzIHJlbW92ZWQgbWlkLXRvdWNoLWludGVyYWN0aW9uIChteSB0aGVvcnkpLlxyXG4gICAgICAgIC8vIEhBQ0s6IHNpbXBseSBkb24ndCBhbGxvdyB0aGlzIHRvIGhhcHBlbi5cclxuICAgICAgICAvLyBBTFNPOiBwcmV2ZW50IHNlbGVjdGlvbiB3aGVuIGFuICpldmVudCogaXMgYWxyZWFkeSByYWlzZWQuXHJcbiAgICAgICAgcmV0dXJuIHZpZXcuaXNTZWxlY3RlZCB8fCB2aWV3LnNlbGVjdGVkRXZlbnQ7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRJZ25vcmVFdmVudFBvaW50aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIG9ubHkgY2FsbCB0aGUgaGFuZGxlcnMgaWYgdGhlcmUgaXMgbm90IGEgZHJhZy9yZXNpemUgaW4gcHJvZ3Jlc3NcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnREcmFnZ2luZyAmJiB0aGlzLmV2ZW50RHJhZ2dpbmcuaXNEcmFnZ2luZykgfHxcclxuICAgICAgICAgICAgKHRoaXMuZXZlbnRSZXNpemluZyAmJiB0aGlzLmV2ZW50UmVzaXppbmcuaXNSZXNpemluZyk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYW5TdGFydFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRFdklzVG91Y2goZXYpICYmXHJcbiAgICAgICAgICAgICF0aGlzLmNhblN0YXJ0UmVzaXplKHNlZywgZXYpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmlzRXZlbnREZWZEcmFnZ2FibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYW5TdGFydERyYWcgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZEcmFnZ2FibGUoc2VnLmZvb3RwcmludC5ldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYW5TdGFydFJlc2l6ZSA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICByZXR1cm4gKCF1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSB8fCB2aWV3LmlzRXZlbnREZWZTZWxlY3RlZChldmVudERlZikpICYmXHJcbiAgICAgICAgICAgIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShldmVudERlZikgJiZcclxuICAgICAgICAgICAgJChldi50YXJnZXQpLmlzKCcuZmMtcmVzaXplcicpO1xyXG4gICAgfTtcclxuICAgIC8vIEtpbGxzIGFsbCBpbi1wcm9ncmVzcyBkcmFnZ2luZy5cclxuICAgIC8vIFVzZWZ1bCBmb3Igd2hlbiBwdWJsaWMgQVBJIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gcmUtcmVuZGVyaW5nIGFyZSBpbnZva2VkIGR1cmluZyBhIGRyYWcuXHJcbiAgICAvLyBBbHNvIHVzZWZ1bCBmb3Igd2hlbiB0b3VjaCBkZXZpY2VzIG1pc2JlaGF2ZSBhbmQgZG9uJ3QgZmlyZSB0aGVpciB0b3VjaGVuZC5cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZW5kSW50ZXJhY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdGhpcy5kYXRlQ2xpY2tpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVNlbGVjdGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudFBvaW50aW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RHJhZ2dpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZXNpemluZ1xyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5lbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERyYWctbi1Ecm9wXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIGRyYWdnZWQgYnkgdGhlIHVzZXJcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZkRyYWdnYWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRXZlbnREZWZTdGFydEVkaXRhYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZTdGFydEVkaXRhYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGlzRWRpdGFibGUgPSBldmVudERlZi5pc1N0YXJ0RXhwbGljaXRseUVkaXRhYmxlKCk7XHJcbiAgICAgICAgaWYgKGlzRWRpdGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc0VkaXRhYmxlID0gdGhpcy5vcHQoJ2V2ZW50U3RhcnRFZGl0YWJsZScpO1xyXG4gICAgICAgICAgICBpZiAoaXNFZGl0YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpc0VkaXRhYmxlID0gdGhpcy5pc0V2ZW50RGVmR2VuZXJhbGx5RWRpdGFibGUoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0VkaXRhYmxlO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZkdlbmVyYWxseUVkaXRhYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGlzRWRpdGFibGUgPSBldmVudERlZi5pc0V4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc0VkaXRhYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMub3B0KCdlZGl0YWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZXNpemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIHN0YXJ0aW5nIGVkZ2VcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydCA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnZXZlbnRSZXNpemFibGVGcm9tU3RhcnQnKSAmJiB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgZnJvbSBpdHMgZW5kaW5nIGVkZ2VcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGJ5IHRoZSB1c2VyIGF0IGFsbFxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmUmVzaXphYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlID0gZXZlbnREZWYuaXNEdXJhdGlvbkV4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc1Jlc2l6YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzUmVzaXphYmxlID0gdGhpcy5vcHQoJ2V2ZW50RHVyYXRpb25FZGl0YWJsZScpO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNSZXNpemFibGUgPSB0aGlzLmlzRXZlbnREZWZHZW5lcmFsbHlFZGl0YWJsZShldmVudERlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzUmVzaXphYmxlO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IE11dGF0aW9uIC8gQ29uc3RyYWludHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gRGlmZnMgdGhlIHR3byBkYXRlcywgcmV0dXJuaW5nIGEgZHVyYXRpb24sIGJhc2VkIG9uIGdyYW51bGFyaXR5IG9mIHRoZSBncmlkXHJcbiAgICAvLyBUT0RPOiBwb3J0IGlzVGltZVNjYWxlIGludG8gdGhpcyBzeXN0ZW0/XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmRpZmZEYXRlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFyZ2VVbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkJ5VW5pdChhLCBiLCB0aGlzLmxhcmdlVW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZEYXlUaW1lKGEsIGIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpcyBpdCBhbGxvd2VkLCBpbiByZWxhdGlvbiB0byB0aGUgdmlldydzIHZhbGlkUmFuZ2U/XHJcbiAgICAvLyBOT1RFOiB2ZXJ5IHNpbWlsYXIgdG8gaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEFsbEV2ZW50UmFuZ2VzKCkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gVE9ETzoganVzdCB1c2UgZ2V0QWxsRXZlbnRSYW5nZXMgZGlyZWN0bHlcclxuICAgICAgICAgICAgaWYgKCFkYXRlUHJvZmlsZS52YWxpZFVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3LmNhbGVuZGFyLmNvbnN0cmFpbnRzLmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZChldmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgfTtcclxuICAgIC8vIE5PVEU6IHZlcnkgc2ltaWxhciB0byBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgIC8vIHdoZW4gaXQncyBhIGNvbXBsZXRlbHkgYW5vbnltb3VzIGV4dGVybmFsIGRyYWcsIG5vIGV2ZW50LlxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRBbGxFdmVudFJhbmdlcygpKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRyZWF0IGl0IGFzIGEgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgaW4gZXZlbnRJbnN0YW5jZUdyb3VwIGluc3RlYWRcclxuICAgICAgICAgICAgLy8gIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBjYWxlbmRhcidzIGNvbnN0cmFpbnQgc3lzdGVtIHRvIGRlcGVuZCBvbiBhIGNvbXBvbmVudCdzXHJcbiAgICAgICAgICAgIC8vICBkZXRlcm1pbmF0aW9uIG9mIGZvb3RwcmludHMuXHJcbiAgICAgICAgICAgIGlmICghdmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50O1xyXG59KERhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudDtcclxuXG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgUmVuZGVyUXVldWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE4KTtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMSk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZyb20gd2hpY2ggb3RoZXIgdmlld3MgaW5oZXJpdCBmcm9tXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHZpZXdTcGVjLm9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYmF0Y2hSZW5kZXJEZXB0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBib29sZWFuIHdoZXRoZXIgYSByYW5nZSBvZiB0aW1lIGlzIHVzZXItc2VsZWN0ZWQgb3Igbm90XHJcbiAgICAgICAgX3RoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICBfdGhpcy52aWV3U3BlYyA9IHZpZXdTcGVjO1xyXG4gICAgICAgIC8vIHNob3J0Y3V0c1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSB2aWV3U3BlYy50eXBlO1xyXG4gICAgICAgIC8vIC5uYW1lIGlzIGRlcHJlY2F0ZWRcclxuICAgICAgICBfdGhpcy5uYW1lID0gX3RoaXMudHlwZTtcclxuICAgICAgICBfdGhpcy5pbml0UmVuZGVyUXVldWUoKTtcclxuICAgICAgICBfdGhpcy5pbml0SGlkZGVuRGF5cygpO1xyXG4gICAgICAgIF90aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yID0gbmV3IF90aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLmJpbmRCYXNlUmVuZGVySGFuZGxlcnMoKTtcclxuICAgICAgICBfdGhpcy5ldmVudE9yZGVyU3BlY3MgPSB1dGlsXzEucGFyc2VGaWVsZFNwZWNzKF90aGlzLm9wdCgnZXZlbnRPcmRlcicpKTtcclxuICAgICAgICAvLyBsZWdhY3lcclxuICAgICAgICBpZiAoX3RoaXNbJ2luaXRpYWxpemUnXSkge1xyXG4gICAgICAgICAgICBfdGhpc1snaW5pdGlhbGl6ZSddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFZpZXcucHJvdG90eXBlLl9nZXRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHJpZXZlcyBhbiBvcHRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAgVmlldy5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xyXG4gICAgfTtcclxuICAgIC8qIFJlbmRlciBRdWV1ZVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLmluaXRSZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlID0gbmV3IFJlbmRlclF1ZXVlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGV2ZW50OiB0aGlzLm9wdCgnZXZlbnRSZW5kZXJXYWl0JylcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uKCdzdGFydCcsIHRoaXMub25SZW5kZXJRdWV1ZVN0YXJ0LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyUXVldWUub24oJ3N0b3AnLCB0aGlzLm9uUmVuZGVyUXVldWVTdG9wLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMub24oJ2JlZm9yZTpjaGFuZ2UnLCB0aGlzLnN0YXJ0QmF0Y2hSZW5kZXIpO1xyXG4gICAgICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMuc3RvcEJhdGNoUmVuZGVyKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5vblJlbmRlclF1ZXVlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhci5mcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5hZGRTY3JvbGwodGhpcy5xdWVyeVNjcm9sbCgpKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5vblJlbmRlclF1ZXVlU3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxlbmRhci51cGRhdGVWaWV3U2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wU2Nyb2xsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIudGhhd0NvbnRlbnRIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdGFydEJhdGNoUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMuYmF0Y2hSZW5kZXJEZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLnBhdXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnN0b3BCYXRjaFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISgtLXRoaXMuYmF0Y2hSZW5kZXJEZXB0aCkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5yZXN1bWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdFJlbmRlciA9IGZ1bmN0aW9uIChmdW5jLCBuYW1lc3BhY2UsIGFjdGlvblR5cGUpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLnF1ZXVlKGZ1bmMsIG5hbWVzcGFjZSwgYWN0aW9uVHlwZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gZ2l2ZW4gZnVuYyB3aWxsIGF1dG8tYmluZCB0byBgdGhpc2BcclxuICAgIFZpZXcucHJvdG90eXBlLndoZW5TaXplVXBkYXRlZCA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyUXVldWUuaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUub25lKCdzdG9wJywgZnVuYy5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogVGl0bGUgYW5kIERhdGUgRm9ybWF0dGluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XHJcbiAgICBWaWV3LnByb3RvdHlwZS5jb21wdXRlVGl0bGUgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlO1xyXG4gICAgICAgIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXHJcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRSYW5nZSh7XHJcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNhbGVuZGFyLm1zVG9Nb21lbnQodW56b25lZFJhbmdlLnN0YXJ0TXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpLFxyXG4gICAgICAgICAgICBlbmQ6IHRoaXMuY2FsZW5kYXIubXNUb01vbWVudCh1bnpvbmVkUmFuZ2UuZW5kTXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpXHJcbiAgICAgICAgfSwgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSwgdGhpcy5vcHQoJ3RpdGxlRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpLCB0aGlzLm9wdCgndGl0bGVSYW5nZVNlcGFyYXRvcicpKTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXHJcbiAgICAvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZVRpdGxlRm9ybWF0ID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRSYW5nZVVuaXQgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0O1xyXG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdZWVlZJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ21vbnRoWWVhckZvcm1hdCcpOyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmFzKCdkYXlzJykgPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbGwnOyAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdMTCc7IC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEYXRlIFNldHRpbmcvVW5zZXR0aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUuc2V0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnREYXRlUHJvZmlsZSA9IHRoaXMuZ2V0KCdkYXRlUHJvZmlsZScpO1xyXG4gICAgICAgIHZhciBuZXdEYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoZGF0ZSwgdW5kZWZpbmVkLCB0cnVlKTsgLy8gZm9yY2VUb1ZhbGlkPXRydWVcclxuICAgICAgICBpZiAoIWN1cnJlbnREYXRlUHJvZmlsZSB8fFxyXG4gICAgICAgICAgICAhY3VycmVudERhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lcXVhbHMobmV3RGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldCgnZGF0ZVByb2ZpbGUnLCBuZXdEYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnVuc2V0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdkYXRlUHJvZmlsZScpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERhdGFcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5mZXRjaEluaXRpYWxFdmVudHMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkgJiYgIXRoaXMudXNlc01pbk1heFRpbWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnJlcXVlc3RFdmVudHMoY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZm9yY2VBbGxEYXkpLCBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lbmRNcywgZm9yY2VBbGxEYXkpKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kRXZlbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jYWxlbmRhciwgJ2V2ZW50c1Jlc2V0JywgdGhpcy5yZXNldEV2ZW50cyk7IC8vIFRPRE86IG1ha2UgdGhpcyBhIHJlYWwgZXZlbnRcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bmJpbmRFdmVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5jYWxlbmRhciwgJ2V2ZW50c1Jlc2V0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc2V0RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB0aGlzLnNldCgnY3VycmVudEV2ZW50cycsIGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIHRoaXMuc2V0KCdoYXNFdmVudHMnLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNldEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdjdXJyZW50RXZlbnRzJyk7XHJcbiAgICAgICAgdGhpcy51bnNldCgnaGFzRXZlbnRzJyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVzZXRFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaFJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMudW5zZXRFdmVudHMoKTtcclxuICAgICAgICB0aGlzLnNldEV2ZW50cyhldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB0aGlzLnN0b3BCYXRjaFJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8vIERhdGUgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZURhdGVSZW5kZXIoZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIH0sICdkYXRlJywgJ2luaXQnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RGF0ZVVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZURhdGVVbnJlbmRlcigpO1xyXG4gICAgICAgIH0sICdkYXRlJywgJ2Rlc3Ryb3knKTtcclxuICAgIH07XHJcbiAgICAvLyBpZiBkYXRlUHJvZmlsZSBub3Qgc3BlY2lmaWVkLCB1c2VzIGN1cnJlbnRcclxuICAgIFZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlci5jYWxsKHRoaXMsIGRhdGVQcm9maWxlKTtcclxuICAgICAgICBpZiAodGhpc1sncmVuZGVyJ10pIHtcclxuICAgICAgICAgICAgdGhpc1sncmVuZGVyJ10oKTsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0ZXNSZW5kZXJlZCcpO1xyXG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKHsgaXNEYXRlSW5pdDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm93SW5kaWNhdG9yKCk7IC8vIHNob3VsZG4ndCByZW5kZXIgeWV0IGJlY2F1c2UgdXBkYXRlU2l6ZSB3aWxsIGJlIGNhbGxlZCBzb29uXHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuZXhlY3V0ZURhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgdGhpcy5zdG9wTm93SW5kaWNhdG9yKCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6ZGF0ZXNVbnJlbmRlcmVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXNbJ2Rlc3Ryb3knXSkge1xyXG4gICAgICAgICAgICB0aGlzWydkZXN0cm95J10oKTsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVVbnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8vIFwiQmFzZVwiIHJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLmJpbmRCYXNlUmVuZGVySGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm9uKCdkYXRlc1JlbmRlcmVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy53aGVuU2l6ZVVwZGF0ZWQoX3RoaXMudHJpZ2dlclZpZXdSZW5kZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub24oJ2JlZm9yZTpkYXRlc1VucmVuZGVyZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJWaWV3RGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJWaWV3UmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyVmlld0Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdEZXN0cm95Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RFdmVudHNSZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZUV2ZW50UmVuZGVyKGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgICAgICBfdGhpcy53aGVuU2l6ZVVwZGF0ZWQoX3RoaXMudHJpZ2dlckFmdGVyRXZlbnRzUmVuZGVyZWQpO1xyXG4gICAgICAgIH0sICdldmVudCcsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEV2ZW50c1VucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlckJlZm9yZUV2ZW50c0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgICAgICBfdGhpcy5leGVjdXRlRXZlbnRVbnJlbmRlcigpO1xyXG4gICAgICAgIH0sICdldmVudCcsICdkZXN0cm95Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVzaW5lc3MgSG91ciBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RCdXNpbmVzc0hvdXJzUmVuZGVyID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyQnVzaW5lc3NIb3VycyhidXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgIH0sICdidXNpbmVzc0hvdXJzJywgJ2luaXQnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1VucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XHJcbiAgICAgICAgfSwgJ2J1c2luZXNzSG91cnMnLCAnZGVzdHJveScpO1xyXG4gICAgfTtcclxuICAgIC8vIE1pc2MgdmlldyByZW5kZXJpbmcgdXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBCaW5kcyBET00gaGFuZGxlcnMgdG8gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgdmlldyBjb250YWluZXIsIHN1Y2ggYXMgdGhlIGRvY3VtZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLCB7XHJcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMucHJvY2Vzc1Vuc2VsZWN0LFxyXG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd25cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBVbmJpbmRzIERPTSBoYW5kbGVycyBmcm9tIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyXHJcbiAgICBWaWV3LnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkpO1xyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBJbW1lZGlhdGVseSByZW5kZXIgdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYW5kIGJlZ2lucyByZS1yZW5kZXJpbmcgaXQgYXQgYW4gaW50ZXJ2YWwsXHJcbiAgICAvLyB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpLlxyXG4gICAgLy8gVE9ETzogc29tZWhvdyBkbyB0aGlzIGZvciB0aGUgY3VycmVudCB3aG9sZSBkYXkncyBiYWNrZ3JvdW5kIHRvb1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RhcnROb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdW5pdDtcclxuICAgICAgICB2YXIgdXBkYXRlO1xyXG4gICAgICAgIHZhciBkZWxheTsgLy8gbXMgd2FpdCB2YWx1ZVxyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnbm93SW5kaWNhdG9yJykpIHtcclxuICAgICAgICAgICAgdW5pdCA9IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xyXG4gICAgICAgICAgICBpZiAodW5pdCkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlID0gdXRpbF8xLnByb3h5KHRoaXMsICd1cGRhdGVOb3dJbmRpY2F0b3InKTsgLy8gYmluZCB0byBgdGhpc2BcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSB0aGlzLmNhbGVuZGFyLmdldE5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5pbml0aWFsTm93RGF0ZS5jbG9uZSgpLnN0YXJ0T2YodW5pdCkuYWRkKDEsIHVuaXQpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd0RhdGUudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gK21vbWVudC5kdXJhdGlvbigxLCB1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IE1hdGgubWF4KDEwMCwgZGVsYXkpOyAvLyBwcmV2ZW50IHRvbyBmcmVxdWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGUsIGRlbGF5KTsgLy8gdXBkYXRlIGV2ZXJ5IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nIHdpbGwgYmUgaW5pdGlhdGVkIGluIHVwZGF0ZVNpemVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gcmVyZW5kZXJzIHRoZSBub3cgaW5kaWNhdG9yLCBjb21wdXRpbmcgdGhlIG5ldyBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgcGFzc2VkXHJcbiAgICAvLyBzaW5jZSB0aGUgaW5pdGlhbCBnZXROb3cgY2FsbC5cclxuICAgIFZpZXcucHJvdG90eXBlLnVwZGF0ZU5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93RGF0ZSAvLyBhY3RpdmF0ZWQgYmVmb3JlP1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7IC8vIHdvbid0IHVucmVuZGVyIGlmIHVubmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5hZGQobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMpIC8vIGFkZCBtc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBJbW1lZGlhdGVseSB1bnJlbmRlcnMgdGhlIHZpZXcncyBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBzdG9wcyBhbnkgcmUtcmVuZGVyaW5nIHRpbWVycy5cclxuICAgIC8vIFdvbid0IGNhdXNlIHNpZGUgZWZmZWN0cyBpZiBpbmRpY2F0b3IgaXNuJ3QgcmVuZGVyZWQuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdG9wTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpO1xyXG4gICAgICAgICAgICB0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRGltZW5zaW9uc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICBpZiAodGhpc1snc2V0SGVpZ2h0J10pIHtcclxuICAgICAgICAgICAgdGhpc1snc2V0SGVpZ2h0J10odG90YWxIZWlnaHQsIGlzQXV0byk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTm93SW5kaWNhdG9yKCk7XHJcbiAgICB9O1xyXG4gICAgLyogU2Nyb2xsZXJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5hZGRTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgdmFyIHF1ZXVlZFNjcm9sbCA9IHRoaXMucXVldWVkU2Nyb2xsIHx8ICh0aGlzLnF1ZXVlZFNjcm9sbCA9IHt9KTtcclxuICAgICAgICAkLmV4dGVuZChxdWV1ZWRTY3JvbGwsIHNjcm9sbCk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucG9wU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXBwbHlRdWV1ZWRTY3JvbGwoKTtcclxuICAgICAgICB0aGlzLnF1ZXVlZFNjcm9sbCA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYXBwbHlRdWV1ZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucXVldWVkU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTY3JvbGwodGhpcy5xdWV1ZWRTY3JvbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5xdWVyeVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHNjcm9sbCwgdGhpcy5xdWVyeURhdGVTY3JvbGwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY3JvbGw7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYXBwbHlTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbC5pc0RhdGVJbml0ICYmIHRoaXMuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHNjcm9sbCwgdGhpcy5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGF0ZVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9OyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZy1uLURyb3BcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFdmVudERyb3AgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbiwgZWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB1bmRvRnVuYyA9IGV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnRJbnN0YW5jZS5kZWYuaWQsIGV2ZW50TXV0YXRpb24pO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb24gPSBldmVudE11dGF0aW9uLmRhdGVNdXRhdGlvbjtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIEV2ZW50SW5zdGFuY2UsIGZvciBoYW5kbGVyc1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSA9IGRhdGVNdXRhdGlvbi5idWlsZE5ld0RhdGVQcm9maWxlKGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUsIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudERyb3AoZXZlbnRJbnN0YW5jZSwgXHJcbiAgICAgICAgLy8gYSBkcm9wIGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiBhIGRhdGUgbXV0YXRpb24gKGV4OiByZXNvdXJjZSBjaGFuZ2UpXHJcbiAgICAgICAgKGRhdGVNdXRhdGlvbiAmJiBkYXRlTXV0YXRpb24uZGF0ZURlbHRhKSB8fCBtb21lbnQuZHVyYXRpb24oKSwgdW5kb0Z1bmMsIGVsLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgZXZlbnQtZHJvcCBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckV2ZW50RHJvcCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBkYXRlRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcm9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBlbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZURlbHRhLFxyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogRXh0ZXJuYWwgRWxlbWVudCBEcmFnLW4tRHJvcFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCwgdmlhIGpRdWVyeSBVSSwgaGFzIGJlZW4gZHJvcHBlZCBvbnRvIHRoZSBjYWxlbmRhci5cclxuICAgIC8vIGBtZXRhYCBpcyB0aGUgcGFyc2VkIGRhdGEgdGhhdCBoYXMgYmVlbiBlbWJlZGRlZCBpbnRvIHRoZSBkcmFnZ2luZyBldmVudC5cclxuICAgIC8vIGBkcm9wTG9jYXRpb25gIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgem9uZWQgc3RhcnQvZW5kL2FsbERheSB2YWx1ZXMgZm9yIHRoZSBldmVudC5cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydEV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChzaW5nbGVFdmVudERlZiwgaXNFdmVudCwgaXNTdGlja3ksIGVsLCBldiwgdWkpIHtcclxuICAgICAgICBpZiAoaXNFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmV2ZW50TWFuYWdlci5hZGRFdmVudERlZihzaW5nbGVFdmVudERlZiwgaXNTdGlja3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXJFeHRlcm5hbERyb3Aoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGVsLCBldiwgdWkpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV4dGVybmFsLWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJFeHRlcm5hbERyb3AgPSBmdW5jdGlvbiAoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGVsLCBldiwgdWkpIHtcclxuICAgICAgICAvLyB0cmlnZ2VyICdkcm9wJyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgZWxlbWVudCByZXByZXNlbnRzIGFuIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2Ryb3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZi5kYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB1aSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0V2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHNpZ25hbCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYuYnVpbGRJbnN0YW5jZSgpLnRvTGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVzaXppbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGluIHRoZSB2aWV3IGhhcyBiZWVuIHJlc2l6ZWQgdG8gYSBuZXcgbGVuZ3RoXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBldmVudE11dGF0aW9uLCBlbCwgZXYpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5jYWxlbmRhci5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHVuZG9GdW5jID0gZXZlbnRNYW5hZ2VyLm11dGF0ZUV2ZW50c1dpdGhJZChldmVudEluc3RhbmNlLmRlZi5pZCwgZXZlbnRNdXRhdGlvbik7XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBFdmVudEluc3RhbmNlLCBmb3IgaGFuZGxlcnNcclxuICAgICAgICBldmVudEluc3RhbmNlLmRhdGVQcm9maWxlID0gZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudFJlc2l6ZShldmVudEluc3RhbmNlLCBldmVudE11dGF0aW9uLmRhdGVNdXRhdGlvbi5lbmREZWx0YSwgdW5kb0Z1bmMsIGVsLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgZXZlbnQtcmVzaXplIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGVsLCBldikge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uRGVsdGEsXHJcbiAgICAgICAgICAgICAgICB1bmRvRnVuYyxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiBTZWxlY3Rpb24gKHRpbWUgcmFuZ2UpXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gU2VsZWN0cyBhIGRhdGUgc3BhbiBvbiB0aGUgdmlldy4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIGJvdGggTW9tZW50cy5cclxuICAgIC8vIGBldmAgaXMgdGhlIG5hdGl2ZSBtb3VzZSBldmVudCB0aGF0IGJlZ2luIHRoZSBpbnRlcmFjdGlvbi5cclxuICAgIFZpZXcucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGV2KSB7XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdChldik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoZm9vdHByaW50KTtcclxuICAgICAgICB0aGlzLnJlcG9ydFNlbGVjdGlvbihmb290cHJpbnQsIGV2KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoZm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3JlbmRlclNlbGVjdGlvbiddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlclNlbGVjdGlvbiddKGZvb3RwcmludC50b0xlZ2FjeSh0aGlzLmNhbGVuZGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludC5jYWxsKHRoaXMsIGZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBtYWRlLiBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJTZWxlY3QoZm9vdHByaW50LCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgaGFuZGxlcnMgdG8gJ3NlbGVjdCdcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJTZWxlY3QgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY2FsZW5kYXIuZm9vdHByaW50VG9EYXRlUHJvZmlsZShmb290cHJpbnQpOyAvLyBhYnVzZSBvZiBcIkV2ZW50XCJEYXRlUHJvZmlsZT9cclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignc2VsZWN0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZS5zdGFydCxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLmVuZCxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5kb2VzIGEgc2VsZWN0aW9uLiB1cGRhdGVzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXHJcbiAgICAvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdhbiB0aGUgaW50ZXJhY3Rpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzWydkZXN0cm95U2VsZWN0aW9uJ10pIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbJ2Rlc3Ryb3lTZWxlY3Rpb24nXSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVucmVuZGVyU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd1bnNlbGVjdCcsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbZXYsIHRoaXNdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZWxlY3RFdmVudEluc3RhbmNlID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlICE9PSBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RFdmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlID09PSBldmVudEluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlID0gZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZWxlY3RFdmVudEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuaXNFdmVudERlZlNlbGVjdGVkID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgLy8gZXZlbnQgcmVmZXJlbmNlcyBtaWdodCBjaGFuZ2Ugb24gcmVmZXRjaEV2ZW50cygpLCB3aGlsZSBzZWxlY3RlZEV2ZW50SW5zdGFuY2UgZG9lc24ndCxcclxuICAgICAgICAvLyBzbyBjb21wYXJlIElEc1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSAmJiB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZS5kZWYuaWQgPT09IGV2ZW50RGVmLmlkO1xyXG4gICAgfTtcclxuICAgIC8qIE1vdXNlIC8gVG91Y2ggVW5zZWxlY3RpbmcgKHRpbWUgcmFuZ2UgJiBldmVudCB1bnNlbGVjdGlvbilcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBUT0RPOiBtb3ZlIGNvbnNpc3RlbnRseSB0byBkb3duL3N0YXJ0IG9yIHVwL2VuZD9cclxuICAgIC8vIFRPRE86IGRvbid0IGtpbGwgcHJldmlvdXMgc2VsZWN0aW9uIGlmIHRvdWNoIHNjcm9sbGluZ1xyXG4gICAgVmlldy5wcm90b3R5cGUuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodXRpbF8xLmlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NVbnNlbGVjdChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnByb2Nlc3NVbnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1JhbmdlVW5zZWxlY3QoZXYpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50VW5zZWxlY3QoZXYpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnByb2Nlc3NSYW5nZVVuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGlnbm9yZTtcclxuICAgICAgICAvLyBpcyB0aGVyZSBhIHRpbWUtcmFuZ2Ugc2VsZWN0aW9uP1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQgJiYgdGhpcy5vcHQoJ3Vuc2VsZWN0QXV0bycpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgdW5zZWxlY3QgaWYgdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBub3QgaWRlbnRpY2FsIHRvIG9yIGluc2lkZSBvZiBhbiAndW5zZWxlY3RDYW5jZWwnIGVsZW1lbnRcclxuICAgICAgICAgICAgaWdub3JlID0gdGhpcy5vcHQoJ3Vuc2VsZWN0Q2FuY2VsJyk7XHJcbiAgICAgICAgICAgIGlmICghaWdub3JlIHx8ICEkKGV2LnRhcmdldCkuY2xvc2VzdChpZ25vcmUpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdChldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucHJvY2Vzc0V2ZW50VW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnLmZjLXNlbGVjdGVkJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0RXZlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFRyaWdnZXJzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckJhc2VSZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1JlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckJhc2VVbnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3RGVzdHJveScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgaGFuZGxlcnMgdG8gJ2RheUNsaWNrJ1xyXG4gICAgLy8gU3BhbiBoYXMgc3RhcnQvZW5kIG9mIHRoZSBjbGlja2VkIGFyZWEuIE9ubHkgdGhlIHN0YXJ0IGlzIHVzZWZ1bC5cclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJEYXlDbGljayA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGRheUVsLCBldikge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY2FsZW5kYXIuZm9vdHByaW50VG9EYXRlUHJvZmlsZShmb290cHJpbnQpOyAvLyBhYnVzZSBvZiBcIkV2ZW50XCJEYXRlUHJvZmlsZT9cclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5Q2xpY2snLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGRheUVsLFxyXG4gICAgICAgICAgICBhcmdzOiBbZGF0ZVByb2ZpbGUuc3RhcnQsIGV2LCB0aGlzXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgVXRpbHNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBGb3IgRGF0ZUNvbXBvbmVudDo6Z2V0RGF5Q2xhc3Nlc1xyXG4gICAgVmlldy5wcm90b3R5cGUuaXNEYXRlSW5PdGhlck1vbnRoID0gZnVuY3Rpb24gKGRhdGUsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIEFyZ3VtZW50cyBhZnRlciBuYW1lIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGEgaHlwb3RoZXRpY2FsIGZ1bmN0aW9uIHZhbHVlXHJcbiAgICAvLyBXQVJOSU5HOiBwYXNzZWQtaW4gYXJndW1lbnRzIHdpbGwgYmUgZ2l2ZW4gdG8gZ2VuZXJhdG9yIGZ1bmN0aW9ucyBhcy1pcyBhbmQgY2FuIGNhdXNlIHNpZGUtZWZmZWN0cy5cclxuICAgIC8vIEFsd2F5cyBjbG9uZSB5b3VyIG9iamVjdHMgaWYgeW91IGZlYXIgbXV0YXRpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS5nZXRVbnpvbmVkUmFuZ2VPcHRpb24gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLm9wdChuYW1lKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YWwgPSB2YWwuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIucGFyc2VVbnpvbmVkUmFuZ2UodmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogSGlkZGVuIERheXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pbml0SGlkZGVuRGF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGlkZGVuRGF5cyA9IHRoaXMub3B0KCdoaWRkZW5EYXlzJykgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXHJcbiAgICAgICAgdmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXHJcbiAgICAgICAgdmFyIGRheUNudCA9IDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCd3ZWVrZW5kcycpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gJC5pbkFycmF5KGksIGhpZGRlbkRheXMpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIGRheUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGF5Q250KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJyk7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXHJcbiAgICAvLyBJZiB0aGUgd2hvbGUgcmFuZ2UgaXMgdHJpbW1lZCBvZmYsIHJldHVybnMgbnVsbFxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAoaW5wdXRVbnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBpbnB1dFVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBlbmQgPSBpbnB1dFVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICBpZiAoc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cclxuICAgIC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgTW9tZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5pc0hpZGRlbkRheSA9IGZ1bmN0aW9uIChkYXkpIHtcclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGRheSkpIHtcclxuICAgICAgICAgICAgZGF5ID0gZGF5LmRheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcclxuICAgIH07XHJcbiAgICAvLyBJbmNyZW1lbnRpbmcgdGhlIGN1cnJlbnQgZGF5IHVudGlsIGl0IGlzIG5vIGxvbmdlciBhIGhpZGRlbiBkYXksIHJldHVybmluZyBhIGNvcHkuXHJcbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFVuem9uZWRSYW5nZSFcclxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXHJcbiAgICAvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxyXG4gICAgVmlldy5wcm90b3R5cGUuc2tpcEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIGlmIChpbmMgPT09IHZvaWQgMCkgeyBpbmMgPSAxOyB9XHJcbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlID09PSB2b2lkIDApIHsgaXNFeGNsdXNpdmUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBvdXQgPSBkYXRlLmNsb25lKCk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNIaWRkZW5EYXlIYXNoWyhvdXQuZGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcclxuICAgICAgICAgICAgb3V0LmFkZChpbmMsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZpZXc7XHJcbn0oSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBWaWV3O1xyXG5WaWV3LnByb3RvdHlwZS51c2VzTWluTWF4VGltZSA9IGZhbHNlO1xyXG5WaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG5WaWV3LndhdGNoKCdkaXNwbGF5aW5nRGF0ZXMnLCBbJ2lzSW5Eb20nLCAnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHRoaXMucmVxdWVzdERhdGVSZW5kZXIoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdERhdGVVbnJlbmRlcigpO1xyXG59KTtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0J1c2luZXNzSG91cnMnLCBbJ2Rpc3BsYXlpbmdEYXRlcycsICdidXNpbmVzc0hvdXJHZW5lcmF0b3InXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHRoaXMucmVxdWVzdEJ1c2luZXNzSG91cnNSZW5kZXIoZGVwcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RCdXNpbmVzc0hvdXJzVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2luaXRpYWxFdmVudHMnLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mZXRjaEluaXRpYWxFdmVudHMoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdiaW5kaW5nRXZlbnRzJywgWydpbml0aWFsRXZlbnRzJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnNldEV2ZW50cyhkZXBzLmluaXRpYWxFdmVudHMpO1xyXG4gICAgdGhpcy5iaW5kRXZlbnRDaGFuZ2VzKCk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudW5iaW5kRXZlbnRDaGFuZ2VzKCk7XHJcbiAgICB0aGlzLnVuc2V0RXZlbnRzKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdkaXNwbGF5aW5nRXZlbnRzJywgWydkaXNwbGF5aW5nRGF0ZXMnLCAnaGFzRXZlbnRzJ10sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdEV2ZW50c1JlbmRlcih0aGlzLmdldCgnY3VycmVudEV2ZW50cycpKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0RXZlbnRzVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ3RpdGxlJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgcmV0dXJuICh0aGlzLnRpdGxlID0gdGhpcy5jb21wdXRlVGl0bGUoZGVwcy5kYXRlUHJvZmlsZSkpOyAvLyBhc3NpZ24gdG8gVmlldyBmb3IgbGVnYWN5IHJlYXNvbnNcclxufSk7XHJcblZpZXcud2F0Y2goJ2xlZ2FjeURhdGVQcm9wcycsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICB2YXIgZGF0ZVByb2ZpbGUgPSBkZXBzLmRhdGVQcm9maWxlO1xyXG4gICAgLy8gREVQUkVDQVRFRCwgYnV0IHdlIG5lZWQgdG8ga2VlcCBpdCB1cGRhdGVkLi4uXHJcbiAgICB0aGlzLnN0YXJ0ID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmVuZCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxuICAgIHRoaXMuaW50ZXJ2YWxTdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxuICAgIHRoaXMuaW50ZXJ2YWxFbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2UuZW5kTXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UmVuZGVyZXIoY29tcG9uZW50LCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBjb21wb25lbnQuX2dldFZpZXcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZpbGxSZW5kZXJlciA9IGZpbGxSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB2YWx1ZXMgdGhhdCByZWx5IG9uIG9wdGlvbnMgYW5kIGFsc28gcmVsYXRlIHRvIHJhbmdlXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yYW5nZVVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlFdmVudEVuZDtcclxuICAgICAgICB0aGlzLmV2ZW50VGltZUZvcm1hdCA9XHJcbiAgICAgICAgICAgIHRoaXMub3B0KCdldmVudFRpbWVGb3JtYXQnKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHQoJ3RpbWVGb3JtYXQnKSB8fCAvLyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQoKTtcclxuICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5vcHQoJ2Rpc3BsYXlFdmVudFRpbWUnKTtcclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSB0aGlzLm9wdCgnZGlzcGxheUV2ZW50RW5kJyk7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudEVuZCgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5RXZlbnRUaW1lID0gZGlzcGxheUV2ZW50VGltZTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlFdmVudEVuZCA9IGRpc3BsYXlFdmVudEVuZDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY29tcG9uZW50Ll9nZXREYXRlUHJvZmlsZSgpO1xyXG4gICAgICAgIHZhciBldmVudERlZklkO1xyXG4gICAgICAgIHZhciBpbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgIHZhciBldmVudFJhbmdlcztcclxuICAgICAgICB2YXIgYmdSYW5nZXMgPSBbXTtcclxuICAgICAgICB2YXIgZmdSYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGV2ZW50RGVmSWQgaW4gZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZUdyb3VwID0gZXZlbnRzUGF5bG9hZFtldmVudERlZklkXTtcclxuICAgICAgICAgICAgZXZlbnRSYW5nZXMgPSBpbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCkuaGFzQmdSZW5kZXJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaC5hcHBseShiZ1JhbmdlcywgZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmdSYW5nZXMucHVzaC5hcHBseShmZ1JhbmdlcywgZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyQmdSYW5nZXMoYmdSYW5nZXMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRmdSYW5nZXMoZmdSYW5nZXMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJCZ1JhbmdlcygpO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJGZ1JhbmdlcygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgLy8gcmVuZGVyIGFuIGAuZWxgIG9uIGVhY2ggc2VnXHJcbiAgICAgICAgLy8gcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgc2Vncy4gc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcclxuICAgICAgICBzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJGZ1NlZ3Moc2VncykgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmdTZWdzID0gc2VncztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJGZ1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRmdTZWdzKHRoaXMuZmdTZWdzIHx8IFtdKTtcclxuICAgICAgICB0aGlzLmZnU2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmdSYW5nZXMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5jb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudC5ldmVudEZvb3RwcmludHNUb1NlZ3MoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJCZ1NlZ3Moc2VncykgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmdTZWdzID0gc2VncztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJCZ1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQmdTZWdzKCk7XHJcbiAgICAgICAgdGhpcy5iZ1NlZ3MgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJnU2VncyB8fCBbXSkuY29uY2F0KHRoaXMuZmdTZWdzIHx8IFtdKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gc2VncyBhbHJlYWR5IGhhcyByZW5kZXJlZCBlbHMsIGFuZCBoYXMgYmVlbiBmaWx0ZXJlZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHNpZ25hbCBmYWlsdXJlIGlmIG5vdCBpbXBsZW1lbnRlZFxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgc2VnbWVudHNcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci5yZW5kZXJTZWdzKCdiZ0V2ZW50Jywgc2Vncywge1xyXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRCZ0NsYXNzZXMoc2VnLmZvb3RwcmludC5ldmVudERlZik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0Q3NzOiBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBfdGhpcy5nZXRCZ0NvbG9yKHNlZy5mb290cHJpbnQuZXZlbnREZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJFbDogZnVuY3Rpb24gKHNlZywgZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmlsdGVyRXZlbnRSZW5kZXJFbChzZWcuZm9vdHByaW50LCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaWduYWwgZmFpbHVyZSBpZiBubyBmaWxsUmVuZGVyZXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJCZ1NlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdiZ0V2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ0VscyA9IGZ1bmN0aW9uIChzZWdzLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkaXNhYmxlUmVzaXppbmcgPT09IHZvaWQgMCkgeyBkaXNhYmxlUmVzaXppbmcgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBoYXNFdmVudFJlbmRlckhhbmRsZXJzID0gdGhpcy52aWV3Lmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudFJlbmRlcicpO1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkU2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBidWlsZCBhIGxhcmdlIGNvbmNhdGVuYXRpb24gb2YgZXZlbnQgc2VnbWVudCBIVE1MXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJlZm9yZUZnU2VnSHRtbChzZWdzW2ldKTtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5mZ1NlZ0h0bWwoc2Vnc1tpXSwgZGlzYWJsZVJlc2l6aW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHcmFiIGluZGl2aWR1YWwgZWxlbWVudHMgZnJvbSB0aGUgY29tYmluZWQgSFRNTCBzdHJpbmcuIFVzZSBlYWNoIGFzIHRoZSBkZWZhdWx0IHJlbmRlcmluZy5cclxuICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LiBBbiBlbCBtaWdodCBiZSBudWxsIGlmIHRoZSBldmVudFJlbmRlciBjYWxsYmFjayByZXR1cm5lZCBmYWxzZS5cclxuICAgICAgICAgICAgJChodG1sKS5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXZlbnRSZW5kZXJIYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gX3RoaXMuZmlsdGVyRXZlbnRSZW5kZXJFbChzZWcuZm9vdHByaW50LCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdmYy1zZWcnLCBzZWcpOyAvLyB1c2VkIGJ5IGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZFNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYmVmb3JlRmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LiBVc2VkIGJ5IHJlbmRlckZnU2VnRWxzKClcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyaWMgdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB0aGUgSFRNTCBjbGFzc05hbWVzIGZvciBhbiBldmVudCBzZWdtZW50J3MgZWxlbWVudFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2VnQ2xhc3NlcyA9IGZ1bmN0aW9uIChzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZSkge1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gW1xyXG4gICAgICAgICAgICAnZmMtZXZlbnQnLFxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCA/ICdmYy1zdGFydCcgOiAnZmMtbm90LXN0YXJ0JyxcclxuICAgICAgICAgICAgc2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcclxuICAgICAgICBdLmNvbmNhdCh0aGlzLmdldENsYXNzZXMoc2VnLmZvb3RwcmludC5ldmVudERlZikpO1xyXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWRyYWdnYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZXNpemFibGUpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1yZXNpemFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXZlbnQgaXMgY3VycmVudGx5IHNlbGVjdGVkPyBhdHRhY2ggYSBjbGFzc05hbWUuXHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBldmVudCBhbmQgdGhlIGRlZmF1bHQgZWxlbWVudCB1c2VkIGZvciByZW5kZXJpbmcsIHJldHVybnMgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYWN0dWFsbHkgYmUgdXNlZC5cclxuICAgIC8vIEJhc2ljYWxseSBydW5zIGV2ZW50cyBhbmQgZWxlbWVudHMgdGhyb3VnaCB0aGUgZXZlbnRSZW5kZXIgaG9vay5cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZpbHRlckV2ZW50UmVuZGVyRWwgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnQsIGVsKSB7XHJcbiAgICAgICAgdmFyIGxlZ2FjeSA9IGV2ZW50Rm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgdmFyIGN1c3RvbSA9IHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIGVsLCB0aGlzLnZpZXddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGN1c3RvbSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdXN0b20gJiYgY3VzdG9tICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGVsID0gJChjdXN0b20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZSB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gYW4gZXZlbnQncyBlbGVtZW50LlxyXG4gICAgLy8gYHJhbmdlYCBjYW4gYmUgdGhlIEV2ZW50IG9iamVjdCBpdHNlbGYsIG9yIHNvbWV0aGluZyByYW5nZS1saWtlLCB3aXRoIGF0IGxlYXN0IGEgYHN0YXJ0YC5cclxuICAgIC8vIElmIGV2ZW50IHRpbWVzIGFyZSBkaXNhYmxlZCwgb3IgdGhlIGV2ZW50IGhhcyBubyB0aW1lLCB3aWxsIHJldHVybiBhIGJsYW5rIHN0cmluZy5cclxuICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGZvcm1hdFN0ciB3aWxsIGRlZmF1bHQgdG8gdGhlIGV2ZW50VGltZUZvcm1hdCBzZXR0aW5nLFxyXG4gICAgLy8gYW5kIGRpc3BsYXlFbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBkaXNwbGF5RXZlbnRFbmQgc2V0dGluZy5cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFRpbWVUZXh0ID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50LCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGltZVRleHQoZXZlbnRGb290cHJpbnQuZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS5zdGFydCwgZXZlbnRGb290cHJpbnQuZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS5lbmQsIGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0VGltZVRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgaXNBbGxEYXksIGZvcm1hdFN0ciwgZGlzcGxheUVuZCkge1xyXG4gICAgICAgIGlmIChmb3JtYXRTdHIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JtYXRTdHIgPSB0aGlzLmV2ZW50VGltZUZvcm1hdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RW5kID0gdGhpcy5kaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgJiYgIWlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5RW5kICYmIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5mb3JtYXRSYW5nZSh7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSwgZmFsc2UsIC8vIGFsbERheVxyXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydC5mb3JtYXQoZm9ybWF0U3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0QmdDbGFzc2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLmdldENsYXNzZXMoZXZlbnREZWYpO1xyXG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtYmdldmVudCcpO1xyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldENsYXNzZXMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzLCBvYmpzW2ldLmV2ZW50Q2xhc3NOYW1lIHx8IG9ianNbaV0uY2xhc3NOYW1lIHx8IFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBldmVudCBza2luLXJlbGF0ZWQgQ1NTIHByb3BlcnRpZXNcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNraW5Dc3MgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuZ2V0QmdDb2xvcihldmVudERlZiksXHJcbiAgICAgICAgICAgICdib3JkZXItY29sb3InOiB0aGlzLmdldEJvcmRlckNvbG9yKGV2ZW50RGVmKSxcclxuICAgICAgICAgICAgY29sb3I6IHRoaXMuZ2V0VGV4dENvbG9yKGV2ZW50RGVmKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJnQ29sb3IgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoICYmICF2YWw7IGkrKykge1xyXG4gICAgICAgICAgICB2YWwgPSBvYmpzW2ldLmV2ZW50QmFja2dyb3VuZENvbG9yIHx8IG9ianNbaV0uZXZlbnRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS5iYWNrZ3JvdW5kQ29sb3IgfHwgb2Jqc1tpXS5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF2YWwpIHtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5vcHQoJ2V2ZW50QmFja2dyb3VuZENvbG9yJykgfHwgdGhpcy5vcHQoJ2V2ZW50Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICAvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0Qm9yZGVyQ29sb3IgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoICYmICF2YWw7IGkrKykge1xyXG4gICAgICAgICAgICB2YWwgPSBvYmpzW2ldLmV2ZW50Qm9yZGVyQ29sb3IgfHwgb2Jqc1tpXS5ldmVudENvbG9yIHx8XHJcbiAgICAgICAgICAgICAgICBvYmpzW2ldLmJvcmRlckNvbG9yIHx8IG9ianNbaV0uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudEJvcmRlckNvbG9yJykgfHwgdGhpcy5vcHQoJ2V2ZW50Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICAvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGV4dENvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudFRleHRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS50ZXh0Q29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudFRleHRDb2xvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFN0eWxpbmdPYmpzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldEZhbGxiYWNrU3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIG9ianMudW5zaGlmdChldmVudERlZik7XHJcbiAgICAgICAgcmV0dXJuIG9ianM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tTdHlsaW5nT2JqcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiBbZXZlbnREZWYuc291cmNlXTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0RXZlbnRTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBzZWdzLnNvcnQodXRpbF8xLnByb3h5KHRoaXMsICdjb21wYXJlRXZlbnRTZWdzJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBzZWdtZW50cyBzaG91bGQgdGFrZSB2aXN1YWwgcHJpb3JpdHlcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXBhcmVFdmVudFNlZ3MgPSBmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xyXG4gICAgICAgIHZhciBmMSA9IHNlZzEuZm9vdHByaW50O1xyXG4gICAgICAgIHZhciBmMiA9IHNlZzIuZm9vdHByaW50O1xyXG4gICAgICAgIHZhciBjZjEgPSBmMS5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGNmMiA9IGYyLmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgcjEgPSBjZjEudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciByMiA9IGNmMi51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgcmV0dXJuIHIxLnN0YXJ0TXMgLSByMi5zdGFydE1zIHx8IC8vIGVhcmxpZXIgZXZlbnRzIGdvIGZpcnN0XHJcbiAgICAgICAgICAgIChyMi5lbmRNcyAtIHIyLnN0YXJ0TXMpIC0gKHIxLmVuZE1zIC0gcjEuc3RhcnRNcykgfHwgLy8gdGllPyBsb25nZXIgZXZlbnRzIGdvIGZpcnN0XHJcbiAgICAgICAgICAgIGNmMi5pc0FsbERheSAtIGNmMS5pc0FsbERheSB8fCAvLyB0aWU/IHB1dCBhbGwtZGF5IGV2ZW50cyBmaXJzdCAoYm9vbGVhbnMgY2FzdCB0byAwLzEpXHJcbiAgICAgICAgICAgIHV0aWxfMS5jb21wYXJlQnlGaWVsZFNwZWNzKGYxLmV2ZW50RGVmLCBmMi5ldmVudERlZiwgdGhpcy52aWV3LmV2ZW50T3JkZXJTcGVjcywgZjEuZXZlbnREZWYubWlzY1Byb3BzLCBmMi5ldmVudERlZi5taXNjUHJvcHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiA0MyAqLyxcbi8qIDQ0ICovLFxuLyogNDUgKi8sXG4vKiA0NiAqLyxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG4vLyBQbHVnaW5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5tb21lbnRfZXh0XzEubmV3TW9tZW50UHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX2Z1bGxDYWxlbmRhciAmJiBhcmd1bWVudHNbMF0pIHtcclxuICAgICAgICByZXR1cm4gZm9ybWF0RGF0ZSh0aGlzLCBhcmd1bWVudHNbMF0pOyAvLyBvdXIgZXh0ZW5kZWQgZm9ybWF0dGluZ1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FtYmlnVGltZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fYW1iaWdab25lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2Z1bGxDYWxlbmRhcikge1xyXG4gICAgICAgIC8vIG1vbWVudC5mb3JtYXQoKSBkb2Vzbid0IGVuc3VyZSBlbmdsaXNoLCBidXQgd2Ugd2FudCB0by5cclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50UHJvdG8uZm9ybWF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbm1vbWVudF9leHRfMS5uZXdNb21lbnRQcm90by50b0lTT1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcclxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gYnJvd3NlciwgbW9tZW50IG1pZ2h0IG5vdCBvdXRwdXQgZW5nbGlzaC4gZW5zdXJlIGVuZ2xpc2guXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvYmxvYi8yLjE4LjEvc3JjL2xpYi9tb21lbnQvZm9ybWF0LmpzI0wyMlxyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50UHJvdG8udG9JU09TdHJpbmcuYXBwbHkoZW5nbGlzaE1vbWVudCh0aGlzKSwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50UHJvdG8udG9JU09TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuZnVuY3Rpb24gZW5nbGlzaE1vbWVudChtb20pIHtcclxuICAgIGlmIChtb20ubG9jYWxlKCkgIT09ICdlbicpIHtcclxuICAgICAgICByZXR1cm4gbW9tLmNsb25lKCkubG9jYWxlKCdlbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vbTtcclxufVxyXG4vLyBDb25maWdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qXHJcbkluc2VydGVkIGJldHdlZW4gY2h1bmtzIGluIHRoZSBmYWtlIChcImludGVybWVkaWF0ZVwiKSBmb3JtYXR0aW5nIHN0cmluZy5cclxuSW1wb3J0YW50IHRoYXQgaXQgcGFzc2VzIGFzIHdoaXRlc3BhY2UgKFxccykgYmVjYXVzZSBtb21lbnQgb2Z0ZW4gaWRlbnRpZmllcyBub24tc3RhbmRhbG9uZSBtb250aHNcclxudmlhIGEgcmVnZXhwIHdpdGggYW4gXFxzLlxyXG4qL1xyXG52YXIgUEFSVF9TRVBBUkFUT1IgPSAnXFx1MDAwYic7IC8vIHZlcnRpY2FsIHRhYlxyXG4vKlxyXG5JbnNlcnRlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGl0ZXJhbC10ZXh0IGNodW5rIHRvIGluZGljYXRlIHRoYXQgdGhlIGxpdGVyYWwgdGV4dCBpcyBub3QgYWN0dWFsbHkgbGl0ZXJhbCB0ZXh0LFxyXG5idXQgcmF0aGVyLCBhIFwic3BlY2lhbFwiIHRva2VuIHRoYXQgaGFzIGN1c3RvbSByZW5kZXJpbmcgKHNlZSBzcGVjaWFsVG9rZW5zIG1hcCkuXHJcbiovXHJcbnZhciBTUEVDSUFMX1RPS0VOX01BUktFUiA9ICdcXHUwMDFmJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDFcclxuLypcclxuSW5zZXJ0ZWQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3BhbiBvZiB0ZXh0IHRoYXQgbXVzdCBoYXZlIG5vbi16ZXJvIG51bWVyaWMgY2hhcmFjdGVycy5cclxuSGFuZGxpbmcgb2YgdGhlc2UgbWFya2VycyBpcyBkb25lIGluIGEgcG9zdC1wcm9jZXNzaW5nIHN0ZXAgYXQgdGhlIHZlcnkgZW5kIG9mIHRleHQgcmVuZGVyaW5nLlxyXG4qL1xyXG52YXIgTUFZQkVfTUFSS0VSID0gJ1xcdTAwMWUnOyAvLyBpbmZvcm1hdGlvbiBzZXBhcmF0b3IgMlxyXG52YXIgTUFZQkVfUkVHRVhQID0gbmV3IFJlZ0V4cChNQVlCRV9NQVJLRVIgKyAnKFteJyArIE1BWUJFX01BUktFUiArICddKiknICsgTUFZQkVfTUFSS0VSLCAnZycpOyAvLyBtdXN0IGJlIGdsb2JhbFxyXG4vKlxyXG5BZGRpdGlvbiBmb3JtYXR0aW5nIHRva2VucyB3ZSB3YW50IHJlY29nbml6ZWRcclxuKi9cclxudmFyIHNwZWNpYWxUb2tlbnMgPSB7XHJcbiAgICB0OiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsICdhJykuY2hhckF0KDApO1xyXG4gICAgfSxcclxuICAgIFQ6IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZGF0ZSwgJ0EnKS5jaGFyQXQoMCk7XHJcbiAgICB9XHJcbn07XHJcbi8qXHJcblRoZSBmaXJzdCBjaGFyYWN0ZXJzIG9mIGZvcm1hdHRpbmcgdG9rZW5zIGZvciB1bml0cyB0aGF0IGFyZSAxIGRheSBvciBsYXJnZXIuXHJcbmB2YWx1ZWAgaXMgZm9yIHJhbmtpbmcgcmVsYXRpdmUgc2l6ZSAobG93ZXIgbWVhbnMgYmlnZ2VyKS5cclxuYHVuaXRgIGlzIGEgbm9ybWFsaXplZCB1bml0LCB1c2VkIGZvciBjb21wYXJpbmcgbW9tZW50cy5cclxuKi9cclxudmFyIGxhcmdlVG9rZW5NYXAgPSB7XHJcbiAgICBZOiB7IHZhbHVlOiAxLCB1bml0OiAneWVhcicgfSxcclxuICAgIE06IHsgdmFsdWU6IDIsIHVuaXQ6ICdtb250aCcgfSxcclxuICAgIFc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LFxyXG4gICAgdzogeyB2YWx1ZTogMywgdW5pdDogJ3dlZWsnIH0sXHJcbiAgICBEOiB7IHZhbHVlOiA0LCB1bml0OiAnZGF5JyB9LFxyXG4gICAgZDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSAvLyBkYXkgb2Ygd2Vla1xyXG59O1xyXG4vLyBTaW5nbGUgRGF0ZSBGb3JtYXR0aW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5Gb3JtYXRzIGBkYXRlYCB3aXRoIGEgTW9tZW50IGZvcm1hdHRpbmcgc3RyaW5nLCBidXQgYWxsb3cgb3VyIG5vbi16ZXJvIGFyZWFzIGFuZCBzcGVjaWFsIHRva2VuXHJcbiovXHJcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gcmVuZGVyRmFrZUZvcm1hdFN0cmluZyhnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKS5mYWtlRm9ybWF0U3RyaW5nLCBkYXRlKTtcclxufVxyXG5leHBvcnRzLmZvcm1hdERhdGUgPSBmb3JtYXREYXRlO1xyXG4vLyBEYXRlIFJhbmdlIEZvcm1hdHRpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBUT0RPOiBtYWtlIGl0IHdvcmsgd2l0aCB0aW1lem9uZSBvZmZzZXRcclxuLypcclxuVXNpbmcgYSBmb3JtYXR0aW5nIHN0cmluZyBtZWFudCBmb3IgYSBzaW5nbGUgZGF0ZSwgZ2VuZXJhdGUgYSByYW5nZSBzdHJpbmcsIGxpa2VcclxuXCJTZXAgMiAtIDkgMjAxM1wiLCB0aGF0IGludGVsbGlnZW50bHkgaW5zZXJ0cyBhIHNlcGFyYXRvciB3aGVyZSB0aGUgZGF0ZXMgZGlmZmVyLlxyXG5JZiB0aGUgZGF0ZXMgYXJlIHRoZSBzYW1lIGFzIGZhciBhcyB0aGUgZm9ybWF0IHN0cmluZyBpcyBjb25jZXJuZWQsIGp1c3QgcmV0dXJuIGEgc2luZ2xlXHJcbnJlbmRlcmluZyBvZiBvbmUgZGF0ZSwgd2l0aG91dCBhbnkgc2VwYXJhdG9yLlxyXG4qL1xyXG5mdW5jdGlvbiBmb3JtYXRSYW5nZShkYXRlMSwgZGF0ZTIsIGZvcm1hdFN0ciwgc2VwYXJhdG9yLCBpc1JUTCkge1xyXG4gICAgdmFyIGxvY2FsZURhdGE7XHJcbiAgICBkYXRlMSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnBhcnNlWm9uZShkYXRlMSk7XHJcbiAgICBkYXRlMiA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnBhcnNlWm9uZShkYXRlMik7XHJcbiAgICBsb2NhbGVEYXRhID0gZGF0ZTEubG9jYWxlRGF0YSgpO1xyXG4gICAgLy8gRXhwYW5kIGxvY2FsaXplZCBmb3JtYXQgc3RyaW5ncywgbGlrZSBcIkxMXCIgLT4gXCJNTU1NIEQgWVlZWVwiLlxyXG4gICAgLy8gQlRXLCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgZm9yIGBmb3JtYXREYXRlYCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgdG8gcHV0IGN1c3RvbSB0b2tlbnNcclxuICAgIC8vIG9yIG5vbi16ZXJvIGFyZWFzIGluIE1vbWVudCdzIGxvY2FsaXplZCBmb3JtYXQgc3RyaW5ncy5cclxuICAgIGZvcm1hdFN0ciA9IGxvY2FsZURhdGEubG9uZ0RhdGVGb3JtYXQoZm9ybWF0U3RyKSB8fCBmb3JtYXRTdHI7XHJcbiAgICByZXR1cm4gcmVuZGVyUGFyc2VkRm9ybWF0KGdldFBhcnNlZEZvcm1hdFN0cmluZyhmb3JtYXRTdHIpLCBkYXRlMSwgZGF0ZTIsIHNlcGFyYXRvciB8fCAnIC0gJywgaXNSVEwpO1xyXG59XHJcbmV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBmb3JtYXRSYW5nZTtcclxuLypcclxuUmVuZGVycyBhIHJhbmdlIHdpdGggYW4gYWxyZWFkeS1wYXJzZWQgZm9ybWF0IHN0cmluZy5cclxuKi9cclxuZnVuY3Rpb24gcmVuZGVyUGFyc2VkRm9ybWF0KHBhcnNlZEZvcm1hdCwgZGF0ZTEsIGRhdGUyLCBzZXBhcmF0b3IsIGlzUlRMKSB7XHJcbiAgICB2YXIgc2FtZVVuaXRzID0gcGFyc2VkRm9ybWF0LnNhbWVVbml0cztcclxuICAgIHZhciB1bnpvbmVkRGF0ZTEgPSBkYXRlMS5jbG9uZSgpLnN0cmlwWm9uZSgpOyAvLyBmb3Igc2FtZS11bml0IGNvbXBhcmlzb25zXHJcbiAgICB2YXIgdW56b25lZERhdGUyID0gZGF0ZTIuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gXCJcclxuICAgIHZhciByZW5kZXJlZFBhcnRzMSA9IHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhwYXJzZWRGb3JtYXQuZmFrZUZvcm1hdFN0cmluZywgZGF0ZTEpO1xyXG4gICAgdmFyIHJlbmRlcmVkUGFydHMyID0gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKHBhcnNlZEZvcm1hdC5mYWtlRm9ybWF0U3RyaW5nLCBkYXRlMik7XHJcbiAgICB2YXIgbGVmdEk7XHJcbiAgICB2YXIgbGVmdFN0ciA9ICcnO1xyXG4gICAgdmFyIHJpZ2h0STtcclxuICAgIHZhciByaWdodFN0ciA9ICcnO1xyXG4gICAgdmFyIG1pZGRsZUk7XHJcbiAgICB2YXIgbWlkZGxlU3RyMSA9ICcnO1xyXG4gICAgdmFyIG1pZGRsZVN0cjIgPSAnJztcclxuICAgIHZhciBtaWRkbGVTdHIgPSAnJztcclxuICAgIC8vIFN0YXJ0IGF0IHRoZSBsZWZ0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgY29udGludWUgdW50aWwgeW91IGhpdCBhIHRva2VuXHJcbiAgICAvLyB0aGF0IGlzIG5vdCB0aGUgc2FtZSBiZXR3ZWVuIGRhdGVzLlxyXG4gICAgZm9yIChsZWZ0SSA9IDA7IGxlZnRJIDwgc2FtZVVuaXRzLmxlbmd0aCAmJiAoIXNhbWVVbml0c1tsZWZ0SV0gfHwgdW56b25lZERhdGUxLmlzU2FtZSh1bnpvbmVkRGF0ZTIsIHNhbWVVbml0c1tsZWZ0SV0pKTsgbGVmdEkrKykge1xyXG4gICAgICAgIGxlZnRTdHIgKz0gcmVuZGVyZWRQYXJ0czFbbGVmdEldO1xyXG4gICAgfVxyXG4gICAgLy8gU2ltaWxhcmx5LCBzdGFydCBhdCB0aGUgcmlnaHRtb3N0IHNpZGUgb2YgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGFuZCBtb3ZlIGxlZnRcclxuICAgIGZvciAocmlnaHRJID0gc2FtZVVuaXRzLmxlbmd0aCAtIDE7IHJpZ2h0SSA+IGxlZnRJICYmICghc2FtZVVuaXRzW3JpZ2h0SV0gfHwgdW56b25lZERhdGUxLmlzU2FtZSh1bnpvbmVkRGF0ZTIsIHNhbWVVbml0c1tyaWdodEldKSk7IHJpZ2h0SS0tKSB7XHJcbiAgICAgICAgLy8gSWYgY3VycmVudCBjaHVuayBpcyBvbiB0aGUgYm91bmRhcnkgb2YgdW5pcXVlIGRhdGUtY29udGVudCwgYW5kIGlzIGEgc3BlY2lhbC1jYXNlXHJcbiAgICAgICAgLy8gZGF0ZS1mb3JtYXR0aW5nIHBvc3RmaXggY2hhcmFjdGVyLCB0aGVuIGRvbid0IGNvbnN1bWUgaXQuIENvbnNpZGVyIGl0IHVuaXF1ZSBkYXRlLWNvbnRlbnQuXHJcbiAgICAgICAgLy8gVE9ETzogbWFrZSBjb25maWd1cmFibGVcclxuICAgICAgICBpZiAocmlnaHRJIC0gMSA9PT0gbGVmdEkgJiYgcmVuZGVyZWRQYXJ0czFbcmlnaHRJXSA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByaWdodFN0ciA9IHJlbmRlcmVkUGFydHMxW3JpZ2h0SV0gKyByaWdodFN0cjtcclxuICAgIH1cclxuICAgIC8vIFRoZSBhcmVhIGluIHRoZSBtaWRkbGUgaXMgZGlmZmVyZW50IGZvciBib3RoIG9mIHRoZSBkYXRlcy5cclxuICAgIC8vIENvbGxlY3QgdGhlbSBkaXN0aW5jdGx5IHNvIHdlIGNhbiBqYW0gdGhlbSB0b2dldGhlciBsYXRlci5cclxuICAgIGZvciAobWlkZGxlSSA9IGxlZnRJOyBtaWRkbGVJIDw9IHJpZ2h0STsgbWlkZGxlSSsrKSB7XHJcbiAgICAgICAgbWlkZGxlU3RyMSArPSByZW5kZXJlZFBhcnRzMVttaWRkbGVJXTtcclxuICAgICAgICBtaWRkbGVTdHIyICs9IHJlbmRlcmVkUGFydHMyW21pZGRsZUldO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pZGRsZVN0cjEgfHwgbWlkZGxlU3RyMikge1xyXG4gICAgICAgIGlmIChpc1JUTCkge1xyXG4gICAgICAgICAgICBtaWRkbGVTdHIgPSBtaWRkbGVTdHIyICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1pZGRsZVN0ciA9IG1pZGRsZVN0cjEgKyBzZXBhcmF0b3IgKyBtaWRkbGVTdHIyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9jZXNzTWF5YmVNYXJrZXJzKGxlZnRTdHIgKyBtaWRkbGVTdHIgKyByaWdodFN0cik7XHJcbn1cclxuLy8gRm9ybWF0IFN0cmluZyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG52YXIgcGFyc2VkRm9ybWF0U3RyQ2FjaGUgPSB7fTtcclxuLypcclxuUmV0dXJucyBhIHBhcnNlZCBmb3JtYXQgc3RyaW5nLCBsZXZlcmFnaW5nIGEgY2FjaGUuXHJcbiovXHJcbmZ1bmN0aW9uIGdldFBhcnNlZEZvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcclxuICAgIHJldHVybiBwYXJzZWRGb3JtYXRTdHJDYWNoZVtmb3JtYXRTdHJdIHx8XHJcbiAgICAgICAgKHBhcnNlZEZvcm1hdFN0ckNhY2hlW2Zvcm1hdFN0cl0gPSBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXRTdHIpKTtcclxufVxyXG4vKlxyXG5QYXJzZXMgYSBmb3JtYXQgc3RyaW5nIGludG8gdGhlIGZvbGxvd2luZzpcclxuLSBmYWtlRm9ybWF0U3RyaW5nOiBhIG1vbWVudEpTIGZvcm1hdHRpbmcgc3RyaW5nLCBsaXR0ZXJlZCB3aXRoIHNwZWNpYWwgY29udHJvbCBjaGFyYWN0ZXJzIHRoYXQgZ2V0IHBvc3QtcHJvY2Vzc2VkLlxyXG4tIHNhbWVVbml0czogZm9yIGV2ZXJ5IHBhcnQgaW4gZmFrZUZvcm1hdFN0cmluZywgaWYgdGhlIHBhcnQgaXMgYSB0b2tlbiwgdGhlIHZhbHVlIHdpbGwgYmUgYSB1bml0IHN0cmluZyAobGlrZSBcImRheVwiKSxcclxuICB0aGF0IGluZGljYXRlcyBob3cgc2ltaWxhciBhIHJhbmdlJ3Mgc3RhcnQgJiBlbmQgbXVzdCBiZSBpbiBvcmRlciB0byBzaGFyZSB0aGUgc2FtZSBmb3JtYXR0ZWQgdGV4dC5cclxuICBJZiBub3QgYSB0b2tlbiwgdGhlbiB0aGUgdmFsdWUgaXMgbnVsbC5cclxuICBBbHdheXMgYSBmbGF0IGFycmF5IChub3QgbmVzdGVkIGxpa2VkIFwiY2h1bmtzXCIpLlxyXG4qL1xyXG5mdW5jdGlvbiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmYWtlRm9ybWF0U3RyaW5nOiBidWlsZEZha2VGb3JtYXRTdHJpbmcoY2h1bmtzKSxcclxuICAgICAgICBzYW1lVW5pdHM6IGJ1aWxkU2FtZVVuaXRzKGNodW5rcylcclxuICAgIH07XHJcbn1cclxuLypcclxuQnJlYWsgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgY2h1bmtzLlxyXG5BICdtYXliZScgY2h1bmsgd2lsbCBoYXZlIG5lc3RlZCBjaHVua3MuXHJcbiovXHJcbmZ1bmN0aW9uIGNodW5rRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikge1xyXG4gICAgdmFyIGNodW5rcyA9IFtdO1xyXG4gICAgdmFyIG1hdGNoO1xyXG4gICAgLy8gVE9ETzogbW9yZSBkZXNjcmltaW5hdGlvblxyXG4gICAgLy8gXFw0IGlzIGEgYmFja3JlZmVyZW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbXVsdGktY2hhcmFjdGVyIHNldC5cclxuICAgIHZhciBjaHVua2VyID0gL1xcWyhbXlxcXV0qKVxcXXxcXCgoW15cXCldKilcXCl8KExUU3xMVHwoXFx3KVxcNCpvPyl8KFteXFx3XFxbXFwoXSspL2c7XHJcbiAgICB3aGlsZSAoKG1hdGNoID0gY2h1bmtlci5leGVjKGZvcm1hdFN0cikpKSB7XHJcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoLmFwcGx5KGNodW5rcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIHNwbGl0U3RyaW5nTGl0ZXJhbChtYXRjaFsxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCh7IG1heWJlOiBjaHVua0Zvcm1hdFN0cmluZyhtYXRjaFsyXSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzNdKSB7XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHsgdG9rZW46IG1hdGNoWzNdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFs1XSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaC5hcHBseShjaHVua3MsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBzcGxpdFN0cmluZ0xpdGVyYWwobWF0Y2hbNV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2h1bmtzO1xyXG59XHJcbi8qXHJcblBvdGVudGlhbGx5IHNwbGl0cyBhIGxpdGVyYWwtdGV4dCBzdHJpbmcgaW50byBtdWx0aXBsZSBwYXJ0cy4gRm9yIHNwZWNpYWwgY2FzZXMuXHJcbiovXHJcbmZ1bmN0aW9uIHNwbGl0U3RyaW5nTGl0ZXJhbChzKSB7XHJcbiAgICBpZiAocyA9PT0gJy4gJykge1xyXG4gICAgICAgIHJldHVybiBbJy4nLCAnICddOyAvLyBmb3IgbG9jYWxlcyB3aXRoIHBlcmlvZHMgYm91bmQgdG8gdGhlIGVuZCBvZiBlYWNoIHllYXIvbW9udGgvZGF0ZVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtzXTtcclxuICAgIH1cclxufVxyXG4vKlxyXG5HaXZlbiBjaHVua3MgcGFyc2VkIGZyb20gYSByZWFsIGZvcm1hdCBzdHJpbmcsIGdlbmVyYXRlIGEgZmFrZSAoYWthIFwiaW50ZXJtZWRpYXRlXCIpIGZvcm1hdCBzdHJpbmcgd2l0aCBzcGVjaWFsIGNvbnRyb2xcclxuY2hhcmFjdGVycyB0aGF0IHdpbGwgZXZlbnR1YWxseSBiZSBnaXZlbiB0byBtb21lbnQgZm9yIGZvcm1hdHRpbmcsIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2VkLlxyXG4qL1xyXG5mdW5jdGlvbiBidWlsZEZha2VGb3JtYXRTdHJpbmcoY2h1bmtzKSB7XHJcbiAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGNodW5rO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ1snICsgY2h1bmsgKyAnXScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuay50b2tlbikge1xyXG4gICAgICAgICAgICBpZiAoY2h1bmsudG9rZW4gaW4gc3BlY2lhbFRva2Vucykge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChTUEVDSUFMX1RPS0VOX01BUktFUiArIC8vIHVzZWZ1bCBkdXJpbmcgcG9zdC1wcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgY2h1bmsudG9rZW4gKyAnXScgLy8gcHJlc2VydmUgYXMgbGl0ZXJhbCB0ZXh0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjaHVuay50b2tlbik7IC8vIHVucHJvdGVjdGVkIHRleHQgaW1wbGllcyBhIGZvcm1hdCBzdHJpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuay5tYXliZSkge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKE1BWUJFX01BUktFUiArIC8vIHVzZWZ1bCBkdXJpbmcgcG9zdC1wcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICBidWlsZEZha2VGb3JtYXRTdHJpbmcoY2h1bmsubWF5YmUpICtcclxuICAgICAgICAgICAgICAgIE1BWUJFX01BUktFUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oUEFSVF9TRVBBUkFUT1IpO1xyXG59XHJcbi8qXHJcbkdpdmVuIHBhcnNlZCBjaHVua3MgZnJvbSBhIHJlYWwgZm9ybWF0dGluZyBzdHJpbmcsIGdlbmVyYXRlcyBhbiBhcnJheSBvZiB1bml0IHN0cmluZ3MgKGxpa2UgXCJkYXlcIikgdGhhdCBpbmRpY2F0ZVxyXG5pbiB3aGljaCByZWdhcmQgdHdvIGRhdGVzIG11c3QgYmUgc2ltaWxhciBpbiBvcmRlciB0byBzaGFyZSByYW5nZSBmb3JtYXR0aW5nIHRleHQuXHJcblRoZSBgY2h1bmtzYCBjYW4gYmUgbmVzdGVkIChiZWNhdXNlIG9mIFwibWF5YmVcIiBjaHVua3MpLCBob3dldmVyLCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBiZSBmbGF0LlxyXG4qL1xyXG5mdW5jdGlvbiBidWlsZFNhbWVVbml0cyhjaHVua3MpIHtcclxuICAgIHZhciB1bml0cyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY2h1bms7XHJcbiAgICB2YXIgdG9rZW5JbmZvO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgIGlmIChjaHVuay50b2tlbikge1xyXG4gICAgICAgICAgICB0b2tlbkluZm8gPSBsYXJnZVRva2VuTWFwW2NodW5rLnRva2VuLmNoYXJBdCgwKV07XHJcbiAgICAgICAgICAgIHVuaXRzLnB1c2godG9rZW5JbmZvID8gdG9rZW5JbmZvLnVuaXQgOiAnc2Vjb25kJyk7IC8vIGRlZmF1bHQgdG8gYSB2ZXJ5IHN0cmljdCBzYW1lLXNlY29uZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuay5tYXliZSkge1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoLmFwcGx5KHVuaXRzLCAvLyBhcHBlbmRcclxuICAgICAgICAgICAgYnVpbGRTYW1lVW5pdHMoY2h1bmsubWF5YmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXRzO1xyXG59XHJcbi8vIFJlbmRlcmluZyB0byB0ZXh0XHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5Gb3JtYXRzIGEgZGF0ZSB3aXRoIGEgZmFrZSBmb3JtYXQgc3RyaW5nLCBwb3N0LXByb2Nlc3NlcyB0aGUgY29udHJvbCBjaGFyYWN0ZXJzLCB0aGVuIHJldHVybnMuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NNYXliZU1hcmtlcnMocmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpLmpvaW4oJycpKTtcclxufVxyXG4vKlxyXG5Gb3JtYXRzIGEgZGF0ZSBpbnRvIHBhcnRzIHRoYXQgd2lsbCBoYXZlIGJlZW4gcG9zdC1wcm9jZXNzZWQsIEVYQ0VQVCBmb3IgdGhlIFwibWF5YmVcIiBtYXJrZXJzLlxyXG4qL1xyXG5mdW5jdGlvbiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICB2YXIgZmFrZVJlbmRlciA9IG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZGF0ZSwgZmFrZUZvcm1hdFN0cmluZyk7XHJcbiAgICB2YXIgZmFrZVBhcnRzID0gZmFrZVJlbmRlci5zcGxpdChQQVJUX1NFUEFSQVRPUik7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBmYWtlUGFydDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBmYWtlUGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmYWtlUGFydCA9IGZha2VQYXJ0c1tpXTtcclxuICAgICAgICBpZiAoZmFrZVBhcnQuY2hhckF0KDApID09PSBTUEVDSUFMX1RPS0VOX01BUktFUikge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFxyXG4gICAgICAgICAgICAvLyB0aGUgbGl0ZXJhbCBzdHJpbmcgSVMgdGhlIHRva2VuJ3MgbmFtZS5cclxuICAgICAgICAgICAgLy8gY2FsbCBzcGVjaWFsIHRva2VuJ3MgcmVnaXN0ZXJlZCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgc3BlY2lhbFRva2Vuc1tmYWtlUGFydC5zdWJzdHJpbmcoMSldKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZmFrZVBhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJ0cztcclxufVxyXG4vKlxyXG5BY2NlcHRzIGFuIGFsbW9zdC1maW5hbGx5LWZvcm1hdHRlZCBzdHJpbmcgYW5kIHByb2Nlc3NlcyB0aGUgXCJtYXliZVwiIGNvbnRyb2wgY2hhcmFjdGVycywgcmV0dXJuaW5nIGEgbmV3IHN0cmluZy5cclxuKi9cclxuZnVuY3Rpb24gcHJvY2Vzc01heWJlTWFya2VycyhzKSB7XHJcbiAgICByZXR1cm4gcy5yZXBsYWNlKE1BWUJFX1JFR0VYUCwgZnVuY3Rpb24gKG0wLCBtMSkge1xyXG4gICAgICAgIGlmIChtMS5tYXRjaCgvWzEtOV0vKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLy8gTWlzYyBVdGlsc1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qXHJcblJldHVybnMgYSB1bml0IHN0cmluZywgZWl0aGVyICd5ZWFyJywgJ21vbnRoJywgJ2RheScsIG9yIG51bGwgZm9yIHRoZSBtb3N0IGdyYW51bGFyIGZvcm1hdHRpbmcgdG9rZW4gaW4gdGhlIHN0cmluZy5cclxuKi9cclxuZnVuY3Rpb24gcXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0KGZvcm1hdFN0cikge1xyXG4gICAgdmFyIGNodW5rcyA9IGNodW5rRm9ybWF0U3RyaW5nKGZvcm1hdFN0cik7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjaHVuaztcclxuICAgIHZhciBjYW5kaWRhdGU7XHJcbiAgICB2YXIgYmVzdDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgY2FuZGlkYXRlID0gbGFyZ2VUb2tlbk1hcFtjaHVuay50b2tlbi5jaGFyQXQoMCldO1xyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJlc3QgfHwgY2FuZGlkYXRlLnZhbHVlID4gYmVzdC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3QgPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYmVzdCkge1xyXG4gICAgICAgIHJldHVybiBiZXN0LnVuaXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5leHBvcnRzLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdCA9IHF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdDtcclxuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9kZWwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb2RlbCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl93YXRjaGVycyA9IHt9O1xyXG4gICAgICAgIF90aGlzLl9wcm9wcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLmFwcGx5R2xvYmFsV2F0Y2hlcnMoKTtcclxuICAgICAgICBfdGhpcy5jb25zdHJ1Y3RlZCgpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1vZGVsLndhdGNoID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIG1ha2UgYSBtYXNrZWQtY29weSBvZiB0aGUgc3VwZXJjbGFzcydzIG1hcFxyXG4gICAgICAgIC8vIFRPRE86IHdyaXRlIHRlc3RcclxuICAgICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdfZ2xvYmFsV2F0Y2hBcmdzJykpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuX2dsb2JhbFdhdGNoQXJncyA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuX2dsb2JhbFdhdGNoQXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3NbbmFtZV0gPSBhcmdzO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB1c2VmdWwgZm9yIG1vbmtleXBhdGNoaW5nLiBUT0RPOiBCYXNlQ2xhc3M/XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFwcGx5R2xvYmFsV2F0Y2hlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX2dsb2JhbFdhdGNoQXJncztcclxuICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gbWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2F0Y2guYXBwbHkodGhpcywgW25hbWVdLmNvbmNhdChtYXBbbmFtZV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGhpcy5fcHJvcHM7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIHZhciBuZXdQcm9wcztcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW25hbWVdID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3UHJvcHMgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFByb3BzKG5ld1Byb3BzKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobmV3UHJvcHMpIHtcclxuICAgICAgICB2YXIgb2xkUHJvcHMgPSB0aGlzLl9wcm9wcztcclxuICAgICAgICB2YXIgY2hhbmdlc2V0ID0ge307IC8vIHdpbGwgaGF2ZSB1bmRlZmluZWQncyB0byBzaWduYWwgdW5zZXRzXHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZXNldFtuYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZXNldFtuYW1lXSA9IG5ld1Byb3BzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFByb3BzKGNoYW5nZXNldCk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbmFtZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBuYW1lcyA9IFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5hbWVzID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW25hbWVzW2ldXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhuZXdQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZWRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBjaGFuZ2VkQ250ID0gMDtcclxuICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICB2YWwgPSBuZXdQcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgLy8gYSBjaGFuZ2UgaW4gdmFsdWU/XHJcbiAgICAgICAgICAgIC8vIGlmIGFuIG9iamVjdCwgZG9uJ3QgY2hlY2sgZXF1YWxpdHksIGJlY2F1c2UgbWlnaHQgaGF2ZSBiZWVuIG11dGF0ZWQgaW50ZXJuYWxseS5cclxuICAgICAgICAgICAgLy8gVE9ETzogZXZlbnR1YWxseSBlbmZvcmNlIGltbXV0YWJpbGl0eS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICB2YWwgIT09IHRoaXMuX3Byb3BzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUHJvcHNbbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZWRDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6YmF0Y2hDaGFuZ2UnLCBjaGFuZ2VkUHJvcHMpO1xyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gY2hhbmdlZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZTpjaGFuZ2UnLCBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlOicgKyBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBjaGFuZ2VkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGNoYW5nZWRQcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW25hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiYXRjaENoYW5nZScsIGNoYW5nZWRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChuYW1lLCBkZXBMaXN0LCBzdGFydEZ1bmMsIHN0b3BGdW5jKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnVud2F0Y2gobmFtZSk7XHJcbiAgICAgICAgdGhpcy5fd2F0Y2hlcnNbbmFtZV0gPSB0aGlzLl93YXRjaERlcHMoZGVwTGlzdCwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHN0YXJ0RnVuYy5jYWxsKF90aGlzLCBkZXBzKTtcclxuICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMudGhlbikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudW5zZXQobmFtZSk7IC8vIHB1dCBpbiBhbiB1bnNldCBzdGF0ZSB3aGlsZSByZXNvbHZpbmdcclxuICAgICAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXQobmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0KG5hbWUsIHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBfdGhpcy51bnNldChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHN0b3BGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9wRnVuYy5jYWxsKF90aGlzLCBkZXBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXJzW25hbWVdO1xyXG4gICAgICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuX3dhdGNoRGVwcyA9IGZ1bmN0aW9uIChkZXBMaXN0LCBzdGFydEZ1bmMsIHN0b3BGdW5jKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcXVldWVkQ2hhbmdlQ250ID0gMDtcclxuICAgICAgICB2YXIgZGVwQ250ID0gZGVwTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHNhdGlzZnlDbnQgPSAwO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB7fTsgLy8gd2hhdCdzIHBhc3NlZCBhcyB0aGUgYGRlcHNgIGFyZ3VtZW50c1xyXG4gICAgICAgIHZhciBiaW5kVHVwbGVzID0gW107IC8vIGFycmF5IG9mIFsgZXZlbnROYW1lLCBoYW5kbGVyRnVuYyBdIGFycmF5c1xyXG4gICAgICAgIHZhciBpc0NhbGxpbmdTdG9wID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG9uQmVmb3JlRGVwQ2hhbmdlID0gZnVuY3Rpb24gKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICBxdWV1ZWRDaGFuZ2VDbnQrKztcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZENoYW5nZUNudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FsbGluZ1N0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb25EZXBDaGFuZ2UgPSBmdW5jdGlvbiAoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHNldD9cclxuICAgICAgICAgICAgICAgIGlmICghaXNPcHRpb25hbCAmJiB2YWx1ZXNbZGVwTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNbZGVwTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBkZXBlbmRlbmN5IHRoYXQgd2FzIHByZXZpb3VzbHkgdW5zZXQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwgJiYgdmFsdWVzW2RlcE5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYXRpc2Z5Q250Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbZGVwTmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVldWVkQ2hhbmdlQ250LS07XHJcbiAgICAgICAgICAgIGlmICghcXVldWVkQ2hhbmdlQ250KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3cgZmluYWxseSBzYXRpc2ZpZWQgb3Igc2F0aXNmaWVkIGFsbCBhbG9uZz9cclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RvcEZ1bmMgaW5pdGlhdGVkIGFub3RoZXIgdmFsdWUgY2hhbmdlLCBpZ25vcmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSBwcm9jZXNzZWQgYnkgYW5vdGhlciBjaGFuZ2UgZXZlbnQgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWxsaW5nU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEZ1bmModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGludGVyY2VwdCBmb3IgLm9uKCkgdGhhdCByZW1lbWJlcnMgaGFuZGxlcnNcclxuICAgICAgICB2YXIgYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgYmluZFR1cGxlcy5wdXNoKFtldmVudE5hbWUsIGhhbmRsZXJdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGxpc3RlbiB0byBkZXBlbmRlbmN5IGNoYW5nZXNcclxuICAgICAgICBkZXBMaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlcE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGRlcE5hbWUuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBkZXBOYW1lLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJpbmQoJ2JlZm9yZTpjaGFuZ2U6JyArIGRlcE5hbWUsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIG9uQmVmb3JlRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBiaW5kKCdjaGFuZ2U6JyArIGRlcE5hbWUsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIG9uRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHByb2Nlc3MgY3VycmVudCBkZXBlbmRlbmN5IHZhbHVlc1xyXG4gICAgICAgIGRlcExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVwTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZGVwTmFtZS5jaGFyQXQoMCkgPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IGRlcE5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmhhcyhkZXBOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzW2RlcE5hbWVdID0gX3RoaXMuZ2V0KGRlcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGluaXRpYWxseSBzYXRpc2ZpZWRcclxuICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0RnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kVHVwbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGJpbmRUdXBsZXNbaV1bMF0sIGJpbmRUdXBsZXNbaV1bMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYmluZFR1cGxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyB3YXMgc2F0aXNmaWVkLCBzbyBjYWxsIHN0b3BGdW5jXHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEZ1bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmxhc2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZmxhc2ggPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlcnNbbmFtZV07XHJcbiAgICAgICAgaWYgKHdhdGNoZXIpIHtcclxuICAgICAgICAgICAgd2F0Y2hlci5mbGFzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9kZWw7XHJcbn0oQ2xhc3NfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGVsO1xyXG5Nb2RlbC5wcm90b3R5cGUuX2dsb2JhbFdhdGNoQXJncyA9IHt9OyAvLyBtdXRhdGlvbiBwcm90ZWN0aW9uIGluIE1vZGVsLndhdGNoXHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhNb2RlbCk7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW9kZWwpO1xyXG5cblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMCk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIHBhcnNlOiBmdW5jdGlvbiAoZXZlbnRJbnB1dCwgc291cmNlKSB7XHJcbiAgICAgICAgaWYgKHV0aWxfMS5pc1RpbWVTdHJpbmcoZXZlbnRJbnB1dC5zdGFydCkgfHwgbW9tZW50LmlzRHVyYXRpb24oZXZlbnRJbnB1dC5zdGFydCkgfHxcclxuICAgICAgICAgICAgdXRpbF8xLmlzVGltZVN0cmluZyhldmVudElucHV0LmVuZCkgfHwgbW9tZW50LmlzRHVyYXRpb24oZXZlbnRJbnB1dC5lbmQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoZXZlbnRJbnB1dCwgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoZXZlbnRJbnB1dCwgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEV2ZW50RGVmRGF0ZU11dGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnREZWZEYXRlTXV0YXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckVuZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUaW1lZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yY2VBbGxEYXkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLmNyZWF0ZUZyb21EaWZmID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlMCwgZGF0ZVByb2ZpbGUxLCBsYXJnZVVuaXQpIHtcclxuICAgICAgICB2YXIgY2xlYXJFbmQgPSBkYXRlUHJvZmlsZTAuZW5kICYmICFkYXRlUHJvZmlsZTEuZW5kO1xyXG4gICAgICAgIHZhciBmb3JjZVRpbWVkID0gZGF0ZVByb2ZpbGUwLmlzQWxsRGF5KCkgJiYgIWRhdGVQcm9maWxlMS5pc0FsbERheSgpO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9ICFkYXRlUHJvZmlsZTAuaXNBbGxEYXkoKSAmJiBkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKTtcclxuICAgICAgICB2YXIgZGF0ZURlbHRhO1xyXG4gICAgICAgIHZhciBlbmREaWZmO1xyXG4gICAgICAgIHZhciBlbmREZWx0YTtcclxuICAgICAgICB2YXIgbXV0YXRpb247XHJcbiAgICAgICAgLy8gc3VidHJhY3RzIHRoZSBkYXRlcyBpbiB0aGUgYXBwcm9wcmlhdGUgd2F5LCByZXR1cm5pbmcgYSBkdXJhdGlvblxyXG4gICAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0RGF0ZXMoZGF0ZTEsIGRhdGUwKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXJnZVVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkJ5VW5pdChkYXRlMSwgZGF0ZTAsIGxhcmdlVW5pdCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGVQcm9maWxlMS5pc0FsbERheSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZEYXkoZGF0ZTEsIGRhdGUwKTsgLy8gcG9vcmx5IG5hbWVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZEYXlUaW1lKGRhdGUxLCBkYXRlMCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVEZWx0YSA9IHN1YnRyYWN0RGF0ZXMoZGF0ZVByb2ZpbGUxLnN0YXJ0LCBkYXRlUHJvZmlsZTAuc3RhcnQpO1xyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZTEuZW5kKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSB1bnpvbmVkUmFuZ2VzIGJlY2F1c2UgZGF0ZVByb2ZpbGUwLmVuZCBtaWdodCBiZSBudWxsXHJcbiAgICAgICAgICAgIGVuZERpZmYgPSBzdWJ0cmFjdERhdGVzKGRhdGVQcm9maWxlMS51bnpvbmVkUmFuZ2UuZ2V0RW5kKCksIGRhdGVQcm9maWxlMC51bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgICAgICBlbmREZWx0YSA9IGVuZERpZmYuc3VidHJhY3QoZGF0ZURlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb24oKTtcclxuICAgICAgICBtdXRhdGlvbi5jbGVhckVuZCA9IGNsZWFyRW5kO1xyXG4gICAgICAgIG11dGF0aW9uLmZvcmNlVGltZWQgPSBmb3JjZVRpbWVkO1xyXG4gICAgICAgIG11dGF0aW9uLmZvcmNlQWxsRGF5ID0gZm9yY2VBbGxEYXk7XHJcbiAgICAgICAgbXV0YXRpb24uc2V0RGF0ZURlbHRhKGRhdGVEZWx0YSk7XHJcbiAgICAgICAgbXV0YXRpb24uc2V0RW5kRGVsdGEoZW5kRGVsdGEpO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgcmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLnByb3RvdHlwZS5idWlsZE5ld0RhdGVQcm9maWxlID0gZnVuY3Rpb24gKGV2ZW50RGF0ZVByb2ZpbGUsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXZlbnREYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIHZhciBzaG91bGRSZXpvbmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZXZlbnREYXRlUHJvZmlsZS5lbmQgJiYgIXRoaXMuY2xlYXJFbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gZXZlbnREYXRlUHJvZmlsZS5lbmQuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmREZWx0YSAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChldmVudERhdGVQcm9maWxlLmlzQWxsRGF5KCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VUaW1lZCkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmICFlbmQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgJiYgZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGVEZWx0YSkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydC5hZGQodGhpcy5kYXRlRGVsdGEpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKHRoaXMuZGF0ZURlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyB0aGlzIGJlZm9yZSBhZGRpbmcgc3RhcnREZWx0YSB0byBzdGFydCwgc28gd2UgY2FuIHdvcmsgb2ZmIG9mIHN0YXJ0XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kRGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmVuZERlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnREZWx0YSkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydC5hZGQodGhpcy5zdGFydERlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFJlem9uZSkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogb2theSB0byBhY2Nlc3MgY2FsZW5kYXIgb3B0aW9uP1xyXG4gICAgICAgIGlmICghZW5kICYmIGNhbGVuZGFyLm9wdCgnZm9yY2VFdmVudER1cmF0aW9uJykpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGF0ZVByb2ZpbGUuaXNBbGxEYXkoKSwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIGNhbGVuZGFyKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuc2V0RGF0ZURlbHRhID0gZnVuY3Rpb24gKGRhdGVEZWx0YSkge1xyXG4gICAgICAgIGlmIChkYXRlRGVsdGEgJiYgZGF0ZURlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVEZWx0YSA9IGRhdGVEZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZURlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldFN0YXJ0RGVsdGEgPSBmdW5jdGlvbiAoc3RhcnREZWx0YSkge1xyXG4gICAgICAgIGlmIChzdGFydERlbHRhICYmIHN0YXJ0RGVsdGEudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREZWx0YSA9IHN0YXJ0RGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuc2V0RW5kRGVsdGEgPSBmdW5jdGlvbiAoZW5kRGVsdGEpIHtcclxuICAgICAgICBpZiAoZW5kRGVsdGEgJiYgZW5kRGVsdGEudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGVsdGEgPSBlbmREZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGVsdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2xlYXJFbmQgJiYgIXRoaXMuZm9yY2VUaW1lZCAmJiAhdGhpcy5mb3JjZUFsbERheSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5kYXRlRGVsdGEgJiYgIXRoaXMuc3RhcnREZWx0YSAmJiAhdGhpcy5lbmREZWx0YTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREZWZEYXRlTXV0YXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmRGF0ZU11dGF0aW9uO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdGFuZGFyZFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMyk7XHJcbnZhciBKcXVlcnlVaVRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNCk7XHJcbnZhciB0aGVtZUNsYXNzSGFzaCA9IHt9O1xyXG5mdW5jdGlvbiBkZWZpbmVUaGVtZVN5c3RlbSh0aGVtZU5hbWUsIHRoZW1lQ2xhc3MpIHtcclxuICAgIHRoZW1lQ2xhc3NIYXNoW3RoZW1lTmFtZV0gPSB0aGVtZUNsYXNzO1xyXG59XHJcbmV4cG9ydHMuZGVmaW5lVGhlbWVTeXN0ZW0gPSBkZWZpbmVUaGVtZVN5c3RlbTtcclxuZnVuY3Rpb24gZ2V0VGhlbWVTeXN0ZW1DbGFzcyh0aGVtZVNldHRpbmcpIHtcclxuICAgIGlmICghdGhlbWVTZXR0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0YW5kYXJkVGhlbWVfMS5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhlbWVTZXR0aW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEpxdWVyeVVpVGhlbWVfMS5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoZW1lQ2xhc3NIYXNoW3RoZW1lU2V0dGluZ107XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXRUaGVtZVN5c3RlbUNsYXNzID0gZ2V0VGhlbWVTeXN0ZW1DbGFzcztcclxuXG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEFycmF5RXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBcnJheUV2ZW50U291cmNlKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXZlbnREZWZzID0gW107IC8vIGZvciBpZiBzZXRSYXdFdmVudERlZnMgaXMgbmV2ZXIgY2FsbGVkXHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgcmF3UHJvcHM7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIHJhdyBpbnB1dFxyXG4gICAgICAgIGlmICgkLmlzQXJyYXkocmF3SW5wdXQuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHJhd0lucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkocmF3SW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0geyBldmVudHM6IHJhd0lucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRTb3VyY2VfMS5kZWZhdWx0LnBhcnNlLmNhbGwodGhpcywgcmF3UHJvcHMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLnNldFJhd0V2ZW50RGVmcyA9IGZ1bmN0aW9uIChyYXdFdmVudERlZnMpIHtcclxuICAgICAgICB0aGlzLnJhd0V2ZW50RGVmcyA9IHJhd0V2ZW50RGVmcztcclxuICAgICAgICB0aGlzLmV2ZW50RGVmcyA9IHRoaXMucGFyc2VFdmVudERlZnMocmF3RXZlbnREZWZzKTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSB0aGlzLmV2ZW50RGVmcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGltZXpvbmUgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lem9uZSAhPT0gdGltZXpvbmUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmc1tpXSBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmc1tpXS5yZXpvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lem9uZSA9IHRpbWV6b25lO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5yZXNvbHZlKGV2ZW50RGVmcyk7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuYWRkRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmcy5wdXNoKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgZXZlbnREZWZJZCBhbHJlYWR5IG5vcm1hbGl6ZWQgdG8gYSBzdHJpbmdcclxuICAgICovXHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdXRpbF8xLnJlbW92ZU1hdGNoaW5nKHRoaXMuZXZlbnREZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGVmLmlkID09PSBldmVudERlZklkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmcyA9IFtdO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYXdFdmVudERlZnM7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyU3VjY2VzcyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc2V0UmF3RXZlbnREZWZzKHJhd1Byb3BzLmV2ZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyU3VjY2VzcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXJyYXlFdmVudFNvdXJjZTtcclxufShFdmVudFNvdXJjZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXJyYXlFdmVudFNvdXJjZTtcclxuQXJyYXlFdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIGV2ZW50czogZmFsc2UgLy8gZG9uJ3QgYXV0b21hdGljYWxseSB0cmFuc2ZlclxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKlxyXG5BIGNhY2hlIGZvciB0aGUgbGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCB2YWx1ZXMgZm9yIG9uZSBvciBtb3JlIGVsZW1lbnRzLlxyXG5Xb3JrcyB3aXRoIGJvdGggb2Zmc2V0IChmcm9tIHRvcGxlZnQgZG9jdW1lbnQpIGFuZCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQpLlxyXG5cbm9wdGlvbnM6XHJcbi0gZWxzXHJcbi0gaXNIb3Jpem9udGFsXHJcbi0gaXNWZXJ0aWNhbFxyXG4qL1xyXG52YXIgQ29vcmRDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvb3JkQ2FjaGUob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gZmFsc2U7IC8vIHdoZXRoZXIgdG8gcXVlcnkgZm9yIGxlZnQvcmlnaHQvd2lkdGhcclxuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBmYWxzZTsgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgdG9wL2JvdHRvbS9oZWlnaHRcclxuICAgICAgICB0aGlzLmVscyA9ICQob3B0aW9ucy5lbHMpO1xyXG4gICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gb3B0aW9ucy5pc0hvcml6b250YWw7XHJcbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gb3B0aW9ucy5pc1ZlcnRpY2FsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWwgPSBvcHRpb25zLm9mZnNldFBhcmVudCA/ICQob3B0aW9ucy5vZmZzZXRQYXJlbnQpIDogbnVsbDtcclxuICAgIH1cclxuICAgIC8vIFF1ZXJpZXMgdGhlIGVscyBmb3IgY29vcmRpbmF0ZXMgYW5kIHN0b3JlcyB0aGVtLlxyXG4gICAgLy8gQ2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgdXNpbmcgYW5kIG9mIHRoZSBnZXQqIG1ldGhvZHMgYmVsb3cuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50RWwgPSB0aGlzLmZvcmNlZE9mZnNldFBhcmVudEVsO1xyXG4gICAgICAgIGlmICghb2Zmc2V0UGFyZW50RWwgJiYgdGhpcy5lbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBvZmZzZXRQYXJlbnRFbCA9IHRoaXMuZWxzLmVxKDApLm9mZnNldFBhcmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG9mZnNldFBhcmVudEVsID9cclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50RWwub2Zmc2V0KCkgOlxyXG4gICAgICAgICAgICBudWxsO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSZWN0ID0gdGhpcy5xdWVyeUJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEZXN0cm95cyBhbGwgaW50ZXJuYWwgZGF0YSBhYm91dCBjb29yZGluYXRlcywgZnJlZWluZyBtZW1vcnlcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3JpZ2luID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZWZ0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG9wcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3R0b21zID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBXaGVuIGNhbGxlZCwgaWYgY29vcmQgY2FjaGVzIGFyZW4ndCBidWlsdCwgYnVpbGRzIHRoZW1cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmVuc3VyZUJ1aWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcmlnaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxIb3Jpem9udGFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGVmdHMgPSBbXTtcclxuICAgICAgICB2YXIgcmlnaHRzID0gW107XHJcbiAgICAgICAgdGhpcy5lbHMuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGVsLm9mZnNldCgpLmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVsLm91dGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgbGVmdHMucHVzaChsZWZ0KTtcclxuICAgICAgICAgICAgcmlnaHRzLnB1c2gobGVmdCArIHdpZHRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxlZnRzID0gbGVmdHM7XHJcbiAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XHJcbiAgICB9O1xyXG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZEVsVmVydGljYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0b3BzID0gW107XHJcbiAgICAgICAgdmFyIGJvdHRvbXMgPSBbXTtcclxuICAgICAgICB0aGlzLmVscy5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgIHZhciB0b3AgPSBlbC5vZmZzZXQoKS50b3A7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBlbC5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgICAgICB0b3BzLnB1c2godG9wKTtcclxuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHRvcCArIGhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50b3BzID0gdG9wcztcclxuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxyXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0SG9yaXpvbnRhbEluZGV4ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgdmFyIGxlZnRzID0gdGhpcy5sZWZ0cztcclxuICAgICAgICB2YXIgcmlnaHRzID0gdGhpcy5yaWdodHM7XHJcbiAgICAgICAgdmFyIGxlbiA9IGxlZnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRPZmZzZXQgPj0gbGVmdHNbaV0gJiYgbGVmdE9mZnNldCA8IHJpZ2h0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cclxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFZlcnRpY2FsSW5kZXggPSBmdW5jdGlvbiAodG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHZhciB0b3BzID0gdGhpcy50b3BzO1xyXG4gICAgICAgIHZhciBib3R0b21zID0gdGhpcy5ib3R0b21zO1xyXG4gICAgICAgIHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRvcE9mZnNldCA+PSB0b3BzW2ldICYmIHRvcE9mZnNldCA8IGJvdHRvbXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0TGVmdE9mZnNldCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldExlZnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgcmlnaHQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCdzIHJpZ2h0IGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwicmlnaHRcIiB3b3VsZCBiZS5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFJpZ2h0T2Zmc2V0ID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSByaWdodCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIHJpZ2h0IGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwicmlnaHRcIiB3b3VsZCBiZS5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFJpZ2h0UG9zaXRpb24gPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5vcmlnaW4ubGVmdDtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRUb3BPZmZzZXQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdG9wIHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0VG9wUG9zaXRpb24gPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF0gLSB0aGlzLm9yaWdpbi50b3A7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgYm90dG9tIG9mZnNldCAoZnJvbSB0aGUgZG9jdW1lbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgYm90dG9tIGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwiYm90dG9tXCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRCb3R0b21PZmZzZXQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgYm90dG9tIHBvc2l0aW9uIChmcm9tIHRoZSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgYm90dG9tIGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwiYm90dG9tXCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRCb3R0b21Qb3NpdGlvbiA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEJvdW5kaW5nIFJlY3RcclxuICAgIC8vIFRPRE86IGRlY291cGxlIHRoaXMgZnJvbSBDb29yZENhY2hlXHJcbiAgICAvLyBDb21wdXRlIGFuZCByZXR1cm4gd2hhdCB0aGUgZWxlbWVudHMnIGJvdW5kaW5nIHJlY3RhbmdsZSBpcywgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlLlxyXG4gICAgLy8gUmlnaHQgbm93LCBvbmx5IHJldHVybnMgYSByZWN0YW5nbGUgaWYgY29uc3RyYWluZWQgYnkgYW4gb3ZlcmZsb3c6c2Nyb2xsIGVsZW1lbnQuXHJcbiAgICAvLyBSZXR1cm5zIG51bGwgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5xdWVyeUJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsUGFyZW50RWw7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50RWwgPSB1dGlsXzEuZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWxzLmVxKDApKTtcclxuICAgICAgICAgICAgaWYgKCFzY3JvbGxQYXJlbnRFbC5pcyhkb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZ2V0Q2xpZW50UmVjdChzY3JvbGxQYXJlbnRFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuaXNQb2ludEluQm91bmRzID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMuaXNUb3BJbkJvdW5kcyh0b3BPZmZzZXQpO1xyXG4gICAgfTtcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmlzTGVmdEluQm91bmRzID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYm91bmRpbmdSZWN0IHx8IChsZWZ0T2Zmc2V0ID49IHRoaXMuYm91bmRpbmdSZWN0LmxlZnQgJiYgbGVmdE9mZnNldCA8IHRoaXMuYm91bmRpbmdSZWN0LnJpZ2h0KTtcclxuICAgIH07XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5pc1RvcEluQm91bmRzID0gZnVuY3Rpb24gKHRvcE9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5ib3VuZGluZ1JlY3QgfHwgKHRvcE9mZnNldCA+PSB0aGlzLmJvdW5kaW5nUmVjdC50b3AgJiYgdG9wT2Zmc2V0IDwgdGhpcy5ib3VuZGluZ1JlY3QuYm90dG9tKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29vcmRDYWNoZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29vcmRDYWNoZTtcclxuXG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG4vKiBUcmFja3MgYSBkcmFnJ3MgbW91c2UgbW92ZW1lbnQsIGZpcmluZyB2YXJpb3VzIGhhbmRsZXJzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBUT0RPOiB1c2UgRW1pdHRlclxyXG52YXIgRHJhZ0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHJhZ0xpc3RlbmVyKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNUb3VjaCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNHZW5lcmljID0gZmFsc2U7IC8vIGluaXRpYXRlZCBieSAnZHJhZ3N0YXJ0JyAoanF1aSlcclxuICAgICAgICB0aGlzLnNob3VsZENhbmNlbFRvdWNoU2Nyb2xsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNjcm9sbEFsd2F5c0tpbGxzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0F1dG9TY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAvLyBkZWZhdWx0c1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsU2Vuc2l0aXZpdHkgPSAzMDsgLy8gcGl4ZWxzIGZyb20gZWRnZSBmb3Igc2Nyb2xsaW5nIHRvIHN0YXJ0XHJcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IDIwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmQsIGF0IG1heGltdW0gc3BlZWRcclxuICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsTXMgPSA1MDsgLy8gbWlsbGlzZWNvbmQgd2FpdCBiZXR3ZWVuIHNjcm9sbCBpbmNyZW1lbnRcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgLy8gSW50ZXJhY3Rpb24gKGhpZ2gtbGV2ZWwpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5zdGFydEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGV2LCBleHRyYU9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoZXh0cmFPcHRpb25zID09PSB2b2lkIDApIHsgZXh0cmFPcHRpb25zID0ge307IH1cclxuICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuICAgICAgICAgICAgaWYgKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdXRpbF8xLmlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudHMgbmF0aXZlIHNlbGVjdGlvbiBpbiBtb3N0IGJyb3dzZXJzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSB1dGlsXzEuZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kZWxheSwgdGhpcy5vcHRpb25zLmRlbGF5LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9IHV0aWxfMS5maXJzdERlZmluZWQoZXh0cmFPcHRpb25zLmRpc3RhbmNlLCB0aGlzLm9wdGlvbnMuZGlzdGFuY2UsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHRoaXMub3B0aW9ucy5zdWJqZWN0RWw7XHJcbiAgICAgICAgICAgIHV0aWxfMS5wcmV2ZW50U2VsZWN0aW9uKCQoJ2JvZHknKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaCA9IHV0aWxfMS5nZXRFdklzVG91Y2goZXYpO1xyXG4gICAgICAgICAgICB0aGlzLmlzR2VuZXJpYyA9IGV2LnR5cGUgPT09ICdkcmFnc3RhcnQnO1xyXG4gICAgICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5YID0gdXRpbF8xLmdldEV2WChldik7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luWSA9IHV0aWxfMS5nZXRFdlkoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsID0gdXRpbF8xLmdldFNjcm9sbFBhcmVudCgkKGV2LnRhcmdldCkpO1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRIYW5kbGVycygpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRBdXRvU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25TdGFydChldik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREZWxheShldik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5taW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvblN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuZW5kSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERyYWcoZXYpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95QXV0b1Njcm9sbCgpO1xyXG4gICAgICAgICAgICB0aGlzLnVuYmluZEhhbmRsZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uRW5kKGV2LCBpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIHV0aWxfMS5hbGxvd1NlbGVjdGlvbigkKCdib2R5JykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uRW5kID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25FbmQnLCBldiwgaXNDYW5jZWxsZWQgfHwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIC8vIEJpbmRpbmcgVG8gRE9NXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5iaW5kSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc29tZSBicm93c2VycyAoU2FmYXJpIGluIGlPUyAxMCkgZG9uJ3QgYWxsb3cgcHJldmVudERlZmF1bHQgb24gdG91Y2ggZXZlbnRzIHRoYXQgYXJlIGJvdW5kIGFmdGVyIHRvdWNoc3RhcnQsXHJcbiAgICAgICAgLy8gc28gbGlzdGVuIHRvIHRoZSBHbG9iYWxFbWl0dGVyIHNpbmdsZXRvbiwgd2hpY2ggaXMgYWx3YXlzIGJvdW5kLCBpbnN0ZWFkIG9mIHRoZSBkb2N1bWVudCBkaXJlY3RseS5cclxuICAgICAgICB2YXIgZ2xvYmFsRW1pdHRlciA9IEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzR2VuZXJpYykge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XHJcbiAgICAgICAgICAgICAgICBkcmFnOiB0aGlzLmhhbmRsZU1vdmUsXHJcbiAgICAgICAgICAgICAgICBkcmFnc3RvcDogdGhpcy5lbmRJbnRlcmFjdGlvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1RvdWNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICAgICAgdG91Y2htb3ZlOiB0aGlzLmhhbmRsZVRvdWNoTW92ZSxcclxuICAgICAgICAgICAgICAgIHRvdWNoZW5kOiB0aGlzLmVuZEludGVyYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhnbG9iYWxFbWl0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxyXG4gICAgICAgICAgICAgICAgbW91c2V1cDogdGhpcy5lbmRJbnRlcmFjdGlvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhnbG9iYWxFbWl0dGVyLCB7XHJcbiAgICAgICAgICAgIHNlbGVjdHN0YXJ0OiB1dGlsXzEucHJldmVudERlZmF1bHQsXHJcbiAgICAgICAgICAgIGNvbnRleHRtZW51OiB1dGlsXzEucHJldmVudERlZmF1bHQgLy8gbG9uZyB0YXBzIHdvdWxkIG9wZW4gbWVudSBvbiBDaHJvbWUgZGV2IHRvb2xzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS51bmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbyhHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKSk7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpOyAvLyBmb3IgaXNHZW5lcmljXHJcbiAgICB9O1xyXG4gICAgLy8gRHJhZyAoaGlnaC1sZXZlbClcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBleHRyYU9wdGlvbnMgaWdub3JlZCBpZiBkcmFnIGFscmVhZHkgc3RhcnRlZFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5zdGFydERyYWcgPSBmdW5jdGlvbiAoZXYsIGV4dHJhT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuc3RhcnRJbnRlcmFjdGlvbihldiwgZXh0cmFPcHRpb25zKTsgLy8gZW5zdXJlIGludGVyYWN0aW9uIGJlZ2FuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZHJhZ1N0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBkeCA9IHV0aWxfMS5nZXRFdlgoZXYpIC0gdGhpcy5vcmlnaW5YO1xyXG4gICAgICAgIHZhciBkeSA9IHV0aWxfMS5nZXRFdlkoZXYpIC0gdGhpcy5vcmlnaW5ZO1xyXG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IHRoaXMubWluRGlzdGFuY2U7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcclxuICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGR4ICogZHggKyBkeSAqIGR5O1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZyhkeCwgZHksIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoaWxlIHRoZSBtb3VzZSBpcyBiZWluZyBtb3ZlZCBhbmQgd2hlbiB3ZSBrbm93IGEgbGVnaXRpbWF0ZSBkcmFnIGlzIHRha2luZyBwbGFjZVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnID0gZnVuY3Rpb24gKGR4LCBkeSwgZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWcnLCBkeCwgZHksIGV2KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUF1dG9TY3JvbGwoZXYpOyAvLyB3aWxsIHBvc3NpYmx5IGNhdXNlIHNjcm9sbGluZ1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuZW5kRHJhZyA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZHJhZ0VuZCcsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBEZWxheVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnREZWxheSA9IGZ1bmN0aW9uIChpbml0aWFsRXYpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZURlbGF5RW5kKGluaXRpYWxFdik7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURlbGF5RW5kID0gZnVuY3Rpb24gKGluaXRpYWxFdikge1xyXG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmFnKGluaXRpYWxFdik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIERpc3RhbmNlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxheUVuZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmFnKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTW91c2UgLyBUb3VjaFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gcHJldmVudCBpbmVydGlhIGFuZCB0b3VjaG1vdmUtc2Nyb2xsaW5nIHdoaWxlIGRyYWdnaW5nXHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLnNob3VsZENhbmNlbFRvdWNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZShldik7XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFNjcm9sbGluZyAodW5yZWxhdGVkIHRvIGF1dG8tc2Nyb2xsKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlVG91Y2hTY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBpZiB0aGUgZHJhZyBpcyBiZWluZyBpbml0aWF0ZWQgYnkgdG91Y2gsIGJ1dCBhIHNjcm9sbCBoYXBwZW5zIGJlZm9yZVxyXG4gICAgICAgIC8vIHRoZSBkcmFnLWluaXRpYXRpbmcgZGVsYXkgaXMgb3ZlciwgY2FuY2VsIHRoZSBkcmFnXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcgfHwgdGhpcy5zY3JvbGxBbHdheXNLaWxscykge1xyXG4gICAgICAgICAgICB0aGlzLmVuZEludGVyYWN0aW9uKGV2LCB0cnVlKTsgLy8gaXNDYW5jZWxsZWQ9dHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXHJcbiAgICAvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWFrZXMgX21ldGhvZHMgY2FsbGFibGUgYnkgZXZlbnQgbmFtZS4gVE9ETzoga2lsbCB0aGlzXHJcbiAgICAgICAgaWYgKHRoaXNbJ18nICsgbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpc1snXycgKyBuYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQXV0by1zY3JvbGxcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmluaXRBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY3JvbGxFbCA9IHRoaXMuc2Nyb2xsRWw7XHJcbiAgICAgICAgdGhpcy5pc0F1dG9TY3JvbGwgPVxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsICYmXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxFbCAmJlxyXG4gICAgICAgICAgICAgICAgIXNjcm9sbEVsLmlzKHdpbmRvdykgJiZcclxuICAgICAgICAgICAgICAgICFzY3JvbGxFbC5pcyhkb2N1bWVudCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIC8vIGRlYm91bmNlIG1ha2VzIHN1cmUgcmFwaWQgY2FsbHMgZG9uJ3QgaGFwcGVuXHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oc2Nyb2xsRWwsICdzY3JvbGwnLCB1dGlsXzEuZGVib3VuY2UodGhpcy5oYW5kbGVEZWJvdW5jZWRTY3JvbGwsIDEwMCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmRlc3Ryb3lBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZW5kQXV0b1Njcm9sbCgpOyAvLyBraWxsIGFueSBhbmltYXRpb24gbG9vcFxyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgc2Nyb2xsIGhhbmRsZXIgaWYgdGhlcmUgaXMgYSBzY3JvbGxFbFxyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbyh0aGlzLnNjcm9sbEVsLCAnc2Nyb2xsJyk7IC8vIHdpbGwgcHJvYmFibHkgZ2V0IHJlbW92ZWQgYnkgdW5iaW5kSGFuZGxlcnMgdG9vIDooXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuZCBzdG9yZXMgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBzY3JvbGxFbFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJvdW5kcyA9IHV0aWxfMS5nZXRPdXRlclJlY3QodGhpcy5zY3JvbGxFbCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBnZXRDbGllbnRSZWN0IGluIGZ1dHVyZS4gYnV0IHByZXZlbnRzIGF1dG8gc2Nyb2xsaW5nIHdoZW4gb24gdG9wIG9mIHNjcm9sbGJhcnNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGRyYWdnaW5nIGlzIGluIHByb2dyZXNzIGFuZCBzY3JvbGxpbmcgc2hvdWxkIGJlIHVwZGF0ZWRcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlQXV0b1Njcm9sbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBzZW5zaXRpdml0eSA9IHRoaXMuc2Nyb2xsU2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuc2Nyb2xsQm91bmRzO1xyXG4gICAgICAgIHZhciB0b3BDbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIGJvdHRvbUNsb3NlbmVzcztcclxuICAgICAgICB2YXIgbGVmdENsb3NlbmVzcztcclxuICAgICAgICB2YXIgcmlnaHRDbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIHRvcFZlbCA9IDA7XHJcbiAgICAgICAgdmFyIGxlZnRWZWwgPSAwO1xyXG4gICAgICAgIGlmIChib3VuZHMpIHtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBjbG9zZW5lc3MgdG8gZWRnZXMuIHZhbGlkIHJhbmdlIGlzIGZyb20gMC4wIC0gMS4wXHJcbiAgICAgICAgICAgIHRvcENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtICh1dGlsXzEuZ2V0RXZZKGV2KSAtIGJvdW5kcy50b3ApKSAvIHNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICBib3R0b21DbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLmJvdHRvbSAtIHV0aWxfMS5nZXRFdlkoZXYpKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgbGVmdENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtICh1dGlsXzEuZ2V0RXZYKGV2KSAtIGJvdW5kcy5sZWZ0KSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgcmlnaHRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLnJpZ2h0IC0gdXRpbF8xLmdldEV2WChldikpKSAvIHNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGUgdmVydGljYWwgY2xvc2VuZXNzIGludG8gdmVsb2NpdHkuXHJcbiAgICAgICAgICAgIC8vIG1vdXNlIG11c3QgYmUgY29tcGxldGVseSBpbiBib3VuZHMgZm9yIHZlbG9jaXR5IHRvIGhhcHBlbi5cclxuICAgICAgICAgICAgaWYgKHRvcENsb3NlbmVzcyA+PSAwICYmIHRvcENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BWZWwgPSB0b3BDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIHVwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYm90dG9tQ2xvc2VuZXNzID49IDAgJiYgYm90dG9tQ2xvc2VuZXNzIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHRvcFZlbCA9IGJvdHRvbUNsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGhvcml6b250YWwgY2xvc2VuZXNzIGludG8gdmVsb2NpdHlcclxuICAgICAgICAgICAgaWYgKGxlZnRDbG9zZW5lc3MgPj0gMCAmJiBsZWZ0Q2xvc2VuZXNzIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRWZWwgPSBsZWZ0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyBsZWZ0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRDbG9zZW5lc3MgPj0gMCAmJiByaWdodENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0VmVsID0gcmlnaHRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsVmVsKHRvcFZlbCwgbGVmdFZlbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2V0cyB0aGUgc3BlZWQtb2Ytc2Nyb2xsaW5nIGZvciB0aGUgc2Nyb2xsRWxcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc2V0U2Nyb2xsVmVsID0gZnVuY3Rpb24gKHRvcFZlbCwgbGVmdFZlbCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wVmVsID0gdG9wVmVsO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdFZlbCA9IGxlZnRWZWw7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gbWFzc2FnZXMgaW50byByZWFsaXN0aWMgdmFsdWVzXHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm9uLXplcm8gdmVsb2NpdHksIGFuZCBhbiBhbmltYXRpb24gbG9vcCBoYXNuJ3QgYWxyZWFkeSBzdGFydGVkLCB0aGVuIFNUQVJUXHJcbiAgICAgICAgaWYgKCh0aGlzLnNjcm9sbFRvcFZlbCB8fCB0aGlzLnNjcm9sbExlZnRWZWwpICYmICF0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodXRpbF8xLnByb3h5KHRoaXMsICdzY3JvbGxJbnRlcnZhbEZ1bmMnKSwgLy8gc2NvcGUgdG8gYHRoaXNgXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEZvcmNlcyBzY3JvbGxUb3BWZWwgYW5kIHNjcm9sbExlZnRWZWwgdG8gYmUgemVybyBpZiBzY3JvbGxpbmcgaGFzIGFscmVhZHkgZ29uZSBhbGwgdGhlIHdheVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJhaW5TY3JvbGxWZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3BWZWwgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5zY3JvbGxUb3AoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxUb3BWZWwgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5zY3JvbGxUb3AoKSArIGVsWzBdLmNsaWVudEhlaWdodCA+PSBlbFswXS5zY3JvbGxIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wVmVsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0VmVsIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsTGVmdCgpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxMZWZ0VmVsID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsTGVmdCgpICsgZWxbMF0uY2xpZW50V2lkdGggPj0gZWxbMF0uc2Nyb2xsV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkdXJpbmcgZXZlcnkgaXRlcmF0aW9uIG9mIHRoZSBzY3JvbGxpbmcgYW5pbWF0aW9uIGxvb3BcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc2Nyb2xsSW50ZXJ2YWxGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XHJcbiAgICAgICAgdmFyIGZyYWMgPSB0aGlzLnNjcm9sbEludGVydmFsTXMgLyAxMDAwOyAvLyBjb25zaWRlcmluZyBhbmltYXRpb24gZnJlcXVlbmN5LCB3aGF0IHRoZSB2ZWwgc2hvdWxkIGJlIG11bHQnZCBieVxyXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdmFsdWUgb2Ygc2Nyb2xsRWwncyBzY3JvbGxcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3BWZWwpIHtcclxuICAgICAgICAgICAgZWwuc2Nyb2xsVG9wKGVsLnNjcm9sbFRvcCgpICsgdGhpcy5zY3JvbGxUb3BWZWwgKiBmcmFjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCkge1xyXG4gICAgICAgICAgICBlbC5zY3JvbGxMZWZ0KGVsLnNjcm9sbExlZnQoKSArIHRoaXMuc2Nyb2xsTGVmdFZlbCAqIGZyYWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnN0cmFpblNjcm9sbFZlbCgpOyAvLyBzaW5jZSB0aGUgc2Nyb2xsIHZhbHVlcyBjaGFuZ2VkLCByZWNvbXB1dGUgdGhlIHZlbG9jaXRpZXNcclxuICAgICAgICAvLyBpZiBzY3JvbGxlZCBhbGwgdGhlIHdheSwgd2hpY2ggY2F1c2VzIHRoZSB2ZWxzIHRvIGJlIHplcm8sIHN0b3AgdGhlIGFuaW1hdGlvbiBsb29wXHJcbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbFRvcFZlbCAmJiAhdGhpcy5zY3JvbGxMZWZ0VmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQXV0b1Njcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBLaWxscyBhbnkgZXhpc3Rpbmcgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZEF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldCBjYWxsZWQgd2hlbiB0aGUgc2Nyb2xsRWwgaXMgc2Nyb2xsZWQgKE5PVEU6IHRoaXMgaXMgZGVsYXllZCB2aWEgZGVib3VuY2UpXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURlYm91bmNlZFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyByZWNvbXB1dGUgYWxsIGNvb3JkaW5hdGVzLCBidXQgKm9ubHkqIGlmIHRoaXMgaXMgKm5vdCogcGFydCBvZiBvdXIgc2Nyb2xsaW5nIGFuaW1hdGlvblxyXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcclxuICAgIH07XHJcbiAgICByZXR1cm4gRHJhZ0xpc3RlbmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnTGlzdGVuZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRHJhZ0xpc3RlbmVyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG4vKlxyXG5BIHNldCBvZiByZW5kZXJpbmcgYW5kIGRhdGUtcmVsYXRlZCBtZXRob2RzIGZvciBhIHZpc3VhbCBjb21wb25lbnQgY29tcHJpc2VkIG9mIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNvbHVtbnMuXHJcblByZXJlcXVpc2l0ZTogdGhlIG9iamVjdCBiZWluZyBtaXhlZCBpbnRvIG5lZWRzIHRvIGJlIGEgKkdyaWQqXHJcbiovXHJcbnZhciBEYXlUYWJsZU1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5VGFibGVNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheVRhYmxlTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUG9wdWxhdGVzIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIGZvciBkYXRlIGNhbGN1bGF0aW9uIGFuZCByZW5kZXJpbmdcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnVwZGF0ZURheVRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHQudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBkYXRlID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgZW5kID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRheUluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGRheUluZGljZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5RGF0ZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5c1BlclJvdztcclxuICAgICAgICB2YXIgZmlyc3REYXk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICB3aGlsZSAoZGF0ZS5pc0JlZm9yZShlbmQpKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3LmlzSGlkZGVuRGF5KGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRheUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRpY2VzLnB1c2goZGF5SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGF5RGF0ZXMucHVzaChkYXRlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGUuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJyZWFrT25XZWVrcykge1xyXG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXHJcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF5RGF0ZXNbMF0uZGF5KCk7XHJcbiAgICAgICAgICAgIGZvciAoZGF5c1BlclJvdyA9IDE7IGRheXNQZXJSb3cgPCBkYXlEYXRlcy5sZW5ndGg7IGRheXNQZXJSb3crKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRheURhdGVzW2RheXNQZXJSb3ddLmRheSgpID09PSBmaXJzdERheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXlEYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XHJcbiAgICAgICAgICAgIGRheXNQZXJSb3cgPSBkYXlEYXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF5RGF0ZXMgPSBkYXlEYXRlcztcclxuICAgICAgICB0aGlzLmRheUluZGljZXMgPSBkYXlJbmRpY2VzO1xyXG4gICAgICAgIHRoaXMuZGF5c1BlclJvdyA9IGRheXNQZXJSb3c7XHJcbiAgICAgICAgdGhpcy5yb3dDbnQgPSByb3dDbnQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZUNvbHMoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgYXNzaWduZWQgdGhlIGNvbENudCBwcm9wZXJ0eSBhbmQgdXBkYXRlcyBhbnkgb3B0aW9ucyB0aGF0IG1heSBiZSBjb21wdXRlZCBmcm9tIGl0XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS51cGRhdGVEYXlUYWJsZUNvbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDbnQgPSB0aGlzLmNvbXB1dGVDb2xDbnQoKTtcclxuICAgICAgICB0aGlzLmNvbEhlYWRGb3JtYXQgPVxyXG4gICAgICAgICAgICB0aGlzLm9wdCgnY29sdW1uSGVhZGVyRm9ybWF0JykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0KCdjb2x1bW5Gb3JtYXQnKSB8fCAvLyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVDb2xIZWFkRm9ybWF0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGV0ZXJtaW5lcyBob3cgbWFueSBjb2x1bW5zIHRoZXJlIHNob3VsZCBiZSBpbiB0aGUgdGFibGVcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmNvbXB1dGVDb2xDbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5c1BlclJvdztcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgYW1iaWd1b3VzbHktdGltZWQgbW9tZW50IGZvciB0aGUgZ2l2ZW4gY2VsbFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q2VsbERhdGUgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXlEYXRlc1t0aGlzLmdldENlbGxEYXlJbmRleChyb3csIGNvbCldLmNsb25lKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIGRhdGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBjZWxsXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDZWxsUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcclxuICAgICAgICB2YXIgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheSBjZWxscywgY2hyb25vbG9naWNhbGx5LCBmcm9tIHRoZSBmaXJzdCBvZiB0aGUgZ3JpZCAoMC1iYXNlZClcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENlbGxEYXlJbmRleCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiByb3cgKiB0aGlzLmRheXNQZXJSb3cgKyB0aGlzLmdldENvbERheUluZGV4KGNvbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtbmVyIG9mIGRheSBjZWxscywgY2hyb25vbG9naWNhbGx5LCBmcm9tIHRoZSBmaXJzdCBjZWxsIGluICphbnkgZ2l2ZW4gcm93KlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q29sRGF5SW5kZXggPSBmdW5jdGlvbiAoY29sKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sQ250IC0gMSAtIGNvbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2w7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZGF0ZSwgcmV0dXJucyBpdHMgY2hyb25vbG9jaWFsIGNlbGwtaW5kZXggZnJvbSB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgZ3JpZC5cclxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cclxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxyXG4gICAgLy8gSWYgYWZ0ZXIgdGhlIGxhc3Qgb2Zmc2V0LCByZXR1cm5zIGFuIG9mZnNldCBwYXN0IHRoZSBsYXN0IGNlbGwgb2Zmc2V0LlxyXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXREYXRlRGF5SW5kZXggPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXlJbmRpY2VzID0gdGhpcy5kYXlJbmRpY2VzO1xyXG4gICAgICAgIHZhciBkYXlPZmZzZXQgPSBkYXRlLmRpZmYodGhpcy5kYXlEYXRlc1swXSwgJ2RheXMnKTtcclxuICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1swXSAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRheU9mZnNldCA+PSBkYXlJbmRpY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1tkYXlJbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXlJbmRpY2VzW2RheU9mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIE9wdGlvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5jb21wdXRlQ29sSGVhZEZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxyXG4gICAgICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxyXG4gICAgICAgIGlmICh0aGlzLnJvd0NudCA+IDEgfHwgdGhpcy5jb2xDbnQgPiAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZCc7IC8vIFwiU2F0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb2xDbnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdCgnZGF5T2ZNb250aEZvcm1hdCcpOyAvLyBcIlNhdCAxMi8xMFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQnOyAvLyBcIlNhdHVyZGF5XCJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogU2xpY2luZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFNsaWNlcyB1cCBhIGRhdGUgcmFuZ2UgaW50byBhIHNlZ21lbnQgZm9yIGV2ZXJ5IHdlZWstcm93IGl0IGludGVyc2VjdHMgd2l0aFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5Um93ID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xyXG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UodW56b25lZFJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcclxuICAgICAgICB2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgdmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgcm93Rmlyc3Q7XHJcbiAgICAgICAgdmFyIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XHJcbiAgICAgICAgdmFyIHNlZ0ZpcnN0O1xyXG4gICAgICAgIHZhciBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICByb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcclxuICAgICAgICAgICAgLy8gaW50ZXJzZWN0IHNlZ21lbnQncyBvZmZzZXQgcmFuZ2Ugd2l0aCB0aGUgcm93J3NcclxuICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLm1heChyYW5nZUZpcnN0LCByb3dGaXJzdCk7XHJcbiAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIHJvd0xhc3QpO1xyXG4gICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIHNlZ0ZpcnN0ID0gTWF0aC5jZWlsKHNlZ0ZpcnN0KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXHJcbiAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLmZsb29yKHNlZ0xhc3QpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgIGlmIChzZWdGaXJzdCA8PSBzZWdMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJvd0RheUluZGV4OiBzZWdGaXJzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSBkYXktY2VsbCBpdCBpbnRlcnNlY3RzIHdpdGguXHJcbiAgICAvLyBUT0RPOiBtYWtlIG1vcmUgRFJZIHdpdGggc2xpY2VSYW5nZUJ5Um93IHNvbWVob3cuXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5zbGljZVJhbmdlQnlEYXkgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3cgPSB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gdGhpcy52aWV3LmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpOyAvLyBtYWtlIHdob2xlLWRheSByYW5nZSwgY29uc2lkZXJpbmcgbmV4dERheVRocmVzaG9sZFxyXG4gICAgICAgIHZhciByYW5nZUZpcnN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcclxuICAgICAgICB2YXIgcmFuZ2VMYXN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheXMnKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgIHZhciByb3dGaXJzdDtcclxuICAgICAgICB2YXIgcm93TGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3IgY3VycmVudCByb3dcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnRmlyc3Q7XHJcbiAgICAgICAgdmFyIHNlZ0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIHNlZ21lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICByb3dGaXJzdCA9IHJvdyAqIGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHJvd0xhc3QgPSByb3dGaXJzdCArIGRheXNQZXJSb3cgLSAxO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSByb3dGaXJzdDsgaSA8PSByb3dMYXN0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXHJcbiAgICAgICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIGkpO1xyXG4gICAgICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGgubWluKHJhbmdlTGFzdCwgaSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcclxuICAgICAgICAgICAgICAgIGlmIChzZWdGaXJzdCA8PSBzZWdMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJvd0RheUluZGV4OiBzZWdMYXN0IC0gcm93Rmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdMYXN0ID09PSByYW5nZUxhc3RcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBIZWFkZXIgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZEh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcm93ICcgKyB0aGVtZS5nZXRDbGFzcygnaGVhZGVyUm93JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRoZWFkPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhlYWRUckh0bWwoKSArXHJcbiAgICAgICAgICAgICc8L3RoZWFkPicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTsgLy8gZmFsbCBiYWNrIHRvIGdlbmVyaWNcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJIZWFkVHJIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSkgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhlYWREYXRlQ2VsbHNIdG1sKCkgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/IHRoaXMucmVuZGVySGVhZEludHJvSHRtbCgpIDogJycpICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHRtbHMgPSBbXTtcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHZhciBkYXRlO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKDAsIGNvbCk7XHJcbiAgICAgICAgICAgIGh0bWxzLnB1c2godGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxIdG1sKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IHdoZW4gaW50ZXJuYWxBcGlWZXJzaW9uLCBhY2NlcHQgYW4gb2JqZWN0IGZvciBIVE1MIGF0dHJpYnV0ZXNcclxuICAgIC8vIChjb2xzcGFuIHNob3VsZCBiZSBubyBkaWZmZXJlbnQpXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJIZWFkRGF0ZUNlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUsIGNvbHNwYW4sIG90aGVyQXR0cnMpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdC5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy1kYXktaGVhZGVyJyxcclxuICAgICAgICAgICAgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJylcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBpbm5lckh0bWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0Lm9wdCgnY29sdW1uSGVhZGVySHRtbCcpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IHQub3B0KCdjb2x1bW5IZWFkZXJIdG1sJykoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0Lm9wdCgnY29sdW1uSGVhZGVyVGV4dCcpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKHQub3B0KCdjb2x1bW5IZWFkZXJUZXh0JykoZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5uZXJIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUoZGF0ZS5mb3JtYXQodC5jb2xIZWFkRm9ybWF0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG9ubHkgb25lIHJvdyBvZiBkYXlzLCB0aGUgY2xhc3NOYW1lcyBvbiB0aGUgaGVhZGVyIGNhbiByZXByZXNlbnQgdGhlIHNwZWNpZmljIGRheXMgYmVuZWF0aFxyXG4gICAgICAgIGlmICh0LnJvd0NudCA9PT0gMSkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5jb25jYXQoXHJcbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIHRoZSBkYXktb2Ytd2VlayBjbGFzc1xyXG4gICAgICAgICAgICAvLyBub1RoZW1lSGlnaGxpZ2h0PXRydWUgKGRvbid0IGhpZ2hsaWdodCB0aGUgaGVhZGVyKVxyXG4gICAgICAgICAgICB0LmdldERheUNsYXNzZXMoZGF0ZSwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy0nICsgdXRpbF8xLmRheUlEc1tkYXRlLmRheSgpXSk7IC8vIG9ubHkgYWRkIHRoZSBkYXktb2Ytd2VlayBjbGFzc1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRoIGNsYXNzPVwiJyArIGNsYXNzTmFtZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICgoaXNEYXRlVmFsaWQgJiYgdC5yb3dDbnQpID09PSAxID9cclxuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChjb2xzcGFuID4gMSA/XHJcbiAgICAgICAgICAgICAgICAnIGNvbHNwYW49XCInICsgY29sc3BhbiArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKG90aGVyQXR0cnMgP1xyXG4gICAgICAgICAgICAgICAgJyAnICsgb3RoZXJBdHRycyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAoaXNEYXRlVmFsaWQgP1xyXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgbWFrZSBhIGxpbmsgaWYgdGhlIGhlYWRpbmcgY291bGQgcmVwcmVzZW50IG11bHRpcGxlIGRheXMsIG9yIGlmIHRoZXJlJ3Mgb25seSBvbmUgZGF5IChmb3JjZU9mZilcclxuICAgICAgICAgICAgICAgIHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCh7IGRhdGU6IGRhdGUsIGZvcmNlT2ZmOiB0LnJvd0NudCA+IDEgfHwgdC5jb2xDbnQgPT09IDEgfSwgaW5uZXJIdG1sKSA6XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgdmFsaWQsIGRpc3BsYXkgdGV4dCwgYnV0IG5vIGxpbmtcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbCkgK1xyXG4gICAgICAgICAgICAnPC90aD4nO1xyXG4gICAgfTtcclxuICAgIC8qIEJhY2tncm91bmQgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVyQmdUckh0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyAnJyA6IHRoaXMucmVuZGVyQmdJbnRyb0h0bWwocm93KSkgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJnQ2VsbHNIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/IHRoaXMucmVuZGVyQmdJbnRyb0h0bWwocm93KSA6ICcnKSArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVyQmdJbnRyb0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVyQmdDZWxsc0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIGh0bWxzLnB1c2godGhpcy5yZW5kZXJCZ0NlbGxIdG1sKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnQ2VsbEh0bWwgPSBmdW5jdGlvbiAoZGF0ZSwgb3RoZXJBdHRycykge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHQudmlldztcclxuICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSB0LmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc0RhdGUoZGF0ZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHQuZ2V0RGF5Q2xhc3NlcyhkYXRlKTtcclxuICAgICAgICBjbGFzc2VzLnVuc2hpZnQoJ2ZjLWRheScsIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSk7XHJcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCInIDogLy8gaWYgZGF0ZSBoYXMgYSB0aW1lLCB3b24ndCBmb3JtYXQgaXRcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz48L3RkPic7XHJcbiAgICB9O1xyXG4gICAgLyogR2VuZXJpY1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIGRlZmF1bHQgSFRNTCBpbnRybyBmb3IgYW55IHJvdy4gVXNlciBjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IGEgZ2VuZXJpYyBtZXRob2QgZm9yIGRlYWxpbmcgd2l0aCA8dHI+LCBSVEwsIGludHJvXHJcbiAgICAvLyB3aGVuIGluY3JlbWVudCBpbnRlcm5hbEFwaVZlcnNpb25cclxuICAgIC8vIHdyYXBUciAoc2NoZWR1bGVyKVxyXG4gICAgLyogVXRpbHNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBBcHBsaWVzIHRoZSBnZW5lcmljIFwiaW50cm9cIiBhbmQgXCJvdXRyb1wiIEhUTUwgdG8gdGhlIGdpdmVuIGNlbGxzLlxyXG4gICAgLy8gSW50cm8gbWVhbnMgdGhlIGxlZnRtb3N0IGNlbGwgd2hlbiB0aGUgY2FsZW5kYXIgaXMgTFRSIGFuZCB0aGUgcmlnaHRtb3N0IGNlbGwgd2hlbiBSVEwuIFZpY2UtdmVyc2EgZm9yIG91dHJvLlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuYm9va2VuZENlbGxzID0gZnVuY3Rpb24gKHRyRWwpIHtcclxuICAgICAgICB2YXIgaW50cm9IdG1sID0gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTtcclxuICAgICAgICBpZiAoaW50cm9IdG1sKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICB0ckVsLmFwcGVuZChpbnRyb0h0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJFbC5wcmVwZW5kKGludHJvSHRtbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheVRhYmxlTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheVRhYmxlTWl4aW47XHJcblxuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBsZW1lbnRzOlxyXG4gICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgLSBldmVudEZvb3RwcmludHNUb1NlZ3NcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBCdXNpbmVzc0hvdXJSZW5kZXJlcihjb21wb25lbnQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyID0gZmlsbFJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZSA9IGNvbXBvbmVudC5fZ2V0RGF0ZVByb2ZpbGUoKS5hY3RpdmVVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGJ1c2luZXNzSG91ckdlbmVyYXRvci5idWlsZEV2ZW50SW5zdGFuY2VHcm91cChjb21wb25lbnQuaGFzQWxsRGF5QnVzaW5lc3NIb3VycywgdW56b25lZFJhbmdlKTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gZXZlbnRJbnN0YW5jZUdyb3VwID9cclxuICAgICAgICAgICAgY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKHVuem9uZWRSYW5nZSkpIDpcclxuICAgICAgICAgICAgW107XHJcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudEZvb3RwcmludHMoZXZlbnRGb290cHJpbnRzKTtcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cykge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTZWdzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuc2VncyA9IHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci5yZW5kZXJTZWdzKCdidXNpbmVzc0hvdXJzJywgc2Vncywge1xyXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZjLW5vbmJ1c2luZXNzJywgJ2ZjLWJnZXZlbnQnXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIudW5yZW5kZXIoJ2J1c2luZXNzSG91cnMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdzIHx8IFtdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCdXNpbmVzc0hvdXJSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQnVzaW5lc3NIb3VyUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEZpbGxSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZpbGxSZW5kZXJlcihjb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLmZpbGxTZWdUYWcgPSAnZGl2JztcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmVsc0J5RmlsbCA9IHt9O1xyXG4gICAgfVxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGb290cHJpbnQgPSBmdW5jdGlvbiAodHlwZSwgY29tcG9uZW50Rm9vdHByaW50LCBwcm9wcykge1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2Vncyh0eXBlLCB0aGlzLmNvbXBvbmVudC5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MoY29tcG9uZW50Rm9vdHByaW50KSwgcHJvcHMpO1xyXG4gICAgfTtcclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzLCBwcm9wcykge1xyXG4gICAgICAgIHZhciBlbHM7XHJcbiAgICAgICAgc2VncyA9IHRoaXMuYnVpbGRTZWdFbHModHlwZSwgc2VncywgcHJvcHMpOyAvLyBhc3NpZ25lcyBgLmVsYCB0byBlYWNoIHNlZy4gcmV0dXJucyBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgc2Vnc1xyXG4gICAgICAgIGVscyA9IHRoaXMuYXR0YWNoU2VnRWxzKHR5cGUsIHNlZ3MpO1xyXG4gICAgICAgIGlmIChlbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRFbHModHlwZSwgZWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgc3BlY2lmaWMgdHlwZSBvZiBmaWxsIHRoYXQgaXMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsc0J5RmlsbFt0eXBlXTtcclxuICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmVsc0J5RmlsbFt0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBhbmQgYXNzaWducyBhbiBgZWxgIHByb3BlcnR5IGZvciBlYWNoIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cclxuICAgIC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2VncywgcHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkU2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBidWlsZCBhIGxhcmdlIGNvbmNhdGVuYXRpb24gb2Ygc2VnbWVudCBIVE1MXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuYnVpbGRTZWdIdG1sKHR5cGUsIHNlZ3NbaV0sIHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHcmFiIGluZGl2aWR1YWwgZWxlbWVudHMgZnJvbSB0aGUgY29tYmluZWQgSFRNTCBzdHJpbmcuIFVzZSBlYWNoIGFzIHRoZSBkZWZhdWx0IHJlbmRlcmluZy5cclxuICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LlxyXG4gICAgICAgICAgICAkKGh0bWwpLmVhY2goZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJChub2RlKTtcclxuICAgICAgICAgICAgICAgIC8vIGFsbG93IGN1c3RvbSBmaWx0ZXIgbWV0aG9kcyBwZXItdHlwZVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmZpbHRlckVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBwcm9wcy5maWx0ZXJFbChzZWcsIGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gJChlbCk7IC8vIGFsbG93IGN1c3RvbSBmaWx0ZXIgdG8gcmV0dXJuIHJhdyBET00gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZWxlbWVudCB0eXBlPyAod291bGQgYmUgYmFkIGlmIGEgbm9uLVREIHdlcmUgaW5zZXJ0ZWQgaW50byBhIHRhYmxlIGZvciBleGFtcGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5pcyhfdGhpcy5maWxsU2VnVGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwgPSBlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRTZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnSHRtbCA9IGZ1bmN0aW9uICh0eXBlLCBzZWcsIHByb3BzKSB7XHJcbiAgICAgICAgLy8gY3VzdG9tIGhvb2tzIHBlci10eXBlXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBwcm9wcy5nZXRDbGFzc2VzID8gcHJvcHMuZ2V0Q2xhc3NlcyhzZWcpIDogW107XHJcbiAgICAgICAgdmFyIGNzcyA9IHV0aWxfMS5jc3NUb1N0cihwcm9wcy5nZXRDc3MgPyBwcm9wcy5nZXRDc3Moc2VnKSA6IHt9KTtcclxuICAgICAgICByZXR1cm4gJzwnICsgdGhpcy5maWxsU2VnVGFnICtcclxuICAgICAgICAgICAgKGNsYXNzZXMubGVuZ3RoID8gJyBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgOiAnJykgK1xyXG4gICAgICAgICAgICAoY3NzID8gJyBzdHlsZT1cIicgKyBjc3MgKyAnXCInIDogJycpICtcclxuICAgICAgICAgICAgJyAvPic7XHJcbiAgICB9O1xyXG4gICAgLy8gU2hvdWxkIHJldHVybiB3cmFwcGluZyBET00gc3RydWN0dXJlXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ0VscyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVwb3J0RWxzID0gZnVuY3Rpb24gKHR5cGUsIG5vZGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxzQnlGaWxsW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxzQnlGaWxsW3R5cGVdID0gdGhpcy5lbHNCeUZpbGxbdHlwZV0uYWRkKG5vZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxzQnlGaWxsW3R5cGVdID0gJChub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBGaWxsUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZpbGxSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEhlbHBlclJlbmRlcmVyKGNvbXBvbmVudCwgZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNvbXBvbmVudC5fZ2V0VmlldygpO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlciA9IGV2ZW50UmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50Rm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKFtcclxuICAgICAgICAgICAgdGhpcy5mYWJyaWNhdGVFdmVudEZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50RHJhZ2dpbmdGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudEZvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsICdmYy1kcmFnZ2luZycsIGlzVG91Y2ggPyBudWxsIDogdGhpcy52aWV3Lm9wdCgnZHJhZ09wYWNpdHknKSk7XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXppbmdGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudEZvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsICdmYy1yZXNpemluZycpO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsIGV4dHJhQ2xhc3NOYW1lcywgb3BhY2l0eSkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAnZmMtaGVscGVyICcgKyAoZXh0cmFDbGFzc05hbWVzIHx8ICcnKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICAvLyBhc3NpZ25zIGVhY2ggc2VnJ3MgZWwgYW5kIHJldHVybnMgYSBzdWJzZXQgb2Ygc2VncyB0aGF0IHdlcmUgcmVuZGVyZWRcclxuICAgICAgICBzZWdzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlckZnU2VnRWxzKHNlZ3MpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3NbaV0uZWwuYWRkQ2xhc3MoY2xhc3NOYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcGFjaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NbaV0uZWwuY3NzKCdvcGFjaXR5Jywgb3BhY2l0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWxwZXJFbHMgPSB0aGlzLnJlbmRlclNlZ3Moc2Vncywgc291cmNlU2VnKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTXVzdCByZXR1cm4gYWxsIG1vY2sgZXZlbnQgZWxlbWVudHNcclxuICAgICovXHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBzb3VyY2VTZWcpIHtcclxuICAgICAgICAvLyBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhlbHBlckVscykge1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlckVscy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUuZmFicmljYXRlRXZlbnRGb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBldmVudERhdGVQcm9maWxlID0gY2FsZW5kYXIuZm9vdHByaW50VG9EYXRlUHJvZmlsZShjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIHZhciBkdW1teUV2ZW50ID0gbmV3IFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdChuZXcgRXZlbnRTb3VyY2VfMS5kZWZhdWx0KGNhbGVuZGFyKSk7XHJcbiAgICAgICAgdmFyIGR1bW15SW5zdGFuY2U7XHJcbiAgICAgICAgZHVtbXlFdmVudC5kYXRlUHJvZmlsZSA9IGV2ZW50RGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgZHVtbXlJbnN0YW5jZSA9IGR1bW15RXZlbnQuYnVpbGRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0KGNvbXBvbmVudEZvb3RwcmludCwgZHVtbXlFdmVudCwgZHVtbXlJbnN0YW5jZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhlbHBlclJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBIZWxwZXJSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV2ZW50UG9pbnRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFBvaW50aW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXZlbnRQb2ludGluZygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IG11c3QgaW1wbGVtZW50OlxyXG4gICAgICAtIHB1YmxpY2x5VHJpZ2dlclxyXG4gICAgKi9cclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZW50ZXInLCB0aGlzLmhhbmRsZU1vdXNlb3Zlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2VsZWF2ZScsIHRoaXMuaGFuZGxlTW91c2VvdXQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW3NlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSwgZXYsIHRoaXMudmlld11cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdmVyXHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVNb3VzZW92ZXIgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICghR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VkT3ZlclNlZyA9IHNlZztcclxuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0byBFdmVudFNlbGVjdGluZydzIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlJlc2l6YWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmFkZENsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TW91c2VvdmVyJywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW3NlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSwgZXYsIHRoaXMudmlld11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzIGZvciB3aGVuIGFuIGV2ZW50IGVsZW1lbnQgaXMgbW91c2VkIG91dC5cclxuICAgIC8vIENhbiBiZSBnaXZlbiBubyBhcmd1bWVudHMsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBtb3VzZW91dCB0aGUgc2VnbWVudCB0aGF0IHdhcyBwcmV2aW91c2x5IG1vdXNlZCBvdmVyLlxyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VvdXQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICh0aGlzLm1vdXNlZE92ZXJTZWcpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZWRPdmVyU2VnID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0byBFdmVudFNlbGVjdGluZydzIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlJlc2l6YWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TW91c2VvdXQnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2IHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vdXNlZE92ZXJTZWcpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZW91dCh0aGlzLm1vdXNlZE92ZXJTZWcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRQb2ludGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRQb2ludGluZztcclxuXG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBEYXRlQ2xpY2tpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ1KTtcclxudmFyIERhdGVTZWxlY3RpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI1KTtcclxudmFyIEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xyXG52YXIgRXZlbnREcmFnZ2luZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQpO1xyXG52YXIgRXZlbnRSZXNpemluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjMpO1xyXG52YXIgRXh0ZXJuYWxEcm9wcGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjIpO1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdGFuZGFyZEludGVyYWN0aW9uc01peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBTdGFuZGFyZEludGVyYWN0aW9uc01peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFyZEludGVyYWN0aW9uc01peGluO1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5kYXRlQ2xpY2tpbmdDbGFzcyA9IERhdGVDbGlja2luZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmRhdGVTZWxlY3RpbmdDbGFzcyA9IERhdGVTZWxlY3RpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5ldmVudFBvaW50aW5nQ2xhc3MgPSBFdmVudFBvaW50aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXZlbnREcmFnZ2luZ0NsYXNzID0gRXZlbnREcmFnZ2luZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV2ZW50UmVzaXppbmdDbGFzcyA9IEV2ZW50UmVzaXppbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5leHRlcm5hbERyb3BwaW5nQ2xhc3MgPSBFeHRlcm5hbERyb3BwaW5nXzEuZGVmYXVsdDtcclxuXG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDb29yZENhY2hlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxudmFyIFBvcG92ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ5KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbnZhciBEYXlUYWJsZU1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MCk7XHJcbnZhciBEYXlHcmlkSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUxKTtcclxudmFyIERheUdyaWRGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUyKTtcclxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIGEgZ3JpZCBvZiB3aG9sZS1kYXlzIHRoYXQgcnVucyBob3Jpem9udGFsbHkuIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSByb3dzLCBvbmUgcGVyIHdlZWsuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgRGF5R3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkKHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTsgLy8gZGlzcGxheSB3ZWVrIG51bWJlcnMgaW4gZGF5IGNlbGw/XHJcbiAgICAgICAgX3RoaXMuYm90dG9tQ29vcmRQYWRkaW5nID0gMDsgLy8gaGFjayBmb3IgZXh0ZW5kaW5nIHRoZSBoaXQgYXJlYSBmb3IgdGhlIGxhc3Qgcm93IG9mIHRoZSBjb29yZGluYXRlIGdyaWRcclxuICAgICAgICAvLyBpc1JpZ2lkIGRldGVybWluZXMgd2hldGhlciB0aGUgaW5kaXZpZHVhbCByb3dzIHNob3VsZCBpZ25vcmUgdGhlIGNvbnRlbnRzIGFuZCBiZSBhIGNvbnN0YW50IGhlaWdodC5cclxuICAgICAgICAvLyBSZWxpZXMgb24gdGhlIHZpZXcncyBjb2xDbnQgYW5kIHJvd0NudC4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb21wb25lbnQgc2hvdWxkIHByb2JhYmx5IGJlIHNlbGYtc3VmZmljaWVudC5cclxuICAgICAgICBfdGhpcy5pc1JpZ2lkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuaGFzQWxsRGF5QnVzaW5lc3NIb3VycyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gU2xpY2VzIHVwIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlSb3coY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmxlZnRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmxhc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgICAgIHNlZy5yaWdodENvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWcuZmlyc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzZWcucmlnaHRDb2wgPSBzZWcubGFzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyB0aGUgcm93cyBhbmQgY29sdW1ucyBpbnRvIHRoZSBjb21wb25lbnQncyBgdGhpcy5lbGAsIHdoaWNoIHNob3VsZCBhbHJlYWR5IGJlIGFzc2lnbmVkLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyR3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgcm93Q250ID0gdGhpcy5yb3dDbnQ7XHJcbiAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIGlmICh0aGlzLmhlYWRDb250YWluZXJFbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRDb250YWluZXJFbC5odG1sKHRoaXMucmVuZGVySGVhZEh0bWwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyRGF5Um93SHRtbChyb3csIHRoaXMuaXNSaWdpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuaHRtbChodG1sKTtcclxuICAgICAgICB0aGlzLnJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdycpO1xyXG4gICAgICAgIHRoaXMuY2VsbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5yb3dFbHMsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMuY2VsbEVscy5zbGljZSgwLCB0aGlzLmNvbENudCksXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHRyaWdnZXIgZGF5UmVuZGVyIHdpdGggZWFjaCBjZWxsJ3MgZWxlbWVudFxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXlSZW5kZXInLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdmlldyxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIHJvdywgd2hpY2ggaXMgYSBkaXYgdGhhdCB3cmFwcyBhIHRhYmxlLlxyXG4gICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJEYXlSb3dIdG1sID0gZnVuY3Rpb24gKHJvdywgaXNSaWdpZCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFsnZmMtcm93JywgJ2ZjLXdlZWsnLCB0aGVtZS5nZXRDbGFzcygnZGF5Um93JyldO1xyXG4gICAgICAgIGlmIChpc1JpZ2lkKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmlnaWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdUckh0bWwocm93KSArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlPicgK1xyXG4gICAgICAgICAgICAodGhpcy5nZXRJc051bWJlcnNWaXNpYmxlKCkgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck51bWJlclRySHRtbChyb3cpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSgpIHx8IHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRJc0RheU51bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd0NudCA+IDE7XHJcbiAgICB9O1xyXG4gICAgLyogR3JpZCBOdW1iZXIgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyVHJIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpKSArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTnVtYmVyQ2VsbHNIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/IHRoaXMucmVuZGVyTnVtYmVySW50cm9IdG1sKHJvdykgOiAnJykgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckludHJvSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJDZWxsc0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIGh0bWxzLnB1c2godGhpcy5yZW5kZXJOdW1iZXJDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSA8dGQ+cyBvZiB0aGUgXCJudW1iZXJcIiByb3cgaW4gdGhlIERheUdyaWQncyBjb250ZW50IHNrZWxldG9uLlxyXG4gICAgLy8gVGhlIG51bWJlciByb3cgd2lsbCBvbmx5IGV4aXN0IGlmIGVpdGhlciBkYXkgbnVtYmVycyBvciB3ZWVrIG51bWJlcnMgYXJlIHR1cm5lZCBvbi5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckNlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHRoaXMuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBpc0RheU51bWJlclZpc2libGUgPSB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSAmJiBpc0RhdGVWYWxpZDtcclxuICAgICAgICB2YXIgY2xhc3NlcztcclxuICAgICAgICB2YXIgd2Vla0NhbGNGaXJzdERvVztcclxuICAgICAgICBpZiAoIWlzRGF5TnVtYmVyVmlzaWJsZSAmJiAhdGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG51bWJlcnMgaW4gZGF5IGNlbGwgKHdlZWsgbnVtYmVyIG11c3QgYmUgYWxvbmcgdGhlIHNpZGUpXHJcbiAgICAgICAgICAgIHJldHVybiAnPHRkLz4nOyAvLyAgd2lsbCBjcmVhdGUgYW4gZW1wdHkgc3BhY2UgYWJvdmUgZXZlbnRzIDooXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzZXMgPSB0aGlzLmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktdG9wJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBUbyBkZXRlcm1pbmUgdGhlIGRheSBvZiB3ZWVrIG51bWJlciBjaGFuZ2UgdW5kZXIgSVNPLCB3ZSBjYW5ub3RcclxuICAgICAgICAgICAgLy8gcmVseSBvbiBtb21lbnQuanMgbWV0aG9kcyBzdWNoIGFzIGZpcnN0RGF5T2ZXZWVrKCkgb3Igd2Vla2RheSgpLFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgcmVseSBvbiB0aGUgbG9jYWxlJ3MgZG93IChwb3NzaWJseSBvdmVycmlkZGVuIGJ5XHJcbiAgICAgICAgICAgIC8vIG91ciBmaXJzdERheSBvcHRpb24pLCB3aGljaCBtYXkgbm90IGJlIE1vbmRheS4gV2UgY2Fubm90IGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBkb3csIGJlY2F1c2UgdGhhdCB3b3VsZCBhZmZlY3QgdGhlIGNhbGVuZGFyIHN0YXJ0IGRheSBhcyB3ZWxsLlxyXG4gICAgICAgICAgICBpZiAoZGF0ZS5fbG9jYWxlLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPT09ICdJU08nKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrQ2FsY0ZpcnN0RG9XID0gMTsgLy8gTW9uZGF5IGJ5IElTTyA4NjAxIGRlZmluaXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdlZWtDYWxjRmlyc3REb1cgPSBkYXRlLl9sb2NhbGUuZmlyc3REYXlPZldlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCkgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JztcclxuICAgICAgICBpZiAodGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlICYmIChkYXRlLmRheSgpID09PSB3ZWVrQ2FsY0ZpcnN0RG9XKSkge1xyXG4gICAgICAgICAgICBodG1sICs9IHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCh7IGRhdGU6IGRhdGUsIHR5cGU6ICd3ZWVrJyB9LCB7ICdjbGFzcyc6ICdmYy13ZWVrLW51bWJlcicgfSwgZGF0ZS5mb3JtYXQoJ3cnKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RheU51bWJlclZpc2libGUpIHtcclxuICAgICAgICAgICAgaHRtbCArPSB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoZGF0ZSwgeyAnY2xhc3MnOiAnZmMtZGF5LW51bWJlcicgfSwgZGF0ZS5mb3JtYXQoJ0QnKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGh0bWwgKz0gJzwvdGQ+JztcclxuICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgIH07XHJcbiAgICAvKiBIaXQgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlLmJvdHRvbXNbdGhpcy5yb3dDbnQgLSAxXSArPSB0aGlzLmJvdHRvbUNvb3JkUGFkZGluZzsgLy8gaGFja1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbENvb3JkQ2FjaGUuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgdGhpcy5yb3dDb29yZENhY2hlLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2YXIgY29sID0gdGhpcy5jb2xDb29yZENhY2hlLmdldEhvcml6b250YWxJbmRleChsZWZ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbEhpdChyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Q2VsbFJhbmdlKGhpdC5yb3csIGhpdC5jb2wpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSwgdHJ1ZSAvLyBhbGwtZGF5P1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbEVsKGhpdC5yb3csIGhpdC5jb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIENlbGwgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEhpdCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICBjb2w6IGNvbCxcclxuICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2wpLFxyXG4gICAgICAgICAgICByaWdodDogdGhpcy5jb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbCksXHJcbiAgICAgICAgICAgIHRvcDogdGhpcy5yb3dDb29yZENhY2hlLmdldFRvcE9mZnNldChyb3cpLFxyXG4gICAgICAgICAgICBib3R0b206IHRoaXMucm93Q29vcmRDYWNoZS5nZXRCb3R0b21PZmZzZXQocm93KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEVsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVscy5lcShyb3cgKiB0aGlzLmNvbENudCArIGNvbCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBldmVudHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8gcmVtb3ZlcyB0aGUgXCJtb3JlLi5cIiBldmVudHMgcG9wb3ZlclxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYWxsIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldE93bkV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBlbmQgdGhlIHNlZ21lbnRzIGZyb20gdGhlIFwibW9yZS4uLlwiIHBvcG92ZXJcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MuY2FsbCh0aGlzKS5jb25jYXQodGhpcy5wb3BvdmVyU2VncyB8fCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cclxuICAgIC8vIGBldmVudExvY2F0aW9uYCBoYXMgem9uZWQgc3RhcnQgYW5kIGVuZCAob3B0aW9uYWwpXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyIGRyYWdzIGZyb20gT1RIRVIgY29tcG9uZW50cyBhcyBoZWxwZXJzXHJcbiAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50cy5sZW5ndGggJiYgc2VnICYmIHNlZy5jb21wb25lbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzaWduYWwgaGVscGVycyByZW5kZXJlZFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgaG92ZXJpbmcgZXZlbnRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIE1vcmUrIExpbmsgUG9wb3ZlclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbW92ZVNlZ1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VnUG9wb3Zlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlZ1BvcG92ZXIuaGlkZSgpOyAvLyBpbiBoYW5kbGVyLCB3aWxsIGNhbGwgc2VnUG9wb3ZlcidzIHJlbW92ZUVsZW1lbnRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTGltaXRzIHRoZSBudW1iZXIgb2YgXCJsZXZlbHNcIiAodmVydGljYWxseSBzdGFja2luZyBsYXllcnMgb2YgZXZlbnRzKSBmb3IgZWFjaCByb3cgb2YgdGhlIGdyaWQuXHJcbiAgICAvLyBgbGV2ZWxMaW1pdGAgY2FuIGJlIGZhbHNlIChkb24ndCBsaW1pdCksIGEgbnVtYmVyLCBvciB0cnVlIChzaG91bGQgYmUgY29tcHV0ZWQpLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3dzID0gZnVuY3Rpb24gKGxldmVsTGltaXQpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3c7IC8vIHJvdyAjXHJcbiAgICAgICAgdmFyIHJvd0xldmVsTGltaXQ7XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dTdHJ1Y3RzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgdGhpcy51bmxpbWl0Um93KHJvdyk7XHJcbiAgICAgICAgICAgIGlmICghbGV2ZWxMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsZXZlbExpbWl0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IGxldmVsTGltaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gdGhpcy5jb21wdXRlUm93TGV2ZWxMaW1pdChyb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyb3dMZXZlbExpbWl0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFJvdyhyb3csIHJvd0xldmVsTGltaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIGEgcm93IHdpbGwgYWNjb21vZGF0ZSB3aXRob3V0IGdvaW5nIG91dHNpZGUgaXRzIGJvdW5kcy5cclxuICAgIC8vIEFzc3VtZXMgdGhlIHJvdyBpcyBcInJpZ2lkXCIgKG1haW50YWlucyBhIGNvbnN0YW50IGhlaWdodCByZWdhcmRsZXNzIG9mIHdoYXQgaXMgaW5zaWRlKS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuY29tcHV0ZVJvd0xldmVsTGltaXQgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIHJvd0VsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gdGhlIGNvbnRhaW5pbmcgXCJmYWtlXCIgcm93IGRpdlxyXG4gICAgICAgIHZhciByb3dIZWlnaHQgPSByb3dFbC5oZWlnaHQoKTsgLy8gVE9ETzogY2FjaGUgc29tZWhvdz9cclxuICAgICAgICB2YXIgdHJFbHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnRib2R5RWwuY2hpbGRyZW4oKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdHJFbDtcclxuICAgICAgICB2YXIgdHJIZWlnaHQ7XHJcbiAgICAgICAgZnVuY3Rpb24gaXRlcklubmVySGVpZ2h0cyhpLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgdHJIZWlnaHQgPSBNYXRoLm1heCh0ckhlaWdodCwgJChjaGlsZE5vZGUpLm91dGVySGVpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXZlYWwgb25lIGxldmVsIDx0cj4gYXQgYSB0aW1lIGFuZCBzdG9wIHdoZW4gd2UgZmluZCBvbmUgb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ckVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0ckVsID0gdHJFbHMuZXEoaSkucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc3RhdGUgKHJldmVhbClcclxuICAgICAgICAgICAgLy8gd2l0aCByb3dzcGFucz4xIGFuZCBJRTgsIHRyRWwub3V0ZXJIZWlnaHQoKSB3b3VsZCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgbGFyZ2VzdCBjZWxsLFxyXG4gICAgICAgICAgICAvLyBzbyBpbnN0ZWFkLCBmaW5kIHRoZSB0YWxsZXN0IGlubmVyIGNvbnRlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgdHJIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0ckVsLmZpbmQoJz4gdGQgPiA6Zmlyc3QtY2hpbGQnKS5lYWNoKGl0ZXJJbm5lckhlaWdodHMpO1xyXG4gICAgICAgICAgICBpZiAodHJFbC5wb3NpdGlvbigpLnRvcCArIHRySGVpZ2h0ID4gcm93SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHNob3VsZCBub3QgbGltaXQgYXQgYWxsXHJcbiAgICB9O1xyXG4gICAgLy8gTGltaXRzIHRoZSBnaXZlbiBncmlkIHJvdyB0byB0aGUgbWF4aW11bSBudW1iZXIgb2YgbGV2ZWxzIGFuZCBpbmplY3RzIFwibW9yZVwiIGxpbmtzIGlmIG5lY2Vzc2FyeS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgLy8gYGxldmVsTGltaXRgIGlzIGEgbnVtYmVyIGZvciB0aGUgbWF4aW11bSAoaW5jbHVzaXZlKSBudW1iZXIgb2YgbGV2ZWxzIGFsbG93ZWQuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5saW1pdFJvdyA9IGZ1bmN0aW9uIChyb3csIGxldmVsTGltaXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3QgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddO1xyXG4gICAgICAgIHZhciBtb3JlTm9kZXMgPSBbXTsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPGE+IGxpbmtzIGFuZCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgIHZhciBjb2wgPSAwOyAvLyBjb2wgIywgbGVmdC10by1yaWdodCAobm90IGNocm9ub2xvZ2ljYWxseSlcclxuICAgICAgICB2YXIgbGV2ZWxTZWdzOyAvLyBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMgaW4gdGhlIGxhc3QgYWxsb3dhYmxlIGxldmVsLCBvcmRlcmVkIGxlZnQtdG8tcmlnaHRcclxuICAgICAgICB2YXIgY2VsbE1hdHJpeDsgLy8gYSBtYXRyaXggKGJ5IGxldmVsLCB0aGVuIGNvbHVtbikgb2YgYWxsIDx0ZD4galF1ZXJ5IGVsZW1lbnRzIGluIHRoZSByb3dcclxuICAgICAgICB2YXIgbGltaXRlZE5vZGVzOyAvLyBhcnJheSBvZiB0ZW1wb3JhcmlseSBoaWRkZW4gbGV2ZWwgPHRyPiBhbmQgc2VnbWVudCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGJlbG93IGBzZWdgIGluIHRoZSBjdXJyZW50IGBjb2xgXHJcbiAgICAgICAgdmFyIHRvdGFsU2Vnc0JlbG93OyAvLyB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgYmVsb3cgYHNlZ2AgaW4gYW55IG9mIHRoZSBjb2x1bW5zIGBzZWdgIG9jY3VwaWVzXHJcbiAgICAgICAgdmFyIGNvbFNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBhcnJheXMsIGJlbG93IHNlZywgb25lIGZvciBlYWNoIGNvbHVtbiAob2Zmc2V0IGZyb20gc2VncydzIGZpcnN0IGNvbHVtbilcclxuICAgICAgICB2YXIgdGQ7XHJcbiAgICAgICAgdmFyIHJvd3NwYW47XHJcbiAgICAgICAgdmFyIHNlZ01vcmVOb2RlczsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPHRkPiBjZWxscyB0aGF0IHdpbGwgc3RhbmQtaW4gZm9yIHRoZSBjdXJyZW50IHNlZydzIGNlbGxcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgbW9yZVRkO1xyXG4gICAgICAgIHZhciBtb3JlV3JhcDtcclxuICAgICAgICB2YXIgbW9yZUxpbms7XHJcbiAgICAgICAgLy8gSXRlcmF0ZXMgdGhyb3VnaCBlbXB0eSBsZXZlbCBjZWxscyBhbmQgcGxhY2VzIFwibW9yZVwiIGxpbmtzIGluc2lkZSBpZiBuZWVkIGJlXHJcbiAgICAgICAgdmFyIGVtcHR5Q2VsbHNVbnRpbCA9IGZ1bmN0aW9uIChlbmRDb2wpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wsIGxldmVsTGltaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZ3NCZWxvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSBfdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIGNvbCwgc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKG1vcmVXcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlTm9kZXMucHVzaChtb3JlV3JhcFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxldmVsTGltaXQgJiYgbGV2ZWxMaW1pdCA8IHJvd1N0cnVjdC5zZWdMZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldmVsU2VncyA9IHJvd1N0cnVjdC5zZWdMZXZlbHNbbGV2ZWxMaW1pdCAtIDFdO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4ID0gcm93U3RydWN0LmNlbGxNYXRyaXg7XHJcbiAgICAgICAgICAgIGxpbWl0ZWROb2RlcyA9IHJvd1N0cnVjdC50Ym9keUVsLmNoaWxkcmVuKCkuc2xpY2UobGV2ZWxMaW1pdCkgLy8gZ2V0IGxldmVsIDx0cj4gZWxlbWVudHMgcGFzdCB0aGUgbGltaXRcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmdldCgpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhvdWdoIHNlZ21lbnRzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoc2VnLmxlZnRDb2wpOyAvLyBwcm9jZXNzIGVtcHR5IGNlbGxzIGJlZm9yZSB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lICphbGwqIHNlZ21lbnRzIGJlbG93IGBzZWdgIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGNvbHVtbnNcclxuICAgICAgICAgICAgICAgIGNvbFNlZ3NCZWxvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdG90YWxTZWdzQmVsb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cucHVzaChzZWdzQmVsb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2Vnc0JlbG93ICs9IHNlZ3NCZWxvdy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG90YWxTZWdzQmVsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW3NlZy5sZWZ0Q29sXTsgLy8gdGhlIHNlZ21lbnQncyBwYXJlbnQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgIHJvd3NwYW4gPSB0ZC5hdHRyKCdyb3dzcGFuJykgfHwgMTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgcmVwbGFjZW1lbnQgPHRkPiBmb3IgZWFjaCBjb2x1bW4gdGhlIHNlZ21lbnQgb2NjdXBpZXMuIHdpbGwgYmUgb25lIGZvciBlYWNoIGNvbHNwYW5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sU2Vnc0JlbG93Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZCA9ICQoJzx0ZCBjbGFzcz1cImZjLW1vcmUtY2VsbFwiLz4nKS5hdHRyKCdyb3dzcGFuJywgcm93c3Bhbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ3NCZWxvdyA9IGNvbFNlZ3NCZWxvd1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSB0aGlzLnJlbmRlck1vcmVMaW5rKHJvdywgc2VnLmxlZnRDb2wgKyBqLCBbc2VnXS5jb25jYXQoc2Vnc0JlbG93KSAvLyBjb3VudCBzZWcgYXMgaGlkZGVuIHRvb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZC5hcHBlbmQobW9yZVdyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmFmdGVyKCQoc2VnTW9yZU5vZGVzKSk7IC8vIGhpZGUgb3JpZ2luYWwgPHRkPiBhbmQgaW5qZWN0IHJlcGxhY2VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ZWROb2Rlcy5wdXNoKHRkWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwodGhpcy5jb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSBsZXZlbFxyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscyA9ICQobW9yZU5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9ICQobGltaXRlZE5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cclxuICAgIC8vIGByb3dgIGlzIGEgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnVubGltaXRSb3cgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd107XHJcbiAgICAgICAgaWYgKHJvd1N0cnVjdC5tb3JlRWxzKSB7XHJcbiAgICAgICAgICAgIHJvd1N0cnVjdC5tb3JlRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3dTdHJ1Y3QubGltaXRlZEVscykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscy5yZW1vdmVDbGFzcygnZmMtbGltaXRlZCcpO1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW4gPGE+IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGhpZGRlbiBldmVudCBlbGVtZW50IGZvciBhIGNlbGwuXHJcbiAgICAvLyBSZXNwb25zaWJsZSBmb3IgYXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgYXMgd2VsbC5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck1vcmVMaW5rID0gZnVuY3Rpb24gKHJvdywgY29sLCBoaWRkZW5TZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJCgnPGEgY2xhc3M9XCJmYy1tb3JlXCIvPicpXHJcbiAgICAgICAgICAgIC50ZXh0KHRoaXMuZ2V0TW9yZUxpbmtUZXh0KGhpZGRlblNlZ3MubGVuZ3RoKSlcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgY2xpY2tPcHRpb24gPSBfdGhpcy5vcHQoJ2V2ZW50TGltaXRDbGljaycpO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IF90aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcclxuICAgICAgICAgICAgdmFyIG1vcmVFbCA9ICQoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciBkYXlFbCA9IF90aGlzLmdldENlbGxFbChyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIHZhciBhbGxTZWdzID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wpO1xyXG4gICAgICAgICAgICAvLyByZXNjb3BlIHRoZSBzZWdtZW50cyB0byBiZSB3aXRoaW4gdGhlIGNlbGwncyBkYXRlXHJcbiAgICAgICAgICAgIHZhciByZXNsaWNlZEFsbFNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhhbGxTZWdzLCBkYXRlKTtcclxuICAgICAgICAgICAgdmFyIHJlc2xpY2VkSGlkZGVuU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGhpZGRlblNlZ3MsIGRhdGUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIGF0b21pYyBvcHRpb25cclxuICAgICAgICAgICAgICAgIGNsaWNrT3B0aW9uID0gX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudExpbWl0Q2xpY2snLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdmlldyxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsOiBkYXlFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVFbDogbW9yZUVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnczogcmVzbGljZWRBbGxTZWdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcmVzbGljZWRIaWRkZW5TZWdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNsaWNrT3B0aW9uID09PSAncG9wb3ZlcicpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNob3dTZWdQb3BvdmVyKHJvdywgY29sLCBtb3JlRWwsIHJlc2xpY2VkQWxsU2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmlldy5jYWxlbmRhci56b29tVG8oZGF0ZSwgY2xpY2tPcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV2ZWFscyB0aGUgcG9wb3ZlciB0aGF0IGRpc3BsYXlzIGFsbCBldmVudHMgd2l0aGluIGEgY2VsbFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuc2hvd1NlZ1BvcG92ZXIgPSBmdW5jdGlvbiAocm93LCBjb2wsIG1vcmVMaW5rLCBzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgbW9yZVdyYXAgPSBtb3JlTGluay5wYXJlbnQoKTsgLy8gdGhlIDxkaXY+IHdyYXBwZXIgYXJvdW5kIHRoZSA8YT5cclxuICAgICAgICB2YXIgdG9wRWw7IC8vIHRoZSBlbGVtZW50IHdlIHdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBjb29yZGluYXRlIG9mXHJcbiAgICAgICAgdmFyIG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMucm93Q250ID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRvcEVsID0gdmlldy5lbDsgLy8gd2lsbCBjYXVzZSB0aGUgcG9wb3ZlciB0byBjb3ZlciBhbnkgc29ydCBvZiBoZWFkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRvcEVsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gd2lsbCBhbGlnbiB3aXRoIHRvcCBvZiByb3dcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmMtbW9yZS1wb3BvdmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQocm93LCBjb2wsIHNlZ3MpLFxyXG4gICAgICAgICAgICBwYXJlbnRFbDogdmlldy5lbCxcclxuICAgICAgICAgICAgdG9wOiB0b3BFbC5vZmZzZXQoKS50b3AsXHJcbiAgICAgICAgICAgIGF1dG9IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgICB2aWV3cG9ydENvbnN0cmFpbjogdGhpcy5vcHQoJ3BvcG92ZXJWaWV3cG9ydENvbnN0cmFpbicpLFxyXG4gICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBraWxsIGV2ZXJ5dGhpbmcgd2hlbiB0aGUgcG9wb3ZlciBpcyBoaWRkZW5cclxuICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBldmVudHMgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnBvcG92ZXJTZWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckJlZm9yZUV2ZW50U2Vnc0Rlc3Ryb3llZChfdGhpcy5wb3BvdmVyU2Vncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucG9wb3ZlclNlZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBEZXRlcm1pbmUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxyXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgbW9yZVdyYXAgaW5zdGVhZCBvZiB0aGUgPHRkPiB0byBhdm9pZCBib3JkZXIgY29uZnVzaW9uLlxyXG4gICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucmlnaHQgPSBtb3JlV3JhcC5vZmZzZXQoKS5sZWZ0ICsgbW9yZVdyYXAub3V0ZXJXaWR0aCgpICsgMTsgLy8gKzEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCAtIDE7IC8vIC0xIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWdQb3BvdmVyID0gbmV3IFBvcG92ZXJfMS5kZWZhdWx0KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2VnUG9wb3Zlci5zaG93KCk7XHJcbiAgICAgICAgLy8gdGhlIHBvcG92ZXIgZG9lc24ndCBsaXZlIHdpdGhpbiB0aGUgZ3JpZCdzIGNvbnRhaW5lciBlbGVtZW50LCBhbmQgdGh1cyB3b24ndCBnZXQgdGhlIGV2ZW50XHJcbiAgICAgICAgLy8gZGVsZWdhdGVkLWhhbmRsZXJzIGZvciBmcmVlLiBhdHRhY2ggZXZlbnQtcmVsYXRlZCBoYW5kbGVycyB0byB0aGUgcG9wb3Zlci5cclxuICAgICAgICB0aGlzLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwodGhpcy5zZWdQb3BvdmVyLmVsKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkKHNlZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgaW5uZXIgRE9NIGNvbnRlbnRzIG9mIHRoZSBzZWdtZW50IHBvcG92ZXJcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlclNlZ1BvcG92ZXJDb250ZW50ID0gZnVuY3Rpb24gKHJvdywgY29sLCBzZWdzKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKS5mb3JtYXQodGhpcy5vcHQoJ2RheVBvcG92ZXJGb3JtYXQnKSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpICsgJ1wiPjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUodGl0bGUpICtcclxuICAgICAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jbGVhclwiLz4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdmFyIHNlZ0NvbnRhaW5lciA9IGNvbnRlbnQuZmluZCgnLmZjLWV2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlbmRlciBlYWNoIHNlZydzIGBlbGAgYW5kIG9ubHkgcmV0dXJuIHRoZSB2aXNpYmxlIHNlZ3NcclxuICAgICAgICBzZWdzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlckZnU2VnRWxzKHNlZ3MsIHRydWUpOyAvLyBkaXNhYmxlUmVzaXppbmc9dHJ1ZVxyXG4gICAgICAgIHRoaXMucG9wb3ZlclNlZ3MgPSBzZWdzO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugc2VnbWVudHMgaW4gdGhlIHBvcG92ZXIgYXJlIG5vdCBwYXJ0IG9mIGEgZ3JpZCBjb29yZGluYXRlIHN5c3RlbSwgcHJvdmlkZSBhIGhpbnQgdG8gYW55XHJcbiAgICAgICAgICAgIC8vIGdyaWRzIHRoYXQgd2FudCB0byBkbyBkcmFnLW4tZHJvcCBhYm91dCB3aGljaCBjZWxsIGl0IGNhbWUgZnJvbVxyXG4gICAgICAgICAgICB0aGlzLmhpdHNOZWVkZWQoKTtcclxuICAgICAgICAgICAgc2Vnc1tpXS5oaXQgPSB0aGlzLmdldENlbGxIaXQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB0aGlzLmhpdHNOb3ROZWVkZWQoKTtcclxuICAgICAgICAgICAgc2VnQ29udGFpbmVyLmFwcGVuZChzZWdzW2ldLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdGhlIGV2ZW50cyB3aXRoaW4gYW4gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzLCByZXNsaWNlIHRoZW0gdG8gYmUgaW4gYSBzaW5nbGUgZGF5XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZXNsaWNlRGF5U2VncyA9IGZ1bmN0aW9uIChzZWdzLCBkYXlEYXRlKSB7XHJcbiAgICAgICAgdmFyIGRheVN0YXJ0ID0gZGF5RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBkYXlFbmQgPSBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIHZhciBkYXlSYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRheVN0YXJ0LCBkYXlFbmQpO1xyXG4gICAgICAgIHZhciBuZXdTZWdzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgc2xpY2VkUmFuZ2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2xpY2VkUmFuZ2UgPSBzZWcuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KGRheVJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZWdzLnB1c2goJC5leHRlbmQoe30sIHNlZywge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvb3RwcmludDogbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChzbGljZWRSYW5nZSwgc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpLCBzZWcuZm9vdHByaW50LmV2ZW50RGVmLCBzZWcuZm9vdHByaW50LmV2ZW50SW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5pc0VuZFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvcmNlIGFuIG9yZGVyIGJlY2F1c2UgZXZlbnRzVG9TZWdzIGRvZXNuJ3QgZ3VhcmFudGVlIG9uZVxyXG4gICAgICAgIC8vIFRPRE86IHJlc2VhcmNoIGlmIHN0aWxsIG5lZWRlZFxyXG4gICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5zb3J0RXZlbnRTZWdzKG5ld1NlZ3MpO1xyXG4gICAgICAgIHJldHVybiBuZXdTZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBpbnNpZGUgYSBcIm1vcmVcIiBsaW5rLCBnaXZlbiB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpdCByZXByZXNlbnRzXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRNb3JlTGlua1RleHQgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0KCdldmVudExpbWl0VGV4dCcpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHQobnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnKycgKyBudW0gKyAnICcgKyBvcHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgc2VnbWVudHMgd2l0aGluIGEgZ2l2ZW4gY2VsbC5cclxuICAgIC8vIElmIGBzdGFydExldmVsYCBpcyBzcGVjaWZpZWQsIHJldHVybnMgb25seSBldmVudHMgaW5jbHVkaW5nIGFuZCBiZWxvdyB0aGF0IGxldmVsLiBPdGhlcndpc2UgcmV0dXJucyBhbGwgc2Vncy5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxTZWdzID0gZnVuY3Rpb24gKHJvdywgY29sLCBzdGFydExldmVsKSB7XHJcbiAgICAgICAgdmFyIHNlZ01hdHJpeCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd10uc2VnTWF0cml4O1xyXG4gICAgICAgIHZhciBsZXZlbCA9IHN0YXJ0TGV2ZWwgfHwgMDtcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgd2hpbGUgKGxldmVsIDwgc2VnTWF0cml4Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdNYXRyaXhbbGV2ZWxdW2NvbF07XHJcbiAgICAgICAgICAgIGlmIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldmVsKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlHcmlkO1xyXG59KEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZDtcclxuRGF5R3JpZC5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gRGF5R3JpZEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5EYXlHcmlkLnByb3RvdHlwZS5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5EYXlHcmlkLnByb3RvdHlwZS5oZWxwZXJSZW5kZXJlckNsYXNzID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuZmlsbFJlbmRlcmVyQ2xhc3MgPSBEYXlHcmlkRmlsbFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xLmRlZmF1bHQubWl4SW50byhEYXlHcmlkKTtcclxuRGF5VGFibGVNaXhpbl8xLmRlZmF1bHQubWl4SW50byhEYXlHcmlkKTtcclxuXG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyOCk7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBcImJhc2ljXCIgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBEYXlHcmlkIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxyXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxyXG52YXIgQmFzaWNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzaWNWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFzaWNWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kYXlHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZC5pc1JpZ2lkID0gX3RoaXMuaGFzUmlnaWRSb3dzKCk7XHJcbiAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnMnKSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCd3ZWVrTnVtYmVyc1dpdGhpbkRheXMnKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY29sV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY29sV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5kYXlHcmlkKTtcclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMuZGF5R3JpZENsYXNzXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlRGF5R3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBhIHN1YmNsYXNzIG9uIHRoZSBmbHkgd2l0aCBCYXNpY1ZpZXctc3BlY2lmaWMgYmVoYXZpb3JcclxuICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGlzIHN1YmNsYXNzXHJcbiAgICAgICAgdmFyIHN1YmNsYXNzID0gbWFrZURheUdyaWRTdWJjbGFzcyh0aGlzLmRheUdyaWRDbGFzcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXlHcmlkLmJyZWFrT25XZWVrcyA9IC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlci5jYWxsKHRoaXMsIGRhdGVQcm9maWxlKTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXlHcmlkQ29udGFpbmVyRWw7XHJcbiAgICAgICAgdmFyIGRheUdyaWRFbDtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1iYXNpYy12aWV3JykuaHRtbCh0aGlzLnJlbmRlclNrZWxldG9uSHRtbCgpKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGRheUdyaWRDb250YWluZXJFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLWRheS1ncmlkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIGRheUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiIC8+JykuYXBwZW5kVG8oZGF5R3JpZENvbnRhaW5lckVsKTtcclxuICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZChkYXlHcmlkQ29udGFpbmVyRWwpO1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5oZWFkQ29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KGRheUdyaWRFbCk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cclxuICAgIC8vIFRoZSBkYXktZ3JpZCBjb21wb25lbnQgd2lsbCByZW5kZXIgaW5zaWRlIG9mIGEgY29udGFpbmVyIGRlZmluZWQgYnkgdGhpcyBIVE1MLlxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbkh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XHJcbiAgICAgICAgICAgICAgICAnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj48L3RkPicgK1xyXG4gICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgJzwvdGJvZHk+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIGFuIEhUTUwgYXR0cmlidXRlIHN0cmluZyBmb3Igc2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIHdlZWsgbnVtYmVyIGNvbHVtbiwgaWYgaXQgaXMga25vd25cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUud2Vla051bWJlclN0eWxlQXR0ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyV2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMud2Vla051bWJlcldpZHRoICsgJ3B4XCInO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGVhY2ggcm93IHNob3VsZCBoYXZlIGEgY29uc3RhbnQgaGVpZ2h0XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmhhc1JpZ2lkUm93cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInO1xyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgIHZhciBoZWFkUm93RWwgPSB0aGlzLmRheUdyaWQuaGVhZENvbnRhaW5lckVsLmZpbmQoJy5mYy1yb3cnKTtcclxuICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRocztcclxuICAgICAgICAvLyBoYWNrIHRvIGdpdmUgdGhlIHZpZXcgc29tZSBoZWlnaHQgcHJpb3IgdG8gZGF5R3JpZCdzIGNvbHVtbnMgYmVpbmcgcmVuZGVyZWRcclxuICAgICAgICAvLyBUT0RPOiBzZXBhcmF0ZSBzZXR0aW5nIGhlaWdodCBmcm9tIHNjcm9sbGVyIFZTIGRheUdyaWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmRheUdyaWQucm93RWxzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHdlZWsgbnVtYmVyIGNlbGxzIHJ1bm5pbmcgZG93biB0aGUgc2lkZSBoYXZlIHRoZSBzYW1lIHdpZHRoLlxyXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHdpZHRoIGZvciBjZWxscyBjcmVhdGVkIGxhdGVyLlxyXG4gICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJXaWR0aCA9IHV0aWxfMS5tYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtd2Vlay1udW1iZXInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc2V0IGFsbCBoZWlnaHRzIHRvIGJlIG5hdHVyYWxcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmNsZWFyKCk7XHJcbiAgICAgICAgdXRpbF8xLnVuY29tcGVuc2F0ZVNjcm9sbChoZWFkUm93RWwpO1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXHJcbiAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGEgY29uc3RhbnQgbGV2ZWwgbnVtYmVyP1xyXG4gICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGZpcnN0IHNvIHRoZSBoZWlnaHQgY2FuIHJlZGlzdHJpYnV0ZSBhZnRlclxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaXN0cmlidXRlIHRoZSBoZWlnaHQgdG8gdGhlIHJvd3NcclxuICAgICAgICAvLyAodG90YWxIZWlnaHQgaXMgYSBcInJlY29tbWVuZGVkXCIgdmFsdWUgaWYgaXNBdXRvKVxyXG4gICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc2V0R3JpZEhlaWdodChzY3JvbGxlckhlaWdodCwgaXNBdXRvKTtcclxuICAgICAgICAvLyBpcyB0aGUgZXZlbnQgbGltaXQgZHluYW1pY2FsbHkgY2FsY3VsYXRlZD9cclxuICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBhZnRlciB0aGUgZ3JpZCdzIHJvdyBoZWlnaHRzIGhhdmUgYmVlbiBzZXRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuY29tcGVuc2F0ZVNjcm9sbChoZWFkUm93RWwsIHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2luZyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNyZWF0ZWQgdGV4dCBvdmVyZmxvdyB3aGljaCBjcmVhdGVkIG1vcmUgaGVpZ2h0LiByZWRvXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVzIHRoZSBzYW1lIHNjcm9sbGJhciB3aWR0aHNcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJIZWlnaHQgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdG90YWxIZWlnaHQgLVxyXG4gICAgICAgICAgICB1dGlsXzEuc3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXHJcbiAgICB9O1xyXG4gICAgLy8gU2V0cyB0aGUgaGVpZ2h0IG9mIGp1c3QgdGhlIERheUdyaWQgY29tcG9uZW50IGluIHRoaXMgdmlld1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5zZXRHcmlkSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgaWYgKGlzQXV0bykge1xyXG4gICAgICAgICAgICB1dGlsXzEudW5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMpOyAvLyBsZXQgdGhlIHJvd3MgYmUgdGhlaXIgbmF0dXJhbCBoZWlnaHQgd2l0aCBubyBleHBhbmRpbmdcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgdHJ1ZSk7IC8vIHRydWUgPSBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogMCB9O1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKSB9O1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuYXBwbHlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3Aoc2Nyb2xsLnRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBCYXNpY1ZpZXc7XHJcbn0oVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzaWNWaWV3O1xyXG5CYXNpY1ZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQ7XHJcbkJhc2ljVmlldy5wcm90b3R5cGUuZGF5R3JpZENsYXNzID0gRGF5R3JpZF8xLmRlZmF1bHQ7XHJcbi8vIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIEJhc2ljVmlldydzIGRheUdyaWRcclxuZnVuY3Rpb24gbWFrZURheUdyaWRTdWJjbGFzcyhTdXBlckNsYXNzKSB7XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKFN1YkNsYXNzLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFN1YkNsYXNzKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7IC8vIGRpc3BsYXkgd2VlayBudW1iZXJzIGFsb25nIHRoZSBzaWRlP1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIHRoZSBkYXktb2Ygd2VlayBoZWFkZXIgY2VsbHNcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVySGVhZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHRoaXMub3B0KCd3ZWVrTnVtYmVyVGl0bGUnKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGg+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSBjb250ZW50LXNrZWxldG9uIGNlbGxzIHRoYXQgZGlzcGxheSB0aGUgZGF5L3dlZWsgbnVtYmVyc1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICB2YXIgd2Vla1N0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiB0aGlzLmNvbENudCA9PT0gMSB9LCB3ZWVrU3RhcnQuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGRheSBiZyBjZWxscyBmb3IgZWFjaCBkYXktcm93XHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBldmVyeSBvdGhlciB0eXBlIG9mIHJvdyBnZW5lcmF0ZWQgYnkgRGF5R3JpZC5cclxuICAgICAgICAvLyBBZmZlY3RzIGhlbHBlci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRGF5R3JpZF8xLmRlZmF1bHQucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTdWJDbGFzcztcclxuICAgIH0oU3VwZXJDbGFzcykpO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDYzICovLFxuLyogNjQgKi8sXG4vKiA2NSAqLyxcbi8qIDY2ICovLFxuLyogNjcgKi8sXG4vKiA2OCAqLyxcbi8qIDY5ICovLFxuLyogNzAgKi8sXG4vKiA3MSAqLyxcbi8qIDcyICovLFxuLyogNzMgKi8sXG4vKiA3NCAqLyxcbi8qIDc1ICovLFxuLyogNzYgKi8sXG4vKiA3NyAqLyxcbi8qIDc4ICovLFxuLyogNzkgKi8sXG4vKiA4MCAqLyxcbi8qIDgxICovLFxuLyogODIgKi8sXG4vKiA4MyAqLyxcbi8qIDg0ICovLFxuLyogODUgKi8sXG4vKiA4NiAqLyxcbi8qIDg3ICovLFxuLyogODggKi8sXG4vKiA4OSAqLyxcbi8qIDkwICovLFxuLyogOTEgKi8sXG4vKiA5MiAqLyxcbi8qIDkzICovLFxuLyogOTQgKi8sXG4vKiA5NSAqLyxcbi8qIDk2ICovLFxuLyogOTcgKi8sXG4vKiA5OCAqLyxcbi8qIDk5ICovLFxuLyogMTAwICovLFxuLyogMTAxICovLFxuLyogMTAyICovLFxuLyogMTAzICovLFxuLyogMTA0ICovLFxuLyogMTA1ICovLFxuLyogMTA2ICovLFxuLyogMTA3ICovLFxuLyogMTA4ICovLFxuLyogMTA5ICovLFxuLyogMTEwICovLFxuLyogMTExICovLFxuLyogMTEyICovLFxuLyogMTEzICovLFxuLyogMTE0ICovLFxuLyogMTE1ICovLFxuLyogMTE2ICovLFxuLyogMTE3ICovLFxuLyogMTE4ICovLFxuLyogMTE5ICovLFxuLyogMTIwICovLFxuLyogMTIxICovLFxuLyogMTIyICovLFxuLyogMTIzICovLFxuLyogMTI0ICovLFxuLyogMTI1ICovLFxuLyogMTI2ICovLFxuLyogMTI3ICovLFxuLyogMTI4ICovLFxuLyogMTI5ICovLFxuLyogMTMwICovLFxuLyogMTMxICovLFxuLyogMTMyICovLFxuLyogMTMzICovLFxuLyogMTM0ICovLFxuLyogMTM1ICovLFxuLyogMTM2ICovLFxuLyogMTM3ICovLFxuLyogMTM4ICovLFxuLyogMTM5ICovLFxuLyogMTQwICovLFxuLyogMTQxICovLFxuLyogMTQyICovLFxuLyogMTQzICovLFxuLyogMTQ0ICovLFxuLyogMTQ1ICovLFxuLyogMTQ2ICovLFxuLyogMTQ3ICovLFxuLyogMTQ4ICovLFxuLyogMTQ5ICovLFxuLyogMTUwICovLFxuLyogMTUxICovLFxuLyogMTUyICovLFxuLyogMTUzICovLFxuLyogMTU0ICovLFxuLyogMTU1ICovLFxuLyogMTU2ICovLFxuLyogMTU3ICovLFxuLyogMTU4ICovLFxuLyogMTU5ICovLFxuLyogMTYwICovLFxuLyogMTYxICovLFxuLyogMTYyICovLFxuLyogMTYzICovLFxuLyogMTY0ICovLFxuLyogMTY1ICovLFxuLyogMTY2ICovLFxuLyogMTY3ICovLFxuLyogMTY4ICovLFxuLyogMTY5ICovLFxuLyogMTcwICovLFxuLyogMTcxICovLFxuLyogMTcyICovLFxuLyogMTczICovLFxuLyogMTc0ICovLFxuLyogMTc1ICovLFxuLyogMTc2ICovLFxuLyogMTc3ICovLFxuLyogMTc4ICovLFxuLyogMTc5ICovLFxuLyogMTgwICovLFxuLyogMTgxICovLFxuLyogMTgyICovLFxuLyogMTgzICovLFxuLyogMTg0ICovLFxuLyogMTg1ICovLFxuLyogMTg2ICovLFxuLyogMTg3ICovLFxuLyogMTg4ICovLFxuLyogMTg5ICovLFxuLyogMTkwICovLFxuLyogMTkxICovLFxuLyogMTkyICovLFxuLyogMTkzICovLFxuLyogMTk0ICovLFxuLyogMTk1ICovLFxuLyogMTk2ICovLFxuLyogMTk3ICovLFxuLyogMTk4ICovLFxuLyogMTk5ICovLFxuLyogMjAwICovLFxuLyogMjAxICovLFxuLyogMjAyICovLFxuLyogMjAzICovLFxuLyogMjA0ICovLFxuLyogMjA1ICovLFxuLyogMjA2ICovLFxuLyogMjA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBFdmVudERlZlBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgQ29uc3RyYWludHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb25zdHJhaW50cyhldmVudE1hbmFnZXIsIF9jYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgfVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGVuZGFyLm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgZGV0ZXJtaW5lcyBpZiBldmVudEluc3RhbmNlR3JvdXAgaXMgYWxsb3dlZCxcclxuICAgIGluIHJlbGF0aW9uIHRvIG90aGVyIEVWRU5UUyBhbmQgYnVzaW5lc3MgaG91cnMuXHJcbiAgICAqL1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBldmVudEluc3RhbmNlR3JvdXAuZ2V0RXZlbnREZWYoKTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRBbGxFdmVudFJhbmdlcygpKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50SW5zdGFuY2VzID0gdGhpcy5nZXRQZWVyRXZlbnRJbnN0YW5jZXMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRSYW5nZXMgPSBwZWVyRXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhwZWVyRXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBjb25zdHJhaW50VmFsID0gZXZlbnREZWYuZ2V0Q29uc3RyYWludCgpO1xyXG4gICAgICAgIHZhciBvdmVybGFwVmFsID0gZXZlbnREZWYuZ2V0T3ZlcmxhcCgpO1xyXG4gICAgICAgIHZhciBldmVudEFsbG93RnVuYyA9IHRoaXMub3B0KCdldmVudEFsbG93Jyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGb290cHJpbnRBbGxvd2VkKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHMsIGNvbnN0cmFpbnRWYWwsIG92ZXJsYXBWYWwsIGV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudEFsbG93RnVuYykge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRBbGxvd0Z1bmMoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludC50b0xlZ2FjeSh0aGlzLl9jYWxlbmRhciksIGV2ZW50Rm9vdHByaW50c1tpXS5nZXRFdmVudExlZ2FjeSgpKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmdldFBlZXJFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZChldmVudERlZi5pZCk7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgcGVlckV2ZW50SW5zdGFuY2VzID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXMoKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50UmFuZ2VzID0gcGVlckV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMocGVlckV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgc2VsZWN0QWxsb3dGdW5jO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRm9vdHByaW50QWxsb3dlZChjb21wb25lbnRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHMsIHRoaXMub3B0KCdzZWxlY3RDb25zdHJhaW50JyksIHRoaXMub3B0KCdzZWxlY3RPdmVybGFwJykpKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdEFsbG93RnVuYyA9IHRoaXMub3B0KCdzZWxlY3RBbGxvdycpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0QWxsb3dGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0QWxsb3dGdW5jKGNvbXBvbmVudEZvb3RwcmludC50b0xlZ2FjeSh0aGlzLl9jYWxlbmRhcikpICE9PSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNGb290cHJpbnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCwgcGVlckV2ZW50Rm9vdHByaW50cywgY29uc3RyYWludFZhbCwgb3ZlcmxhcFZhbCwgc3ViamVjdEV2ZW50SW5zdGFuY2UgLy8gb3B0aW9uYWxcclxuICAgICkge1xyXG4gICAgICAgIHZhciBjb25zdHJhaW50Rm9vdHByaW50czsgLy8gQ29tcG9uZW50Rm9vdHByaW50W11cclxuICAgICAgICB2YXIgb3ZlcmxhcEV2ZW50Rm9vdHByaW50czsgLy8gRXZlbnRGb290cHJpbnRbXVxyXG4gICAgICAgIGlmIChjb25zdHJhaW50VmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3RyYWludEZvb3RwcmludHMgPSB0aGlzLmNvbnN0cmFpbnRWYWxUb0Zvb3RwcmludHMoY29uc3RyYWludFZhbCwgY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9vdHByaW50V2l0aGluQ29uc3RyYWludHMoY29tcG9uZW50Rm9vdHByaW50LCBjb25zdHJhaW50Rm9vdHByaW50cykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvdmVybGFwRXZlbnRGb290cHJpbnRzID0gdGhpcy5jb2xsZWN0T3ZlcmxhcEV2ZW50Rm9vdHByaW50cyhwZWVyRXZlbnRGb290cHJpbnRzLCBjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIGlmIChvdmVybGFwVmFsID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3ZlcmxhcFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoIWlzT3ZlcmxhcHNBbGxvd2VkQnlGdW5jKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIG92ZXJsYXBWYWwsIHN1YmplY3RFdmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdWJqZWN0RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzT3ZlcmxhcEV2ZW50SW5zdGFuY2VzQWxsb3dlZChvdmVybGFwRXZlbnRGb290cHJpbnRzLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvLyBDb25zdHJhaW50XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc0Zvb3RwcmludFdpdGhpbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCwgY29uc3RyYWludEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uc3RyYWludEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9vdHByaW50Q29udGFpbnNGb290cHJpbnQoY29uc3RyYWludEZvb3RwcmludHNbaV0sIGNvbXBvbmVudEZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuY29uc3RyYWludFZhbFRvRm9vdHByaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50VmFsLCBpc0FsbERheSkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcztcclxuICAgICAgICBpZiAoY29uc3RyYWludFZhbCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQ3VycmVudEJ1c2luZXNzRm9vdHByaW50cyhpc0FsbERheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25zdHJhaW50VmFsID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlcyA9IHRoaXMucGFyc2VFdmVudERlZlRvSW5zdGFuY2VzKGNvbnN0cmFpbnRWYWwpOyAvLyBoYW5kbGVzIHJlY3VycmluZyBldmVudHNcclxuICAgICAgICAgICAgaWYgKCFldmVudEluc3RhbmNlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb290cHJpbnRzKGNvbnN0cmFpbnRWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMoZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbnN0cmFpbnRWYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlcyA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzV2l0aElkKGNvbnN0cmFpbnRWYWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyhldmVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHJldHVybnMgQ29tcG9uZW50Rm9vdHByaW50W11cclxuICAgIC8vIHVzZXMgY3VycmVudCB2aWV3J3MgcmFuZ2VcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5idWlsZEN1cnJlbnRCdXNpbmVzc0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2NhbGVuZGFyLnZpZXc7XHJcbiAgICAgICAgdmFyIGJ1c2luZXNzSG91ckdlbmVyYXRvciA9IHZpZXcuZ2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InKTtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gdmlldy5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGJ1c2luZXNzSG91ckdlbmVyYXRvci5idWlsZEV2ZW50SW5zdGFuY2VHcm91cChpc0FsbERheSwgdW56b25lZFJhbmdlKTtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNvbnZlcnNpb24gdXRpbFxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50UmFuZ2VzID0gZXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICByZXR1cm4gZXZlbnRGb290cHJpbnRzLm1hcCh1dGlsXzEuZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICB9O1xyXG4gICAgLy8gT3ZlcmxhcFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuY29sbGVjdE92ZXJsYXBFdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAocGVlckV2ZW50Rm9vdHByaW50cywgdGFyZ2V0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBFdmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGVlckV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb290cHJpbnRzSW50ZXJzZWN0KHRhcmdldEZvb3RwcmludCwgcGVlckV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybGFwRXZlbnRGb290cHJpbnRzLnB1c2gocGVlckV2ZW50Rm9vdHByaW50c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG92ZXJsYXBFdmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29udmVyc2lvbjogZXZlbnREZWZzIC0+IGV2ZW50SW5zdGFuY2VzIC0+IGV2ZW50UmFuZ2VzIC0+IGV2ZW50Rm9vdHByaW50cyAtPiBjb21wb25lbnRGb290cHJpbnRzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIE5PVEU6IHRoaXMgbWlnaHQgc2VlbSBsaWtlIHJlcGV0aXRpdmUgY29kZSB3aXRoIHRoZSBHcmlkIGNsYXNzLCBob3dldmVyLCB0aGlzIGNvZGUgaXMgcmVsYXRlZCB0b1xyXG4gICAgLy8gY29uc3RyYWludHMgd2hlcmVhcyB0aGUgR3JpZCBjb2RlIGlzIHJlbGF0ZWQgdG8gcmVuZGVyaW5nLiBFYWNoIGFwcHJvYWNoIG1pZ2h0IHdhbnQgdG8gY29udmVydFxyXG4gICAgLy8gZXZlbnRSYW5nZXMgLT4gZXZlbnRGb290cHJpbnRzIGluIGEgZGlmZmVyZW50IHdheS4gUmVnYXJkbGVzcywgdGhlcmUgYXJlIG9wcG9ydHVuaXRpZXMgdG8gbWFrZVxyXG4gICAgLy8gdGhpcyBtb3JlIERSWS5cclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIGZhbHNlIG9uIGludmFsaWQgaW5wdXQuXHJcbiAgICAqL1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLnBhcnNlRXZlbnREZWZUb0luc3RhbmNlcyA9IGZ1bmN0aW9uIChldmVudElucHV0KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IEV2ZW50RGVmUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShldmVudElucHV0LCBuZXcgRXZlbnRTb3VyY2VfMS5kZWZhdWx0KHRoaXMuX2NhbGVuZGFyKSk7XHJcbiAgICAgICAgaWYgKCFldmVudERlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudERlZi5idWlsZEluc3RhbmNlcyhldmVudE1hbmFnZXIuY3VycmVudFBlcmlvZC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudFJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMucHVzaC5hcHBseSgvLyBmb290cHJpbnRzXHJcbiAgICAgICAgICAgIGV2ZW50Rm9vdHByaW50cywgdGhpcy5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50cztcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gW3V0aWxfMS5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludChldmVudFJhbmdlKV07XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFBhcnNlcyBmb290cHJpbnRzIGRpcmVjdGx5LlxyXG4gICAgVmVyeSBzaW1pbGFyIHRvIEV2ZW50RGF0ZVByb2ZpbGU6OnBhcnNlIDooXHJcbiAgICAqL1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLnBhcnNlRm9vdHByaW50cyA9IGZ1bmN0aW9uIChyYXdJbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIGlmIChyYXdJbnB1dC5zdGFydCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuX2NhbGVuZGFyLm1vbWVudChyYXdJbnB1dC5zdGFydCk7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd0lucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLl9jYWxlbmRhci5tb21lbnQocmF3SW5wdXQuZW5kKTtcclxuICAgICAgICAgICAgaWYgKCFlbmQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpLCAoc3RhcnQgJiYgIXN0YXJ0Lmhhc1RpbWUoKSkgfHwgKGVuZCAmJiAhZW5kLmhhc1RpbWUoKSkgLy8gaXNBbGxEYXlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgLy8gRm9vdHByaW50IFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZm9vdHByaW50Q29udGFpbnNGb290cHJpbnQgPSBmdW5jdGlvbiAob3V0ZXJGb290cHJpbnQsIGlubmVyRm9vdHByaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG91dGVyRm9vdHByaW50LnVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGlubmVyRm9vdHByaW50LnVuem9uZWRSYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmZvb3RwcmludHNJbnRlcnNlY3QgPSBmdW5jdGlvbiAoZm9vdHByaW50MCwgZm9vdHByaW50MSkge1xyXG4gICAgICAgIHJldHVybiBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5pbnRlcnNlY3RzV2l0aChmb290cHJpbnQxLnVuem9uZWRSYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnN0cmFpbnRzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb25zdHJhaW50cztcclxuLy8gb3B0aW9uYWwgc3ViamVjdEV2ZW50SW5zdGFuY2VcclxuZnVuY3Rpb24gaXNPdmVybGFwc0FsbG93ZWRCeUZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgb3ZlcmxhcEZ1bmMsIHN1YmplY3RFdmVudEluc3RhbmNlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBvdmVybGFwRXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFvdmVybGFwRnVuYyhvdmVybGFwRXZlbnRGb290cHJpbnRzW2ldLmV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSwgc3ViamVjdEV2ZW50SW5zdGFuY2UgPyBzdWJqZWN0RXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpIDogbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT3ZlcmxhcEV2ZW50SW5zdGFuY2VzQWxsb3dlZChvdmVybGFwRXZlbnRGb290cHJpbnRzLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgdmFyIHN1YmplY3RMZWdhY3lJbnN0YW5jZSA9IHN1YmplY3RFdmVudEluc3RhbmNlLnRvTGVnYWN5KCk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBvdmVybGFwRXZlbnRJbnN0YW5jZTtcclxuICAgIHZhciBvdmVybGFwRXZlbnREZWY7XHJcbiAgICB2YXIgb3ZlcmxhcFZhbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBvdmVybGFwRXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb3ZlcmxhcEV2ZW50SW5zdGFuY2UgPSBvdmVybGFwRXZlbnRGb290cHJpbnRzW2ldLmV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgb3ZlcmxhcEV2ZW50RGVmID0gb3ZlcmxhcEV2ZW50SW5zdGFuY2UuZGVmO1xyXG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8gcGFzcyBpbiBjYWxlbmRhciwgYmVjYXVzZSBkb24ndCB3YW50IHRvIGNvbnNpZGVyIGdsb2JhbCBldmVudE92ZXJsYXAgcHJvcGVydHksXHJcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhbHJlYWR5IGNvbnNpZGVyZWQgdGhhdCBlYXJsaWVyIGluIHRoZSBwcm9jZXNzLlxyXG4gICAgICAgIG92ZXJsYXBWYWwgPSBvdmVybGFwRXZlbnREZWYuZ2V0T3ZlcmxhcCgpO1xyXG4gICAgICAgIGlmIChvdmVybGFwVmFsID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvdmVybGFwVmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICghb3ZlcmxhcFZhbChvdmVybGFwRXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpLCBzdWJqZWN0TGVnYWN5SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypcclxuVVNBR0U6XHJcbiAgaW1wb3J0IHsgZGVmYXVsdCBhcyBQYXJzYWJsZU1vZGVsTWl4aW4sIFBhcnNhYmxlTW9kZWxJbnRlcmZhY2UgfSBmcm9tICcuL1BhcnNhYmxlTW9kZWxNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgYXBwbHlQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlQcm9wcyddXHJcbiAgYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydhcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMnXVxyXG4gIGFwcGx5TWlzY1Byb3BzOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydhcHBseU1pc2NQcm9wcyddXHJcbiAgaXNTdGFuZGFyZFByb3A6IFBhcnNhYmxlTW9kZWxJbnRlcmZhY2VbJ2lzU3RhbmRhcmRQcm9wJ11cclxuICBzdGF0aWMgZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbi5kZWZpbmVTdGFuZGFyZFByb3BzXHJcbiAgc3RhdGljIGNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW4uY29weVZlcmJhdGltU3RhbmRhcmRQcm9wc1xyXG5hZnRlciBjbGFzczpcclxuICBQYXJzYWJsZU1vZGVsTWl4aW4ubWl4SW50byhUaGVDbGFzcylcclxuKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgUGFyc2FibGVNb2RlbE1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUGFyc2FibGVNb2RlbE1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGFyc2FibGVNb2RlbE1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5kZWZpbmVTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHByb3BEZWZzKSB7XHJcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnc3RhbmRhcmRQcm9wTWFwJykpIHtcclxuICAgICAgICAgICAgcHJvdG8uc3RhbmRhcmRQcm9wTWFwID0gT2JqZWN0LmNyZWF0ZShwcm90by5zdGFuZGFyZFByb3BNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1dGlsXzEuY29weU93blByb3BzKHByb3BEZWZzLCBwcm90by5zdGFuZGFyZFByb3BNYXApO1xyXG4gICAgfTtcclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHNyYywgZGVzdCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLnByb3RvdHlwZS5zdGFuZGFyZFByb3BNYXA7XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gbWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChzcmNbcHJvcE5hbWVdICE9IG51bGwgJiYgLy8gaW4gdGhlIHNyYyBvYmplY3Q/XHJcbiAgICAgICAgICAgICAgICBtYXBbcHJvcE5hbWVdID09PSB0cnVlIC8vIGZhbHNlIG1lYW5zIFwiY29weSB2ZXJiYXRpbVwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtwcm9wTmFtZV0gPSBzcmNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIHRydWUvZmFsc2UgZm9yIHN1Y2Nlc3MuXHJcbiAgICBNZWFudCB0byBiZSBvbmx5IGNhbGxlZCBPTkNFLCBhdCBvYmplY3QgY3JlYXRpb24uXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5hcHBseVByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcE1hcCA9IHRoaXMuc3RhbmRhcmRQcm9wTWFwO1xyXG4gICAgICAgIHZhciBtYW51YWxQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBtaXNjUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgcHJvcE5hbWU7XHJcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoc3RhbmRhcmRQcm9wTWFwW3Byb3BOYW1lXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhbmRhcmRQcm9wTWFwW3Byb3BOYW1lXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIG1hbnVhbFByb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1pc2NQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBseU1pc2NQcm9wcyhtaXNjUHJvcHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyhtYW51YWxQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIElmIHN1YmNsYXNzZXMgb3ZlcnJpZGUsIHRoZXkgbXVzdCBjYWxsIHRoaXMgc3VwZXJtZXRob2QgYW5kIHJldHVybiB0aGUgYm9vbGVhbiByZXNwb25zZS5cclxuICAgIE1lYW50IHRvIGJlIG9ubHkgY2FsbGVkIE9OQ0UsIGF0IG9iamVjdCBjcmVhdGlvbi5cclxuICAgICovXHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBDYW4gYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgaW5pdGlhbCBvYmplY3QgY3JlYXRpb24uXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5hcHBseU1pc2NQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBUT0RPOiB3aHkgaXMgdGhpcyBhIG1ldGhvZCB3aGVuIGRlZmluZVN0YW5kYXJkUHJvcHMgaXMgc3RhdGljXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5pc1N0YW5kYXJkUHJvcCA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9wTmFtZSBpbiB0aGlzLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGFyc2FibGVNb2RlbE1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQYXJzYWJsZU1vZGVsTWl4aW47XHJcblBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuc3RhbmRhcmRQcm9wTWFwID0ge307IC8vIHdpbGwgYmUgY2xvbmVkIGJ5IGRlZmluZVN0YW5kYXJkUHJvcHNcclxuXG5cbi8qKiovIH0pLFxuLyogMjA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV2ZW50SW5zdGFuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEluc3RhbmNlKGRlZiwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRlZiA9IGRlZjtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICB9XHJcbiAgICBFdmVudEluc3RhbmNlLnByb3RvdHlwZS50b0xlZ2FjeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLmRlZi50b0xlZ2FjeSgpO1xyXG4gICAgICAgIG9iai5zdGFydCA9IGRhdGVQcm9maWxlLnN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgb2JqLmVuZCA9IGRhdGVQcm9maWxlLmVuZCA/IGRhdGVQcm9maWxlLmVuZC5jbG9uZSgpIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEluc3RhbmNlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEluc3RhbmNlO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbnZhciBFdmVudEluc3RhbmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOSk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVjdXJyaW5nRXZlbnREZWYsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZWN1cnJpbmdFdmVudERlZigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuaXNBbGxEYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YXJ0VGltZSAmJiAhdGhpcy5lbmRUaW1lO1xyXG4gICAgfTtcclxuICAgIFJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5idWlsZEluc3RhbmNlcyA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnNvdXJjZS5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdW56b25lZERhdGUgPSB1bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgdW56b25lZEVuZCA9IHVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICB2YXIgem9uZWREYXlTdGFydDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VTdGFydDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VFbmQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlICh1bnpvbmVkRGF0ZS5pc0JlZm9yZSh1bnpvbmVkRW5kKSkge1xyXG4gICAgICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kb3dIYXNoIHx8IHRoaXMuZG93SGFzaFt1bnpvbmVkRGF0ZS5kYXkoKV0pIHtcclxuICAgICAgICAgICAgICAgIHpvbmVkRGF5U3RhcnQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKHVuem9uZWREYXRlKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSB6b25lZERheVN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0LnRpbWUodGhpcy5zdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUVuZCA9IHpvbmVkRGF5U3RhcnQuY2xvbmUoKS50aW1lKHRoaXMuZW5kVGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChuZXcgRXZlbnRJbnN0YW5jZV8xLmRlZmF1bHQodGhpcywgLy8gZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgICAgbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KGluc3RhbmNlU3RhcnQsIGluc3RhbmNlRW5kLCBjYWxlbmRhcikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1bnpvbmVkRGF0ZS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcztcclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuc2V0RG93ID0gZnVuY3Rpb24gKGRvd051bWJlcnMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG93SGFzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvd0hhc2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb3dOdW1iZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG93SGFzaFtkb3dOdW1iZXJzW2ldXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmID0gX3N1cGVyLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmIChkZWYuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIGRlZi5zdGFydFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5zdGFydFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgZGVmLmVuZFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5lbmRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZG93SGFzaCkge1xyXG4gICAgICAgICAgICBkZWYuZG93SGFzaCA9ICQuZXh0ZW5kKHt9LCB0aGlzLmRvd0hhc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZjtcclxufShFdmVudERlZl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVjdXJyaW5nRXZlbnREZWY7XHJcbi8qXHJcbkhBQ0sgdG8gd29yayB3aXRoIFR5cGVTY3JpcHQgbWl4aW5zXHJcbk5PVEU6IGlmIHN1cGVyLW1ldGhvZCBmYWlscywgc2hvdWxkIHN0aWxsIGF0dGVtcHQgdG8gYXBwbHlcclxuKi9cclxuUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmFwcGx5UHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBFdmVudERlZl8xLmRlZmF1bHQucHJvdG90eXBlLmFwcGx5UHJvcHMuY2FsbCh0aGlzLCByYXdQcm9wcyk7XHJcbiAgICBpZiAocmF3UHJvcHMuc3RhcnQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG1vbWVudC5kdXJhdGlvbihyYXdQcm9wcy5zdGFydCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmF3UHJvcHMuZW5kKSB7XHJcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHJhd1Byb3BzLmVuZCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmF3UHJvcHMuZG93KSB7XHJcbiAgICAgICAgdGhpcy5zZXREb3cocmF3UHJvcHMuZG93KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbn07XHJcbi8vIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblJlY3VycmluZ0V2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgc3RhcnQ6IGZhbHNlLFxyXG4gICAgZW5kOiBmYWxzZSxcclxuICAgIGRvdzogZmFsc2VcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRSYW5nZSh1bnpvbmVkUmFuZ2UsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB1bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZiA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50UmFuZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmFuZ2U7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMgPSB7XHJcbiAgICBzdGFydDogJzA5OjAwJyxcclxuICAgIGVuZDogJzE3OjAwJyxcclxuICAgIGRvdzogWzEsIDIsIDMsIDQsIDVdLFxyXG4gICAgcmVuZGVyaW5nOiAnaW52ZXJzZS1iYWNrZ3JvdW5kJ1xyXG4gICAgLy8gY2xhc3NOYW1lcyBhcmUgZGVmaW5lZCBpbiBidXNpbmVzc0hvdXJzU2VnQ2xhc3Nlc1xyXG59O1xyXG52YXIgQnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnVzaW5lc3NIb3VyR2VuZXJhdG9yKHJhd0NvbXBsZXhEZWYsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5yYXdDb21wbGV4RGVmID0gcmF3Q29tcGxleERlZjtcclxuICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICB9XHJcbiAgICBCdXNpbmVzc0hvdXJHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRXZlbnRJbnN0YW5jZUdyb3VwID0gZnVuY3Rpb24gKGlzQWxsRGF5LCB1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gdGhpcy5idWlsZEV2ZW50RGVmcyhpc0FsbERheSk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICBpZiAoZXZlbnREZWZzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXAgPSBuZXcgRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdCh1dGlsXzEuZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcyhldmVudERlZnMsIHVuem9uZWRSYW5nZSkpO1xyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IGludmVyc2UtYmFja2dyb3VuZCByZW5kZXJpbmcgY2FuIGhhcHBlbiBldmVuIHdoZW4gbm8gZXZlbnRSYW5nZXMgaW4gdmlld1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXAuZXhwbGljaXRFdmVudERlZiA9IGV2ZW50RGVmc1swXTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEV2ZW50RGVmcyA9IGZ1bmN0aW9uIChpc0FsbERheSkge1xyXG4gICAgICAgIHZhciByYXdDb21wbGV4RGVmID0gdGhpcy5yYXdDb21wbGV4RGVmO1xyXG4gICAgICAgIHZhciByYXdEZWZzID0gW107XHJcbiAgICAgICAgdmFyIHJlcXVpcmVEb3cgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZGVmcyA9IFtdO1xyXG4gICAgICAgIGlmIChyYXdDb21wbGV4RGVmID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTIHZlcmJhdGltXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChyYXdDb21wbGV4RGVmKSkge1xyXG4gICAgICAgICAgICByYXdEZWZzID0gW3Jhd0NvbXBsZXhEZWZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkocmF3Q29tcGxleERlZikpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IHJhd0NvbXBsZXhEZWY7XHJcbiAgICAgICAgICAgIHJlcXVpcmVEb3cgPSB0cnVlOyAvLyBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYXdEZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghcmVxdWlyZURvdyB8fCByYXdEZWZzW2ldLmRvdykge1xyXG4gICAgICAgICAgICAgICAgZGVmcy5wdXNoKHRoaXMuYnVpbGRFdmVudERlZihpc0FsbERheSwgcmF3RGVmc1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZzO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91ckdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRFdmVudERlZiA9IGZ1bmN0aW9uIChpc0FsbERheSwgcmF3RGVmKSB7XHJcbiAgICAgICAgdmFyIGZ1bGxSYXdEZWYgPSAkLmV4dGVuZCh7fSwgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUywgcmF3RGVmKTtcclxuICAgICAgICBpZiAoaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgZnVsbFJhd0RlZi5zdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgIGZ1bGxSYXdEZWYuZW5kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlY3VycmluZ0V2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZShmdWxsUmF3RGVmLCBuZXcgRXZlbnRTb3VyY2VfMS5kZWZhdWx0KHRoaXMuY2FsZW5kYXIpIC8vIGR1bW15IHNvdXJjZVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJ1c2luZXNzSG91ckdlbmVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQnVzaW5lc3NIb3VyR2VuZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBTdGFuZGFyZFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhbmRhcmRUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YW5kYXJkVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0YW5kYXJkVGhlbWU7XHJcbn0oVGhlbWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YW5kYXJkVGhlbWU7XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy11bnRoZW1lZCcsXHJcbiAgICB3aWRnZXRIZWFkZXI6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIHdpZGdldENvbnRlbnQ6ICdmYy13aWRnZXQtY29udGVudCcsXHJcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXHJcbiAgICBidXR0b246ICdmYy1idXR0b24nLFxyXG4gICAgY29ybmVyTGVmdDogJ2ZjLWNvcm5lci1sZWZ0JyxcclxuICAgIGNvcm5lclJpZ2h0OiAnZmMtY29ybmVyLXJpZ2h0JyxcclxuICAgIHN0YXRlRGVmYXVsdDogJ2ZjLXN0YXRlLWRlZmF1bHQnLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdmYy1zdGF0ZS1hY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2ZjLXN0YXRlLWRpc2FibGVkJyxcclxuICAgIHN0YXRlSG92ZXI6ICdmYy1zdGF0ZS1ob3ZlcicsXHJcbiAgICBzdGF0ZURvd246ICdmYy1zdGF0ZS1kb3duJyxcclxuICAgIHBvcG92ZXJIZWFkZXI6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIHBvcG92ZXJDb250ZW50OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgLy8gZGF5IGdyaWRcclxuICAgIGhlYWRlclJvdzogJ2ZjLXdpZGdldC1oZWFkZXInLFxyXG4gICAgZGF5Um93OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ2ZjLXdpZGdldC1jb250ZW50J1xyXG59O1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcclxuICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcclxuICAgIHByZXY6ICdmYy1pY29uLWxlZnQtc2luZ2xlLWFycm93JyxcclxuICAgIG5leHQ6ICdmYy1pY29uLXJpZ2h0LXNpbmdsZS1hcnJvdycsXHJcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tbGVmdC1kb3VibGUtYXJyb3cnLFxyXG4gICAgbmV4dFllYXI6ICdmYy1pY29uLXJpZ2h0LWRvdWJsZS1hcnJvdydcclxufTtcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBKcXVlcnlVaVRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSnF1ZXJ5VWlUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEpxdWVyeVVpVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEpxdWVyeVVpVGhlbWU7XHJcbn0oVGhlbWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEpxdWVyeVVpVGhlbWU7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICd1aS13aWRnZXQnLFxyXG4gICAgd2lkZ2V0SGVhZGVyOiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICB3aWRnZXRDb250ZW50OiAndWktd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAndWktYnV0dG9uJyxcclxuICAgIGNvcm5lckxlZnQ6ICd1aS1jb3JuZXItbGVmdCcsXHJcbiAgICBjb3JuZXJSaWdodDogJ3VpLWNvcm5lci1yaWdodCcsXHJcbiAgICBzdGF0ZURlZmF1bHQ6ICd1aS1zdGF0ZS1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAndWktc3RhdGUtYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICd1aS1zdGF0ZS1kaXNhYmxlZCcsXHJcbiAgICBzdGF0ZUhvdmVyOiAndWktc3RhdGUtaG92ZXInLFxyXG4gICAgc3RhdGVEb3duOiAndWktc3RhdGUtZG93bicsXHJcbiAgICB0b2RheTogJ3VpLXN0YXRlLWhpZ2hsaWdodCcsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICd1aS13aWRnZXQtaGVhZGVyJyxcclxuICAgIGRheVJvdzogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICd1aS13aWRnZXQtY29udGVudCdcclxufTtcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICd1aS1pY29uJztcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ3VpLWljb24tY2xvc2V0aGljaycsXHJcbiAgICBwcmV2OiAndWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtdycsXHJcbiAgICBuZXh0OiAndWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtZScsXHJcbiAgICBwcmV2WWVhcjogJ3VpLWljb24tc2Vlay1wcmV2JyxcclxuICAgIG5leHRZZWFyOiAndWktaWNvbi1zZWVrLW5leHQnXHJcbn07XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICd0aGVtZUJ1dHRvbkljb25zJztcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ3RoZW1lSWNvbic7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICd1aS1pY29uLSc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEZ1bmNFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEZ1bmNFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZ1bmNFdmVudFNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHJhd0lucHV0LmV2ZW50cykpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgZXZlbnRzOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnB1c2hMb2FkaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LmNvbnN0cnVjdChmdW5jdGlvbiAob25SZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmZ1bmMuY2FsbChfdGhpcy5jYWxlbmRhciwgc3RhcnQuY2xvbmUoKSwgZW5kLmNsb25lKCksIHRpbWV6b25lLCBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWxlbmRhci5wb3BMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBvblJlc29sdmUoX3RoaXMucGFyc2VFdmVudERlZnMocmF3RXZlbnREZWZzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJpbWl0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmM7XHJcbiAgICB9O1xyXG4gICAgRnVuY0V2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB2YXIgc3VwZXJTdWNjZXNzID0gX3N1cGVyLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMuY2FsbCh0aGlzLCByYXdQcm9wcyk7XHJcbiAgICAgICAgdGhpcy5mdW5jID0gcmF3UHJvcHMuZXZlbnRzO1xyXG4gICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZ1bmNFdmVudFNvdXJjZTtcclxufShFdmVudFNvdXJjZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRnVuY0V2ZW50U291cmNlO1xyXG5GdW5jRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICBldmVudHM6IGZhbHNlIC8vIGRvbid0IGF1dG9tYXRpY2FsbHkgdHJhbnNmZXJcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBKc29uRmVlZEV2ZW50U291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSnNvbkZlZWRFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEpzb25GZWVkRXZlbnRTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgcmF3UHJvcHM7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIHJhdyBpbnB1dFxyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3SW5wdXQudXJsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHJhd0lucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3SW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0geyB1cmw6IHJhd0lucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRTb3VyY2VfMS5kZWZhdWx0LnBhcnNlLmNhbGwodGhpcywgcmF3UHJvcHMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYWpheFNldHRpbmdzID0gdGhpcy5hamF4U2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIG9uU3VjY2VzcyA9IGFqYXhTZXR0aW5ncy5zdWNjZXNzO1xyXG4gICAgICAgIHZhciBvbkVycm9yID0gYWpheFNldHRpbmdzLmVycm9yO1xyXG4gICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gdGhpcy5idWlsZFJlcXVlc3RQYXJhbXMoc3RhcnQsIGVuZCwgdGltZXpvbmUpO1xyXG4gICAgICAgIC8vIHRvZG86IGV2ZW50dWFsbHkgaGFuZGxlIHRoZSBwcm9taXNlJ3MgdGhlbixcclxuICAgICAgICAvLyBkb24ndCBpbnRlcmNlcHQgc3VjY2Vzcy9lcnJvclxyXG4gICAgICAgIC8vIHRobyB3aWxsIGJlIGEgYnJlYWtpbmcgQVBJIGNoYW5nZVxyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIucHVzaExvYWRpbmcoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQuY29uc3RydWN0KGZ1bmN0aW9uIChvblJlc29sdmUsIG9uUmVqZWN0KSB7XHJcbiAgICAgICAgICAgICQuYWpheCgkLmV4dGVuZCh7fSwgLy8gZGVzdGluYXRpb25cclxuICAgICAgICAgICAgSnNvbkZlZWRFdmVudFNvdXJjZS5BSkFYX0RFRkFVTFRTLCBhamF4U2V0dGluZ3MsIHtcclxuICAgICAgICAgICAgICAgIHVybDogX3RoaXMudXJsLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyYXdFdmVudERlZnMsIHN0YXR1cywgeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrUmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrUmVzID0gdXRpbF8xLmFwcGx5QWxsKG9uU3VjY2VzcywgX3RoaXMsIFtyYXdFdmVudERlZnMsIHN0YXR1cywgeGhyXSk7IC8vIHJlZGlyZWN0IGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGNhbGxiYWNrUmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnREZWZzID0gY2FsbGJhY2tSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNvbHZlKF90aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1c1RleHQsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hcHBseUFsbChvbkVycm9yLCBfdGhpcywgW3hociwgc3RhdHVzVGV4dCwgZXJyb3JUaHJvd25dKTsgLy8gcmVkaXJlY3QgYHRoaXNgXHJcbiAgICAgICAgICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmJ1aWxkUmVxdWVzdFBhcmFtcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGFqYXhTZXR0aW5ncyA9IHRoaXMuYWpheFNldHRpbmdzO1xyXG4gICAgICAgIHZhciBzdGFydFBhcmFtO1xyXG4gICAgICAgIHZhciBlbmRQYXJhbTtcclxuICAgICAgICB2YXIgdGltZXpvbmVQYXJhbTtcclxuICAgICAgICB2YXIgY3VzdG9tUmVxdWVzdFBhcmFtcztcclxuICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgc3RhcnRQYXJhbSA9IHRoaXMuc3RhcnRQYXJhbTtcclxuICAgICAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFyYW0gPSBjYWxlbmRhci5vcHQoJ3N0YXJ0UGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kUGFyYW0gPSB0aGlzLmVuZFBhcmFtO1xyXG4gICAgICAgIGlmIChlbmRQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZFBhcmFtID0gY2FsZW5kYXIub3B0KCdlbmRQYXJhbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lem9uZVBhcmFtID0gdGhpcy50aW1lem9uZVBhcmFtO1xyXG4gICAgICAgIGlmICh0aW1lem9uZVBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGltZXpvbmVQYXJhbSA9IGNhbGVuZGFyLm9wdCgndGltZXpvbmVQYXJhbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgJC5hamF4IGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xyXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWpheFNldHRpbmdzLmRhdGEpKSB7XHJcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gYWpheFNldHRpbmdzLmRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gYWpheFNldHRpbmdzLmRhdGEgfHwge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQuZXh0ZW5kKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XHJcbiAgICAgICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gc3RhcnQuZm9ybWF0KCk7XHJcbiAgICAgICAgcGFyYW1zW2VuZFBhcmFtXSA9IGVuZC5mb3JtYXQoKTtcclxuICAgICAgICBpZiAodGltZXpvbmUgJiYgdGltZXpvbmUgIT09ICdsb2NhbCcpIHtcclxuICAgICAgICAgICAgcGFyYW1zW3RpbWV6b25lUGFyYW1dID0gdGltZXpvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJpbWl0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1pc2NQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHRoaXMuYWpheFNldHRpbmdzID0gcmF3UHJvcHM7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5BSkFYX0RFRkFVTFRTID0ge1xyXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgY2FjaGU6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpzb25GZWVkRXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEpzb25GZWVkRXZlbnRTb3VyY2U7XHJcbkpzb25GZWVkRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyICh0cnVlKS4uLlxyXG4gICAgdXJsOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogdHJ1ZSxcclxuICAgIGVuZFBhcmFtOiB0cnVlLFxyXG4gICAgdGltZXpvbmVQYXJhbTogdHJ1ZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBUYXNrUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrUXVldWUoKSB7XHJcbiAgICAgICAgdGhpcy5xID0gW107XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnEucHVzaC5hcHBseSh0aGlzLnEsIGFyZ3MpOyAvLyBhcHBlbmRcclxuICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUuZ2V0SXNJZGxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQ7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS50cnlTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmIHRoaXMuY2FuUnVuTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzdGFydCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1blJlbWFpbmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLmNhblJ1bk5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzUGF1c2VkICYmIHRoaXMucS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5ydW5SZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdGFzaztcclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdGFzayA9IHRoaXMucS5zaGlmdCgpOyAvLyBhbHdheXMgZnJlc2hseSByZWZlcmVuY2UgcS4gbWlnaHQgaGF2ZSBiZWVuIHJlYXNzaWduZWQuXHJcbiAgICAgICAgICAgIHJlcyA9IHRoaXMucnVuVGFzayh0YXNrKTtcclxuICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMudGhlbikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jYW5SdW5OZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuUmVtYWluaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHByZXZlbnQgbWFya2luZyBhcyBzdG9wcGVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICh0aGlzLmNhblJ1bk5leHQoKSk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzdG9wJyk7IC8vIG5vdCByZWFsbHkgYSAnc3RvcCcgLi4uIG1vcmUgb2YgYSAnZHJhaW5lZCdcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGlmICdzdG9wJyBoYW5kbGVyIGFkZGVkIG1vcmUgdGFza3MuLi4uIFRPRE86IHdyaXRlIHRlc3QgZm9yIHRoaXNcclxuICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5ydW5UYXNrID0gZnVuY3Rpb24gKHRhc2spIHtcclxuICAgICAgICByZXR1cm4gdGFzaygpOyAvLyB0YXNrICppcyogdGhlIGZ1bmN0aW9uLCBidXQgc3ViY2xhc3NlcyBjYW4gY2hhbmdlIHRoZSBmb3JtYXQgb2YgYSB0YXNrXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRhc2tRdWV1ZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGFza1F1ZXVlO1xyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGFza1F1ZXVlKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGFza1F1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNyk7XHJcbnZhciBSZW5kZXJRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFJlbmRlclF1ZXVlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyUXVldWUod2FpdHNCeU5hbWVzcGFjZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMud2FpdHNCeU5hbWVzcGFjZSA9IHdhaXRzQnlOYW1lc3BhY2UgfHwge307XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24gKHRhc2tGdW5jLCBuYW1lc3BhY2UsIHR5cGUpIHtcclxuICAgICAgICB2YXIgdGFzayA9IHtcclxuICAgICAgICAgICAgZnVuYzogdGFza0Z1bmMsXHJcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgd2FpdE1zO1xyXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgd2FpdE1zID0gdGhpcy53YWl0c0J5TmFtZXNwYWNlW25hbWVzcGFjZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdGhpcy53YWl0TmFtZXNwYWNlICYmIHdhaXRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5V2FpdCh3YWl0TXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5U3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb21wb3VuZFRhc2sodGFzaykpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLndhaXROYW1lc3BhY2UgJiYgd2FpdE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRXYWl0KG5hbWVzcGFjZSwgd2FpdE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5U3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuc3RhcnRXYWl0ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgd2FpdE1zKSB7XHJcbiAgICAgICAgdGhpcy53YWl0TmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG4gICAgICAgIHRoaXMuc3Bhd25XYWl0KHdhaXRNcyk7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLmRlbGF5V2FpdCA9IGZ1bmN0aW9uICh3YWl0TXMpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53YWl0SWQpO1xyXG4gICAgICAgIHRoaXMuc3Bhd25XYWl0KHdhaXRNcyk7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLnNwYXduV2FpdCA9IGZ1bmN0aW9uICh3YWl0TXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMud2FpdElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLndhaXROYW1lc3BhY2UgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy50cnlTdGFydCgpO1xyXG4gICAgICAgIH0sIHdhaXRNcyk7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLmNsZWFyV2FpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhaXRJZCk7XHJcbiAgICAgICAgICAgIHRoaXMud2FpdElkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy53YWl0TmFtZXNwYWNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLmNhblJ1bk5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFfc3VwZXIucHJvdG90eXBlLmNhblJ1bk5leHQuY2FsbCh0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhaXRpbmcgZm9yIGEgY2VydGFpbiBuYW1lc3BhY2UgdG8gc3RvcCByZWNlaXZpbmcgdGFza3M/XHJcbiAgICAgICAgaWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgZGlmZmVyZW50IG5hbWVzcGFjZSB0YXNrIGluIHRoZSBtZWFudGltZSxcclxuICAgICAgICAgICAgLy8gdGhhdCBmb3JjZXMgYWxsIHByZXZpb3VzbHktd2FpdGluZyB0YXNrcyB0byBzdWRkZW5seSBleGVjdXRlLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGRvIHRoaXMgaW4gY29uc3RhbnQgdGltZS5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocVtpXS5uYW1lc3BhY2UgIT09IHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBhbGxvdyBleGVjdXRpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5ydW5UYXNrID0gZnVuY3Rpb24gKHRhc2spIHtcclxuICAgICAgICB0YXNrLmZ1bmMoKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuY29tcG91bmRUYXNrID0gZnVuY3Rpb24gKG5ld1Rhc2spIHtcclxuICAgICAgICB2YXIgcSA9IHRoaXMucTtcclxuICAgICAgICB2YXIgc2hvdWxkQXBwZW5kID0gdHJ1ZTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdGFzaztcclxuICAgICAgICBpZiAobmV3VGFzay5uYW1lc3BhY2UgJiYgbmV3VGFzay50eXBlID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBpbml0L2FkZC9yZW1vdmUgb3BzIHdpdGggc2FtZSBuYW1lc3BhY2UsIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcclxuICAgICAgICAgICAgZm9yIChpID0gcS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdGFzayA9IHFbaV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhc2sudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luaXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRBcHBlbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGF0ZXN0IGRlc3Ryb3kgaXMgY2FuY2VsbGVkIG91dCBieSBub3QgZG9pbmcgdGhlIGluaXRcclxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5zcGxpY2UoaSwgMSk7IC8vIHJlbW92ZSB0YXNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZEFwcGVuZCkge1xyXG4gICAgICAgICAgICBxLnB1c2gobmV3VGFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaG91bGRBcHBlbmQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlbmRlclF1ZXVlO1xyXG59KFRhc2tRdWV1ZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVuZGVyUXVldWU7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxudmFyIGRhdGVfZm9ybWF0dGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcbnZhciBDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3KTtcclxudmFyIHV0aWxfMiA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRGF0ZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXRlQ29tcG9uZW50KF92aWV3LCBfb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNSVEwgPSBmYWxzZTsgLy8gZnJlcXVlbnRseSBhY2Nlc3NlZCBvcHRpb25zXHJcbiAgICAgICAgX3RoaXMuaGl0c05lZWRlZERlcHRoID0gMDsgLy8gbmVjZXNzYXJ5IGJlY2F1c2UgbXVsdGlwbGUgY2FsbGVycyBtaWdodCBuZWVkIHRoZSBzYW1lIGhpdHNcclxuICAgICAgICBfdGhpcy5oYXNBbGxEYXlCdXNpbmVzc0hvdXJzID0gZmFsc2U7IC8vIFRPRE86IHVuaWZ5IHdpdGggbGFyZ2VVbml0IGFuZCBpc1RpbWVTY2FsZT9cclxuICAgICAgICBfdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBoYWNrIHRvIHNldCBvcHRpb25zIHByaW9yIHRvIHRoZSB0aGlzLm9wdCBjYWxsc1xyXG4gICAgICAgIGlmIChfdmlldykge1xyXG4gICAgICAgICAgICBfdGhpc1sndmlldyddID0gX3ZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfb3B0aW9ucykge1xyXG4gICAgICAgICAgICBfdGhpc1snb3B0aW9ucyddID0gX29wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnVpZCA9IFN0cmluZyhEYXRlQ29tcG9uZW50Lmd1aWQrKyk7XHJcbiAgICAgICAgX3RoaXMuY2hpbGRyZW5CeVVpZCA9IHt9O1xyXG4gICAgICAgIF90aGlzLm5leHREYXlUaHJlc2hvbGQgPSBtb21lbnQuZHVyYXRpb24oX3RoaXMub3B0KCduZXh0RGF5VGhyZXNob2xkJykpO1xyXG4gICAgICAgIF90aGlzLmlzUlRMID0gX3RoaXMub3B0KCdpc1JUTCcpO1xyXG4gICAgICAgIGlmIChfdGhpcy5maWxsUmVuZGVyZXJDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5maWxsUmVuZGVyZXIgPSBuZXcgX3RoaXMuZmlsbFJlbmRlcmVyQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnRSZW5kZXJlckNsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UmVuZGVyZXIgPSBuZXcgX3RoaXMuZXZlbnRSZW5kZXJlckNsYXNzKF90aGlzLCBfdGhpcy5maWxsUmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuaGVscGVyUmVuZGVyZXJDbGFzcyAmJiBfdGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhlbHBlclJlbmRlcmVyID0gbmV3IF90aGlzLmhlbHBlclJlbmRlcmVyQ2xhc3MoX3RoaXMsIF90aGlzLmV2ZW50UmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyAmJiBfdGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIgPSBuZXcgX3RoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyhfdGhpcywgX3RoaXMuZmlsbFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdID0gY2hpbGQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IG9ubHkgZG8gaWYgaXNJbkRvbT9cclxuICAgIC8vIFRPRE86IG1ha2UgcGFydCBvZiBDb21wb25lbnQsIGFsb25nIHdpdGggY2hpbGRyZW4vYmF0Y2gtcmVuZGVyIHN5c3RlbT9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndXBkYXRlU2l6ZScsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gT3B0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZpZXcoKS5vcHQobmFtZSk7IC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wdWJsaWNseVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuX2dldENhbGVuZGFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlci5hcHBseShjYWxlbmRhciwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGFzUHVibGljSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuX2dldENhbGVuZGFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmhhc1B1YmxpY0hhbmRsZXJzLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7IC8vIGZvciByZW5kZXJpbmdcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGVzKGRhdGVQcm9maWxlKTtcclxuICAgICAgICB0aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVEYXRlUmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRGF0ZVVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdleGVjdXRlRGF0ZVVucmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRGF0ZXMoKTtcclxuICAgICAgICB0aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIGRhdGUtY2VsbCBjb250ZW50IG9ubHlcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gZGF0ZS1jZWxsIGNvbnRlbnQgb25seVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIC8vIE5vdy1JbmRpY2F0b3JcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nIHVuaXQsIGxpa2UgJ3NlY29uZCcgb3IgJ21pbnV0ZScgdGhhdCBkZWZpbmVkIGhvdyBvZnRlbiB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvclxyXG4gICAgLy8gc2hvdWxkIGJlIHJlZnJlc2hlZC4gSWYgc29tZXRoaW5nIGZhbHN5IGlzIHJldHVybmVkLCBubyB0aW1lIGluZGljYXRvciBpcyByZW5kZXJlZCBhdCBhbGwuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGF0IHRoZSBnaXZlbiBkYXRldGltZVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyTm93SW5kaWNhdG9yJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbmRvZXMgdGhlIHJlbmRlcmluZyBhY3Rpb25zIGZyb20gcmVuZGVyTm93SW5kaWNhdG9yXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJOb3dJbmRpY2F0b3InLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1c2luZXNzIEhvdXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci5yZW5kZXIoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlckJ1c2luZXNzSG91cnMnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBwcmV2aW91c2x5LXJlbmRlcmVkIGJ1c2luZXNzLWhvdXJzXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyQnVzaW5lc3NIb3VycycsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEaXNwbGF5aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50UmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5yYW5nZVVwZGF0ZWQoKTsgLy8gcG9vcmx5IG5hbWVkIG5vd1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyKGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzWydyZW5kZXJFdmVudHMnXSkge1xyXG4gICAgICAgICAgICB0aGlzWydyZW5kZXJFdmVudHMnXShjb252ZXJ0RXZlbnRzUGF5bG9hZFRvTGVnYWN5QXJyYXkoZXZlbnRzUGF5bG9hZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZUV2ZW50UmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZUV2ZW50VW5yZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXNbJ2Rlc3Ryb3lFdmVudHMnXSkge1xyXG4gICAgICAgICAgICB0aGlzWydkZXN0cm95RXZlbnRzJ10oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QnVzaW5lc3NIb3VyU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuZ2V0T3duQnVzaW5lc3NIb3VyU2VncygpO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgY2hpbGQuZ2V0QnVzaW5lc3NIb3VyU2VncygpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRPd25CdXNpbmVzc0hvdXJTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyLmdldFNlZ3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuZ2V0T3duRXZlbnRTZWdzKCk7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHNlZ3MucHVzaC5hcHBseShzZWdzLCBjaGlsZC5nZXRFdmVudFNlZ3MoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3duRXZlbnRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZW5kZXJlci5nZXRTZWdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZW5kZXJpbmcgVHJpZ2dlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJBZnRlckV2ZW50c1JlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckFmdGVyRXZlbnRTZWdzUmVuZGVyZWQodGhpcy5nZXRFdmVudFNlZ3MoKSk7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50QWZ0ZXJBbGxSZW5kZXInLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGFuIG9wdGltaXphdGlvbiwgYmVjYXVzZSBnZXRFdmVudExlZ2FjeSBpcyBleHBlbnNpdmVcclxuICAgICAgICBpZiAodGhpcy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRBZnRlclJlbmRlcicpKSB7XHJcbiAgICAgICAgICAgIHNlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVnYWN5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeSA9IHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50QWZ0ZXJSZW5kZXInLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGxlZ2FjeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xlZ2FjeSwgc2VnLmVsLCBfdGhpc11cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJCZWZvcmVFdmVudHNEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkKHRoaXMuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJCZWZvcmVFdmVudFNlZ3NEZXN0cm95ZWQgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50RGVzdHJveScpKSB7XHJcbiAgICAgICAgICAgIHNlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVnYWN5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeSA9IHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RGVzdHJveScsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbGVnYWN5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbGVnYWN5LCBzZWcuZWwsIF90aGlzXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVuZGVyaW5nIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gSGlkZXMgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcclxuICAgIC8vIFJFQ1VSU0lWRSB3aXRoIHN1YmNvbXBvbmVudHNcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3dFdmVudHNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkID09PSBldmVudERlZklkICYmXHJcbiAgICAgICAgICAgICAgICBzZWcuZWwgLy8gbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignc2hvd0V2ZW50c1dpdGhJZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2hvd3MgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcclxuICAgIC8vIFJFQ1VSU0lWRSB3aXRoIHN1YmNvbXBvbmVudHNcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhpZGVFdmVudHNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkID09PSBldmVudERlZklkICYmXHJcbiAgICAgICAgICAgICAgICBzZWcuZWwgLy8gbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignaGlkZUV2ZW50c1dpdGhJZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRHJhZy1uLURyb3AgUmVuZGVyaW5nIChmb3IgYm90aCBldmVudHMgYW5kIGV4dGVybmFsIGVsZW1lbnRzKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGRyYWcgb3ZlciB0aGUgZ2l2ZW4gZHJvcCB6b25lLlxyXG4gICAgLy8gSWYgYW4gZXh0ZXJuYWwtZWxlbWVudCwgc2VnIHdpbGwgYmUgYG51bGxgLlxyXG4gICAgLy8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlZEhlbHBlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucmVuZGVyRHJhZyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSGVscGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZW5kZXJlZEhlbHBlcjtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGJlaW5nIGRyYWdnZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyRHJhZycsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJFdmVudFJlc2l6ZScsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyRXZlbnRSZXNpemUnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFNlbGVjdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgdGhlIHNlbGVjdGlvblxyXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGByZW5kZXJTZWxlY3Rpb25gIGFmdGVyIGxlZ2FjeSBpcyBnb25lXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyU2VsZWN0aW9uRm9vdHByaW50JywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBzZWxlY3Rpb25cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJTZWxlY3Rpb24nLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEhpZ2hsaWdodFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGFuIGVtcGhhc2lzIG9uIHRoZSBnaXZlbiBkYXRlIHJhbmdlLiBHaXZlbiBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJIaWdobGlnaHQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlckZvb3RwcmludCgnaGlnaGxpZ2h0JywgY29tcG9uZW50Rm9vdHByaW50LCB7XHJcbiAgICAgICAgICAgICAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZmMtaGlnaGxpZ2h0J107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVySGlnaGxpZ2h0JywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgdGhlIGVtcGhhc2lzIG9uIGEgZGF0ZSByYW5nZVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdoaWdobGlnaHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVySGlnaGxpZ2h0JywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBIaXQgQXJlYXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8ganVzdCBiZWNhdXNlIGFsbCBEYXRlQ29tcG9uZW50cyBzdXBwb3J0IHRoaXMgaW50ZXJmYWNlXHJcbiAgICAvLyBkb2Vzbid0IG1lYW4gdGhleSBuZWVkIHRvIGhhdmUgdGhlaXIgb3duIGludGVybmFsIGNvb3JkIHN5c3RlbS4gdGhleSBjYW4gZGVmZXIgdG8gc3ViLWNvbXBvbmVudHMuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oaXRzTmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMuaGl0c05lZWRlZERlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2hpdHNOZWVkZWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhpdHNOb3ROZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGl0c05lZWRlZERlcHRoICYmICEoLS10aGlzLmhpdHNOZWVkZWREZXB0aCkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignaGl0c05vdE5lZWRlZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVsZWFzZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gY29vcmRpbmF0ZXMgZnJvbSB0aGUgdG9wbGVmdCBvZiB0aGUgZG9jdW1lbnQsIHJldHVybiBkYXRhIGFib3V0IHRoZSBkYXRlLXJlbGF0ZWQgYXJlYSB1bmRlcm5lYXRoLlxyXG4gICAgLy8gQ2FuIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhcmJpdHJhcnkgcHJvcGVydGllcyAoYWx0aG91Z2ggdG9wL3JpZ2h0L2xlZnQvYm90dG9tIGFyZSBlbmNvdXJhZ2VkKS5cclxuICAgIC8vIE11c3QgaGF2ZSBhIGBncmlkYCBwcm9wZXJ0eSwgYSByZWZlcmVuY2UgdG8gdGhpcyBjdXJyZW50IGdyaWQuIFRPRE86IGF2b2lkIHRoaXNcclxuICAgIC8vIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBiZSBwcm9jZXNzZWQgYnkgZ2V0SGl0Rm9vdHByaW50IGFuZCBnZXRIaXRFbC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkJ5VWlkID0gdGhpcy5jaGlsZHJlbkJ5VWlkO1xyXG4gICAgICAgIHZhciB1aWQ7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBmb3IgKHVpZCBpbiBjaGlsZHJlbkJ5VWlkKSB7XHJcbiAgICAgICAgICAgIGhpdCA9IGNoaWxkcmVuQnlVaWRbdWlkXS5xdWVyeUhpdChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0O1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldFNhZmVIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgdmFyIGZvb3RwcmludCA9IHRoaXMuZ2V0SGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9vdHByaW50O1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyB3aGF0IGFib3V0IGJlaW5nIGFic3RyYWN0IT9cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBwb3NpdGlvbi1sZXZlbCBpbmZvcm1hdGlvbiBhYm91dCBhIGRhdGUtcmVsYXRlZCBhcmVhIHdpdGhpbiB0aGUgZ3JpZCxcclxuICAgIC8vIHNob3VsZCByZXR1cm4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IGJlc3QgcmVwcmVzZW50cyBpdC4gcGFzc2VkIHRvIGRheUNsaWNrIGNhbGxiYWNrLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gd2hhdCBhYm91dCBiZWluZyBhYnN0cmFjdCE/XHJcbiAgICB9O1xyXG4gICAgLyogQ29udmVydGluZyBldmVudFJhbmdlIC0+IGV2ZW50Rm9vdHByaW50XHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLnB1c2guYXBwbHkoLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGV2ZW50Rm9vdHByaW50cywgdGhpcy5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50cztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBbdXRpbF8yLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50KGV2ZW50UmFuZ2UpXTtcclxuICAgIH07XHJcbiAgICAvKiBDb252ZXJ0aW5nIGNvbXBvbmVudEZvb3RwcmludC9ldmVudEZvb3RwcmludCAtPiBzZWdzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRGb290cHJpbnRzVG9TZWdzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cykge1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgdGhpcy5ldmVudEZvb3RwcmludFRvU2VncyhldmVudEZvb3RwcmludHNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKSwgYW5kIHRoZSBldmVudCBpdHNlbGYsXHJcbiAgICAvLyBzbGljZXMgaW50byBzZWdtZW50cyBhbmQgYXR0YWNoZXMgZXZlbnQtZGVyaXZlZCBwcm9wZXJ0aWVzIHRvIHRoZW0uXHJcbiAgICAvLyBldmVudFNwYW4gLSB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kLCBvdGhlcnRoaW5ncy4uLiB9XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBzZWdzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgc2VncyA9IHRoaXMuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgaWYgKCF1bnpvbmVkUmFuZ2UuaXNTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXVuem9uZWRSYW5nZS5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnLmZvb3RwcmludCA9IGV2ZW50Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZW5hbWUgdG8gc2VnLmV2ZW50Rm9vdHByaW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FsbENoaWxkcmVuID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGFyZ3MpIHtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgY2hpbGRbbWV0aG9kTmFtZV0uYXBwbHkoY2hpbGQsIGFyZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLml0ZXJDaGlsZHJlbiA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuQnlVaWQgPSB0aGlzLmNoaWxkcmVuQnlVaWQ7XHJcbiAgICAgICAgdmFyIHVpZDtcclxuICAgICAgICBmb3IgKHVpZCBpbiBjaGlsZHJlbkJ5VWlkKSB7XHJcbiAgICAgICAgICAgIGZ1bmMoY2hpbGRyZW5CeVVpZFt1aWRdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldENhbGVuZGFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdC5jYWxlbmRhciB8fCB0LnZpZXcuY2FsZW5kYXI7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5fZ2V0RGF0ZVByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZpZXcoKS5nZXQoJ2RhdGVQcm9maWxlJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIEhUTUwgZm9yIGFuIGFuY2hvciB0byBhbm90aGVyIHZpZXcgaW50byB0aGUgY2FsZW5kYXIuXHJcbiAgICAvLyBXaWxsIGVpdGhlciBnZW5lcmF0ZSBhbiA8YT4gdGFnIG9yIGEgbm9uLWNsaWNrYWJsZSA8c3Bhbj4gdGFnLCBkZXBlbmRpbmcgb24gZW5hYmxlZCBzZXR0aW5ncy5cclxuICAgIC8vIGBnb3RvT3B0aW9uc2AgY2FuIGVpdGhlciBiZSBhIG1vbWVudCBpbnB1dCwgb3IgYW4gb2JqZWN0IHdpdGggdGhlIGZvcm06XHJcbiAgICAvLyB7IGRhdGUsIHR5cGUsIGZvcmNlT2ZmIH1cclxuICAgIC8vIGB0eXBlYCBpcyBhIHZpZXctdHlwZSBsaWtlIFwiZGF5XCIgb3IgXCJ3ZWVrXCIuIGRlZmF1bHQgdmFsdWUgaXMgXCJkYXlcIi5cclxuICAgIC8vIGBhdHRyc2AgYW5kIGBpbm5lckh0bWxgIGFyZSB1c2UgdG8gZ2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIEhUTUwgdGFnLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRHb3RvQW5jaG9ySHRtbCA9IGZ1bmN0aW9uIChnb3RvT3B0aW9ucywgYXR0cnMsIGlubmVySHRtbCkge1xyXG4gICAgICAgIHZhciBkYXRlO1xyXG4gICAgICAgIHZhciB0eXBlO1xyXG4gICAgICAgIHZhciBmb3JjZU9mZjtcclxuICAgICAgICB2YXIgZmluYWxPcHRpb25zO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoZ290b09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBnb3RvT3B0aW9ucy5kYXRlO1xyXG4gICAgICAgICAgICB0eXBlID0gZ290b09wdGlvbnMudHlwZTtcclxuICAgICAgICAgICAgZm9yY2VPZmYgPSBnb3RvT3B0aW9ucy5mb3JjZU9mZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBnb3RvT3B0aW9uczsgLy8gYSBzaW5nbGUgbW9tZW50IGlucHV0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGUgPSBtb21lbnRfZXh0XzEuZGVmYXVsdChkYXRlKTsgLy8gaWYgYSBzdHJpbmcsIHBhcnNlIGl0XHJcbiAgICAgICAgZmluYWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkYXRlOiBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdkYXknXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSBhdHRycztcclxuICAgICAgICAgICAgYXR0cnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdHRycyA9IGF0dHJzID8gJyAnICsgdXRpbF8xLmF0dHJzVG9TdHIoYXR0cnMpIDogJyc7IC8vIHdpbGwgaGF2ZSBhIGxlYWRpbmcgc3BhY2VcclxuICAgICAgICBpbm5lckh0bWwgPSBpbm5lckh0bWwgfHwgJyc7XHJcbiAgICAgICAgaWYgKCFmb3JjZU9mZiAmJiB0aGlzLm9wdCgnbmF2TGlua3MnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxhJyArIGF0dHJzICtcclxuICAgICAgICAgICAgICAgICcgZGF0YS1nb3RvPVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KGZpbmFsT3B0aW9ucykpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sICtcclxuICAgICAgICAgICAgICAgICc8L2E+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHNwYW4nICsgYXR0cnMgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sICtcclxuICAgICAgICAgICAgICAgICc8L3NwYW4+JztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QWxsRGF5SHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2FsbERheUh0bWwnKSB8fCB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLm9wdCgnYWxsRGF5VGV4dCcpKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBIVE1MIGNsYXNzTmFtZXMgZm9yIGEgc2luZ2xlLWRheSBlbGVtZW50XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXREYXlDbGFzc2VzID0gZnVuY3Rpb24gKGRhdGUsIG5vVGhlbWVIaWdobGlnaHQpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0b2RheTtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKSkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWRpc2FibGVkLWRheScpOyAvLyBUT0RPOiBqUXVlcnkgVUkgdGhlbWU/XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLScgKyB1dGlsXzEuZGF5SURzW2RhdGUuZGF5KCldKTtcclxuICAgICAgICAgICAgaWYgKHZpZXcuaXNEYXRlSW5PdGhlck1vbnRoKGRhdGUsIHRoaXMuZGF0ZVByb2ZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLW90aGVyLW1vbnRoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9kYXkgPSB2aWV3LmNhbGVuZGFyLmdldE5vdygpO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZS5pc1NhbWUodG9kYXksICdkYXknKSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy10b2RheScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vVGhlbWVIaWdobGlnaHQgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2godmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZSA8IHRvZGF5KSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXBhc3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZnV0dXJlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbGl0eSBmb3IgZm9ybWF0dGluZyBhIHJhbmdlLiBBY2NlcHRzIGEgcmFuZ2Ugb2JqZWN0LCBmb3JtYXR0aW5nIHN0cmluZywgYW5kIG9wdGlvbmFsIHNlcGFyYXRvci5cclxuICAgIC8vIERpc3BsYXlzIGFsbC1kYXkgcmFuZ2VzIG5hdHVyYWxseSwgd2l0aCBhbiBpbmNsdXNpdmUgZW5kLiBUYWtlcyB0aGUgY3VycmVudCBpc1JUTCBpbnRvIGFjY291bnQuXHJcbiAgICAvLyBUaGUgdGltZXpvbmVzIG9mIHRoZSBkYXRlcyB3aXRoaW4gYHJhbmdlYCB3aWxsIGJlIHJlc3BlY3RlZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBpc0FsbERheSwgZm9ybWF0U3RyLCBzZXBhcmF0b3IpIHtcclxuICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xyXG4gICAgICAgIGlmIChpc0FsbERheSkge1xyXG4gICAgICAgICAgICBlbmQgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdCgxKTsgLy8gY29udmVydCB0byBpbmNsdXNpdmUuIGxhc3QgbXMgb2YgcHJldmlvdXMgZGF5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlX2Zvcm1hdHRpbmdfMS5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgZW5kLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgdGhpcy5pc1JUTCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHRoZSBnaXZlIHVuaXRzIGluIHRoZSBcImN1cnJlbnRcIiByYW5nZS5cclxuICAgIC8vIFdpbGwgcmV0dXJuIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLiBXb24ndCByb3VuZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRSYW5nZUFzID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGF0ZVByb2ZpbGUoKS5jdXJyZW50VW56b25lZFJhbmdlLmFzKHVuaXQpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIGRhdGUgcmFuZ2Ugb2YgdGhlIGZ1bGwgZGF5cyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFycyB0byBvY2N1cHkuXHJcbiAgICAvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdpdGggc3RhcnQvZW5kLCBOT1QgYW4gVW56b25lZFJhbmdlIVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcHV0ZURheVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuX2dldENhbGVuZGFyKCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0RGF5ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh1bnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXHJcbiAgICAgICAgdmFyIGVuZCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodW56b25lZFJhbmdlLmVuZE1zKTtcclxuICAgICAgICB2YXIgZW5kVGltZU1TID0gK2VuZC50aW1lKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcclxuICAgICAgICB2YXIgZW5kRGF5ID0gZW5kLmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2UgZXhjbHVzaXZlbHkgZW5kc1xyXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZWF2aW5nIGl0IGFzIGluY2x1c2l2ZSB3aWxsIGNhdXNlIGl0IHRvIGV4Y2x1ZGUgYGVuZERheWAuXHJcbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gdGhpcy5uZXh0RGF5VGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIGVuZERheS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgZW5kIGlzIHdpdGhpbiBgc3RhcnREYXlgIGJ1dCBub3QgcGFzdCBuZXh0RGF5VGhyZXNob2xkLCBhc3NpZ24gdGhlIGRlZmF1bHQgZHVyYXRpb24gb2Ygb25lIGRheS5cclxuICAgICAgICBpZiAoZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XHJcbiAgICAgICAgICAgIGVuZERheSA9IHN0YXJ0RGF5LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydERheSwgZW5kOiBlbmREYXkgfTtcclxuICAgIH07XHJcbiAgICAvLyBEb2VzIHRoZSBnaXZlbiByYW5nZSB2aXN1YWxseSBhcHBlYXIgdG8gb2NjdXB5IG1vcmUgdGhhbiBvbmUgZGF5P1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNNdWx0aURheVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlSYW5nZSA9IHRoaXMuY29tcHV0ZURheVJhbmdlKHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIGRheVJhbmdlLmVuZC5kaWZmKGRheVJhbmdlLnN0YXJ0LCAnZGF5cycpID4gMTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50Lmd1aWQgPSAwOyAvLyBUT0RPOiBiZXR0ZXIgc3lzdGVtIGZvciB0aGlzP1xyXG4gICAgcmV0dXJuIERhdGVDb21wb25lbnQ7XHJcbn0oQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRlQ29tcG9uZW50O1xyXG4vLyBsZWdhY3lcclxuZnVuY3Rpb24gY29udmVydEV2ZW50c1BheWxvYWRUb0xlZ2FjeUFycmF5KGV2ZW50c1BheWxvYWQpIHtcclxuICAgIHZhciBldmVudERlZklkO1xyXG4gICAgdmFyIGV2ZW50SW5zdGFuY2VzO1xyXG4gICAgdmFyIGxlZ2FjeUV2ZW50cyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGV2ZW50RGVmSWQgaW4gZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VzID0gZXZlbnRzUGF5bG9hZFtldmVudERlZklkXS5ldmVudEluc3RhbmNlcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGVnYWN5RXZlbnRzLnB1c2goZXZlbnRJbnN0YW5jZXNbaV0udG9MZWdhY3koKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2FjeUV2ZW50cztcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgSXRlcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM4KTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBUb29sYmFyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOSk7XHJcbnZhciBPcHRpb25zTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDApO1xyXG52YXIgVmlld1NwZWNNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0MSk7XHJcbnZhciBDb25zdHJhaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDcpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgRXZlbnRNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Mik7XHJcbnZhciBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcclxudmFyIEV2ZW50U291cmNlUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxudmFyIEV2ZW50RGVmUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxudmFyIENhbGVuZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIoZWwsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0xldmVsID0gMDsgLy8gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBsb2FkaW5nIHRhc2tzXHJcbiAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGggPSAwO1xyXG4gICAgICAgIC8vIGRlY2xhcmUgdGhlIGN1cnJlbnQgY2FsZW5kYXIgaW5zdGFuY2UgcmVsaWVzIG9uIEdsb2JhbEVtaXR0ZXIuIG5lZWRlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vIHVubmVlZGVkKCkgaXMgY2FsbGVkIGluIGRlc3Ryb3kuXHJcbiAgICAgICAgR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQubmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMudmlld3NCeVR5cGUgPSB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gbmV3IE9wdGlvbnNNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzLCBvdmVycmlkZXMpO1xyXG4gICAgICAgIHRoaXMudmlld1NwZWNNYW5hZ2VyID0gbmV3IFZpZXdTcGVjTWFuYWdlcl8xLmRlZmF1bHQodGhpcy5vcHRpb25zTWFuYWdlciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5pbml0TW9tZW50SW50ZXJuYWxzKCk7IC8vIG5lZWRzIHRvIGhhcHBlbiBhZnRlciBvcHRpb25zIGhhc2ggaW5pdGlhbGl6ZWRcclxuICAgICAgICB0aGlzLmluaXRDdXJyZW50RGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50TWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBuZXcgQ29uc3RyYWludHNfMS5kZWZhdWx0KHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdGVkKCk7XHJcbiAgICB9XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtb25rZXlwYXRjaGluZy4gdXNlZD9cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wdWJsaWNseVRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgdHJpZ2dlckluZm8pIHtcclxuICAgICAgICB2YXIgb3B0SGFuZGxlciA9IHRoaXMub3B0KG5hbWUpO1xyXG4gICAgICAgIHZhciBjb250ZXh0O1xyXG4gICAgICAgIHZhciBhcmdzO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodHJpZ2dlckluZm8pKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSB0cmlnZ2VySW5mby5jb250ZXh0O1xyXG4gICAgICAgICAgICBhcmdzID0gdHJpZ2dlckluZm8uYXJncztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHRyaWdnZXJJbmZvKSkge1xyXG4gICAgICAgICAgICBhcmdzID0gdHJpZ2dlckluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuZWxbMF07IC8vIGZhbGxiYWNrIGNvbnRleHRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmdzKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyV2l0aChuYW1lLCBjb250ZXh0LCBhcmdzKTsgLy8gRW1pdHRlcidzIG1ldGhvZFxyXG4gICAgICAgIGlmIChvcHRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaGFzUHVibGljSGFuZGxlcnMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hhbmRsZXJzKG5hbWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMub3B0KG5hbWUpOyAvLyBoYW5kbGVyIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcbiAgICB9O1xyXG4gICAgLy8gT3B0aW9ucyBQdWJsaWMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHVibGljIGdldHRlci9zZXR0ZXJcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgbmV3T3B0aW9uSGFzaDtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zTWFuYWdlci5nZXQobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25IYXNoID0ge307XHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25IYXNoW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmFkZChuZXdPcHRpb25IYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHByaXZhdGUgZ2V0dGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zTWFuYWdlci5nZXQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVmlld1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEdpdmVuIGEgdmlldyBuYW1lIGZvciBhIGN1c3RvbSB2aWV3IG9yIGEgc3RhbmRhcmQgdmlldywgY3JlYXRlcyBhIHJlYWR5LXRvLWdvIFZpZXcgb2JqZWN0XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5zdGFudGlhdGVWaWV3ID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIHNwZWMgPSB0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyh2aWV3VHlwZSk7XHJcbiAgICAgICAgaWYgKCFzcGVjKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXcgdHlwZSBcXFwiXCIgKyB2aWV3VHlwZSArIFwiXFxcIiBpcyBub3QgdmFsaWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgc3BlY1snY2xhc3MnXSh0aGlzLCBzcGVjKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSB2aWV3IGlzIG9rYXkgdG8gaW5zdGFudGlhdGUgYXQgc29tZSBwb2ludFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmlzVmFsaWRWaWV3VHlwZSA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbiAodmlld05hbWUsIGRhdGVPclJhbmdlKSB7XHJcbiAgICAgICAgaWYgKGRhdGVPclJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIucmVjb3JkT3ZlcnJpZGVzKHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlUmFuZ2U6IGRhdGVPclJhbmdlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudChkYXRlT3JSYW5nZSkuc3RyaXBab25lKCk7IC8vIGp1c3QgbGlrZSBnb3RvRGF0ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyh2aWV3TmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgIC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnpvb21UbyA9IGZ1bmN0aW9uIChuZXdEYXRlLCB2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBzcGVjO1xyXG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cclxuICAgICAgICBzcGVjID0gdGhpcy52aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWModmlld1R5cGUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9IG5ld0RhdGUuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoc3BlYyA/IHNwZWMudHlwZSA6IG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8vIEN1cnJlbnQgRGF0ZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0Q3VycmVudERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHREYXRlSW5wdXQgPSB0aGlzLm9wdCgnZGVmYXVsdERhdGUnKTtcclxuICAgICAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcclxuICAgICAgICBpZiAoZGVmYXVsdERhdGVJbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudChkZWZhdWx0RGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLmdldE5vdygpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHByZXZJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIGlmIChwcmV2SW5mby5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBwcmV2SW5mby5kYXRlO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG5leHRJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIGlmIChuZXh0SW5mby5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBuZXh0SW5mby5kYXRlO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnByZXZZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKC0xLCAneWVhcnMnKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubmV4dFllYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZS5hZGQoMSwgJ3llYXJzJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLmdldE5vdygpOyAvLyBzaG91bGQgZGVueSBsaWtlIHByZXYvbmV4dD9cclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ290b0RhdGUgPSBmdW5jdGlvbiAoem9uZWREYXRlSW5wdXQpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoem9uZWREYXRlSW5wdXQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbmNyZW1lbnREYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZS5hZGQobW9tZW50LmR1cmF0aW9uKGRlbHRhKSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gZm9yIGV4dGVybmFsIEFQSVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUaW1lem9uZSh0aGlzLmN1cnJlbnREYXRlKTsgLy8gaW5mdXNlIHRoZSBjYWxlbmRhcidzIHRpbWV6b25lXHJcbiAgICB9O1xyXG4gICAgLy8gTG9hZGluZyBUcmlnZ2VyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gU2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFueSB0eXBlIG9mIGFzeW5jIGRhdGEgZmV0Y2hpbmcgYmVnaW5zXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucHVzaExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5sb2FkaW5nTGV2ZWwrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBbdHJ1ZSwgdGhpcy52aWV3XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGNvbXBsZXRlc1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBvcExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmxvYWRpbmdMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBbZmFsc2UsIHRoaXMudmlld10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRFbCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIG1haW5seSBmb3IgdGhlIHB1YmxpYyBBUElcclxuICAgICAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0aWFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICBlbC5hZGRDbGFzcygnZmMnKTtcclxuICAgICAgICAvLyBldmVudCBkZWxlZ2F0aW9uIGZvciBuYXYgbGlua3NcclxuICAgICAgICBlbC5vbignY2xpY2suZmMnLCAnYVtkYXRhLWdvdG9dJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBhbmNob3JFbCA9ICQoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciBnb3RvT3B0aW9ucyA9IGFuY2hvckVsLmRhdGEoJ2dvdG8nKTsgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IHBhcnNlIEpTT05cclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5tb21lbnQoZ290b09wdGlvbnMuZGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3VHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XHJcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IGxpa2UgXCJuYXZMaW5rRGF5Q2xpY2tcIi4gbWlnaHQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICB2YXIgY3VzdG9tQWN0aW9uID0gX3RoaXMudmlldy5vcHQoJ25hdkxpbmsnICsgdXRpbF8xLmNhcGl0YWxpc2VGaXJzdExldHRlcih2aWV3VHlwZSkgKyAnQ2xpY2snKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbihkYXRlLCBldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnpvb21UbyhkYXRlLCB2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB1cG9uIG9wdGlvbiBjaGFuZ2VcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdzZXR0aW5nVGhlbWUnLCBbJz90aGVtZScsICc/dGhlbWVTeXN0ZW0nXSwgZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIHRoZW1lQ2xhc3MgPSBUaGVtZVJlZ2lzdHJ5XzEuZ2V0VGhlbWVTeXN0ZW1DbGFzcyhvcHRzLnRoZW1lU3lzdGVtIHx8IG9wdHMudGhlbWUpO1xyXG4gICAgICAgICAgICB2YXIgdGhlbWUgPSBuZXcgdGhlbWVDbGFzcyhfdGhpcy5vcHRpb25zTWFuYWdlcik7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXRDbGFzcyA9IHRoZW1lLmdldENsYXNzKCd3aWRnZXQnKTtcclxuICAgICAgICAgICAgX3RoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgaWYgKHdpZGdldENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcyh3aWRnZXRDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXRDbGFzcyA9IF90aGlzLnRoZW1lLmdldENsYXNzKCd3aWRnZXQnKTtcclxuICAgICAgICAgICAgX3RoaXMudGhlbWUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAod2lkZ2V0Q2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKHdpZGdldENsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIud2F0Y2goJ3NldHRpbmdCdXNpbmVzc0hvdXJHZW5lcmF0b3InLCBbJz9idXNpbmVzc0hvdXJzJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvciA9IG5ldyBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMS5kZWZhdWx0KGRlcHMuYnVzaW5lc3NIb3VycywgX3RoaXMpO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMudmlldykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy5zZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicsIF90aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvciA9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlLlxyXG4gICAgICAgIC8vIEhBQ0s6IGxvY2FsZSBvZnRlbiBhZmZlY3RzIGlzUlRMLCBzbyB3ZSBleHBsaWNpdGx5IGxpc3RlbiB0byB0aGF0IHRvby5cclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdhcHBseWluZ0RpckNsYXNzZXMnLCBbJz9pc1JUTCcsICc/bG9jYWxlJ10sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIGVsLnRvZ2dsZUNsYXNzKCdmYy1sdHInLCAhb3B0cy5pc1JUTCk7XHJcbiAgICAgICAgICAgIGVsLnRvZ2dsZUNsYXNzKCdmYy1ydGwnLCBvcHRzLmlzUlRMKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbCA9ICQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3LWNvbnRhaW5lcicvPlwiKS5wcmVwZW5kVG8oZWwpO1xyXG4gICAgICAgIHRoaXMuaW5pdFRvb2xiYXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJIZWFkZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckZvb3RlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyh0aGlzLm9wdCgnZGVmYXVsdFZpZXcnKSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdoYW5kbGVXaW5kb3dSZXNpemUnKSkge1xyXG4gICAgICAgICAgICAkKHdpbmRvdykucmVzaXplKHRoaXMud2luZG93UmVzaXplUHJveHkgPSB1dGlsXzEuZGVib3VuY2UoLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dSZXNpemUuYmluZCh0aGlzKSwgdGhpcy5vcHQoJ3dpbmRvd1Jlc2l6ZURlbGF5JykpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3JlbW92ZUVsZW1lbnQnKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZUNsYXNzKCdmYyBmYy1sdHIgZmMtcnRsJyk7XHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGVtZS1yZWxhdGVkIHJvb3QgY2xhc3NOYW1lXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci51bndhdGNoKCdzZXR0aW5nVGhlbWUnKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnVud2F0Y2goJ3NldHRpbmdCdXNpbmVzc0hvdXJHZW5lcmF0b3InKTtcclxuICAgICAgICB0aGlzLmVsLm9mZignLmZjJyk7IC8vIHVuYmluZCBuYXYgbGluayBoYW5kbGVyc1xyXG4gICAgICAgIGlmICh0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KSB7XHJcbiAgICAgICAgICAgICQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplUHJveHkpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQudW5uZWVkZWQoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZWxlbWVudFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuaXMoJzp2aXNpYmxlJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVyIFF1ZXVlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmJpbmRWaWV3SGFuZGxlcnMgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmlldy53YXRjaCgndGl0bGVGb3JDYWxlbmRhcicsIFsndGl0bGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgaWYgKHZpZXcgPT09IF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFRvb2xiYXJzVGl0bGUoZGVwcy50aXRsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2aWV3LndhdGNoKCdkYXRlUHJvZmlsZUZvckNhbGVuZGFyJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBpZiAodmlldyA9PT0gX3RoaXMudmlldykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudERhdGUgPSBkZXBzLmRhdGVQcm9maWxlLmRhdGU7IC8vIG1pZ2h0IGhhdmUgYmVlbiBjb25zdHJhaW5lZCBieSB2aWV3IGRhdGVzXHJcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUb29sYmFyQnV0dG9ucyhkZXBzLmRhdGVQcm9maWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51bmJpbmRWaWV3SGFuZGxlcnMgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIHZpZXcudW53YXRjaCgndGl0bGVGb3JDYWxlbmRhcicpO1xyXG4gICAgICAgIHZpZXcudW53YXRjaCgnZGF0ZVByb2ZpbGVGb3JDYWxlbmRhcicpO1xyXG4gICAgfTtcclxuICAgIC8vIFZpZXcgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpZXcgYmVjYXVzZSBvZiBhIGRhdGUgY2hhbmdlLCB2aWV3LXR5cGUgY2hhbmdlLCBvciBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAvLyBJZiBub3QgZ2l2ZW4gYSB2aWV3VHlwZSwga2VlcCB0aGUgY3VycmVudCB2aWV3IGJ1dCByZW5kZXIgZGlmZmVyZW50IGRhdGVzLlxyXG4gICAgLy8gQWNjZXB0cyBhbiBvcHRpb25hbCBzY3JvbGwgc3RhdGUgdG8gcmVzdG9yZSB0by5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJWaWV3ID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIG9sZFZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG5ld1ZpZXc7XHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgaWYgKG9sZFZpZXcgJiYgdmlld1R5cGUgJiYgb2xkVmlldy50eXBlICE9PSB2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB2aWV3VHlwZSBjaGFuZ2VkLCBvciB0aGUgdmlldyB3YXMgbmV2ZXIgY3JlYXRlZCwgY3JlYXRlIGEgZnJlc2ggdmlld1xyXG4gICAgICAgIGlmICghdGhpcy52aWV3ICYmIHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXcgPSB0aGlzLnZpZXcgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3c0J5VHlwZVt2aWV3VHlwZV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy52aWV3c0J5VHlwZVt2aWV3VHlwZV0gPSB0aGlzLmluc3RhbnRpYXRlVmlldyh2aWV3VHlwZSkpO1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRWaWV3SGFuZGxlcnMobmV3Vmlldyk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXcuc3RhcnRCYXRjaFJlbmRlcigpOyAvLyBzbyB0aGF0IHNldEVsZW1lbnQrc2V0RGF0ZSByZW5kZXJpbmcgYXJlIGpvaW5lZFxyXG4gICAgICAgICAgICBuZXdWaWV3LnNldEVsZW1lbnQoJChcIjxkaXYgY2xhc3M9J2ZjLXZpZXcgZmMtXCIgKyB2aWV3VHlwZSArIFwiLXZpZXcnIC8+XCIpLmFwcGVuZFRvKHRoaXMuY29udGVudEVsKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgnYWN0aXZhdGVCdXR0b24nLCB2aWV3VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgLy8gcHJldmVudCB1bm5lY2Vzc2FyeSBjaGFuZ2UgZmlyaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuZ2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InKSAhPT0gdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicsIHRoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0RGF0ZSh0aGlzLmN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgaWYgKG5ld1ZpZXcpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZpZXcuc3RvcEJhdGNoUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aGF3Q29udGVudEhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyB0aGUgY3VycmVudCB2aWV3IGFuZCByZWZsZWN0cyB0aGlzIGNoYW5nZSBpbiB0aGUgSGVhZGVyLlxyXG4gICAgLy8gVW5yZWdzaXRlcnMgdGhlIGB2aWV3YCwgYnV0IGRvZXMgbm90IHJlbW92ZSBmcm9tIHZpZXdCeVR5cGUgaGFzaC5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jbGVhclZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgnZGVhY3RpdmF0ZUJ1dHRvbicsIGN1cnJlbnRWaWV3LnR5cGUpO1xyXG4gICAgICAgIHRoaXMudW5iaW5kVmlld0hhbmRsZXJzKGN1cnJlbnRWaWV3KTtcclxuICAgICAgICBjdXJyZW50Vmlldy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgY3VycmVudFZpZXcudW5zZXREYXRlKCk7IC8vIHNvIGJpbmRWaWV3SGFuZGxlcnMgZG9lc24ndCBmaXJlIHdpdGggb2xkIHZhbHVlcyBuZXh0IHRpbWVcclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIERlc3Ryb3lzIHRoZSB2aWV3LCBpbmNsdWRpbmcgdGhlIHZpZXcgb2JqZWN0LiBUaGVuLCByZS1pbnN0YW50aWF0ZXMgaXQgYW5kIHJlbmRlcnMgaXQuXHJcbiAgICAvLyBNYWludGFpbnMgdGhlIHNhbWUgc2Nyb2xsIHN0YXRlLlxyXG4gICAgLy8gVE9ETzogbWFpbnRhaW4gYW55IG90aGVyIHVzZXItbWFuaXB1bGF0ZWQgc3RhdGUuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVpbml0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb2xkVmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgc2Nyb2xsID0gb2xkVmlldy5xdWVyeVNjcm9sbCgpOyAvLyB3b3VsZG4ndCBiZSBzbyBjb21wbGljYXRlZCBpZiBDYWxlbmRhciBvd25lZCB0aGUgc2Nyb2xsXHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB0aGlzLmNhbGNTaXplKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KG9sZFZpZXcudHlwZSk7IC8vIG5lZWRzIHRoZSB0eXBlIHRvIGZyZXNobHkgcmVuZGVyXHJcbiAgICAgICAgdGhpcy52aWV3LmFwcGx5U2Nyb2xsKHNjcm9sbCk7XHJcbiAgICAgICAgdGhpcy50aGF3Q29udGVudEhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlc2l6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodDtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXNIZWlnaHRBdXRvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnY29udGVudEhlaWdodCcpID09PSAnYXV0bycgfHwgdGhpcy5vcHQoJ2hlaWdodCcpID09PSAnYXV0byc7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZVZpZXdTaXplID0gZnVuY3Rpb24gKGlzUmVzaXplKSB7XHJcbiAgICAgICAgaWYgKGlzUmVzaXplID09PSB2b2lkIDApIHsgaXNSZXNpemUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBzY3JvbGw7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplICYmIHZpZXcpIHtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNTaXplKCk7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGwgPSB2aWV3LnF1ZXJ5U2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSsrO1xyXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVNpemUodGhpcy5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0KCksIHRoaXMuaXNIZWlnaHRBdXRvKCksIGlzUmVzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZS0tO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuYXBwbHlTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIHN1Y2Nlc3NcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNhbGNTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsY1NpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl9jYWxjU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29udGVudEhlaWdodElucHV0ID0gdGhpcy5vcHQoJ2NvbnRlbnRIZWlnaHQnKTtcclxuICAgICAgICB2YXIgaGVpZ2h0SW5wdXQgPSB0aGlzLm9wdCgnaGVpZ2h0Jyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGNvbnRlbnRIZWlnaHRJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBoZWlnaHRJbnB1dCAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHRJbnB1dCA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gdGhpcy5lbC5wYXJlbnQoKS5oZWlnaHQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmNvbnRlbnRFbC53aWR0aCgpIC9cclxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHRoaXMub3B0KCdhc3BlY3RSYXRpbycpLCAuNSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUud2luZG93UmVzaXplID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgIC8vIHRoZSBwdXJwb3NlOiBzbyB3ZSBkb24ndCBwcm9jZXNzIGpxdWkgXCJyZXNpemVcIiBldmVudHMgdGhhdCBoYXZlIGJ1YmJsZWQgdXBcclxuICAgICAgICAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIC50YXJnZXQsIHdoaWNoIGlzIEVsZW1lbnQsIGNhbid0IGJlIGNvbXBhcmVkIHRvIHdpbmRvdyBmb3Igc29tZSByZWFzb24uXHJcbiAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgJiZcclxuICAgICAgICAgICAgdGhpcy52aWV3ICYmXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5pc0RhdGVzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlVmlld1NpemUodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd3aW5kb3dSZXNpemUnLCBbdGhpcy52aWV3XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogSGVpZ2h0IFwiRnJlZXppbmdcIlxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmZyZWV6ZUNvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmZvcmNlRnJlZXplQ29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5jc3Moe1xyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGVudEVsLmhlaWdodCgpLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudGhhd0NvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGgtLTtcclxuICAgICAgICAvLyBhbHdheXMgYnJpbmcgYmFjayB0byBuYXR1cmFsIGhlaWdodFxyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmNzcyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICcnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYnV0IGlmIHRoZXJlIGFyZSBmdXR1cmUgdGhhd3MsIHJlLWZyZWV6ZVxyXG4gICAgICAgIGlmICh0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHREZXB0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlRnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUb29sYmFyXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluaXRUb29sYmFycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBUb29sYmFyXzEuZGVmYXVsdCh0aGlzLCB0aGlzLmNvbXB1dGVIZWFkZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIHRoaXMuZm9vdGVyID0gbmV3IFRvb2xiYXJfMS5kZWZhdWx0KHRoaXMsIHRoaXMuY29tcHV0ZUZvb3Rlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIgPSBuZXcgSXRlcmF0b3JfMS5kZWZhdWx0KFt0aGlzLmhlYWRlciwgdGhpcy5mb290ZXJdKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29tcHV0ZUhlYWRlck9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZXh0cmFDbGFzc2VzOiAnZmMtaGVhZGVyLXRvb2xiYXInLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMub3B0KCdoZWFkZXInKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXB1dGVGb290ZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NlczogJ2ZjLWZvb3Rlci10b29sYmFyJyxcclxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLm9wdCgnZm9vdGVyJylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgSGVhZGVyIHdpbGwgcmVyZW5kZXJcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyO1xyXG4gICAgICAgIGhlYWRlci5zZXRUb29sYmFyT3B0aW9ucyh0aGlzLmNvbXB1dGVIZWFkZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIGhlYWRlci5yZW5kZXIoKTtcclxuICAgICAgICBpZiAoaGVhZGVyLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucHJlcGVuZChoZWFkZXIuZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIEZvb3RlciB3aWxsIHJlcmVuZGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyRm9vdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmb290ZXIgPSB0aGlzLmZvb3RlcjtcclxuICAgICAgICBmb290ZXIuc2V0VG9vbGJhck9wdGlvbnModGhpcy5jb21wdXRlRm9vdGVyT3B0aW9ucygpKTtcclxuICAgICAgICBmb290ZXIucmVuZGVyKCk7XHJcbiAgICAgICAgaWYgKGZvb3Rlci5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZChmb290ZXIuZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2V0VG9vbGJhcnNUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgndXBkYXRlVGl0bGUnLCB0aXRsZSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZVRvb2xiYXJCdXR0b25zID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuZ2V0Tm93KCk7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHRvZGF5SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93KTtcclxuICAgICAgICB2YXIgcHJldkluZm8gPSB2aWV3LmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldih2aWV3LmdldCgnZGF0ZVByb2ZpbGUnKSk7XHJcbiAgICAgICAgdmFyIG5leHRJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgodG9kYXlJbmZvLmlzVmFsaWQgJiYgIWRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKG5vdykpID9cclxuICAgICAgICAgICAgJ2VuYWJsZUJ1dHRvbicgOlxyXG4gICAgICAgICAgICAnZGlzYWJsZUJ1dHRvbicsICd0b2RheScpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbChwcmV2SW5mby5pc1ZhbGlkID9cclxuICAgICAgICAgICAgJ2VuYWJsZUJ1dHRvbicgOlxyXG4gICAgICAgICAgICAnZGlzYWJsZUJ1dHRvbicsICdwcmV2Jyk7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKG5leHRJbmZvLmlzVmFsaWQgP1xyXG4gICAgICAgICAgICAnZW5hYmxlQnV0dG9uJyA6XHJcbiAgICAgICAgICAgICdkaXNhYmxlQnV0dG9uJywgJ25leHQnKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucXVlcnlUb29sYmFyc0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b29sYmFyc01hbmFnZXIuaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgdG9vbGJhcikge1xyXG4gICAgICAgICAgICB2YXIgdG9vbGJhckhlaWdodCA9IHRvb2xiYXIuZWwgPyB0b29sYmFyLmVsLm91dGVySGVpZ2h0KHRydWUpIDogMDsgLy8gaW5jbHVkZXMgbWFyZ2luXHJcbiAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvciArIHRvb2xiYXJIZWlnaHQ7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VsZWN0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gdGhpcyBwdWJsaWMgbWV0aG9kIHJlY2VpdmVzIHN0YXJ0L2VuZCBkYXRlcyBpbiBhbnkgZm9ybWF0LCB3aXRoIGFueSB0aW1lem9uZVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICh6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcclxuICAgICAgICB0aGlzLnZpZXcuc2VsZWN0KHRoaXMuYnVpbGRTZWxlY3RGb290cHJpbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnVuc2VsZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFyZ3VtZW50cyB0byB0aGUgc2VsZWN0IG1ldGhvZCBpbiB0aGUgQVBJLCByZXR1cm5zIGEgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIGluZm8pXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYnVpbGRTZWxlY3RGb290cHJpbnQgPSBmdW5jdGlvbiAoem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tb21lbnQoem9uZWRTdGFydElucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIGlmICh6b25lZEVuZElucHV0KSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubW9tZW50KHpvbmVkRW5kSW5wdXQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCksICFzdGFydC5oYXNUaW1lKCkpO1xyXG4gICAgfTtcclxuICAgIC8vIERhdGUgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdE1vbWVudEludGVybmFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ2RlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uJykpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbicpKTtcclxuICAgICAgICAvLyBDYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB3aGVuIGFueSBvZiB0aGUgb3B0aW9ucyBjaGFuZ2UuXHJcbiAgICAgICAgLy8gSGFwcGVucyBiZWZvcmUgYW55IGludGVybmFsIG9iamVjdHMgcmVidWlsZCBvciByZXJlbmRlciwgYmVjYXVzZSB0aGlzIGlzIHZlcnkgY29yZS5cclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdidWlsZGluZ01vbWVudExvY2FsZScsIFtcclxuICAgICAgICAgICAgJz9sb2NhbGUnLCAnP21vbnRoTmFtZXMnLCAnP21vbnRoTmFtZXNTaG9ydCcsICc/ZGF5TmFtZXMnLCAnP2RheU5hbWVzU2hvcnQnLFxyXG4gICAgICAgICAgICAnP2ZpcnN0RGF5JywgJz93ZWVrTnVtYmVyQ2FsY3VsYXRpb24nXHJcbiAgICAgICAgXSwgZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9IG9wdHMud2Vla051bWJlckNhbGN1bGF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgZmlyc3REYXkgPSBvcHRzLmZpcnN0RGF5O1xyXG4gICAgICAgICAgICB2YXIgX3dlZWs7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZVxyXG4gICAgICAgICAgICBpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnaXNvJykge1xyXG4gICAgICAgICAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uID0gJ0lTTyc7IC8vIG5vcm1hbGl6ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsb2NhbGVEYXRhID0gT2JqZWN0LmNyZWF0ZSgvLyBtYWtlIGEgY2hlYXAgY29weVxyXG4gICAgICAgICAgICBsb2NhbGVfMS5nZXRNb21lbnRMb2NhbGVEYXRhKG9wdHMubG9jYWxlKSAvLyB3aWxsIGZhbGwgYmFjayB0byBlblxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAob3B0cy5tb250aE5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl9tb250aHMgPSBvcHRzLm1vbnRoTmFtZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdHMubW9udGhOYW1lc1Nob3J0KSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl9tb250aHNTaG9ydCA9IG9wdHMubW9udGhOYW1lc1Nob3J0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmRheU5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl93ZWVrZGF5cyA9IG9wdHMuZGF5TmFtZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdHMuZGF5TmFtZXNTaG9ydCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fd2Vla2RheXNTaG9ydCA9IG9wdHMuZGF5TmFtZXNTaG9ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3REYXkgPT0gbnVsbCAmJiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdERheSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0RGF5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF93ZWVrID0gT2JqZWN0LmNyZWF0ZShsb2NhbGVEYXRhLl93ZWVrKTsgLy8gX3dlZWs6IHsgZG93OiAjIH1cclxuICAgICAgICAgICAgICAgIF93ZWVrLmRvdyA9IGZpcnN0RGF5O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fd2VlayA9IF93ZWVrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nIHx8XHJcbiAgICAgICAgICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdsb2NhbCcgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYyA9IHdlZWtOdW1iZXJDYWxjdWxhdGlvbjsgLy8gbW9tZW50LWV4dCB3aWxsIGtub3cgd2hhdCB0byBkbyB3aXRoIGl0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnRlcm5hbCBjdXJyZW50IGRhdGUgb2JqZWN0IGFscmVhZHkgZXhpc3RzLCBtb3ZlIHRvIG5ldyBsb2NhbGUuXHJcbiAgICAgICAgICAgIC8vIFdlIGRvIE5PVCBuZWVkIHRvIGRvIHRoaXMgdGVjaG5pcXVlIGZvciBldmVudCBkYXRlcywgYmVjYXVzZSB0aGlzIGhhcHBlbnMgd2hlbiBjb252ZXJ0aW5nIHRvIFwic2VnbWVudHNcIi5cclxuICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2NhbGl6ZU1vbWVudChfdGhpcy5jdXJyZW50RGF0ZSk7IC8vIHNldHMgdG8gbG9jYWxlRGF0YVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbW9tZW50IHVzaW5nIHRoZSBzZXR0aW5ncyBvZiB0aGUgY3VycmVudCBjYWxlbmRhcjogdGltZXpvbmUgYW5kIGxvY2FsZS5cclxuICAgIC8vIEFjY2VwdHMgYW55dGhpbmcgdGhlIHZhbmlsbGEgbW9tZW50KCkgY29uc3RydWN0b3IgYWNjZXB0cy5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tb21lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb207XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCd0aW1lem9uZScpID09PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgbW9tZW50IHRvIGJlIGxvY2FsLCBiZWNhdXNlIG1vbWVudEV4dCBkb2Vzbid0IGd1YXJhbnRlZSBpdC5cclxuICAgICAgICAgICAgaWYgKG1vbS5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIG1vbS5sb2NhbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0KCd0aW1lem9uZScpID09PSAnVVRDJykge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMuYXBwbHkobnVsbCwgYXJncyk7IC8vIHByb2Nlc3MgYXMgVVRDXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUuYXBwbHkobnVsbCwgYXJncyk7IC8vIGxldCB0aGUgaW5wdXQgZGVjaWRlIHRoZSB6b25lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTsgLy8gVE9ET1xyXG4gICAgICAgIHJldHVybiBtb207XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm1zVG9Nb21lbnQgPSBmdW5jdGlvbiAobXMsIGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhtcyk7IC8vIFRPRE86IG9wdGltaXplIGJ5IHVzaW5nIERhdGUuVVRDXHJcbiAgICAgICAgaWYgKGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIG1vbS5zdHJpcFRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vbSA9IHRoaXMuYXBwbHlUaW1lem9uZShtb20pOyAvLyBtYXkgb3IgbWF5IG5vdCBhcHBseSBsb2NhbGVcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbGl6ZU1vbWVudChtb20pO1xyXG4gICAgICAgIHJldHVybiBtb207XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm1zVG9VdGNNb21lbnQgPSBmdW5jdGlvbiAobXMsIGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhtcyk7IC8vIFRPRE86IG9wdGltaXplIGJ5IHVzaW5nIERhdGUuVVRDXHJcbiAgICAgICAgaWYgKGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIG1vbS5zdHJpcFRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbGl6ZU1vbWVudChtb20pO1xyXG4gICAgICAgIHJldHVybiBtb207XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB0aGUgZ2l2ZW4gbW9tZW50J3MgbG9jYWxlIHNldHRpbmdzIHRvIHRoZSBjdXJyZW50IGNhbGVuZGFyIGxvY2FsZSBzZXR0aW5ncy5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5sb2NhbGl6ZU1vbWVudCA9IGZ1bmN0aW9uIChtb20pIHtcclxuICAgICAgICBtb20uX2xvY2FsZSA9IHRoaXMubG9jYWxlRGF0YTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsZW5kYXIga25vd3MgaG93IHRvIGNhbGN1bGF0ZVxyXG4gICAgLy8gdGhlIHRpbWV6b25lIG9mZnNldCBvZiBhcmJpdHJhcnkgZGF0ZXMgaW4gdGhlIGN1cnJlbnQgdGltZXpvbmUuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0SXNBbWJpZ1RpbWV6b25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgndGltZXpvbmUnKSAhPT0gJ2xvY2FsJyAmJiB0aGlzLm9wdCgndGltZXpvbmUnKSAhPT0gJ1VUQyc7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIGN1cnJlbnQgdGltZXpvbmUuIEhhcyBubyBlZmZlY3Qgb24gZGF0ZXMgd2l0aG91dCB0aW1lcy5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5hcHBseVRpbWV6b25lID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICBpZiAoIWRhdGUuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB6b25lZERhdGUgPSB0aGlzLm1vbWVudChkYXRlLnRvQXJyYXkoKSk7XHJcbiAgICAgICAgdmFyIHRpbWVBZGp1c3QgPSBkYXRlLnRpbWUoKS5hc01pbGxpc2Vjb25kcygpIC0gem9uZWREYXRlLnRpbWUoKS5hc01pbGxpc2Vjb25kcygpO1xyXG4gICAgICAgIHZhciBhZGp1c3RlZFpvbmVkRGF0ZTtcclxuICAgICAgICAvLyBTYWZhcmkgc29tZXRpbWVzIGhhcyBwcm9ibGVtcyB3aXRoIHRoaXMgY29lcnNpb24gd2hlbiBuZWFyIERTVC4gQWRqdXN0IGlmIG5lY2Vzc2FyeS4gKGJ1ZyAjMjM5NilcclxuICAgICAgICBpZiAodGltZUFkanVzdCkge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFpvbmVkRGF0ZSA9IHpvbmVkRGF0ZS5jbG9uZSgpLmFkZCh0aW1lQWRqdXN0KTsgLy8gYWRkIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICBpZiAoZGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKSAtIGFkanVzdGVkWm9uZWREYXRlLnRpbWUoKS5hc01pbGxpc2Vjb25kcygpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lZERhdGUgPSBhZGp1c3RlZFpvbmVkRGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gem9uZWREYXRlO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBBc3N1bWVzIHRoZSBmb290cHJpbnQgaXMgbm9uLW9wZW4tZW5kZWQuXHJcbiAgICAqL1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBpZ25vcmVFbmQpIHtcclxuICAgICAgICBpZiAoaWdub3JlRW5kID09PSB2b2lkIDApIHsgaWdub3JlRW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5zdGFydE1zKTtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIGlmICghaWdub3JlRW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuYXBwbHlUaW1lem9uZShzdGFydCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIG1vbWVudCBmb3IgdGhlIGN1cnJlbnQgZGF0ZSwgYXMgZGVmaW5lZCBieSB0aGUgY2xpZW50J3MgY29tcHV0ZXIgb3IgZnJvbSB0aGUgYG5vd2Agb3B0aW9uLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gYW4gbW9tZW50IHdpdGggYW4gYW1iaWd1b3VzIHRpbWV6b25lLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldE5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm93ID0gdGhpcy5vcHQoJ25vdycpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm93ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG5vdyA9IG5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tb21lbnQobm93KS5zdHJpcFpvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBQcm9kdWNlcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4gICAgLy8gU2lkZS1lZmZlY3Q6IGNoYW5nZXMgdGhlIGxvY2FsZSBvZiB0aGUgZ2l2ZW4gZHVyYXRpb24uXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaHVtYW5pemVEdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5sb2NhbGUodGhpcy5vcHQoJ2xvY2FsZScpKS5odW1hbml6ZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIHdpbGwgcmV0dXJuIGBudWxsYCBpZiBpbnZhbGlkIHJhbmdlXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucGFyc2VVbnpvbmVkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VJbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVuZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm1vbWVudChyYW5nZUlucHV0LnN0YXJ0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQuZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubW9tZW50KHJhbmdlSW5wdXQuZW5kKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZC5pc0JlZm9yZShzdGFydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudC1EYXRlIFV0aWxpdGllc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0RXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXJfMS5kZWZhdWx0KHRoaXMpO1xyXG4gICAgICAgIHZhciByYXdTb3VyY2VzID0gdGhpcy5vcHQoJ2V2ZW50U291cmNlcycpIHx8IFtdO1xyXG4gICAgICAgIHZhciBzaW5nbGVSYXdTb3VyY2UgPSB0aGlzLm9wdCgnZXZlbnRzJyk7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XHJcbiAgICAgICAgaWYgKHNpbmdsZVJhd1NvdXJjZSkge1xyXG4gICAgICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQoc2luZ2xlUmF3U291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLm9uKCdyZWxlYXNlJywgZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlcignZXZlbnRzUmVzZXQnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgcmF3U291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYXdTb3VyY2UpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShyYXdTb3VyY2UsIF90aGlzKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmFkZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVxdWVzdEV2ZW50cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLnJlcXVlc3RFdmVudHMoc3RhcnQsIGVuZCwgdGhpcy5vcHQoJ3RpbWV6b25lJyksICF0aGlzLm9wdCgnbGF6eUZldGNoaW5nJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEdldCBhbiBldmVudCdzIG5vcm1hbGl6ZWQgZW5kIGRhdGUuIElmIG5vdCBwcmVzZW50LCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZGVmYXVsdHMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQuZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5lbmQuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRFdmVudEVuZChldmVudC5hbGxEYXksIGV2ZW50LnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxyXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXREZWZhdWx0RXZlbnRFbmQgPSBmdW5jdGlvbiAoYWxsRGF5LCB6b25lZFN0YXJ0KSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHpvbmVkU3RhcnQuY2xvbmUoKTtcclxuICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKS5hZGQodGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQuYWRkKHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdldElzQW1iaWdUaW1lem9uZSgpKSB7XHJcbiAgICAgICAgICAgIGVuZC5zdHJpcFpvbmUoKTsgLy8gd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSB0em8gc2hvdWxkIGJlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICB9O1xyXG4gICAgLy8gUHVibGljIEV2ZW50cyBBUElcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVyZW5kZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3LmZsYXNoKCdkaXNwbGF5aW5nRXZlbnRzJyk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlZmV0Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIucmVmZXRjaEFsbFNvdXJjZXMoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50SW5wdXRzLCBpc1N0aWNreSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRJbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudChldmVudElucHV0c1tpXSwgaXNTdGlja3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50SW5wdXQsIGlzU3RpY2t5KSB7XHJcbiAgICAgICAgaWYgKGlzU3RpY2t5ID09PSB2b2lkIDApIHsgaXNTdGlja3kgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UoZXZlbnRJbnB1dCwgZXZlbnRJbnB1dC5zb3VyY2UgfHwgZXZlbnRNYW5hZ2VyLnN0aWNreVNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudERlZihldmVudERlZiwgaXNTdGlja3kpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBsZWdhY3lRdWVyeSBvcGVyYXRlcyBvbiBsZWdhY3kgZXZlbnQgaW5zdGFuY2Ugb2JqZWN0c1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbW92ZUV2ZW50cyA9IGZ1bmN0aW9uIChsZWdhY3lRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgbGVnYWN5SW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgdmFyIGlkTWFwID0ge307XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChsZWdhY3lRdWVyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVBbGxFdmVudERlZnMoKTsgLy8gcGVyc2lzdD10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdhY3lJbnN0YW5jZXMucHVzaChldmVudEluc3RhbmNlLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVnYWN5SW5zdGFuY2VzID0gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSk7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdW5pcXVlIElEc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVnYWN5SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZiA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50RGVmQnlVaWQobGVnYWN5SW5zdGFuY2VzW2ldLl9pZCk7XHJcbiAgICAgICAgICAgICAgICBpZE1hcFtldmVudERlZi5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICAgICAgZm9yIChpIGluIGlkTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlRXZlbnREZWZzQnlJZChpKTsgLy8gcGVyc2lzdD10cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gbGVnYWN5UXVlcnkgb3BlcmF0ZXMgb24gbGVnYWN5IGV2ZW50IGluc3RhbmNlIG9iamVjdHNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jbGllbnRFdmVudHMgPSBmdW5jdGlvbiAobGVnYWN5UXVlcnkpIHtcclxuICAgICAgICB2YXIgbGVnYWN5RXZlbnRJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgbGVnYWN5RXZlbnRJbnN0YW5jZXMucHVzaChldmVudEluc3RhbmNlLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJMZWdhY3lFdmVudEluc3RhbmNlcyhsZWdhY3lFdmVudEluc3RhbmNlcywgbGVnYWN5UXVlcnkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRQcm9wc0FycmF5KSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudFByb3BzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVFdmVudChldmVudFByb3BzQXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50UHJvcHMpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudERlZkJ5VWlkKGV2ZW50UHJvcHMuX2lkKTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAoZXZlbnREZWYgaW5zdGFuY2VvZiBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSA9IGV2ZW50RGVmLmJ1aWxkSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0LmNyZWF0ZUZyb21SYXdQcm9wcyhldmVudEluc3RhbmNlLCBldmVudFByb3BzLCAvLyByYXcgcHJvcHNcclxuICAgICAgICAgICAgbnVsbCAvLyBsYXJnZVVuaXQgLS0gd2hvIHVzZXMgaXQ/XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm11dGF0ZUV2ZW50c1dpdGhJZChldmVudERlZi5pZCwgZXZlbnREZWZNdXRhdGlvbik7IC8vIHdpbGwgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIub3RoZXJTb3VyY2VzLnNsaWNlKCk7IC8vIGNsb25lXHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5nZXRTb3VyY2VCeUlkKEV2ZW50U291cmNlXzEuZGVmYXVsdC5ub3JtYWxpemVJZChpZCkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5hZGRFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VJbnB1dCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucGFyc2Uoc291cmNlSW5wdXQsIHRoaXMpO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkU291cmNlKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoc291cmNlTXVsdGlRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgc291cmNlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc291cmNlTXVsdGlRdWVyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZUFsbFNvdXJjZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNvdXJjZXMgPSBldmVudE1hbmFnZXIubXVsdGlRdWVyeVNvdXJjZXMoc291cmNlTXVsdGlRdWVyeSk7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbW92ZUV2ZW50U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gZXZlbnRNYW5hZ2VyLnF1ZXJ5U291cmNlcyhzb3VyY2VRdWVyeSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlZmV0Y2hFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoc291cmNlTXVsdGlRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgc291cmNlcyA9IGV2ZW50TWFuYWdlci5tdWx0aVF1ZXJ5U291cmNlcyhzb3VyY2VNdWx0aVF1ZXJ5KTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlZmV0Y2hTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gbm90IGZvciBpbnRlcm5hbCB1c2UuIHVzZSBvcHRpb25zIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxyXG4gICAgQ2FsZW5kYXIuZGVmYXVsdHMgPSBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHM7XHJcbiAgICBDYWxlbmRhci5lbmdsaXNoRGVmYXVsdHMgPSBvcHRpb25zXzEuZW5nbGlzaERlZmF1bHRzO1xyXG4gICAgQ2FsZW5kYXIucnRsRGVmYXVsdHMgPSBvcHRpb25zXzEucnRsRGVmYXVsdHM7XHJcbiAgICByZXR1cm4gQ2FsZW5kYXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENhbGVuZGFyO1xyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oQ2FsZW5kYXIpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKENhbGVuZGFyKTtcclxuZnVuY3Rpb24gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5RXZlbnRJbnN0YW5jZXMsIGxlZ2FjeVF1ZXJ5KSB7XHJcbiAgICBpZiAobGVnYWN5UXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihsZWdhY3lRdWVyeSkpIHtcclxuICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZXMuZmlsdGVyKGxlZ2FjeVF1ZXJ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxlZ2FjeVF1ZXJ5ICs9ICcnOyAvLyBub3JtYWxpemUgdG8gc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAobGVnYWN5RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAvLyBzb2Z0IGNvbXBhcmlzb24gYmVjYXVzZSBpZCBub3QgYmUgbm9ybWFsaXplZCB0byBzdHJpbmdcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlLmlkID09IGxlZ2FjeVF1ZXJ5IHx8XHJcbiAgICAgICAgICAgICAgICBsZWdhY3lFdmVudEluc3RhbmNlLl9pZCA9PT0gbGVnYWN5UXVlcnk7IC8vIGNhbiBzcGVjaWZ5IGludGVybmFsIGlkLCBidXQgbXVzdCBleGFjdGx5IG1hdGNoXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlUHJvZmlsZUdlbmVyYXRvcihfdmlldykge1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcclxuICAgIH1cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcudHJpbUhpZGRlbkRheXModW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUubXNUb1V0Y01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5jYWxlbmRhci5tc1RvVXRjTW9tZW50KG1zLCBmb3JjZUFsbERheSk7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUHJldiA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgcHJldkRhdGUgPSBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZS5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5zdGFydE9mKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxyXG4gICAgICAgICAgICAuc3VidHJhY3QoY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGROZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBuZXh0RGF0ZSA9IGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlLmNsb25lKClcclxuICAgICAgICAgICAgLnN0YXJ0T2YoY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpXHJcbiAgICAgICAgICAgIC5hZGQoY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBPcHRpb25hbCBkaXJlY3Rpb24gcGFyYW0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgYmVpbmcgaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWRcclxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCA9PT0gdm9pZCAwKSB7IGZvcmNlVG9WYWxpZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGlzRGF0ZUFsbERheSA9ICFkYXRlLmhhc1RpbWUoKTtcclxuICAgICAgICB2YXIgdmFsaWRVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIG1pblRpbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBtYXhUaW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgY3VycmVudEluZm87XHJcbiAgICAgICAgdmFyIGlzUmFuZ2VBbGxEYXk7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBpc1ZhbGlkO1xyXG4gICAgICAgIHZhbGlkVW56b25lZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcclxuICAgICAgICB2YWxpZFVuem9uZWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRVbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMubXNUb1V0Y01vbWVudCh2YWxpZFVuem9uZWRSYW5nZS5jb25zdHJhaW5EYXRlKGRhdGUpLCAvLyByZXR1cm5zIE1TXHJcbiAgICAgICAgICAgIGlzRGF0ZUFsbERheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xyXG4gICAgICAgIHJlbmRlclVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZSksIGN1cnJlbnRJbmZvLnVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHJlbmRlclVuem9uZWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyVW56b25lZFJhbmdlKTtcclxuICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2UgPSByZW5kZXJVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgICAgICBpZiAoIXRoaXMub3B0KCdzaG93Tm9uQ3VycmVudERhdGVzJykpIHtcclxuICAgICAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gYWN0aXZlVW56b25lZFJhbmdlLmludGVyc2VjdChjdXJyZW50SW5mby51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5UaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtaW5UaW1lJykpO1xyXG4gICAgICAgIG1heFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ21heFRpbWUnKSk7XHJcbiAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVVbnpvbmVkUmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpO1xyXG4gICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IGFjdGl2ZVVuem9uZWRSYW5nZS5pbnRlcnNlY3QodmFsaWRVbnpvbmVkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxyXG4gICAgICAgIGlmIChhY3RpdmVVbnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMubXNUb1V0Y01vbWVudChhY3RpdmVVbnpvbmVkUmFuZ2UuY29uc3RyYWluRGF0ZShkYXRlKSwgLy8gcmV0dXJucyBNU1xyXG4gICAgICAgICAgICBpc0RhdGVBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcclxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAgICBpc1ZhbGlkID0gY3VycmVudEluZm8udW56b25lZFJhbmdlLmludGVyc2VjdHNXaXRoKHZhbGlkVW56b25lZFJhbmdlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxyXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIHZhbGlkVW56b25lZFJhbmdlOiB2YWxpZFVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxyXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcclxuICAgICAgICAgICAgY3VycmVudFVuem9uZWRSYW5nZTogY3VycmVudEluZm8udW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXHJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXHJcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXk6IGlzUmFuZ2VBbGxEYXksXHJcbiAgICAgICAgICAgIC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXHJcbiAgICAgICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZTogYWN0aXZlVW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cclxuICAgICAgICAgICAgcmVuZGVyVW56b25lZFJhbmdlOiByZW5kZXJVbnpvbmVkUmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XHJcbiAgICAgICAgICAgIG1pblRpbWU6IG1pblRpbWUsXHJcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgbWF4VGltZTogbWF4VGltZSxcclxuICAgICAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcclxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcclxuICAgICAgICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKVxyXG4gICAgICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cclxuICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXHJcbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkVmFsaWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRVbnpvbmVkUmFuZ2VPcHRpb24oJ3ZhbGlkUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmdldE5vdygpKSB8fFxyXG4gICAgICAgICAgICBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdCgpOyAvLyBjb21wbGV0ZWx5IG9wZW4tZW5kZWRcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcclxuICAgIC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxyXG4gICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXHJcbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgdmlld1NwZWMgPSB0aGlzLl92aWV3LnZpZXdTcGVjO1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIHZhciBkYXlDb3VudDtcclxuICAgICAgICBpZiAodmlld1NwZWMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB2aWV3U3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdW5pdCA9IHZpZXdTcGVjLmR1cmF0aW9uVW5pdDtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLm9wdCgnZGF5Q291bnQnKSkpIHtcclxuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xyXG4gICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQodW56b25lZFJhbmdlLmdldFN0YXJ0KCksIHVuem9uZWRSYW5nZS5nZXRFbmQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xyXG4gICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgdW56b25lZFJhbmdlOiB1bnpvbmVkUmFuZ2UgfTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogMSB9KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgbmV3IGFjdGl2ZVVuem9uZWRSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXHJcbiAgICAvLyBtaW5UaW1lIG9yIG1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYWRqdXN0QWN0aXZlUmFuZ2UgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlLCBtaW5UaW1lLCBtYXhUaW1lKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICBpZiAodGhpcy5fdmlldy51c2VzTWluTWF4VGltZSkge1xyXG4gICAgICAgICAgICBpZiAobWluVGltZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCkuYWRkKG1pblRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhUaW1lID4gMjQgKiA2MCAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnRpbWUobWF4VGltZSAtICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXHJcbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgY29tcHV0ZUdyZWF0ZXN0VW5pdCB2YWx1ZSBvZiBkdXJhdGlvbi5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EdXJhdGlvbiA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XHJcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50Jyk7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnRJbnB1dDtcclxuICAgICAgICB2YXIgZGF0ZUluY3JlbWVudER1cmF0aW9uO1xyXG4gICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXHJcbiAgICAgICAgaWYgKCFhbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudElucHV0ID0gdGhpcy5vcHQoJ2RhdGVJbmNyZW1lbnQnKTtcclxuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnREdXJhdGlvbiA8IGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdXRpbF8xLmNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkYXRlSW5jcmVtZW50RHVyYXRpb24sIGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxyXG4gICAgICAgIGlmIChkdXJhdGlvbi5hcygnZGF5cycpIDw9IDEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZXcuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX3ZpZXcuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zdGFydE9mKCdkYXknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUmVzKCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgcmVzID0gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXB1dGVSZXMoKTtcclxuICAgICAgICAvLyBpZiByYW5nZSBpcyBjb21wbGV0ZWx5IGVudmVsb3BlZCBieSBoaWRkZW4gZGF5cywgZ28gcGFzdCB0aGUgaGlkZGVuIGRheXNcclxuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5fdmlldy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxyXG4gICAgLy8gVE9ETzogYWNjZXB0IGEgTVMtdGltZSBpbnN0ZWFkIG9mIGEgbW9tZW50IGBkYXRlYD9cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbURheUNvdW50ID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcclxuICAgICAgICB2YXIgY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5vcHQoJ2RhdGVBbGlnbm1lbnQnKTtcclxuICAgICAgICB2YXIgcnVubmluZ0NvdW50ID0gMDtcclxuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoY3VzdG9tQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0YXJ0T2YoY3VzdG9tQWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnQuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgc3RhcnQgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBlbmQuYWRkKDEsICdkYXknKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl92aWV3LmlzSGlkZGVuRGF5KGVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHJ1bm5pbmdDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxyXG4gICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50VW56b25lZFJhbmdlIGFuZCBhY3RpdmVVbnpvbmVkUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciB2aXNpYmxlVW56b25lZFJhbmdlID0gdGhpcy5fdmlldy5nZXRVbnpvbmVkUmFuZ2VPcHRpb24oJ3Zpc2libGVSYW5nZScsIHRoaXMuX3ZpZXcuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShkYXRlKSAvLyBjb3JyZWN0IHpvbmUuIGFsc28gZ2VuZXJhdGVzIG5ldyBvYmogdGhhdCBhdm9pZHMgbXV0YXRpb25zXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodmlzaWJsZVVuem9uZWRSYW5nZSAmJiAodmlzaWJsZVVuem9uZWRSYW5nZS5zdGFydE1zID09IG51bGwgfHwgdmlzaWJsZVVuem9uZWRSYW5nZS5lbmRNcyA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpc2libGVVbnpvbmVkUmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHJhbmdlIHRoYXQgd2lsbCByZXByZXNlbnQgdGhlIGVsZW1lbnQvY2VsbHMgZm9yICpyZW5kZXJpbmcqLFxyXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxyXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudFVuem9uZWRSYW5nZS5jbG9uZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcclxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGREYXRlSW5jcmVtZW50ID0gZnVuY3Rpb24gKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0KCdkYXRlSW5jcmVtZW50Jyk7XHJcbiAgICAgICAgdmFyIGN1c3RvbUFsaWdubWVudDtcclxuICAgICAgICBpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50JykpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIGV4cG9ydEhvb2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV4dGVybmFsRHJvcHBpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFeHRlcm5hbERyb3BwaW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxEcm9wcGluZygpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGpxdWktZHJhZ2dpbmcgYW4gZXh0ZXJuYWwgZWxlbWVudD8gYm9vbGVhblxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wZW1lbnRzOlxyXG4gICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgLSBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICAgLSBpc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICAgLSByZW5kZXJEcmFnXHJcbiAgICAgIC0gdW5yZW5kZXJEcmFnXHJcbiAgICAqL1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5iaW5kVG9Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XHJcbiAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5oYW5kbGVEcmFnU3RhcnQsXHJcbiAgICAgICAgICAgIHNvcnRzdGFydDogdGhpcy5oYW5kbGVEcmFnU3RhcnQgLy8ganF1aVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLnVuYmluZEZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBpcyBpbml0aWF0ZWQgYW55d2hlcmUgaW4gdGhlIERPTVxyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2LCB1aSkge1xyXG4gICAgICAgIHZhciBlbDtcclxuICAgICAgICB2YXIgYWNjZXB0O1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnZHJvcHBhYmxlJykpIHtcclxuICAgICAgICAgICAgZWwgPSAkKCh1aSA/IHVpLml0ZW0gOiBudWxsKSB8fCBldi50YXJnZXQpO1xyXG4gICAgICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIGRyYWdnZWQgZWxlbWVudCBwYXNzZXMgdGhlIGRyb3BBY2NlcHQgc2VsZWN0b3Igb3IgZmlsdGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAvLyBGWUksIHRoZSBkZWZhdWx0IGlzIFwiKlwiIChtYXRjaGVzIGFsbClcclxuICAgICAgICAgICAgYWNjZXB0ID0gdGhpcy5vcHQoJ2Ryb3BBY2NlcHQnKTtcclxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihhY2NlcHQpID8gYWNjZXB0LmNhbGwoZWxbMF0sIGVsKSA6IGVsLmlzKGFjY2VwdCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ub0V4dGVybmFsRHJhZyhlbCwgZXYsIHVpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIGpRdWVyeSBVSSBkcmFnIHN0YXJ0cyBhbmQgaXQgbmVlZHMgdG8gYmUgbW9uaXRvcmVkIGZvciBkcm9wcGluZ1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUubGlzdGVuVG9FeHRlcm5hbERyYWcgPSBmdW5jdGlvbiAoZWwsIGV2LCB1aSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBtZXRhID0gZ2V0RHJhZ2dlZEVsTWV0YShlbCk7IC8vIGV4dHJhIGRhdGEgYWJvdXQgZXZlbnQgZHJvcCwgaW5jbHVkaW5nIHBvc3NpYmxlIGV2ZW50IHRvIGNyZWF0ZVxyXG4gICAgICAgIHZhciBzaW5nbGVFdmVudERlZjsgLy8gYSBudWxsIHZhbHVlIHNpZ25hbHMgYW4gdW5zdWNjZXNzZnVsIGRyYWdcclxuICAgICAgICAvLyBsaXN0ZW5lciB0aGF0IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIGRhdGUtYXNzb2NpYXRlZCBwaXhlbCByZWdpb25zXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRGb290cHJpbnQgPSBoaXQuY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTsgLy8gaGl0IG1pZ2h0IG5vdCBiZWxvbmcgdG8gdGhpcyBncmlkXHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgICAgIGlmIChoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IF90aGlzLmNvbXB1dGVFeHRlcm5hbERyb3AoaGl0Rm9vdHByaW50LCBtZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCA9IG5ldyBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0KHNpbmdsZUV2ZW50RGVmLmJ1aWxkSW5zdGFuY2VzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBtZXRhLmV2ZW50UHJvcHMgPyAvLyBpc0V2ZW50P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZChtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlckRyYWcoLy8gY2FsbGVkIHdpdGhvdXQgYSBzZWcgcGFyYW1ldGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhjb21wb25lbnQuZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLCB2aWV3LmNhbGVuZGFyKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmID0gbnVsbDsgLy8gc2lnbmFsIHVuc3VjY2Vzc2Z1bFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudW5yZW5kZXJEcmFnKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFdmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVwb3J0RXh0ZXJuYWxEcm9wKHNpbmdsZUV2ZW50RGVmLCBCb29sZWFuKG1ldGEuZXZlbnRQcm9wcyksIC8vIGlzRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuKG1ldGEuc3RpY2spLCAvLyBpc1N0aWNreVxyXG4gICAgICAgICAgICAgICAgICAgIGVsLCBldiwgdWkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydERyYWcoZXYpOyAvLyBzdGFydCBsaXN0ZW5pbmcgaW1tZWRpYXRlbHlcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGhpdCB0byBiZSBkcm9wcGVkIHVwb24sIGFuZCBtaXNjIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBqcXVpIGRyYWcgKGd1YXJhbnRlZWQgdG8gYmUgYSBwbGFpbiBvYmplY3QpLFxyXG4gICAgLy8gcmV0dXJucyB0aGUgem9uZWQgc3RhcnQvZW5kIGRhdGVzIGZvciB0aGUgZXZlbnQgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSB0aGUgaHlwb3RoZXRpY2FsIGRyb3AuIGVuZCBtaWdodCBiZSBudWxsLlxyXG4gICAgLy8gUmV0dXJuaW5nIGEgbnVsbCB2YWx1ZSBzaWduYWxzIGFuIGludmFsaWQgZHJvcCBoaXQuXHJcbiAgICAvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnQuXHJcbiAgICAvLyBBc3N1bWVzIGJvdGggZm9vdHByaW50cyBhcmUgbm9uLW9wZW4tZW5kZWQuXHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5jb21wdXRlRXh0ZXJuYWxEcm9wID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCwgbWV0YSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgc3RhcnQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5zdGFydE1zKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIHZhciBldmVudERlZjtcclxuICAgICAgICBpZiAoY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGRyb3BwZWQgb24gYW4gYWxsLWRheSBzcGFuLCBhbmQgZWxlbWVudCdzIG1ldGFkYXRhIHNwZWNpZmllZCBhIHRpbWUsIHNldCBpdFxyXG4gICAgICAgICAgICBpZiAobWV0YS5zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUobWV0YS5zdGFydFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1ldGEuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQobWV0YS5kdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0ID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShzdGFydCk7XHJcbiAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50RGVmID0gU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKCQuZXh0ZW5kKHt9LCBtZXRhLmV2ZW50UHJvcHMsIHtcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZFxyXG4gICAgICAgIH0pLCBuZXcgRXZlbnRTb3VyY2VfMS5kZWZhdWx0KGNhbGVuZGFyKSk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50RGVmO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFeHRlcm5hbERyb3BwaW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFeHRlcm5hbERyb3BwaW5nO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV4dGVybmFsRHJvcHBpbmcpO1xyXG4vKiBFeHRlcm5hbC1EcmFnZ2luZy1FbGVtZW50IERhdGFcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFJlcXVpcmUgYWxsIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVzIHVzZWQgYnkgRnVsbENhbGVuZGFyIHRvIGhhdmUgdGhpcyBwcmVmaXguXHJcbi8vIEEgdmFsdWUgb2YgJycgd2lsbCBxdWVyeSBhdHRyaWJ1dGVzIGxpa2UgZGF0YS1ldmVudC4gQSB2YWx1ZSBvZiAnZmMnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZmMtZXZlbnQuXHJcbmV4cG9ydEhvb2tzLmRhdGFBdHRyUHJlZml4ID0gJyc7XHJcbi8vIEdpdmVuIGEgalF1ZXJ5IGVsZW1lbnQgdGhhdCBtaWdodCByZXByZXNlbnQgYSBkcmFnZ2VkIEZ1bGxDYWxlbmRhciBldmVudCwgcmV0dXJucyBhbiBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVcclxuLy8gdG8gYmUgdXNlZCBmb3IgRXZlbnQgT2JqZWN0IGNyZWF0aW9uLlxyXG4vLyBBIGRlZmluZWQgYC5ldmVudFByb3BzYCwgZXZlbiB3aGVuIGVtcHR5LCBpbmRpY2F0ZXMgdGhhdCBhbiBldmVudCBzaG91bGQgYmUgY3JlYXRlZC5cclxuZnVuY3Rpb24gZ2V0RHJhZ2dlZEVsTWV0YShlbCkge1xyXG4gICAgdmFyIHByZWZpeCA9IGV4cG9ydEhvb2tzLmRhdGFBdHRyUHJlZml4O1xyXG4gICAgdmFyIGV2ZW50UHJvcHM7IC8vIHByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIHRoZSBldmVudCwgbm90IHJlbGF0ZWQgdG8gZGF0ZS90aW1lXHJcbiAgICB2YXIgc3RhcnRUaW1lOyAvLyBhIER1cmF0aW9uXHJcbiAgICB2YXIgZHVyYXRpb247XHJcbiAgICB2YXIgc3RpY2s7XHJcbiAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgcHJlZml4ICs9ICctJztcclxuICAgIH1cclxuICAgIGV2ZW50UHJvcHMgPSBlbC5kYXRhKHByZWZpeCArICdldmVudCcpIHx8IG51bGw7XHJcbiAgICBpZiAoZXZlbnRQcm9wcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRQcm9wcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZXZlbnRQcm9wcyA9ICQuZXh0ZW5kKHt9LCBldmVudFByb3BzKTsgLy8gbWFrZSBhIGNvcHlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50UHJvcHMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGx1Y2sgc3BlY2lhbC1jYXNlZCBkYXRlL3RpbWUgcHJvcGVydGllc1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IGV2ZW50UHJvcHMuc3RhcnQ7XHJcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGV2ZW50UHJvcHMudGltZTtcclxuICAgICAgICB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxyXG4gICAgICAgIGR1cmF0aW9uID0gZXZlbnRQcm9wcy5kdXJhdGlvbjtcclxuICAgICAgICBzdGljayA9IGV2ZW50UHJvcHMuc3RpY2s7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuc3RhcnQ7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMudGltZTtcclxuICAgICAgICBkZWxldGUgZXZlbnRQcm9wcy5kdXJhdGlvbjtcclxuICAgICAgICBkZWxldGUgZXZlbnRQcm9wcy5zdGljaztcclxuICAgIH1cclxuICAgIC8vIGZhbGxiYWNrIHRvIHN0YW5kYWxvbmUgYXR0cmlidXRlIHZhbHVlcyBmb3IgZWFjaCBvZiB0aGUgZGF0ZS90aW1lIHByb3BlcnRpZXNcclxuICAgIGlmIChzdGFydFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3N0YXJ0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhcnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICd0aW1lJyk7XHJcbiAgICB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxyXG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcclxuICAgICAgICBkdXJhdGlvbiA9IGVsLmRhdGEocHJlZml4ICsgJ2R1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RpY2sgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0aWNrID0gZWwuZGF0YShwcmVmaXggKyAnc3RpY2snKTtcclxuICAgIH1cclxuICAgIC8vIG1hc3NhZ2UgaW50byBjb3JyZWN0IGRhdGEgdHlwZXNcclxuICAgIHN0YXJ0VGltZSA9IHN0YXJ0VGltZSAhPSBudWxsID8gbW9tZW50LmR1cmF0aW9uKHN0YXJ0VGltZSkgOiBudWxsO1xyXG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAhPSBudWxsID8gbW9tZW50LmR1cmF0aW9uKGR1cmF0aW9uKSA6IG51bGw7XHJcbiAgICBzdGljayA9IEJvb2xlYW4oc3RpY2spO1xyXG4gICAgcmV0dXJuIHsgZXZlbnRQcm9wczogZXZlbnRQcm9wcywgc3RhcnRUaW1lOiBzdGFydFRpbWUsIGR1cmF0aW9uOiBkdXJhdGlvbiwgc3RpY2s6IHN0aWNrIH07XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XHJcbnZhciBIaXREcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRXZlbnRSZXNpemluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50UmVzaXppbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGVtZW50czpcclxuICAgICAgLSBiaW5kU2VnSGFuZGxlclRvRWxcclxuICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICAgLSBkaWZmRGF0ZXNcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgIC0gZ2V0U2FmZUhpdEZvb3RwcmludFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIEV2ZW50UmVzaXppbmcoY29tcG9uZW50LCBldmVudFBvaW50aW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nID0gZXZlbnRQb2ludGluZztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bi5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZywgJChldi50YXJnZXQpLmlzKCcuZmMtc3RhcnQtcmVzaXplcicpKVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHsgZGlzdGFuY2U6IDUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZywgJChldi50YXJnZXQpLmlzKCcuZmMtc3RhcnQtcmVzaXplcicpKVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIgYXMgdGhleSByZXNpemUgYW4gZXZlbnQgc2VnbWVudC5cclxuICAgIC8vIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBHcmlkLlxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnLCBpc1N0YXJ0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBlbCA9IHNlZy5lbDtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBpc0RyYWdnaW5nO1xyXG4gICAgICAgIHZhciByZXNpemVNdXRhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzLiBmYWxzeSBpZiBpbnZhbGlkIHJlc2l6ZVxyXG4gICAgICAgIC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqZ3JpZCdzKiBjb29yZGluYXRlIG1hcFxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIHN1YmplY3RFbDogZWwsXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgbW91c2VvdXQgb24gdGhlIG1hbmlwdWxhdGVkIGV2ZW50IGhhcyBiZWVuIHJlcG9ydGVkXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nLmhhbmRsZU1vdXNlb3V0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnUmVzaXplU3RhcnQoc2VnLCBldik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0hpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KG9yaWdIaXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnSGl0Rm9vdHByaW50ICYmIGhpdEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gaXNTdGFydCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVFdmVudFN0YXJ0UmVzaXplTXV0YXRpb24ob3JpZ0hpdEZvb3RwcmludCwgaGl0Rm9vdHByaW50LCBzZWcuZm9vdHByaW50KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVFdmVudEVuZFJlc2l6ZU11dGF0aW9uKG9yaWdIaXRGb290cHJpbnQsIGhpdEZvb3RwcmludCwgc2VnLmZvb3RwcmludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBldmVudE1hbmFnZXIuYnVpbGRNdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKGV2ZW50RGVmLmlkLCByZXNpemVNdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNpemVNdXRhdGlvbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjaGFuZ2UuIChGWUksIGV2ZW50IGRhdGVzIG1pZ2h0IGhhdmUgem9uZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5oaWRlRXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyRXZlbnRSZXNpemUoY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhjb21wb25lbnQuZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLCBjYWxlbmRhcikpLCBzZWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmlldy51bnJlbmRlckV2ZW50UmVzaXplKHNlZyk7XHJcbiAgICAgICAgICAgICAgICB2aWV3LnNob3dFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnUmVzaXplU3RvcChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmUtc2hvdyBvcmlnaW5hbCwgd2lsbCByZXJlbmRlciBhbGwgYW55d2F5cy4gZXNwIGltcG9ydGFudCBpZiBldmVudFJlbmRlcldhaXRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV2ZW50UmVzaXplKGV2ZW50SW5zdGFuY2UsIHJlc2l6ZU11dGF0aW9uLCBlbCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0YXJ0c1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuc2VnUmVzaXplU3RhcnQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHRoaXMuaXNSZXNpemluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0b3BzXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5zZWdSZXNpemVTdG9wID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmNvbXB1dGVFdmVudFN0YXJ0UmVzaXplTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgb3JpZ0V2ZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIG9yaWdSYW5nZSA9IG9yaWdFdmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBzdGFydERlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKSwgc3RhcnRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCkpO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKG9yaWdSYW5nZS5nZXRTdGFydCgpLmFkZChzdGFydERlbHRhKSA8IG9yaWdSYW5nZS5nZXRFbmQoKSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbi5zZXRTdGFydERlbHRhKHN0YXJ0RGVsdGEpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKGRhdGVNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBuZXcgZGF0ZS1pbmZvcm1hdGlvbiBmb3IgYW4gZXZlbnQgc2VnbWVudCBiZWluZyByZXNpemVkIGZyb20gaXRzIGVuZFxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RW5kUmVzaXplTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgb3JpZ0V2ZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIG9yaWdSYW5nZSA9IG9yaWdFdmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBlbmREZWx0YSA9IHRoaXMuY29tcG9uZW50LmRpZmZEYXRlcyhlbmRGb290cHJpbnQudW56b25lZFJhbmdlLmdldEVuZCgpLCBzdGFydEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKG9yaWdSYW5nZS5nZXRFbmQoKS5hZGQoZW5kRGVsdGEpID4gb3JpZ1JhbmdlLmdldFN0YXJ0KCkpIHtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24uc2V0RW5kRGVsdGEoZW5kRGVsdGEpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKGRhdGVNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UmVzaXppbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmVzaXppbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudERlZk11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxudmFyIEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XHJcbnZhciBIaXREcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgTW91c2VGb2xsb3dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDQpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRXZlbnREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50RHJhZ2dpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGxlbWVudHM6XHJcbiAgICAgIC0gYmluZFNlZ0hhbmRsZXJUb0VsXHJcbiAgICAgIC0gcHVibGljbHlUcmlnZ2VyXHJcbiAgICAgIC0gZGlmZkRhdGVzXHJcbiAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAtIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIEV2ZW50RHJhZ2dpbmcoY29tcG9uZW50LCBldmVudFBvaW50aW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nID0gZXZlbnRQb2ludGluZztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmdldFNlbGVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0KCdldmVudExvbmdQcmVzc0RlbGF5Jyk7XHJcbiAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsYXkgPSB0aGlzLm9wdCgnbG9uZ1ByZXNzRGVsYXknKTsgLy8gZmFsbGJhY2tcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfTtcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlZG93bi5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuc2hvdWxkSWdub3JlTW91c2UoKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5jYW5TdGFydERyYWcoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcpLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHsgZGlzdGFuY2U6IDUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgIGRlbGF5OiB0aGlzLnZpZXcuaXNFdmVudERlZlNlbGVjdGVkKHNlZy5mb290cHJpbnQuZXZlbnREZWYpID8gLy8gYWxyZWFkeSBzZWxlY3RlZD9cclxuICAgICAgICAgICAgICAgIDAgOiB0aGlzLmdldFNlbGVjdGlvbkRlbGF5KClcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjb21wb25lbnQuY2FuU3RhcnREcmFnKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREcmFnTGlzdGVuZXIoc2VnKS5zdGFydEludGVyYWN0aW9uKGV2LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5jYW5TdGFydFNlbGVjdGlvbihzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkU2VsZWN0TGlzdGVuZXIoc2VnKS5zdGFydEludGVyYWN0aW9uKGV2LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHNlZyBpc24ndCBkcmFnZ2FibGUsIGJ1dCBsZXQncyB1c2UgYSBnZW5lcmljIERyYWdMaXN0ZW5lclxyXG4gICAgLy8gc2ltcGx5IGZvciB0aGUgZGVsYXksIHNvIGl0IGNhbiBiZSBzZWxlY3RlZC5cclxuICAgIC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgZHJhZ0xpc3RlbmVyYFxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuYnVpbGRTZWxlY3RMaXN0ZW5lciA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBzZWcuZm9vdHByaW50LmV2ZW50SW5zdGFuY2U7IC8vIG51bGwgZm9yIGludmVyc2UtYmFja2dyb3VuZCBldmVudHNcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgRHJhZ0xpc3RlbmVyXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0xpc3RlbmVyLmlzVG91Y2ggJiZcclxuICAgICAgICAgICAgICAgICAgICAhdmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoZXZlbnREZWYpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBwcmV2aW91c2x5IHNlbGVjdGVkLCB3aWxsIGZpcmUgYWZ0ZXIgYSBkZWxheS4gdGhlbiwgc2VsZWN0IHRoZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2VsZWN0RXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyYWNrIHVzZXItZHJhZ2dpbmcgb24gYW4gZXZlbnQgc2VnbWVudC5cclxuICAgIC8vIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBHcmlkLlxyXG4gICAgLy8gSGFzIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcvdW5zZXR0aW5nIGBkcmFnTGlzdGVuZXJgXHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5idWlsZERyYWdMaXN0ZW5lciA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSBjYWxlbmRhci5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGVsID0gc2VnLmVsO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBzZWcuZm9vdHByaW50LmV2ZW50SW5zdGFuY2U7IC8vIG51bGwgZm9yIGludmVyc2UtYmFja2dyb3VuZCBldmVudHNcclxuICAgICAgICB2YXIgaXNEcmFnZ2luZztcclxuICAgICAgICB2YXIgbW91c2VGb2xsb3dlcjsgLy8gQSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0aGF0IHdpbGwgbW92ZSB3aXRoIHRoZSBtb3VzZVxyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFnTGlzdGVuZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqdmlldydzKiBjb29yZGluYXRlIG1hcC4gQWxsb3dzIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBiZXR3ZWVuIHN1YmNvbXBvbmVudHNcclxuICAgICAgICAvLyBvZiB0aGUgdmlldy5cclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdCh2aWV3LCB7XHJcbiAgICAgICAgICAgIHNjcm9sbDogdGhpcy5vcHQoJ2RyYWdTY3JvbGwnKSxcclxuICAgICAgICAgICAgc3ViamVjdEVsOiBlbCxcclxuICAgICAgICAgICAgc3ViamVjdENlbnRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuY29tcG9uZW50ID0gY29tcG9uZW50OyAvLyBmb3IgcmVuZGVyRHJhZ1xyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlciA9IG5ldyBNb3VzZUZvbGxvd2VyXzEuZGVmYXVsdChzZWcuZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ2xhc3M6ICdmYy1kcmFnZ2luZycsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWw6IHZpZXcuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogZHJhZ0xpc3RlbmVyLmlzVG91Y2ggPyBudWxsIDogX3RoaXMub3B0KCdkcmFnT3BhY2l0eScpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldmVydER1cmF0aW9uOiBfdGhpcy5vcHQoJ2RyYWdSZXZlcnREdXJhdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogMiAvLyBvbmUgYWJvdmUgdGhlIC5mYy12aWV3XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBkb24ndCBzaG93IHVudGlsIHdlIGtub3cgdGhpcyBpcyBhIHJlYWwgZHJhZ1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5zdGFydChldik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0xpc3RlbmVyLmlzVG91Y2ggJiZcclxuICAgICAgICAgICAgICAgICAgICAhdmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoZXZlbnREZWYpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBwcmV2aW91c2x5IHNlbGVjdGVkLCB3aWxsIGZpcmUgYWZ0ZXIgYSBkZWxheS4gdGhlbiwgc2VsZWN0IHRoZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2VsZWN0RXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgbW91c2VvdXQgb24gdGhlIG1hbmlwdWxhdGVkIGV2ZW50IGhhcyBiZWVuIHJlcG9ydGVkXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nLmhhbmRsZU1vdXNlb3V0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnRHJhZ1N0YXJ0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgdmlldy5oaWRlRXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydGluZyBoaXQgY291bGQgYmUgZm9yY2VkIChEYXlHcmlkLmxpbWl0KVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5oaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnSGl0ID0gc2VnLmhpdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGhpdCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZCwgc28gcXVlcnkgb3JpZ2luIGdyaWRcclxuICAgICAgICAgICAgICAgIG9yaWdGb290cHJpbnQgPSBvcmlnSGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KG9yaWdIaXQpO1xyXG4gICAgICAgICAgICAgICAgZm9vdHByaW50ID0gaGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0Zvb3RwcmludCAmJiBmb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gX3RoaXMuY29tcHV0ZUV2ZW50RHJvcE11dGF0aW9uKG9yaWdGb290cHJpbnQsIGZvb3RwcmludCwgZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudERlZk11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBldmVudE1hbmFnZXIuYnVpbGRNdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKGV2ZW50RGVmLmlkLCBldmVudERlZk11dGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gY29tcG9uZW50LmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZChtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgYSB2YWxpZCBkcm9wIGxvY2F0aW9uLCBoYXZlIHRoZSBzdWJjbGFzcyByZW5kZXIgYSB2aXN1YWwgaW5kaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmTXV0YXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlbmRlckRyYWcoLy8gdHJ1dGh5IGlmIHJlbmRlcmVkIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgY2FsZW5kYXIpKSwgc2VnLCBkcmFnTGlzdGVuZXIuaXNUb3VjaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLmhpZGUoKTsgLy8gaWYgdGhlIHN1YmNsYXNzIGlzIGFscmVhZHkgdXNpbmcgYSBtb2NrIGV2ZW50IFwiaGVscGVyXCIsIGhpZGUgb3VyIG93blxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5zaG93KCk7IC8vIG90aGVyd2lzZSwgaGF2ZSB0aGUgaGVscGVyIGZvbGxvdyB0aGUgbW91c2UgKG5vIHNuYXBwaW5nKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzT3JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGhhdmUgbW92ZWQgaGl0cyB0byBiZSBhIHZhbGlkIGRyb3BcclxuICAgICAgICAgICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LnVucmVuZGVyRHJhZyhzZWcpOyAvLyB1bnJlbmRlciB3aGF0ZXZlciB3YXMgZG9uZSBpbiByZW5kZXJEcmFnXHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnNob3coKTsgLy8gc2hvdyBpbiBjYXNlIHdlIGFyZSBtb3Zpbmcgb3V0IG9mIGFsbCBoaXRzXHJcbiAgICAgICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VnLmNvbXBvbmVudDsgLy8gcHJldmVudCBzaWRlIGVmZmVjdHNcclxuICAgICAgICAgICAgICAgIC8vIGRvIHJldmVydCBhbmltYXRpb24gaWYgaGFzbid0IGNoYW5nZWQuIGNhbGxzIGEgY2FsbGJhY2sgd2hlbiBmaW5pc2hlZCAod2hldGhlciBhbmltYXRpb24gb3Igbm90KVxyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5zdG9wKCFldmVudERlZk11dGF0aW9uLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy51bnJlbmRlckRyYWcoc2VnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnRHJhZ1N0b3Aoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2hvd0V2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHJlLXNob3cgb3JpZ2luYWwsIHdpbGwgcmVyZW5kZXIgYWxsIGFueXdheXMuIGVzcCBpbXBvcnRhbnQgaWYgZXZlbnRSZW5kZXJXYWl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcucmVwb3J0RXZlbnREcm9wKGV2ZW50SW5zdGFuY2UsIGV2ZW50RGVmTXV0YXRpb24sIGVsLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYmVmb3JlIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RhcnRzXHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5zZWdEcmFnU3RhcnQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYWZ0ZXIgZXZlbnQgc2VnbWVudCBkcmFnZ2luZyBzdG9wc1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuc2VnRHJhZ1N0b3AgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnRcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmNvbXB1dGVFdmVudERyb3BNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50LCBldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5zZXREYXRlTXV0YXRpb24odGhpcy5jb21wdXRlRXZlbnREYXRlTXV0YXRpb24oc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCkpO1xyXG4gICAgICAgIHJldHVybiBldmVudERlZk11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmNvbXB1dGVFdmVudERhdGVNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIGRhdGUwID0gc3RhcnRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGRhdGUxID0gZW5kRm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBjbGVhckVuZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBmb3JjZVRpbWVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGZvcmNlQWxsRGF5ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRhdGVEZWx0YTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIGlmIChzdGFydEZvb3RwcmludC5pc0FsbERheSAhPT0gZW5kRm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGNsZWFyRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGVuZEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VBbGxEYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZGF0ZTAuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZVRpbWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlRGVsdGEgPSB0aGlzLmNvbXBvbmVudC5kaWZmRGF0ZXMoZGF0ZTEsIGRhdGUwKTtcclxuICAgICAgICBkYXRlTXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uLmNsZWFyRW5kID0gY2xlYXJFbmQ7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uLmZvcmNlVGltZWQgPSBmb3JjZVRpbWVkO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5mb3JjZUFsbERheSA9IGZvcmNlQWxsRGF5O1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5zZXREYXRlRGVsdGEoZGF0ZURlbHRhKTtcclxuICAgICAgICByZXR1cm4gZGF0ZU11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudERyYWdnaW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERyYWdnaW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBEYXRlU2VsZWN0aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF0ZVNlbGVjdGluZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgIC0gYmluZERhdGVIYW5kbGVyVG9FbFxyXG4gICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICAgLSByZW5kZXJIaWdobGlnaHRcclxuICAgICAgLSB1bnJlbmRlckhpZ2hsaWdodFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGVTZWxlY3RpbmcoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IF90aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuZ2V0RGVsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5vcHQoJ3NlbGVjdExvbmdQcmVzc0RlbGF5Jyk7XHJcbiAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsYXkgPSB0aGlzLm9wdCgnbG9uZ1ByZXNzRGVsYXknKTsgLy8gZmFsbGJhY2tcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfTtcclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3NlbGVjdGFibGUnKSAmJiAhY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IF90aGlzLm9wdCgnc2VsZWN0TWluRGlzdGFuY2UnKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnc2VsZWN0YWJsZScpICYmICFjb21wb25lbnQuc2hvdWxkSWdub3JlVG91Y2goKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheTogX3RoaXMuZ2V0RGVsYXkoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB1dGlsXzEucHJldmVudFNlbGVjdGlvbihlbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyJ3MgZHJhZyBhY3Jvc3MgZGF5IGVsZW1lbnRzLCBmb3IgZGF5IHNlbGVjdGluZy5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBzZWxlY3Rpb25Gb290cHJpbnQ7IC8vIG51bGwgaWYgaW52YWxpZCBzZWxlY3Rpb25cclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgIHNjcm9sbDogdGhpcy5vcHQoJ2RyYWdTY3JvbGwnKSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcudW5zZWxlY3QoZXYpOyAvLyBzaW5jZSB3ZSBjb3VsZCBiZSByZW5kZXJpbmcgYSBuZXcgc2VsZWN0aW9uLCB3ZSB3YW50IHRvIGNsZWFyIGFueSBvbGQgb25lXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdIaXRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGl0Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnSGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQob3JpZ0hpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdEZvb3RwcmludCAmJiBoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gX3RoaXMuY29tcHV0ZVNlbGVjdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KHNlbGVjdGlvbkZvb3RwcmludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbkZvb3RwcmludCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bnJlbmRlclNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkICYmIHNlbGVjdGlvbkZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb24gd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiByZW5kZXJlZC4ganVzdCByZXBvcnQgaXRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnJlcG9ydFNlbGVjdGlvbihzZWxlY3Rpb25Gb290cHJpbnQsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdGhlIGZpcnN0IGFuZCBsYXN0IGRhdGUtc3BhbnMgb2YgYSBzZWxlY3Rpb24sIHJldHVybnMgYW5vdGhlciBkYXRlLXNwYW4gb2JqZWN0LlxyXG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgYW5kIHByb3ZpZGUgYWRkaXRpb25hbCBkYXRhIGluIHRoZSBzcGFuIG9iamVjdC4gV2lsbCBiZSBwYXNzZWQgdG8gcmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KCkuXHJcbiAgICAvLyBXaWxsIHJldHVybiBmYWxzZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGludmFsaWQgYW5kIHRoaXMgc2hvdWxkIGJlIGluZGljYXRlZCB0byB0aGUgdXNlci5cclxuICAgIC8vIFdpbGwgcmV0dXJuIG51bGwvdW5kZWZpbmVkIGlmIGEgc2VsZWN0aW9uIGludmFsaWQgYnV0IG5vIGVycm9yIHNob3VsZCBiZSByZXBvcnRlZC5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmNvbXB1dGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZm9vdHByaW50MCwgZm9vdHByaW50MSkge1xyXG4gICAgICAgIHZhciB3aG9sZUZvb3RwcmludCA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvbkZvb3RwcmludChmb290cHJpbnQwLCBmb290cHJpbnQxKTtcclxuICAgICAgICBpZiAod2hvbGVGb290cHJpbnQgJiYgIXRoaXMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKHdob2xlRm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3aG9sZUZvb3RwcmludDtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiB0d28gc3BhbnMsIG11c3QgcmV0dXJuIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxyXG4gICAgLy8gVE9ETzogZG8gdGhpcyBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIChjb21iaW5pbmcgVlMgdmFsaWRhdGlvbikgZm9yIGV2ZW50IGRuZC9yZXNpemUgdG9vLlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuY29tcHV0ZVNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChmb290cHJpbnQwLCBmb290cHJpbnQxKSB7XHJcbiAgICAgICAgdmFyIG1zID0gW1xyXG4gICAgICAgICAgICBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MS51bnpvbmVkUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MS51bnpvbmVkUmFuZ2UuZW5kTXNcclxuICAgICAgICBdO1xyXG4gICAgICAgIG1zLnNvcnQodXRpbF8xLmNvbXBhcmVOdW1iZXJzKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQobXNbMF0sIG1zWzNdKSwgZm9vdHByaW50MC5pc0FsbERheSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5kYXRlUHJvZmlsZS52YWxpZFVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpICYmXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVNlbGVjdGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZVNlbGVjdGluZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFNjcm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxudmFyIFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG52YXIgVGltZUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI3KTtcclxudmFyIERheUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG52YXIgQUdFTkRBX0FMTF9EQVlfRVZFTlRfTElNSVQgPSA1O1xyXG52YXIgYWdlbmRhVGltZUdyaWRNZXRob2RzO1xyXG52YXIgYWdlbmRhRGF5R3JpZE1ldGhvZHM7XHJcbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciBhbGwgYWdlbmRhLXJlbGF0ZWQgdmlld3MuIERpc3BsYXlzIG9uZSBtb3JlIGNvbHVtbnMgd2l0aCB0aW1lIHNsb3RzIHJ1bm5pbmcgdmVydGljYWxseS5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIElzIGEgbWFuYWdlciBmb3IgdGhlIFRpbWVHcmlkIHN1YmNvbXBvbmVudCBhbmQgcG9zc2libHkgdGhlIERheUdyaWQgc3ViY29tcG9uZW50IChpZiBhbGxEYXlTbG90IGlzIG9uKS5cclxuLy8gUmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxudmFyIEFnZW5kYVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBZ2VuZGFWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWdlbmRhVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhciwgdmlld1NwZWMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudXNlc01pbk1heFRpbWUgPSB0cnVlOyAvLyBpbmRpY2F0ZXMgdGhhdCBtaW5UaW1lL21heFRpbWUgYWZmZWN0cyByZW5kZXJpbmdcclxuICAgICAgICBfdGhpcy50aW1lR3JpZCA9IF90aGlzLmluc3RhbnRpYXRlVGltZUdyaWQoKTtcclxuICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy50aW1lR3JpZCk7XHJcbiAgICAgICAgaWYgKF90aGlzLm9wdCgnYWxsRGF5U2xvdCcpKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRheUdyaWQgPSBfdGhpcy5pbnN0YW50aWF0ZURheUdyaWQoKTsgLy8gdGhlIGFsbC1kYXkgc3ViY29tcG9uZW50IG9mIHRoaXMgdmlld1xyXG4gICAgICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5kYXlHcmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBJbnN0YW50aWF0ZXMgdGhlIFRpbWVHcmlkIG9iamVjdCB0aGlzIHZpZXcgbmVlZHMuIERyYXdzIGZyb20gdGhpcy50aW1lR3JpZENsYXNzXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5pbnN0YW50aWF0ZVRpbWVHcmlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZCA9IG5ldyB0aGlzLnRpbWVHcmlkQ2xhc3ModGhpcyk7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhhZ2VuZGFUaW1lR3JpZE1ldGhvZHMsIHRpbWVHcmlkKTtcclxuICAgICAgICByZXR1cm4gdGltZUdyaWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbWlnaHQgbmVlZC4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuaW5zdGFudGlhdGVEYXlHcmlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXlHcmlkID0gbmV3IHRoaXMuZGF5R3JpZENsYXNzKHRoaXMpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMoYWdlbmRhRGF5R3JpZE1ldGhvZHMsIGRheUdyaWQpO1xyXG4gICAgICAgIHJldHVybiBkYXlHcmlkO1xyXG4gICAgfTtcclxuICAgIC8qIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZFdyYXBFbDtcclxuICAgICAgICB2YXIgdGltZUdyaWRFbDtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1hZ2VuZGEtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICB0aW1lR3JpZFdyYXBFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLXRpbWUtZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICB0aW1lR3JpZEVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXRpbWUtZ3JpZFwiIC8+JykuYXBwZW5kVG8odGltZUdyaWRXcmFwRWwpO1xyXG4gICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLWJvZHkgPiB0ciA+IHRkJykuYXBwZW5kKHRpbWVHcmlkV3JhcEVsKTtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmhlYWRDb250YWluZXJFbCA9IHRoaXMuZWwuZmluZCgnLmZjLWhlYWQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5zZXRFbGVtZW50KHRpbWVHcmlkRWwpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnNldEVsZW1lbnQodGhpcy5lbC5maW5kKCcuZmMtZGF5LWdyaWQnKSk7XHJcbiAgICAgICAgICAgIC8vIGhhdmUgdGhlIGRheS1ncmlkIGV4dGVuZCBpdCdzIGNvb3JkaW5hdGUgYXJlYSBvdmVyIHRoZSA8aHI+IGRpdmlkaW5nIHRoZSB0d28gZ3JpZHNcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmJvdHRvbUNvb3JkUGFkZGluZyA9IHRoaXMuZGF5R3JpZC5lbC5uZXh0KCdocicpLm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIEhUTUwgc2tlbGV0b24gZm9yIHRoZSB2aWV3LlxyXG4gICAgLy8gVGhlIGRheS1ncmlkIGFuZCB0aW1lLWdyaWQgY29tcG9uZW50cyB3aWxsIHJlbmRlciBpbnNpZGUgY29udGFpbmVycyBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5vcHQoJ2NvbHVtbkhlYWRlcicpID9cclxuICAgICAgICAgICAgICAgICc8dGhlYWQgY2xhc3M9XCJmYy1oZWFkXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtaGVhZC1jb250YWluZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIj4mbmJzcDs8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzx0Ym9keSBjbGFzcz1cImZjLWJvZHlcIj4nICtcclxuICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5kYXlHcmlkID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZGF5LWdyaWRcIi8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIi8+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBheGlzLCBpZiBpdCBpcyBrbm93blxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuYXhpc1N0eWxlQXR0ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5heGlzV2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMuYXhpc1dpZHRoICsgJ3B4XCInO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgLyogTm93IEluZGljYXRvclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmdldE5vd0luZGljYXRvclVuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBBZGp1c3RzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWVzXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbGVySGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIC8vIG1ha2UgYWxsIGF4aXMgY2VsbHMgbGluZSB1cCwgYW5kIHJlY29yZCB0aGUgd2lkdGggc28gbmV3bHkgY3JlYXRlZCBheGlzIGNlbGxzIHdpbGwgaGF2ZSBpdFxyXG4gICAgICAgIHRoaXMuYXhpc1dpZHRoID0gdXRpbF8xLm1hdGNoQ2VsbFdpZHRocyh0aGlzLmVsLmZpbmQoJy5mYy1heGlzJykpO1xyXG4gICAgICAgIC8vIGhhY2sgdG8gZ2l2ZSB0aGUgdmlldyBzb21lIGhlaWdodCBwcmlvciB0byB0aW1lR3JpZCdzIGNvbHVtbnMgYmVpbmcgcmVuZGVyZWRcclxuICAgICAgICAvLyBUT0RPOiBzZXBhcmF0ZSBzZXR0aW5nIGhlaWdodCBmcm9tIHNjcm9sbGVyIFZTIHRpbWVHcmlkLlxyXG4gICAgICAgIGlmICghdGhpcy50aW1lR3JpZC5jb2xFbHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IG9mIGZha2Ugcm93IGVsZW1lbnRzIHRoYXQgbXVzdCBjb21wZW5zYXRlIHdoZW4gc2Nyb2xsZXIgaGFzIHNjcm9sbGJhcnNcclxuICAgICAgICB2YXIgbm9TY3JvbGxSb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3c6bm90KC5mYy1zY3JvbGxlciAqKScpO1xyXG4gICAgICAgIC8vIHJlc2V0IGFsbCBkaW1lbnNpb25zIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHN0YXRlXHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5ib3R0b21SdWxlRWwuaGlkZSgpOyAvLyAuc2hvdygpIHdpbGwgYmUgY2FsbGVkIGxhdGVyIGlmIHRoaXMgPGhyPiBpcyBuZWNlc3NhcnlcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmNsZWFyKCk7IC8vIHNldHMgaGVpZ2h0IHRvICdhdXRvJyBhbmQgY2xlYXJzIG92ZXJmbG93XHJcbiAgICAgICAgdXRpbF8xLnVuY29tcGVuc2F0ZVNjcm9sbChub1Njcm9sbFJvd0Vscyk7XHJcbiAgICAgICAgLy8gbGltaXQgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUgYWxsLWRheSBhcmVhXHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgICAgICBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudExpbWl0ID0gQUdFTkRBX0FMTF9EQVlfRVZFTlRfTElNSVQ7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnRMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBhbGwtZGF5IGFuZCBoZWFkZXIgcm93cyBsaW5lcyB1cFxyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmNvbXBlbnNhdGVTY3JvbGwobm9TY3JvbGxSb3dFbHMsIHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNoYW5nZWQgdGV4dCBmbG93LCB3aGljaCBtaWdodCBhZmZlY3QgaGVpZ2h0LCBzbyByZWNhbGN1bGF0ZVxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlYXBwbHkgdGhlIGRlc2lyZWQgaGVpZ2h0IHRvIHRoZSBzY3JvbGxlci5cclxuICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBzcGFjZSBiZWxvdyB0aGUgc2xhdHMsIHNob3cgdGhlIGhvcml6b250YWwgcnVsZS5cclxuICAgICAgICAgICAgLy8gdGhpcyB3b24ndCBjYXVzZSBhbnkgbmV3IG92ZXJmbG93LCBiZWNhdXNlIGxvY2tPdmVyZmxvdyBhbHJlYWR5IGNhbGxlZC5cclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZUdyaWQuZ2V0VG90YWxTbGF0SGVpZ2h0KCkgPCBzY3JvbGxlckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5ib3R0b21SdWxlRWwuc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckhlaWdodCA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbEhlaWdodCAtXHJcbiAgICAgICAgICAgIHV0aWxfMS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgIH07XHJcbiAgICAvKiBTY3JvbGxcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyB0aGUgaW5pdGlhbCBwcmUtY29uZmlndXJlZCBzY3JvbGwgc3RhdGUgcHJpb3IgdG8gYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2hhbmdlIGl0XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ3Njcm9sbFRpbWUnKSk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMudGltZUdyaWQuY29tcHV0ZVRpbWVUb3Aoc2Nyb2xsVGltZSk7XHJcbiAgICAgICAgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcclxuICAgICAgICB0b3AgPSBNYXRoLmNlaWwodG9wKTtcclxuICAgICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgICAgIHRvcCsrOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AgfTtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5xdWVyeURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuYXBwbHlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3Aoc2Nyb2xsLnRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhpdCBBcmVhc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIGZvcndhcmQgYWxsIGhpdC1yZWxhdGVkIG1ldGhvZCBjYWxscyB0byB0aGUgZ3JpZHMgKGRheUdyaWQgbWlnaHQgbm90IGJlIGRlZmluZWQpXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXRIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXHJcbiAgICAgICAgcmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXHJcbiAgICAgICAgcmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0RWwoaGl0KTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5leGVjdXRlRXZlbnRSZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBkYXlFdmVudHNQYXlsb2FkID0ge307XHJcbiAgICAgICAgdmFyIHRpbWVkRXZlbnRzUGF5bG9hZCA9IHt9O1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgIC8vIHNlcGFyYXRlIHRoZSBldmVudHMgaW50byBhbGwtZGF5IGFuZCB0aW1lZFxyXG4gICAgICAgIGZvciAoaWQgaW4gZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXAgPSBldmVudHNQYXlsb2FkW2lkXTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpLmlzQWxsRGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGRheUV2ZW50c1BheWxvYWRbaWRdID0gZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGltZWRFdmVudHNQYXlsb2FkW2lkXSA9IGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmV4ZWN1dGVFdmVudFJlbmRlcih0aW1lZEV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmV4ZWN1dGVFdmVudFJlbmRlcihkYXlFdmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRHJhZ2dpbmcvUmVzaXppbmcgUm91dGluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHZhciByZW5kZXJlZEhlbHBlciA9IGZhbHNlO1xyXG4gICAgICAgIHJlbmRlcmVkSGVscGVyID0gdGhpcy50aW1lR3JpZC5yZW5kZXJEcmFnKGdyb3Vwcy50aW1lZCwgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkSGVscGVyID0gdGhpcy5kYXlHcmlkLnJlbmRlckRyYWcoZ3JvdXBzLmFsbERheSwgc2VnLCBpc1RvdWNoKSB8fCByZW5kZXJlZEhlbHBlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkSGVscGVyO1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IGdyb3VwRXZlbnRGb290cHJpbnRzQnlBbGxEYXkoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLnJlbmRlckV2ZW50UmVzaXplKGdyb3Vwcy50aW1lZCwgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW5kZXJFdmVudFJlc2l6ZShncm91cHMuYWxsRGF5LCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVHcmlkLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQWdlbmRhVmlldztcclxufShWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBZ2VuZGFWaWV3O1xyXG5BZ2VuZGFWaWV3LnByb3RvdHlwZS50aW1lR3JpZENsYXNzID0gVGltZUdyaWRfMS5kZWZhdWx0O1xyXG5BZ2VuZGFWaWV3LnByb3RvdHlwZS5kYXlHcmlkQ2xhc3MgPSBEYXlHcmlkXzEuZGVmYXVsdDtcclxuLy8gV2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQWdlbmRhVmlldydzIHRpbWVHcmlkXHJcbmFnZW5kYVRpbWVHcmlkTWV0aG9kcyA9IHtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIHRoZSBkYXktb2Ygd2VlayBoZWFkZXIgY2VsbHNcclxuICAgIHJlbmRlckhlYWRJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB3ZWVrU3RhcnQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KHRoaXMuZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIHRydWUpO1xyXG4gICAgICAgIHZhciB3ZWVrVGV4dDtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcclxuICAgICAgICAgICAgd2Vla1RleHQgPSB3ZWVrU3RhcnQuZm9ybWF0KHRoaXMub3B0KCdzbWFsbFdlZWtGb3JtYXQnKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiZmMtYXhpcyBmYy13ZWVrLW51bWJlciAnICsgY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgeyBkYXRlOiB3ZWVrU3RhcnQsIHR5cGU6ICd3ZWVrJywgZm9yY2VPZmY6IHRoaXMuY29sQ250ID4gMSB9LCB1dGlsXzEuaHRtbEVzY2FwZSh3ZWVrVGV4dCkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICAgICAnPC90aD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8dGggY2xhc3M9XCJmYy1heGlzICcgKyBjYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RoPic7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBiZyBvZiB0aGUgVGltZUdyaWQgc2xvdCBhcmVhLiBMb25nIHZlcnRpY2FsIGNvbHVtbi5cclxuICAgIHJlbmRlckJnSW50cm9IdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICB9LFxyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxyXG4gICAgLy8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cclxuICAgIHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgfVxyXG59O1xyXG4vLyBXaWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgZGF5R3JpZFxyXG5hZ2VuZGFEYXlHcmlkTWV0aG9kcyA9IHtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBhbGwtZGF5IGNlbGxzXHJcbiAgICByZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICB2aWV3LmdldEFsbERheUh0bWwoKSArXHJcbiAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICB9LFxyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxyXG4gICAgLy8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cclxuICAgIHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBncm91cEV2ZW50Rm9vdHByaW50c0J5QWxsRGF5KGV2ZW50Rm9vdHByaW50cykge1xyXG4gICAgdmFyIGFsbERheSA9IFtdO1xyXG4gICAgdmFyIHRpbWVkID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBhbGxEYXkucHVzaChldmVudEZvb3RwcmludHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGltZWQucHVzaChldmVudEZvb3RwcmludHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGFsbERheTogYWxsRGF5LCB0aW1lZDogdGltZWQgfTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcbnZhciBDb29yZENhY2hlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBUaW1lR3JpZEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ2KTtcclxudmFyIFRpbWVHcmlkSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3KTtcclxudmFyIFRpbWVHcmlkRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0OCk7XHJcbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBvbmUgb3IgbW9yZSBjb2x1bW5zIG9mIHZlcnRpY2FsIHRpbWUgc2xvdHNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFdlIG1peGluIERheVRhYmxlLCBldmVuIHRob3VnaCB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHJvdyBvZiBkYXlzXHJcbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXHJcbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxyXG52YXIgQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlMgPSBbXHJcbiAgICB7IGhvdXJzOiAxIH0sXHJcbiAgICB7IG1pbnV0ZXM6IDMwIH0sXHJcbiAgICB7IG1pbnV0ZXM6IDE1IH0sXHJcbiAgICB7IHNlY29uZHM6IDMwIH0sXHJcbiAgICB7IHNlY29uZHM6IDE1IH1cclxuXTtcclxudmFyIFRpbWVHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZCh2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wcm9jZXNzT3B0aW9ucygpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2VCeVRpbWVzKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzW2ldLmNvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWdzW2ldLmRheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5jb2wgPSBzZWdzW2ldLmRheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgSGFuZGxpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5VGltZXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgc2VnUmFuZ2U7XHJcbiAgICAgICAgdmFyIGRheUluZGV4O1xyXG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHRoaXMuZGF5c1BlclJvdzsgZGF5SW5kZXgrKykge1xyXG4gICAgICAgICAgICBzZWdSYW5nZSA9IHVuem9uZWRSYW5nZS5pbnRlcnNlY3QodGhpcy5kYXlSYW5nZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TXM6IHNlZ1JhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTXM6IHNlZ1JhbmdlLmVuZE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmlzRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4OiBkYXlJbmRleFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogT3B0aW9uc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFBhcnNlcyB2YXJpb3VzIG9wdGlvbnMgaW50byBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNsb3REdXJhdGlvbiA9IHRoaXMub3B0KCdzbG90RHVyYXRpb24nKTtcclxuICAgICAgICB2YXIgc25hcER1cmF0aW9uID0gdGhpcy5vcHQoJ3NuYXBEdXJhdGlvbicpO1xyXG4gICAgICAgIHZhciBpbnB1dDtcclxuICAgICAgICBzbG90RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oc2xvdER1cmF0aW9uKTtcclxuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb24gPyBtb21lbnQuZHVyYXRpb24oc25hcER1cmF0aW9uKSA6IHNsb3REdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBzUGVyU2xvdCA9IHNsb3REdXJhdGlvbiAvIHNuYXBEdXJhdGlvbjsgLy8gVE9ETzogZW5zdXJlIGFuIGludGVnZXIgbXVsdGlwbGU/XHJcbiAgICAgICAgLy8gbWlnaHQgYmUgYW4gYXJyYXkgdmFsdWUgKGZvciBUaW1lbGluZVZpZXcpLlxyXG4gICAgICAgIC8vIGlmIHNvLCBnZXR0aW5nIHRoZSBtb3N0IGdyYW51bGFyIGVudHJ5ICh0aGUgbGFzdCBvbmUgcHJvYmFibHkpLlxyXG4gICAgICAgIGlucHV0ID0gdGhpcy5vcHQoJ3Nsb3RMYWJlbEZvcm1hdCcpO1xyXG4gICAgICAgIGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFiZWxGb3JtYXQgPSBpbnB1dCB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdCgnc21hbGxUaW1lRm9ybWF0Jyk7IC8vIHRoZSBjb21wdXRlZCBkZWZhdWx0XHJcbiAgICAgICAgaW5wdXQgPSB0aGlzLm9wdCgnc2xvdExhYmVsSW50ZXJ2YWwnKTtcclxuICAgICAgICB0aGlzLmxhYmVsSW50ZXJ2YWwgPSBpbnB1dCA/XHJcbiAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbihpbnB1dCkgOlxyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVMYWJlbEludGVydmFsID0gZnVuY3Rpb24gKHNsb3REdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBsYWJlbEludGVydmFsO1xyXG4gICAgICAgIHZhciBzbG90c1BlckxhYmVsO1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxyXG4gICAgICAgIGZvciAoaSA9IEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxhYmVsSW50ZXJ2YWwgPSBtb21lbnQuZHVyYXRpb24oQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xyXG4gICAgICAgICAgICBzbG90c1BlckxhYmVsID0gdXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodXRpbF8xLmlzSW50KHNsb3RzUGVyTGFiZWwpICYmIHNsb3RzUGVyTGFiZWwgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7IC8vIGZhbGwgYmFjay4gY2xvbmVcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURheVRhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTbGF0cygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ29sdW1ucygpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHRoaXMudW5yZW5kZXJTbGF0cygpOyAvLyBkb24ndCBuZWVkIHRoaXMgYmVjYXVzZSByZXBlYXRlZCAuaHRtbCgpIGNhbGxzIGNsZWFyXHJcbiAgICAgICAgdGhpcy51bnJlbmRlckNvbHVtbnMoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHRoaXMuZWwuaHRtbCgnPGRpdiBjbGFzcz1cImZjLWJnXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtc2xhdHNcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIC8+Jyk7XHJcbiAgICAgICAgdGhpcy5ib3R0b21SdWxlRWwgPSB0aGlzLmVsLmZpbmQoJ2hyJyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNsYXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB0aGlzLnNsYXRDb250YWluZXJFbCA9IHRoaXMuZWwuZmluZCgnPiAuZmMtc2xhdHMnKVxyXG4gICAgICAgICAgICAuaHRtbCgvLyBhdm9pZHMgbmVlZGluZyA6OnVucmVuZGVyU2xhdHMoKVxyXG4gICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNsYXRSb3dIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nKTtcclxuICAgICAgICB0aGlzLnNsYXRFbHMgPSB0aGlzLnNsYXRDb250YWluZXJFbC5maW5kKCd0cicpO1xyXG4gICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMuc2xhdEVscyxcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNsYXRSb3dIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIGlzUlRMID0gdGhpcy5pc1JUTDtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHNsb3RUaW1lID0gbW9tZW50LmR1cmF0aW9uKCtkYXRlUHJvZmlsZS5taW5UaW1lKTsgLy8gd2lzaCB0aGVyZSB3YXMgLmNsb25lKCkgZm9yIGR1cmF0aW9uc1xyXG4gICAgICAgIHZhciBzbG90SXRlcmF0b3IgPSBtb21lbnQuZHVyYXRpb24oMCk7XHJcbiAgICAgICAgdmFyIHNsb3REYXRlOyAvLyB3aWxsIGJlIG9uIHRoZSB2aWV3J3MgZmlyc3QgZGF5LCBidXQgd2Ugb25seSBjYXJlIGFib3V0IGl0cyB0aW1lXHJcbiAgICAgICAgdmFyIGlzTGFiZWxlZDtcclxuICAgICAgICB2YXIgYXhpc0h0bWw7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0aW1lIGZvciBlYWNoIHNsb3RcclxuICAgICAgICB3aGlsZSAoc2xvdFRpbWUgPCBkYXRlUHJvZmlsZS5tYXhUaW1lKSB7XHJcbiAgICAgICAgICAgIHNsb3REYXRlID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcykudGltZShzbG90VGltZSk7XHJcbiAgICAgICAgICAgIGlzTGFiZWxlZCA9IHV0aWxfMS5pc0ludCh1dGlsXzEuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKHNsb3RJdGVyYXRvciwgdGhpcy5sYWJlbEludGVydmFsKSk7XHJcbiAgICAgICAgICAgIGF4aXNIdG1sID1cclxuICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1heGlzIGZjLXRpbWUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAoaXNMYWJlbGVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShzbG90RGF0ZS5mb3JtYXQodGhpcy5sYWJlbEZvcm1hdCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgICAgICAgICAgaHRtbCArPVxyXG4gICAgICAgICAgICAgICAgJzx0ciBkYXRhLXRpbWU9XCInICsgc2xvdERhdGUuZm9ybWF0KCdISDptbTpzcycpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzTGFiZWxlZCA/ICcnIDogJyBjbGFzcz1cImZjLW1pbm9yXCInKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAoIWlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIi8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICAgICAgICAgIHNsb3RUaW1lLmFkZCh0aGlzLnNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHNsb3RJdGVyYXRvci5hZGQodGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB0aGlzLmRheVJhbmdlcyA9IHRoaXMuZGF5RGF0ZXMubWFwKGZ1bmN0aW9uIChkYXlEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXlEYXRlLmNsb25lKCkuYWRkKGRhdGVQcm9maWxlLm1pblRpbWUpLCBkYXlEYXRlLmNsb25lKCkuYWRkKGRhdGVQcm9maWxlLm1heFRpbWUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5oZWFkQ29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkQ29udGFpbmVyRWwuaHRtbCh0aGlzLnJlbmRlckhlYWRIdG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmZpbmQoJz4gLmZjLWJnJykuaHRtbCgnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ1RySHRtbCgwKSArIC8vIHJvdz0wXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicpO1xyXG4gICAgICAgIHRoaXMuY29sRWxzID0gdGhpcy5lbC5maW5kKCcuZmMtZGF5LCAuZmMtZGlzYWJsZWQtZGF5Jyk7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLmNvbEVscyxcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcclxuICAgIH07XHJcbiAgICAvKiBDb250ZW50IFNrZWxldG9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyB0aGUgRE9NIHRoYXQgdGhlIHZpZXcncyBjb250ZW50IHdpbGwgbGl2ZSBpblxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckNvbnRlbnRTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2VsbEh0bWwgPSAnJztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2tlbGV0b25FbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjZWxsSHRtbCArPVxyXG4gICAgICAgICAgICAgICAgJzx0ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtY29sXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXIgZmMtaGVscGVyLWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1oaWdobGlnaHQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1iZ2V2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYnVzaW5lc3MtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNrZWxldG9uRWwgPSB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZT4nICtcclxuICAgICAgICAgICAgJzx0cj4nICsgY2VsbEh0bWwgKyAnPC90cj4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgICAgICB0aGlzLmNvbENvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWNvbnRlbnQtY29sJyk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1oZWxwZXItY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5mZ0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWV2ZW50LWNvbnRhaW5lcjpub3QoLmZjLWhlbHBlci1jb250YWluZXIpJyk7XHJcbiAgICAgICAgdGhpcy5iZ0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWJnZXZlbnQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1oaWdobGlnaHQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5idXNpbmVzc0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWJ1c2luZXNzLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuYm9va2VuZENlbGxzKHNrZWxldG9uRWwuZmluZCgndHInKSk7IC8vIFRPRE86IGRvIHRoaXMgb24gc3RyaW5nIGxldmVsXHJcbiAgICAgICAgdGhpcy5lbC5hcHBlbmQoc2tlbGV0b25FbCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyQ29udGVudFNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRTa2VsZXRvbkVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFNrZWxldG9uRWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFNrZWxldG9uRWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNvbENvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mZ0NvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodENvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIGNvbFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdyb3VwU2Vnc0J5Q29sID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5Q29sID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29sQ250OyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzQnlDb2xbc2Vnc1tpXS5jb2xdLnB1c2goc2Vnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzQnlDb2w7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgZ3JvdXBlZCBieSBjb2x1bW4sIGluc2VydCB0aGUgc2VnbWVudHMnIGVsZW1lbnRzIGludG8gYSBwYXJhbGxlbCBhcnJheSBvZiBjb250YWluZXJcclxuICAgIC8vIGVsZW1lbnRzLCBlYWNoIGxpdmluZyB3aXRoaW4gYSBjb2x1bW4uXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuYXR0YWNoU2Vnc0J5Q29sID0gZnVuY3Rpb24gKHNlZ3NCeUNvbCwgY29udGFpbmVyRWxzKSB7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgc2VncztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBzZWdzID0gc2Vnc0J5Q29sW2NvbF07XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbHMuZXEoY29sKS5hcHBlbmQoc2Vnc1tpXS5lbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogTm93IEluZGljYXRvclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnbWludXRlJzsgLy8gd2lsbCByZWZyZXNoIG9uIHRoZSBtaW51dGVcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAvLyBIQUNLOiBpZiBkYXRlIGNvbHVtbnMgbm90IHJlYWR5IGZvciBzb21lIHJlYXNvbiAoc2NoZWR1bGVyKVxyXG4gICAgICAgIGlmICghdGhpcy5jb2xDb250YWluZXJFbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZWcgc3lzdGVtIG1pZ2h0IGJlIG92ZXJraWxsLCBidXQgaXQgaGFuZGxlcyBzY2VuYXJpbyB3aGVyZSBsaW5lIG5lZWRzIHRvIGJlIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gIG1vcmUgdGhhbiBvbmNlIGJlY2F1c2Ugb2YgY29sdW1ucyB3aXRoIHRoZSBzYW1lIGRhdGUgKHJlc291cmNlcyBjb2x1bW5zIGZvciBleGFtcGxlKVxyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF0ZSwgZGF0ZS52YWx1ZU9mKCkgKyAxKSwgLy8gcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcclxuICAgICAgICBmYWxzZSAvLyBhbGwtZGF5XHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3AoZGF0ZSwgZGF0ZSk7XHJcbiAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gcmVuZGVyIGxpbmVzIHdpdGhpbiB0aGUgY29sdW1uc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lXCI+PC9kaXY+JylcclxuICAgICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIHRvcClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmNvbENvbnRhaW5lckVscy5lcShzZWdzW2ldLmNvbCkpWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1hcnJvd1wiPjwvZGl2PicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKCd0b3AnLCB0b3ApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy5lbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbicpKVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm93SW5kaWNhdG9yRWxzID0gJChub2Rlcyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvckVscykge1xyXG4gICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBDb29yZGluYXRlc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcclxuICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoW10uY29uY2F0KHRoaXMuZXZlbnRSZW5kZXJlci5nZXRTZWdzKCksIHRoaXMuYnVzaW5lc3NTZWdzIHx8IFtdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXRUb3RhbFNsYXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xhdENvbnRhaW5lckVsLm91dGVySGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgIC8vIGBtc2AgY2FuIGJlIGEgbWlsbGlzZWNvbmQgVVRDIHRpbWUgT1IgYSBVVEMgbW9tZW50LlxyXG4gICAgLy8gQSBgc3RhcnRPZkRheURhdGVgIG11c3QgYmUgZ2l2ZW4gZm9yIGF2b2lkaW5nIGFtYmlndWl0eSBvdmVyIGhvdyB0byB0cmVhdCBtaWRuaWdodC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlRGF0ZVRvcCA9IGZ1bmN0aW9uIChtcywgc3RhcnRPZkRheURhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChtb21lbnQuZHVyYXRpb24obXMgLSBzdGFydE9mRGF5RGF0ZS5jbG9uZSgpLnN0cmlwVGltZSgpKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVRpbWVUb3AgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnNsYXRFbHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIHNsYXRDb3ZlcmFnZSA9ICh0aW1lIC0gZGF0ZVByb2ZpbGUubWluVGltZSkgLyB0aGlzLnNsb3REdXJhdGlvbjsgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXHJcbiAgICAgICAgdmFyIHNsYXRJbmRleDtcclxuICAgICAgICB2YXIgc2xhdFJlbWFpbmRlcjtcclxuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxyXG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgb2Ygc2xhdHMgKGluY2x1c2l2ZSlcclxuICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIG1pblRpbWUvbWF4VGltZSBtaWdodCBiZSBjdXN0b21pemVkLlxyXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgIC8vIGFuIGludGVnZXIgaW5kZXggb2YgdGhlIGZ1cnRoZXN0IHdob2xlIHNsYXRcclxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXHJcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGgubWluKHNsYXRJbmRleCwgbGVuIC0gMSk7XHJcbiAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXHJcbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcclxuICAgICAgICBzbGF0UmVtYWluZGVyID0gc2xhdENvdmVyYWdlIC0gc2xhdEluZGV4O1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNsYXRDb29yZENhY2hlLmdldFRvcFBvc2l0aW9uKHNsYXRJbmRleCkgK1xyXG4gICAgICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcclxuICAgIH07XHJcbiAgICAvLyBSZWZyZXNoZXMgdGhlIENTUyB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIGZvciBlYWNoIHNlZ21lbnQgZWxlbWVudC5cclxuICAgIC8vIFdvcmtzIHdoZW4gY2FsbGVkIGFmdGVyIGluaXRpYWwgcmVuZGVyLCBhZnRlciBhIHdpbmRvdyByZXNpemUvem9vbSBmb3IgZXhhbXBsZS5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51cGRhdGVTZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgICAgICB0aGlzLmFzc2lnblNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBGb3IgZWFjaCBzZWdtZW50IGluIGFuIGFycmF5LCBjb21wdXRlcyBhbmQgYXNzaWducyBpdHMgdG9wIGFuZCBib3R0b20gcHJvcGVydGllc1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVTZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBldmVudE1pbkhlaWdodCA9IHRoaXMub3B0KCdhZ2VuZGFFdmVudE1pbkhlaWdodCcpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIGRheURhdGU7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgZGF5RGF0ZSA9IHRoaXMuZGF5RGF0ZXNbc2VnLmRheUluZGV4XTtcclxuICAgICAgICAgICAgc2VnLnRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0TXMsIGRheURhdGUpO1xyXG4gICAgICAgICAgICBzZWcuYm90dG9tID0gTWF0aC5tYXgoc2VnLnRvcCArIGV2ZW50TWluSGVpZ2h0LCB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmRNcywgZGF5RGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBzZWdtZW50cyB0aGF0IGFscmVhZHkgaGF2ZSB0aGVpciB0b3AvYm90dG9tIHByb3BlcnRpZXMgY29tcHV0ZWQsIGFwcGxpZXMgdGhvc2UgdmFsdWVzIHRvXHJcbiAgICAvLyB0aGUgc2VnbWVudHMnIGVsZW1lbnRzLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmFzc2lnblNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIENTUyBwcm9wZXJ0aWVzIGZvciB0aGUgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBvZiBhIHNlZ21lbnQgZWxlbWVudFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdlbmVyYXRlU2VnVmVydGljYWxDc3MgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9wOiBzZWcudG9wLFxyXG4gICAgICAgICAgICBib3R0b206IC1zZWcuYm90dG9tIC8vIGZsaXBwZWQgYmVjYXVzZSBuZWVkcyB0byBiZSBzcGFjZSBiZXlvbmQgYm90dG9tIGVkZ2Ugb2YgZXZlbnQgY29udGFpbmVyXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKiBIaXQgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVsZWFzZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmNsZWFyKCk7XHJcbiAgICAgICAgLy8gTk9URTogZG9uJ3QgY2xlYXIgc2xhdENvb3JkQ2FjaGUgYmVjYXVzZSB3ZSByZWx5IG9uIGl0IGZvciBjb21wdXRlVGltZVRvcFxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICB2YXIgc25hcHNQZXJTbG90ID0gdGhpcy5zbmFwc1BlclNsb3Q7XHJcbiAgICAgICAgdmFyIGNvbENvb3JkQ2FjaGUgPSB0aGlzLmNvbENvb3JkQ2FjaGU7XHJcbiAgICAgICAgdmFyIHNsYXRDb29yZENhY2hlID0gdGhpcy5zbGF0Q29vcmRDYWNoZTtcclxuICAgICAgICBpZiAoY29sQ29vcmRDYWNoZS5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiBzbGF0Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbEluZGV4ID0gY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciBzbGF0SW5kZXggPSBzbGF0Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xJbmRleCAhPSBudWxsICYmIHNsYXRJbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xhdFRvcCA9IHNsYXRDb29yZENhY2hlLmdldFRvcE9mZnNldChzbGF0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gKHRvcE9mZnNldCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcFRvcCA9IHNsYXRUb3AgKyAobG9jYWxTbmFwSW5kZXggLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwQm90dG9tID0gc2xhdFRvcCArICgobG9jYWxTbmFwSW5kZXggKyAxKSAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHNuYXA6IHNuYXBJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRDYWNoZS5nZXRMZWZ0T2Zmc2V0KGNvbEluZGV4KSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sQ29vcmRDYWNoZS5nZXRSaWdodE9mZnNldChjb2xJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBzbmFwVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc25hcEJvdHRvbVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUoMCwgaGl0LmNvbCk7IC8vIHJvdz0wXHJcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLmNvbXB1dGVTbmFwVGltZShoaXQuc25hcCk7IC8vIHBhc3MgaW4gdGhlIHNuYXAtaW5kZXhcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIHN0YXJ0LnRpbWUodGltZSk7XHJcbiAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5zbmFwRHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgZmFsc2UgLy8gYWxsLWRheT9cclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgcm93IG51bWJlciBvZiB0aGUgZ3JpZCwgcmVwcmVzZW50aW5nIGEgXCJzbmFwXCIsIHJldHVybnMgYSB0aW1lIChEdXJhdGlvbikgZnJvbSBpdHMgc3RhcnQtb2YtZGF5XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNuYXBUaW1lID0gZnVuY3Rpb24gKHNuYXBJbmRleCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odGhpcy5kYXRlUHJvZmlsZS5taW5UaW1lICsgdGhpcy5zbmFwRHVyYXRpb24gKiBzbmFwSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXRIaXRFbCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xFbHMuZXEoaGl0LmNvbCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWQgb3ZlciB0aGUgc3BlY2lmaWVkIGRhdGUocykuXHJcbiAgICAvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzZWcpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYSBoZWxwZXIgaGFzIGJlZW4gcmVuZGVyZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnJlbmRlckV2ZW50UmVzaXppbmdGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb24uIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCwgd2hpY2ggd2FzIHRvIHNpbXBseSByZW5kZXIgYSBoaWdobGlnaHQuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnc2VsZWN0SGVscGVyJykpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJDb21wb25lbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lR3JpZDtcclxufShJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVHcmlkO1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gVGltZUdyaWRFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuVGltZUdyaWQucHJvdG90eXBlLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MgPSBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5oZWxwZXJSZW5kZXJlckNsYXNzID0gVGltZUdyaWRIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5maWxsUmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkRmlsbFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xLmRlZmF1bHQubWl4SW50byhUaW1lR3JpZCk7XHJcbkRheVRhYmxlTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGltZUdyaWQpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjEpO1xyXG52YXIgQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyVW56b25lZFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7IC8vIGFuIFVuem9uZWRSYW5nZVxyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMubXNUb1V0Y01vbWVudChyZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMubXNUb1V0Y01vbWVudChyZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXHJcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xyXG4gICAgICAgICAgICBzdGFydC5zdGFydE9mKCd3ZWVrJyk7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcclxuICAgICAgICAgICAgaWYgKGVuZC53ZWVrZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5hZGQoMSwgJ3dlZWsnKS5zdGFydE9mKCd3ZWVrJyk7IC8vIGV4Y2x1c2l2ZWx5IG1vdmUgYmFja3dhcmRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufShEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgQmFzaWNWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcclxudmFyIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1Myk7XHJcbi8qIEEgbW9udGggdmlldyB3aXRoIGRheSBjZWxscyBydW5uaW5nIGluIHJvd3MgKG9uZS1wZXItd2VlaykgYW5kIGNvbHVtbnNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBNb250aFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb250aFZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb250aFZpZXcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IEJhc2ljVmlldyBiZWhhdmlvciB0byBoYXZlIHNwZWNpYWwgbXVsdGktd2VlayBhdXRvLWhlaWdodCBsb2dpY1xyXG4gICAgTW9udGhWaWV3LnByb3RvdHlwZS5zZXRHcmlkSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgLy8gaWYgYXV0bywgbWFrZSB0aGUgaGVpZ2h0IG9mIGVhY2ggcm93IHRoZSBoZWlnaHQgdGhhdCBpdCB3b3VsZCBiZSBpZiB0aGVyZSB3ZXJlIDYgd2Vla3NcclxuICAgICAgICBpZiAoaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLmRheUdyaWQucm93Q250IC8gNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbF8xLmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0VscywgaGVpZ2h0LCAhaXNBdXRvKTsgLy8gaWYgYXV0bywgZG9uJ3QgY29tcGVuc2F0ZSBmb3IgaGVpZ2h0LWhvZ2dpbmcgcm93c1xyXG4gICAgfTtcclxuICAgIE1vbnRoVmlldy5wcm90b3R5cGUuaXNEYXRlSW5PdGhlck1vbnRoID0gZnVuY3Rpb24gKGRhdGUsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUubW9udGgoKSAhPT0gbW9tZW50LnV0YyhkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLnN0YXJ0TXMpLm1vbnRoKCk7IC8vIFRPRE86IG9wdGltaXplXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vbnRoVmlldztcclxufShCYXNpY1ZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vbnRoVmlldztcclxuTW9udGhWaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxudmFyIFNjcm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxudmFyIExpc3RFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1NCk7XHJcbnZhciBMaXN0RXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTUpO1xyXG4vKlxyXG5SZXNwb25zaWJsZSBmb3IgdGhlIHNjcm9sbGVyLCBhbmQgZm9yd2FyZGluZyBldmVudC1yZWxhdGVkIGFjdGlvbnMgaW50byB0aGUgXCJncmlkXCIuXHJcbiovXHJcbnZhciBMaXN0VmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKExpc3RWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdFZpZXcoY2FsZW5kYXIsIHZpZXdTcGVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIsIHZpZXdTcGVjKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnNlZ1NlbGVjdG9yID0gJy5mYy1saXN0LWl0ZW0nOyAvLyB3aGljaCBlbGVtZW50cyBhY2NlcHQgZXZlbnQgYWN0aW9uc1xyXG4gICAgICAgIF90aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWwuYWRkQ2xhc3MoJ2ZjLWxpc3QtdmlldyAnICtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnbGlzdFZpZXcnKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmVsLmFwcGVuZFRvKHRoaXMuZWwpO1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsID0gdGhpcy5zY3JvbGxlci5zY3JvbGxFbDsgLy8gc2hvcnRjdXRcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTsgLy8gd2lsbCByZW1vdmUgdGhlIEdyaWQgdG9vXHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpOyAvLyBzZXRzIGhlaWdodCB0byAnYXV0bycgYW5kIGNsZWFycyBvdmVyZmxvd1xyXG4gICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJIZWlnaHQgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdG90YWxIZWlnaHQgLVxyXG4gICAgICAgICAgICB1dGlsXzEuc3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZGF5U3RhcnQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KGRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgdmlld0VuZCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQoZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLmVuZE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgZGF5RGF0ZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5UmFuZ2VzID0gW107XHJcbiAgICAgICAgd2hpbGUgKGRheVN0YXJ0IDwgdmlld0VuZCkge1xyXG4gICAgICAgICAgICBkYXlEYXRlcy5wdXNoKGRheVN0YXJ0LmNsb25lKCkpO1xyXG4gICAgICAgICAgICBkYXlSYW5nZXMucHVzaChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXlTdGFydCwgZGF5U3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheScpKSk7XHJcbiAgICAgICAgICAgIGRheVN0YXJ0LmFkZCgxLCAnZGF5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF5RGF0ZXMgPSBkYXlEYXRlcztcclxuICAgICAgICB0aGlzLmRheVJhbmdlcyA9IGRheVJhbmdlcztcclxuICAgICAgICAvLyBhbGwgcmVhbCByZW5kZXJpbmcgaGFwcGVucyBpbiBFdmVudFJlbmRlcmVyXHJcbiAgICB9O1xyXG4gICAgLy8gc2xpY2VzIGJ5IGRheVxyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChmb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgZGF5UmFuZ2VzID0gdGhpcy5kYXlSYW5nZXM7XHJcbiAgICAgICAgdmFyIGRheUluZGV4O1xyXG4gICAgICAgIHZhciBzZWdSYW5nZTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgZm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgZGF5UmFuZ2VzLmxlbmd0aDsgZGF5SW5kZXgrKykge1xyXG4gICAgICAgICAgICBzZWdSYW5nZSA9IGZvb3RwcmludC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KGRheVJhbmdlc1tkYXlJbmRleF0pO1xyXG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHNlZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1zOiBzZWdSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1zOiBzZWdSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5pc0VuZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleDogZGF5SW5kZXhcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCB3aGVuIGZvb3RwcmludCB3b24ndCBnbyBmdWxseSBpbnRvIHRoZSBuZXh0IGRheSxcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlZy5pc0VuZCAmJiAhZm9vdHByaW50LmlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXggKyAxIDwgZGF5UmFuZ2VzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGZvb3RwcmludC51bnpvbmVkUmFuZ2UuZW5kTXMgPCBkYXlSYW5nZXNbZGF5SW5kZXggKyAxXS5zdGFydE1zICsgdGhpcy5uZXh0RGF5VGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVuZE1zID0gZm9vdHByaW50LnVuem9uZWRSYW5nZS5lbmRNcztcclxuICAgICAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJFbXB0eU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuaHRtbCgnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDJcIj4nICsgLy8gVE9ETzogdHJ5IGxlc3Mgd3JhcHNcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5LXdyYXAxXCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eVwiPicgK1xyXG4gICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLm9wdCgnbm9FdmVudHNNZXNzYWdlJykpICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgIH07XHJcbiAgICAvLyByZW5kZXIgdGhlIGV2ZW50IHNlZ21lbnRzIGluIHRoZSB2aWV3XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyU2VnTGlzdCA9IGZ1bmN0aW9uIChhbGxTZWdzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3NCeURheSA9IHRoaXMuZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICB2YXIgZGF5U2VncztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdGFibGVFbCA9ICQoJzx0YWJsZSBjbGFzcz1cImZjLWxpc3QtdGFibGUgJyArIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlTGlzdCcpICsgJ1wiPjx0Ym9keS8+PC90YWJsZT4nKTtcclxuICAgICAgICB2YXIgdGJvZHlFbCA9IHRhYmxlRWwuZmluZCgndGJvZHknKTtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoZGF5U2Vncykge1xyXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGEgZGF5IGhlYWRlclxyXG4gICAgICAgICAgICAgICAgdGJvZHlFbC5hcHBlbmQodGhpcy5kYXlIZWFkZXJIdG1sKHRoaXMuZGF5RGF0ZXNbZGF5SW5kZXhdKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuc29ydEV2ZW50U2VncyhkYXlTZWdzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXlTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGJvZHlFbC5hcHBlbmQoZGF5U2Vnc1tpXS5lbCk7IC8vIGFwcGVuZCBldmVudCByb3dcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpLmFwcGVuZCh0YWJsZUVsKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgc3BhcnNlIGFycmF5IG9mIGFycmF5cywgc2VncyBncm91cGVkIGJ5IHRoZWlyIGRheUluZGV4XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuZ3JvdXBTZWdzQnlEYXkgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxyXG4gICAgICAgICAgICAgICAgLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeURheTtcclxuICAgIH07XHJcbiAgICAvLyBnZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBkYXkgaGVhZGVycyB0aGF0IGxpdmUgYW1vbmdzdCB0aGUgZXZlbnQgcm93c1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmRheUhlYWRlckh0bWwgPSBmdW5jdGlvbiAoZGF5RGF0ZSkge1xyXG4gICAgICAgIHZhciBtYWluRm9ybWF0ID0gdGhpcy5vcHQoJ2xpc3REYXlGb3JtYXQnKTtcclxuICAgICAgICB2YXIgYWx0Rm9ybWF0ID0gdGhpcy5vcHQoJ2xpc3REYXlBbHRGb3JtYXQnKTtcclxuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cImZjLWxpc3QtaGVhZGluZ1wiIGRhdGEtZGF0ZT1cIicgKyBkYXlEYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArICh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd0YWJsZUxpc3RIZWFkaW5nJykgfHxcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykpICsgJ1wiIGNvbHNwYW49XCIzXCI+JyArXHJcbiAgICAgICAgICAgIChtYWluRm9ybWF0ID9cclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRHb3RvQW5jaG9ySHRtbChkYXlEYXRlLCB7ICdjbGFzcyc6ICdmYy1saXN0LWhlYWRpbmctbWFpbicgfSwgdXRpbF8xLmh0bWxFc2NhcGUoZGF5RGF0ZS5mb3JtYXQobWFpbkZvcm1hdCkpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGFsdEZvcm1hdCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkR290b0FuY2hvckh0bWwoZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLWFsdCcgfSwgdXRpbF8xLmh0bWxFc2NhcGUoZGF5RGF0ZS5mb3JtYXQoYWx0Rm9ybWF0KSkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdFZpZXc7XHJcbn0oVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdFZpZXc7XHJcbkxpc3RWaWV3LnByb3RvdHlwZS5ldmVudFJlbmRlcmVyQ2xhc3MgPSBMaXN0RXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkxpc3RWaWV3LnByb3RvdHlwZS5ldmVudFBvaW50aW5nQ2xhc3MgPSBMaXN0RXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzMSAqLyxcbi8qIDIzMiAqLyxcbi8qIDIzMyAqLyxcbi8qIDIzNCAqLyxcbi8qIDIzNSAqLyxcbi8qIDIzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENhbGVuZGFyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMCk7XHJcbi8vIGZvciBpbnRlbnRpb25hbCBzaWRlLWVmZmVjdHNcclxuX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1Nik7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjU3KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2MSk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjYyKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNjMpO1xyXG4kLmZ1bGxDYWxlbmRhciA9IGV4cG9ydEhvb2tzO1xyXG4kLmZuLmZ1bGxDYWxlbmRhciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBhIHBvc3NpYmxlIG1ldGhvZCBjYWxsXHJcbiAgICB2YXIgcmVzID0gdGhpczsgLy8gd2hhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuICh0aGlzIGpRdWVyeSBvYmplY3QgYnkgZGVmYXVsdClcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgX2VsZW1lbnQpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoX2VsZW1lbnQpO1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJyk7IC8vIGdldCB0aGUgZXhpc3RpbmcgY2FsZW5kYXIgb2JqZWN0IChpZiBhbnkpXHJcbiAgICAgICAgdmFyIHNpbmdsZVJlczsgLy8gdGhlIHJldHVybmVkIHZhbHVlIG9mIHRoaXMgc2luZ2xlIG1ldGhvZCBjYWxsXHJcbiAgICAgICAgLy8gYSBtZXRob2QgY2FsbFxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09ICdnZXRDYWxlbmRhcicpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGNhbGVuZGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09ICdkZXN0cm95Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRGF0YSgnZnVsbENhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEud2FybignQXR0ZW1wdGluZyB0byBjYWxsIGEgRnVsbENhbGVuZGFyIG1ldGhvZCBvbiBhbiBlbGVtZW50IHdpdGggbm8gY2FsZW5kYXIuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKGNhbGVuZGFyW29wdGlvbnNdKSkge1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlUmVzID0gY2FsZW5kYXJbb3B0aW9uc10uYXBwbHkoY2FsZW5kYXIsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gc2luZ2xlUmVzOyAvLyByZWNvcmQgdGhlIGZpcnN0IG1ldGhvZCBjYWxsIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09ICdkZXN0cm95Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRGF0YSgnZnVsbENhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEud2FybihcIidcIiArIG9wdGlvbnMgKyBcIicgaXMgYW4gdW5rbm93biBGdWxsQ2FsZW5kYXIgbWV0aG9kLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghY2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXJfMS5kZWZhdWx0KGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmRhdGEoJ2Z1bGxDYWxlbmRhcicsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgY2FsZW5kYXIucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydEhvb2tzO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBNb2RlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMuYmluZEdsb2JhbEhhbmRsZXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTa2VsZXRvbigpO1xyXG4gICAgICAgIHRoaXMuc2V0KCdpc0luRG9tJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2lzSW5Eb20nKTtcclxuICAgICAgICB0aGlzLnVucmVuZGVyU2tlbGV0b24oKTtcclxuICAgICAgICB0aGlzLnVuYmluZEdsb2JhbEhhbmRsZXJzKCk7XHJcbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAvLyBOT1RFOiBkb24ndCBudWxsLW91dCB0aGlzLmVsIGluIGNhc2UgdGhlIFZpZXcgd2FzIGRlc3Ryb3llZCB3aXRoaW4gYW4gQVBJIGNhbGxiYWNrLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IG51bGwtb3V0IHRoZSBWaWV3J3Mgb3RoZXIgalF1ZXJ5IGVsZW1lbnQgcmVmZXJlbmNlcyB1cG9uIGRlc3Ryb3ksXHJcbiAgICAgICAgLy8gIHNvIHdlIHNob3VsZG4ndCBraWxsIHRoaXMuZWwgZWl0aGVyLlxyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOT1RFOiBDYW4ndCBoYXZlIGEgYHJlbmRlcmAgbWV0aG9kLiBSZWFkIHRoZSBkZXByZWNhdGlvbiBub3RpY2UgaW4gVmlldzo6ZXhlY3V0ZURhdGVSZW5kZXJcclxuICAgICovXHJcbiAgICAvLyBSZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXcgYmVmb3JlIGFueSBjb250ZW50IGlzIHJlbmRlcmVkXHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSB2aWV3XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudDtcclxufShNb2RlbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9uZW50O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvcihpdGVtcykge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcclxuICAgIH1cclxuICAgIC8qIENhbGxzIGEgbWV0aG9kIG9uIGV2ZXJ5IGl0ZW0gcGFzc2luZyB0aGUgYXJndW1lbnRzIHRocm91Z2ggKi9cclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5wcm94eUNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1bbWV0aG9kTmFtZV0uYXBwbHkoaXRlbSwgYXJncykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJdGVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSXRlcmF0b3I7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbi8qIFRvb2xiYXIgd2l0aCBidXR0b25zIGFuZCB0aXRsZVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIFRvb2xiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUb29sYmFyKGNhbGVuZGFyLCB0b29sYmFyT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuZWwgPSBudWxsOyAvLyBtaXJyb3JzIGxvY2FsIGBlbGBcclxuICAgICAgICB0aGlzLnZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy50b29sYmFyT3B0aW9ucyA9IHRvb2xiYXJPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gbWV0aG9kIHRvIHVwZGF0ZSB0b29sYmFyLXNwZWNpZmljIG9wdGlvbnMsIG5vdCBjYWxlbmRhci13aWRlIG9wdGlvbnNcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnNldFRvb2xiYXJPcHRpb25zID0gZnVuY3Rpb24gKG5ld1Rvb2xiYXJPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy50b29sYmFyT3B0aW9ucyA9IG5ld1Rvb2xiYXJPcHRpb25zO1xyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgd2lsbCByZXJlbmRlclxyXG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWN0aW9ucyA9IHRoaXMudG9vbGJhck9wdGlvbnMubGF5b3V0O1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgaWYgKHNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghZWwpIHtcclxuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5lbCA9ICQoXCI8ZGl2IGNsYXNzPSdmYy10b29sYmFyIFwiICsgdGhpcy50b29sYmFyT3B0aW9ucy5leHRyYUNsYXNzZXMgKyBcIicvPlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsLmVtcHR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuYXBwZW5kKHRoaXMucmVuZGVyU2VjdGlvbignbGVmdCcpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ3JpZ2h0JykpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJykpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdGhlbWUgPSBjYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgb3B0aW9uc01hbmFnZXIgPSBjYWxlbmRhci5vcHRpb25zTWFuYWdlcjtcclxuICAgICAgICB2YXIgdmlld1NwZWNNYW5hZ2VyID0gY2FsZW5kYXIudmlld1NwZWNNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzZWN0aW9uRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtJyArIHBvc2l0aW9uICsgJ1wiLz4nKTtcclxuICAgICAgICB2YXIgYnV0dG9uU3RyID0gdGhpcy50b29sYmFyT3B0aW9ucy5sYXlvdXRbcG9zaXRpb25dO1xyXG4gICAgICAgIHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBvcHRpb25zTWFuYWdlci5nZXQoJ2N1c3RvbUJ1dHRvbnMnKSB8fCB7fTtcclxuICAgICAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dCA9IG9wdGlvbnNNYW5hZ2VyLmdldCgnYnV0dG9uVGV4dCcpIHx8IHt9O1xyXG4gICAgICAgIGlmIChidXR0b25TdHIpIHtcclxuICAgICAgICAgICAgJC5lYWNoKGJ1dHRvblN0ci5zcGxpdCgnICcpLCBmdW5jdGlvbiAoaSwgYnV0dG9uR3JvdXBTdHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cENoaWxkcmVuID0gJCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwRWw7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKSwgZnVuY3Rpb24gKGosIGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tQnV0dG9uUHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdTcGVjO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25DbGljaztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSWNvbjsgLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uVGV4dDsgLy8gXCJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSW5uZXJIdG1sO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25DbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25FbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQXJpYUF0dHI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbiA9IGdyb3VwQ2hpbGRyZW4uYWRkKCQoJzxoMj4mbmJzcDs8L2gyPicpKTsgLy8gd2UgYWx3YXlzIHdhbnQgaXQgdG8gdGFrZSB1cCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoYnV0dG9uRWxbMF0sIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKGJ1dHRvbk5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYWxlbmRhcltidXR0b25OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJbYnV0dG9uTmFtZV0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIF4gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25DbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3NlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdzdGF0ZURlZmF1bHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5uZXJIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUoYnV0dG9uVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQXJpYUF0dHIgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbkljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgPSBcIjxzcGFuIGNsYXNzPSdcIiArIGJ1dHRvbkljb24gKyBcIic+PC9zcGFuPlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyID0gJyBhcmlhLWxhYmVsPVwiJyArIGJ1dHRvbk5hbWUgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwgPSAkKC8vIHR5cGU9XCJidXR0b25cIiBzbyB0aGF0IGl0IGRvZXNuJ3Qgc3VibWl0IGEgZm9ybVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJyArIGJ1dHRvbkNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQXJpYUF0dHIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc+JyArIGJ1dHRvbklubmVySHRtbCArICc8L2J1dHRvbj4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBwcm9jZXNzIGNsaWNrcyBmb3IgZGlzYWJsZWQgYnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnV0dG9uRWwuaGFzQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2soZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgY2xpY2sgYWN0aW9uLCBpZiB0aGUgYnV0dG9uIGJlY29tZXMgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5ldmVyIGhhdmUgYSBob3ZlciBjbGFzcywgc28gcmVtb3ZlIGl0IG5vdy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwuaGFzQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZUhvdmVyJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubW91c2Vkb3duKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgKmRvd24qIGVmZmVjdCAobW91c2UgcHJlc3NlZCBpbikuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1vdXNldXAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZG8gdGhlICpkb3duKiBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVEb3duJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaG92ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSAqaG92ZXIqIGVmZmVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubm90KCcuJyArIHRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubm90KCcuJyArIHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRvIHRoZSAqaG92ZXIqIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTsgLy8gaWYgbW91c2VsZWF2ZSBoYXBwZW5zIGJlZm9yZSBtb3VzZXVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZChidXR0b25FbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc09ubHlCdXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3QoKS5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnY29ybmVyTGVmdCcpKS5lbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubGFzdCgpLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdjb3JuZXJSaWdodCcpKS5lbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChncm91cENoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cEVsID0gJCgnPGRpdi8+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT25seUJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbC5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25FbC5hcHBlbmQoZ3JvdXBFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pOyAvLyAxIG9yIDAgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWN0aW9uRWw7XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnaDInKS50ZXh0KHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5hY3RpdmF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmRlYWN0aXZhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5kaXNhYmxlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZW5hYmxlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmdldFZpZXdzV2l0aEJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3NXaXRoQnV0dG9ucztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVG9vbGJhcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbGJhcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgb3B0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG52YXIgT3B0aW9uc01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhPcHRpb25zTWFuYWdlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9wdGlvbnNNYW5hZ2VyKF9jYWxlbmRhciwgb3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMub3ZlcnJpZGVzID0gJC5leHRlbmQoe30sIG92ZXJyaWRlcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgX3RoaXMuZHluYW1pY092ZXJyaWRlcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLmNvbXB1dGUoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICB2YXIgb3B0aW9uQ250ID0gMDtcclxuICAgICAgICB2YXIgb3B0aW9uTmFtZTtcclxuICAgICAgICB0aGlzLnJlY29yZE92ZXJyaWRlcyhuZXdPcHRpb25IYXNoKTsgLy8gd2lsbCB0cmlnZ2VyIHRoaXMgbW9kZWwncyB3YXRjaGVyc1xyXG4gICAgICAgIGZvciAob3B0aW9uTmFtZSBpbiBuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbkNudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2Ygc2luZ2xlIG9wdGlvbiBjaGFuZ2UuXHJcbiAgICAgICAgLy8gaWYgb25seSBvbmUgb3B0aW9uIGNoYW5nZSwgYG9wdGlvbk5hbWVgIHdpbGwgYmUgaXRzIG5hbWUuXHJcbiAgICAgICAgaWYgKG9wdGlvbkNudCA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ2hlaWdodCcgfHwgb3B0aW9uTmFtZSA9PT0gJ2NvbnRlbnRIZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdhc3BlY3RSYXRpbycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLnVwZGF0ZVZpZXdTaXplKHRydWUpOyAvLyBpc1Jlc2l6ZT10cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2RlZmF1bHREYXRlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCBjaGFuZ2UgZGF0ZSB0aGlzIHdheS4gdXNlIGdvdG9EYXRlIGluc3RlYWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25OYW1lID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGhpcyBtb2RlbCBhbHJlYWR5IHJlYWN0cyB0byB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoL14oZXZlbnR8c2VsZWN0KShPdmVybGFwfENvbnN0cmFpbnR8QWxsb3cpJC8udGVzdChvcHRpb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBkb2Vzbid0IGFmZmVjdCByZW5kZXJpbmcuIG9ubHkgaW50ZXJhY3Rpb25zLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICd0aW1lem9uZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLnZpZXcuZmxhc2goJ2luaXRpYWxFdmVudHMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYXRjaC1hbGwuIHJlcmVuZGVyIHRoZSBoZWFkZXIgYW5kIGZvb3RlciBhbmQgcmVidWlsZC9yZXJlbmRlciB0aGUgY3VycmVudCB2aWV3XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVuZGVySGVhZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVuZGVyRm9vdGVyKCk7XHJcbiAgICAgICAgLy8gZXZlbiBub24tY3VycmVudCB2aWV3cyB3aWxsIGJlIGFmZmVjdGVkIGJ5IHRoaXMgb3B0aW9uIGNoYW5nZS4gZG8gYmVmb3JlIHJlcmVuZGVyXHJcbiAgICAgICAgLy8gVE9ETzogZGV0YW5nbGVcclxuICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3c0J5VHlwZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlaW5pdFZpZXcoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIG9wdGlvbnMgaGFzaCBmb3IgdGhlIGNhbGVuZGFyIGFuZCBhc3NpZ25zIHRvIGB0aGlzLm9wdGlvbnNgLlxyXG4gICAgLy8gQXNzdW1lcyB0aGlzLm92ZXJyaWRlcyBhbmQgdGhpcy5keW5hbWljT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsZTtcclxuICAgICAgICB2YXIgbG9jYWxlRGVmYXVsdHM7XHJcbiAgICAgICAgdmFyIGlzUlRMO1xyXG4gICAgICAgIHZhciBkaXJEZWZhdWx0cztcclxuICAgICAgICB2YXIgcmF3T3B0aW9ucztcclxuICAgICAgICBsb2NhbGUgPSB1dGlsXzEuZmlyc3REZWZpbmVkKC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gZ2l2ZW4/XHJcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmxvY2FsZSwgdGhpcy5vdmVycmlkZXMubG9jYWxlKTtcclxuICAgICAgICBsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZV8xLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXTtcclxuICAgICAgICBpZiAoIWxvY2FsZURlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIGxvY2FsZSA9IG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGU7XHJcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzID0gbG9jYWxlXzEubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVdIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1JUTCA9IHV0aWxfMS5maXJzdERlZmluZWQoLy8gYmFzZWQgb24gb3B0aW9ucyBjb21wdXRlZCBzbyBmYXIsIGlzIGRpcmVjdGlvbiBSVEw/XHJcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmlzUlRMLCB0aGlzLm92ZXJyaWRlcy5pc1JUTCwgbG9jYWxlRGVmYXVsdHMuaXNSVEwsIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5pc1JUTCk7XHJcbiAgICAgICAgZGlyRGVmYXVsdHMgPSBpc1JUTCA/IG9wdGlvbnNfMS5ydGxEZWZhdWx0cyA6IHt9O1xyXG4gICAgICAgIHRoaXMuZGlyRGVmYXVsdHMgPSBkaXJEZWZhdWx0cztcclxuICAgICAgICB0aGlzLmxvY2FsZURlZmF1bHRzID0gbG9jYWxlRGVmYXVsdHM7XHJcbiAgICAgICAgcmF3T3B0aW9ucyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW1xyXG4gICAgICAgICAgICBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIGRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgdGhpcy5vdmVycmlkZXMsXHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlc1xyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxvY2FsZV8xLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhyYXdPcHRpb25zKTsgLy8gZmlsbCBpbiBnYXBzIHdpdGggY29tcHV0ZWQgb3B0aW9uc1xyXG4gICAgICAgIHRoaXMucmVzZXQocmF3T3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLy8gc3RvcmVzIHRoZSBuZXcgb3B0aW9ucyBpbnRlcm5hbGx5LCBidXQgZG9lcyBub3QgcmVyZW5kZXIgYW55dGhpbmcuXHJcbiAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUucmVjb3JkT3ZlcnJpZGVzID0gZnVuY3Rpb24gKG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICB2YXIgb3B0aW9uTmFtZTtcclxuICAgICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXNbb3B0aW9uTmFtZV0gPSBuZXdPcHRpb25IYXNoW29wdGlvbk5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3U3BlY01hbmFnZXIuY2xlYXJDYWNoZSgpOyAvLyB0aGUgZHluYW1pYyBvdmVycmlkZSBpbnZhbGlkYXRlcyB0aGUgb3B0aW9ucyBpbiB0aGlzIGNhY2hlLCBzbyBqdXN0IGNsZWFyIGl0XHJcbiAgICAgICAgdGhpcy5jb21wdXRlKCk7IC8vIHRoaXMub3B0aW9ucyBuZWVkcyB0byBiZSByZWNvbXB1dGVkIGFmdGVyIHRoZSBkeW5hbWljIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9wdGlvbnNNYW5hZ2VyO1xyXG59KE1vZGVsXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPcHRpb25zTWFuYWdlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFZpZXdSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgb3B0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG52YXIgVmlld1NwZWNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlld1NwZWNNYW5hZ2VyKG9wdGlvbnNNYW5hZ2VyLCBfY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gb3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XHJcbiAgICB9XHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3U3BlY0NhY2hlID0ge307XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gY3JlYXRlIGEgdmlldy4gV2lsbCB1c2UgYSBjYWNoZS5cclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuZ2V0Vmlld1NwZWMgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLnZpZXdTcGVjQ2FjaGU7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlW3ZpZXdUeXBlXSB8fCAoY2FjaGVbdmlld1R5cGVdID0gdGhpcy5idWlsZFZpZXdTcGVjKHZpZXdUeXBlKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxyXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5nZXRVbml0Vmlld1NwZWMgPSBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIHZhciB2aWV3VHlwZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNwZWM7XHJcbiAgICAgICAgaWYgKCQuaW5BcnJheSh1bml0LCB1dGlsXzEudW5pdHNEZXNjKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gcHV0IHZpZXdzIHRoYXQgaGF2ZSBidXR0b25zIGZpcnN0LiB0aGVyZSB3aWxsIGJlIGR1cGxpY2F0ZXMsIGJ1dCBvaCB3ZWxsXHJcbiAgICAgICAgICAgIHZpZXdUeXBlcyA9IHRoaXMuX2NhbGVuZGFyLmhlYWRlci5nZXRWaWV3c1dpdGhCdXR0b25zKCk7IC8vIFRPRE86IGluY2x1ZGUgZm9vdGVyIGFzIHdlbGw/XHJcbiAgICAgICAgICAgICQuZWFjaChWaWV3UmVnaXN0cnlfMS52aWV3SGFzaCwgZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0gdGhpcy5nZXRWaWV3U3BlYyh2aWV3VHlwZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gb24gaG93IHRvIGNyZWF0ZSBhIGdpdmVuIHZpZXdcclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuYnVpbGRWaWV3U3BlYyA9IGZ1bmN0aW9uIChyZXF1ZXN0ZWRWaWV3VHlwZSkge1xyXG4gICAgICAgIHZhciB2aWV3T3ZlcnJpZGVzID0gdGhpcy5vcHRpb25zTWFuYWdlci5vdmVycmlkZXMudmlld3MgfHwge307XHJcbiAgICAgICAgdmFyIHNwZWNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgdmFyIGRlZmF1bHRzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciBvdmVycmlkZXNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgdmFyIHZpZXdUeXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XHJcbiAgICAgICAgdmFyIHNwZWM7IC8vIGZvciB0aGUgdmlld1xyXG4gICAgICAgIHZhciBvdmVycmlkZXM7IC8vIGZvciB0aGUgdmlld1xyXG4gICAgICAgIHZhciBkdXJhdGlvbklucHV0O1xyXG4gICAgICAgIHZhciBkdXJhdGlvbjtcclxuICAgICAgICB2YXIgdW5pdDtcclxuICAgICAgICAvLyBpdGVyYXRlIGZyb20gdGhlIHNwZWNpZmljIHZpZXcgZGVmaW5pdGlvbiB0byBhIG1vcmUgZ2VuZXJhbCBvbmUgdW50aWwgd2UgaGl0IGFuIGFjdHVhbCBWaWV3IGNsYXNzXHJcbiAgICAgICAgd2hpbGUgKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIHNwZWMgPSBWaWV3UmVnaXN0cnlfMS52aWV3SGFzaFt2aWV3VHlwZV07XHJcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHZpZXdPdmVycmlkZXNbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICB2aWV3VHlwZSA9IG51bGw7IC8vIGNsZWFyLiBtaWdodCByZXBvcHVsYXRlIGZvciBhbm90aGVyIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNwZWMgPSB7ICdjbGFzcyc6IHNwZWMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgICAgICAgICAgc3BlY0NoYWluLnVuc2hpZnQoc3BlYyk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0c0NoYWluLnVuc2hpZnQoc3BlYy5kZWZhdWx0cyB8fCB7fSk7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fCBzcGVjLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCBzcGVjLnR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzQ2hhaW4udW5zaGlmdChvdmVycmlkZXMpOyAvLyB2aWV3LXNwZWNpZmljIG9wdGlvbiBoYXNoZXMgaGF2ZSBvcHRpb25zIGF0IHplcm8tbGV2ZWxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8IG92ZXJyaWRlcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgb3ZlcnJpZGVzLnR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3BlYyA9IHV0aWxfMS5tZXJnZVByb3BzKHNwZWNDaGFpbik7XHJcbiAgICAgICAgc3BlYy50eXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XHJcbiAgICAgICAgaWYgKCFzcGVjWydjbGFzcyddKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRvcC1sZXZlbCBgZHVyYXRpb25gIG9wdGlvblxyXG4gICAgICAgIGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcy5kdXJhdGlvbiB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5kdXJhdGlvbjtcclxuICAgICAgICBpZiAoZHVyYXRpb25JbnB1dCkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbklucHV0KTtcclxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgc3BlYy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3BlYy5kdXJhdGlvblVuaXQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgLy8gdmlldyBpcyBhIHNpbmdsZS11bml0IGR1cmF0aW9uLCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCJcclxuICAgICAgICAgICAgICAgIC8vIGluY29ycG9yYXRlIG9wdGlvbnMgZm9yIHRoaXMuIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uLmFzKHVuaXQpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlYy5zaW5nbGVVbml0ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXNDaGFpbi51bnNoaWZ0KHZpZXdPdmVycmlkZXNbdW5pdF0gfHwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNwZWMuZGVmYXVsdHMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKGRlZmF1bHRzQ2hhaW4pO1xyXG4gICAgICAgIHNwZWMub3ZlcnJpZGVzID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhvdmVycmlkZXNDaGFpbik7XHJcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjT3B0aW9ucyhzcGVjKTtcclxuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNCdXR0b25UZXh0KHNwZWMsIHJlcXVlc3RlZFZpZXdUeXBlKTtcclxuICAgICAgICByZXR1cm4gc3BlYztcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBvcHRpb25zIG9iamVjdCBmcm9tIGl0cyBhbHJlYWR5LWFzc2lnbmVkIGRlZmF1bHRzIGFuZCBvdmVycmlkZXNcclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuYnVpbGRWaWV3U3BlY09wdGlvbnMgPSBmdW5jdGlvbiAoc3BlYykge1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IHRoaXMub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgc3BlYy5vcHRpb25zID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhbXHJcbiAgICAgICAgICAgIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cyxcclxuICAgICAgICAgICAgc3BlYy5kZWZhdWx0cyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZGlyRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLmxvY2FsZURlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5vdmVycmlkZXMsXHJcbiAgICAgICAgICAgIHNwZWMub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5keW5hbWljT3ZlcnJpZGVzIC8vIGR5bmFtaWNhbGx5IHNldCB2aWEgc2V0dGVyLiBoaWdoZXN0IHByZWNlZGVuY2VcclxuICAgICAgICBdKTtcclxuICAgICAgICBsb2NhbGVfMS5wb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMoc3BlYy5vcHRpb25zKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgYXNzaWducyBhIHZpZXcgc3BlYydzIGJ1dHRvblRleHQtcmVsYXRlZCBvcHRpb25zXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWNCdXR0b25UZXh0ID0gZnVuY3Rpb24gKHNwZWMsIHJlcXVlc3RlZFZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnNNYW5hZ2VyID0gdGhpcy5vcHRpb25zTWFuYWdlcjtcclxuICAgICAgICAvLyBnaXZlbiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgcG9zc2libGUgYGJ1dHRvblRleHRgIGhhc2gsIGxvb2t1cCB0aGUgYnV0dG9uVGV4dCBmb3IgdGhlXHJcbiAgICAgICAgLy8gcmVxdWVzdGVkIHZpZXcsIGZhbGxpbmcgYmFjayB0byBhIGdlbmVyaWMgdW5pdCBlbnRyeSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCJcclxuICAgICAgICBmdW5jdGlvbiBxdWVyeUJ1dHRvblRleHQob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uVGV4dCA9IG9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRbcmVxdWVzdGVkVmlld1R5cGVdIHx8XHJcbiAgICAgICAgICAgICAgICAvLyB2aWV3IGNhbiBkZWNpZGUgdG8gbG9vayB1cCBhIGNlcnRhaW4ga2V5XHJcbiAgICAgICAgICAgICAgICAoc3BlYy5idXR0b25UZXh0S2V5ID8gYnV0dG9uVGV4dFtzcGVjLmJ1dHRvblRleHRLZXldIDogbnVsbCkgfHxcclxuICAgICAgICAgICAgICAgIC8vIGEga2V5IGxpa2UgXCJtb250aFwiXHJcbiAgICAgICAgICAgICAgICAoc3BlYy5zaW5nbGVVbml0ID8gYnV0dG9uVGV4dFtzcGVjLnNpbmdsZVVuaXRdIDogbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5XHJcbiAgICAgICAgc3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgPVxyXG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5vdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgICAgIHNwZWMub3ZlcnJpZGVzLmJ1dHRvblRleHQ7IC8vIGBidXR0b25UZXh0YCBmb3Igdmlldy1zcGVjaWZpYyBvcHRpb25zIGlzIGEgc3RyaW5nXHJcbiAgICAgICAgLy8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHkuIG1pcnJvcnMgYnVpbGRWaWV3U3BlY09wdGlvbnNcclxuICAgICAgICBzcGVjLmJ1dHRvblRleHREZWZhdWx0ID1cclxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmxvY2FsZURlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgc3BlYy5kZWZhdWx0cy5idXR0b25UZXh0IHx8IC8vIGEgc2luZ2xlIHN0cmluZy4gZnJvbSBWaWV3U3ViY2xhc3MuZGVmYXVsdHNcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICAoc3BlYy5kdXJhdGlvbiA/IHRoaXMuX2NhbGVuZGFyLmh1bWFuaXplRHVyYXRpb24oc3BlYy5kdXJhdGlvbikgOiBudWxsKSB8fCAvLyBsaWtlIFwiMyBkYXlzXCJcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZpZXdUeXBlOyAvLyBmYWxsIGJhY2sgdG8gZ2l2ZW4gdmlldyBuYW1lXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZpZXdTcGVjTWFuYWdlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVmlld1NwZWNNYW5hZ2VyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRQZXJpb2RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQzKTtcclxudmFyIEFycmF5RXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBFdmVudE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIoY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy5zdGlja3lTb3VyY2UgPSBuZXcgQXJyYXlFdmVudFNvdXJjZV8xLmRlZmF1bHQoY2FsZW5kYXIpO1xyXG4gICAgICAgIHRoaXMub3RoZXJTb3VyY2VzID0gW107XHJcbiAgICB9XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlcXVlc3RFdmVudHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUsIGZvcmNlKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRQZXJpb2QgfHxcclxuICAgICAgICAgICAgIXRoaXMuY3VycmVudFBlcmlvZC5pc1dpdGhpblJhbmdlKHN0YXJ0LCBlbmQpIHx8XHJcbiAgICAgICAgICAgIHRpbWV6b25lICE9PSB0aGlzLmN1cnJlbnRQZXJpb2QudGltZXpvbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQZXJpb2QoLy8gd2lsbCBjaGFuZ2UgdGhpcy5jdXJyZW50UGVyaW9kXHJcbiAgICAgICAgICAgIG5ldyBFdmVudFBlcmlvZF8xLmRlZmF1bHQoc3RhcnQsIGVuZCwgdGltZXpvbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC53aGVuUmVsZWFzZWQoKTtcclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgQWRkaW5nL1JlbW92aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLm90aGVyU291cmNlcy5wdXNoKGV2ZW50U291cmNlKTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlKGV2ZW50U291cmNlKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChkb29tZWRTb3VyY2UpIHtcclxuICAgICAgICB1dGlsXzEucmVtb3ZlRXhhY3QodGhpcy5vdGhlclNvdXJjZXMsIGRvb21lZFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucHVyZ2VTb3VyY2UoZG9vbWVkU291cmNlKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclNvdXJjZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5wdXJnZUFsbFNvdXJjZXMoKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgUmVmZXRjaGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVmZXRjaFNvdXJjZSA9IGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gdGhpcy5jdXJyZW50UGVyaW9kO1xyXG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucHVyZ2VTb3VyY2UoZXZlbnRTb3VyY2UpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlcXVlc3RTb3VyY2UoZXZlbnRTb3VyY2UpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnRoYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZWZldGNoQWxsU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnB1cmdlQWxsU291cmNlcygpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlcXVlc3RTb3VyY2VzKHRoaXMuZ2V0U291cmNlcygpKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFNvdXJjZSBRdWVyeWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuc3RpY2t5U291cmNlXS5jb25jYXQodGhpcy5vdGhlclNvdXJjZXMpO1xyXG4gICAgfTtcclxuICAgIC8vIGxpa2UgcXVlcnlTb3VyY2VzLCBidXQgYWNjZXB0cyBtdWx0cGxlIG1hdGNoIGNyaXRlcmlhIChsaWtlIG11bHRpcGxlIElEcylcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUubXVsdGlRdWVyeVNvdXJjZXMgPSBmdW5jdGlvbiAobWF0Y2hJbnB1dHMpIHtcclxuICAgICAgICAvLyBjb2VyY2UgaW50byBhbiBhcnJheVxyXG4gICAgICAgIGlmICghbWF0Y2hJbnB1dHMpIHtcclxuICAgICAgICAgICAgbWF0Y2hJbnB1dHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoISQuaXNBcnJheShtYXRjaElucHV0cykpIHtcclxuICAgICAgICAgICAgbWF0Y2hJbnB1dHMgPSBbbWF0Y2hJbnB1dHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0Y2hpbmdTb3VyY2VzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gcmVzb2x2ZSByYXcgaW5wdXRzIHRvIHJlYWwgZXZlbnQgc291cmNlIG9iamVjdHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF0Y2hJbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbWF0Y2hpbmdTb3VyY2VzLnB1c2guYXBwbHkoLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIG1hdGNoaW5nU291cmNlcywgdGhpcy5xdWVyeVNvdXJjZXMobWF0Y2hJbnB1dHNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nU291cmNlcztcclxuICAgIH07XHJcbiAgICAvLyBtYXRjaElucHV0IGNhbiBlaXRoZXIgYnkgYSByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3QsIGFuIElELCBvciB0aGUgZnVuY3Rpb24vVVJMIGZvciB0aGUgc291cmNlLlxyXG4gICAgLy8gcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBzb3VyY2Ugb2JqZWN0cy5cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucXVlcnlTb3VyY2VzID0gZnVuY3Rpb24gKG1hdGNoSW5wdXQpIHtcclxuICAgICAgICB2YXIgc291cmNlcyA9IHRoaXMub3RoZXJTb3VyY2VzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzb3VyY2U7XHJcbiAgICAgICAgLy8gZ2l2ZW4gYSBwcm9wZXIgZXZlbnQgc291cmNlIG9iamVjdFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IG1hdGNoSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc291cmNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiBJRCBtYXRjaFxyXG4gICAgICAgIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlQnlJZChFdmVudFNvdXJjZV8xLmRlZmF1bHQubm9ybWFsaXplSWQobWF0Y2hJbnB1dCkpO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtzb3VyY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXJzZSBhcyBhbiBldmVudCBzb3VyY2VcclxuICAgICAgICBtYXRjaElucHV0ID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKG1hdGNoSW5wdXQsIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIGlmIChtYXRjaElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkLmdyZXAoc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU291cmNlc0VxdWl2YWxlbnQobWF0Y2hJbnB1dCwgc291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBJRCBhc3N1bWVkIHRvIGFscmVhZHkgYmUgbm9ybWFsaXplZFxyXG4gICAgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiAkLmdyZXAodGhpcy5vdGhlclNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5pZCAmJiBzb3VyY2UuaWQgPT09IGlkO1xyXG4gICAgICAgIH0pWzBdO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50LVBlcmlvZFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0UGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLnVuYmluZFBlcmlvZCh0aGlzLmN1cnJlbnRQZXJpb2QpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QgPSBldmVudFBlcmlvZDtcclxuICAgICAgICB0aGlzLmJpbmRQZXJpb2QoZXZlbnRQZXJpb2QpO1xyXG4gICAgICAgIGV2ZW50UGVyaW9kLnJlcXVlc3RTb3VyY2VzKHRoaXMuZ2V0U291cmNlcygpKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmJpbmRQZXJpb2QgPSBmdW5jdGlvbiAoZXZlbnRQZXJpb2QpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKGV2ZW50UGVyaW9kLCAncmVsZWFzZScsIGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVsZWFzZScsIGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kUGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oZXZlbnRQZXJpb2QpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEdldHRpbmcvQWRkaW5nL1JlbW92aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudERlZkJ5VWlkID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudERlZkJ5VWlkKHVpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYsIGlzU3RpY2t5KSB7XHJcbiAgICAgICAgaWYgKGlzU3RpY2t5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RpY2t5U291cmNlLmFkZEV2ZW50RGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QuYWRkRXZlbnREZWYoZXZlbnREZWYpOyAvLyBtaWdodCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudElkKSB7XHJcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UucmVtb3ZlRXZlbnREZWZzQnlJZChldmVudElkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZW1vdmVFdmVudERlZnNCeUlkKGV2ZW50SWQpOyAvLyBtaWdodCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlLnJlbW92ZUFsbEV2ZW50RGVmcygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLnJlbW92ZUFsbEV2ZW50RGVmcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBNdXRhdGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIGFuIHVuZG8gZnVuY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5tdXRhdGVFdmVudHNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCwgZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gdGhpcy5jdXJyZW50UGVyaW9kO1xyXG4gICAgICAgIHZhciBldmVudERlZnM7XHJcbiAgICAgICAgdmFyIHVuZG9GdW5jcyA9IFtdO1xyXG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmcyA9IGN1cnJlbnRQZXJpb2QuZ2V0RXZlbnREZWZzQnlJZChldmVudERlZklkKTtcclxuICAgICAgICAgICAgZXZlbnREZWZzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQvcmVtb3ZlIGVzcCBiZWNhdXNlIGlkIG1pZ2h0IGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZW1vdmVFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgICAgICAgICB1bmRvRnVuY3MucHVzaChldmVudERlZk11dGF0aW9uLm11dGF0ZVNpbmdsZShldmVudERlZikpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5hZGRFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnRoYXcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWYoZXZlbnREZWZzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmRvRnVuY3NbaV0oKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLmFkZEV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLnRoYXcoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgY29waWVzIGFuZCB0aGVuIG11dGF0ZXNcclxuICAgICovXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCA9IGZ1bmN0aW9uIChldmVudERlZklkLCBldmVudERlZk11dGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuZ2V0RXZlbnREZWZzQnlJZChldmVudERlZklkKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZGVmQ29weTtcclxuICAgICAgICB2YXIgYWxsSW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZWZDb3B5ID0gZXZlbnREZWZzW2ldLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWZDb3B5IGluc3RhbmNlb2YgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZk11dGF0aW9uLm11dGF0ZVNpbmdsZShkZWZDb3B5KTtcclxuICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlcy5wdXNoLmFwcGx5KGFsbEluc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgICAgICBkZWZDb3B5LmJ1aWxkSW5zdGFuY2VzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdChhbGxJbnN0YW5jZXMpO1xyXG4gICAgfTtcclxuICAgIC8vIEZyZWV6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUudGhhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIG1ldGhvZHMgdGhhdCBzaW1wbHkgZm9yd2FyZCB0byBFdmVudFBlcmlvZFxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGVyaW9kLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGVyaW9kLmdldEV2ZW50SW5zdGFuY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlc1dpdGhJZChldmVudERlZklkKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGVyaW9kLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkKGV2ZW50RGVmSWQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudE1hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50TWFuYWdlcjtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50TWFuYWdlcik7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnRNYW5hZ2VyKTtcclxuZnVuY3Rpb24gaXNTb3VyY2VzRXF1aXZhbGVudChzb3VyY2UwLCBzb3VyY2UxKSB7XHJcbiAgICByZXR1cm4gc291cmNlMC5nZXRQcmltaXRpdmUoKSA9PT0gc291cmNlMS5nZXRQcmltaXRpdmUoKTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIEV2ZW50UGVyaW9kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRQZXJpb2Qoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJlZXplRGVwdGggPSAwO1xyXG4gICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMucmVsZWFzZUNudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMudGltZXpvbmUgPSB0aW1lem9uZTtcclxuICAgICAgICB0aGlzLnVuem9uZWRSYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCksIGVuZC5jbG9uZSgpLnN0cmlwWm9uZSgpKTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5VWlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeUlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHt9O1xyXG4gICAgfVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmlzV2l0aGluUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIC8vIFRPRE86IHVzZSBhIHJhbmdlIHV0aWwgZnVuY3Rpb24/XHJcbiAgICAgICAgcmV0dXJuICFzdGFydC5pc0JlZm9yZSh0aGlzLnN0YXJ0KSAmJiAhZW5kLmlzQWZ0ZXIodGhpcy5lbmQpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlcXVlc3RpbmcgYW5kIFB1cmdpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVxdWVzdFNvdXJjZXMgPSBmdW5jdGlvbiAoc291cmNlcykge1xyXG4gICAgICAgIHRoaXMuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlcXVlc3RTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHsgc291cmNlOiBzb3VyY2UsIHN0YXR1czogJ3BlbmRpbmcnLCBldmVudERlZnM6IG51bGwgfTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWRbc291cmNlLnVpZF0gPSByZXF1ZXN0O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NudCArPSAxO1xyXG4gICAgICAgIHNvdXJjZS5mZXRjaCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy50aW1lem9uZSkudGhlbihmdW5jdGlvbiAoZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2NvbXBsZXRlZCc7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmV2ZW50RGVmcyA9IGV2ZW50RGVmcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50RGVmcyhldmVudERlZnMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdmYWlsZWQnO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnB1cmdlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RzQnlVaWRbc291cmNlLnVpZF07XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdjYW5jZWxsZWQnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ250LS07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZXZlbnREZWZzLmZvckVhY2godGhpcy5yZW1vdmVFdmVudERlZi5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucHVyZ2VBbGxTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0c0J5VWlkID0gdGhpcy5yZXF1ZXN0c0J5VWlkO1xyXG4gICAgICAgIHZhciB1aWQ7XHJcbiAgICAgICAgdmFyIHJlcXVlc3Q7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlZENudCA9IDA7XHJcbiAgICAgICAgZm9yICh1aWQgaW4gcmVxdWVzdHNCeVVpZCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdHNCeVVpZFt1aWRdO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZENudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVxdWVzdHNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NudCA9IDA7XHJcbiAgICAgICAgaWYgKGNvbXBsZXRlZENudCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50RGVmcygpOyAvLyBtaWdodCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERlZmluaXRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50RGVmQnlVaWQgPSBmdW5jdGlvbiAoZXZlbnREZWZVaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudERlZnNCeVVpZFtldmVudERlZlVpZF07XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5ldmVudERlZnNCeUlkW2V2ZW50RGVmSWRdO1xyXG4gICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKCk7IC8vIGNsb25lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUuYWRkRXZlbnREZWZzID0gZnVuY3Rpb24gKGV2ZW50RGVmcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnREZWYoZXZlbnREZWZzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmc0J5SWQgPSB0aGlzLmV2ZW50RGVmc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQgPSBldmVudERlZi5pZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gZXZlbnREZWZzQnlJZFtldmVudERlZklkXSB8fCAoZXZlbnREZWZzQnlJZFtldmVudERlZklkXSA9IFtdKTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSBldmVudERlZi5idWlsZEluc3RhbmNlcyh0aGlzLnVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWYudWlkXSA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZXNbaV0sIGV2ZW50RGVmSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlzRW1wdHkgPSAkLmlzRW1wdHlPYmplY3QodGhpcy5ldmVudERlZnNCeVVpZCk7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlJZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB7fTtcclxuICAgICAgICBpZiAoIWlzRW1wdHkpIHtcclxuICAgICAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZnNCeUlkID0gdGhpcy5ldmVudERlZnNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSBldmVudERlZnNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICBkZWxldGUgdGhpcy5ldmVudERlZnNCeVVpZFtldmVudERlZi51aWRdO1xyXG4gICAgICAgIGlmIChldmVudERlZnMpIHtcclxuICAgICAgICAgICAgdXRpbF8xLnJlbW92ZUV4YWN0KGV2ZW50RGVmcywgZXZlbnREZWYpO1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50RGVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudERlZnNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SW5zdGFuY2VzRm9yRGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgSW5zdGFuY2VzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgdmFyIGlkO1xyXG4gICAgICAgIGZvciAoaWQgaW4gZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMucHVzaC5hcHBseShldmVudEluc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2lkXS5ldmVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEluc3RhbmNlcztcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcy5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkO1xyXG4gICAgICAgIHZhciBtYXRjaGluZ0luc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCAhPT0gZXZlbnREZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdJbnN0YW5jZXMucHVzaC5hcHBseShtYXRjaGluZ0luc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXBzQnlJZFtpZF0uZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGluZ0luc3RhbmNlcztcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUuYWRkRXZlbnRJbnN0YW5jZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbZXZlbnREZWZJZF0gfHxcclxuICAgICAgICAgICAgKGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLnB1c2goZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlbW92ZUV2ZW50SW5zdGFuY2VzRm9yRGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbZXZlbnREZWYuaWRdO1xyXG4gICAgICAgIHZhciByZW1vdmVDbnQ7XHJcbiAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgICAgICByZW1vdmVDbnQgPSB1dGlsXzEucmVtb3ZlTWF0Y2hpbmcoZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLCBmdW5jdGlvbiAoY3VycmVudEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RXZlbnRJbnN0YW5jZS5kZWYgPT09IGV2ZW50RGVmO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbZXZlbnREZWYuaWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZW1vdmVDbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbGVhc2luZyBhbmQgRnJlZXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUudHJ5UmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0NudCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZnJlZXplRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHVudGVkUmVsZWFzZUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVsZWFzZUNudCsrO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVsZWFzZScsIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS53aGVuUmVsZWFzZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5yZWxlYXNlQ250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5yZXNvbHZlKHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LmNvbnN0cnVjdChmdW5jdGlvbiAob25SZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmUoJ3JlbGVhc2UnLCBvblJlc29sdmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmZyZWV6ZURlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUudGhhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISgtLXRoaXMuZnJlZXplRGVwdGgpICYmIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQgJiYgIXRoaXMucGVuZGluZ0NudCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UGVyaW9kO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFBlcmlvZDtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50UGVyaW9kKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbi8qIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBlbGVtZW50IGFuZCBsZXRzIGl0IHRyYWNrIHRoZSBtb3VzZSBhcyBpdCBtb3Zlc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIE1vdXNlRm9sbG93ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb3VzZUZvbGxvd2VyKHNvdXJjZUVsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7IC8vIGRvaW5nIHRoZSByZXZlcnQgYW5pbWF0aW9uP1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcclxuICAgICAgICB0aGlzLnBhcmVudEVsID0gb3B0aW9ucy5wYXJlbnRFbCA/ICQob3B0aW9ucy5wYXJlbnRFbCkgOiBzb3VyY2VFbC5wYXJlbnQoKTsgLy8gZGVmYXVsdCB0byBzb3VyY2VFbCdzIHBhcmVudFxyXG4gICAgfVxyXG4gICAgLy8gQ2F1c2VzIHRoZSBlbGVtZW50IHRvIHN0YXJ0IGZvbGxvd2luZyB0aGUgbW91c2VcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRm9sbG93aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNGb2xsb3dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnkwID0gdXRpbF8xLmdldEV2WShldik7XHJcbiAgICAgICAgICAgIHRoaXMueDAgPSB1dGlsXzEuZ2V0RXZYKGV2KTtcclxuICAgICAgICAgICAgdGhpcy50b3BEZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdERlbHRhID0gMDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxfMS5nZXRFdklzVG91Y2goZXYpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdG9wIGZvbGxvd2luZyB0aGUgbW91c2UuIElmIHNob3VsZFJldmVydCBpcyB0cnVlLCB3aWxsIGFuaW1hdGUgYmFjayB0byBvcmlnaW5hbCBwb3NpdGlvbi5cclxuICAgIC8vIGBjYWxsYmFja2AgZ2V0cyBpbnZva2VkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS4gSWYgbm8gYW5pbWF0aW9uLCBpdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5LlxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChzaG91bGRSZXZlcnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmV2ZXJ0RHVyYXRpb24gPSB0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb247XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIF90aGlzLnRvcDAgPSBfdGhpcy5sZWZ0MCA9IG51bGw7IC8vIHJlc2V0IHN0YXRlIGZvciBmdXR1cmUgdXBkYXRlUG9zaXRpb24gY2FsbHNcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5pc0ZvbGxvd2luZyAmJiAhdGhpcy5pc0FuaW1hdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRm9sbG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFJldmVydCAmJiByZXZlcnREdXJhdGlvbiAmJiAhdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy50b3AwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMubGVmdDBcclxuICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogcmV2ZXJ0RHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdHJhY2tpbmcgZWxlbWVudC4gQ3JlYXRlIGl0IGlmIG5lY2Vzc2FyeVxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuZ2V0RWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgIGVsID0gdGhpcy5lbCA9IHRoaXMuc291cmNlRWwuY2xvbmUoKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hZGRpdGlvbmFsQ2xhc3MgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiB0aGlzLmlzSGlkZGVuID8gJ25vbmUnIDogJycsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zb3VyY2VFbC53aWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnNvdXJjZUVsLmhlaWdodCgpLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLm9wYWNpdHkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMub3B0aW9ucy56SW5kZXhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cclxuICAgICAgICAgICAgLy8gd291bGQgdXNlIHByZXZlbnRTZWxlY3Rpb24oKSwgYnV0IHRoYXQgcHJldmVudHMgc2VsZWN0c3RhcnQsIGNhdXNpbmcgcHJvYmxlbXMuXHJcbiAgICAgICAgICAgIGVsLmFkZENsYXNzKCdmYy11bnNlbGVjdGFibGUnKTtcclxuICAgICAgICAgICAgZWwuYXBwZW5kVG8odGhpcy5wYXJlbnRFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH07XHJcbiAgICAvLyBSZW1vdmVzIHRoZSB0cmFja2luZyBlbGVtZW50IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlIHRoZSBDU1MgcG9zaXRpb24gb2YgdGhlIHRyYWNraW5nIGVsZW1lbnRcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzb3VyY2VPZmZzZXQ7XHJcbiAgICAgICAgdmFyIG9yaWdpbjtcclxuICAgICAgICB0aGlzLmdldEVsKCk7IC8vIGVuc3VyZSB0aGlzLmVsXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIG9yaWdpbiBpbmZvIHdhcyBjb21wdXRlZFxyXG4gICAgICAgIGlmICh0aGlzLnRvcDAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzb3VyY2VPZmZzZXQgPSB0aGlzLnNvdXJjZUVsLm9mZnNldCgpO1xyXG4gICAgICAgICAgICBvcmlnaW4gPSB0aGlzLmVsLm9mZnNldFBhcmVudCgpLm9mZnNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRvcDAgPSBzb3VyY2VPZmZzZXQudG9wIC0gb3JpZ2luLnRvcDtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0MCA9IHNvdXJjZU9mZnNldC5sZWZ0IC0gb3JpZ2luLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuY3NzKHtcclxuICAgICAgICAgICAgdG9wOiB0aGlzLnRvcDAgKyB0aGlzLnRvcERlbHRhLFxyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQwICsgdGhpcy5sZWZ0RGVsdGFcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudG9wRGVsdGEgPSB1dGlsXzEuZ2V0RXZZKGV2KSAtIHRoaXMueTA7XHJcbiAgICAgICAgdGhpcy5sZWZ0RGVsdGEgPSB1dGlsXzEuZ2V0RXZYKGV2KSAtIHRoaXMueDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGVtcG9yYXJpbHkgbWFrZXMgdGhlIHRyYWNraW5nIGVsZW1lbnQgaW52aXNpYmxlLiBDYW4gYmUgY2FsbGVkIGJlZm9yZSBmb2xsb3dpbmcgc3RhcnRzXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFNob3cgdGhlIHRyYWNraW5nIGVsZW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gdGVtcG9yYXJpbHkgaGlkZGVuXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmdldEVsKCkuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTW91c2VGb2xsb3dlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW91c2VGb2xsb3dlcjtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhNb3VzZUZvbGxvd2VyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIERhdGVDbGlja2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVDbGlja2luZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgIC0gYmluZERhdGVIYW5kbGVyVG9FbFxyXG4gICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICAgLSBnZXRIaXRFbFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGVDbGlja2luZyhjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gX3RoaXMuYnVpbGREcmFnTGlzdGVuZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIERhdGVDbGlja2luZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5zaG91bGRJZ25vcmVUb3VjaCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgY2xpY2tpbmcuXHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkYXlDbGlja0hpdDsgLy8gbnVsbCBpZiBpbnZhbGlkIGRheUNsaWNrXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRheUNsaWNrSGl0ID0gZHJhZ0xpc3RlbmVyLm9yaWdIaXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkcmFnZ2VkIHRvIGFub3RoZXIgY2VsbCBhdCBhbnkgcG9pbnQsIGl0IGNhbiBubyBsb25nZXIgYmUgYSBkYXlDbGlja1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09yaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXlDbGlja0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGF5Q2xpY2tIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQgJiYgZGF5Q2xpY2tIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChkYXlDbGlja0hpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnRyaWdnZXJEYXlDbGljayhjb21wb25lbnRGb290cHJpbnQsIGNvbXBvbmVudC5nZXRIaXRFbChkYXlDbGlja0hpdCksIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBiZWNhdXNlIGRyYWdMaXN0ZW5lciB3b24ndCBiZSBjYWxsZWQgd2l0aCBhbnkgdGltZSBkZWxheSwgXCJkcmFnZ2luZ1wiIHdpbGwgYmVnaW4gaW1tZWRpYXRlbHksXHJcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBraWxsIGFueSB0b3VjaG1vdmluZy9zY3JvbGxpbmcuIFByZXZlbnQgdGhpcy5cclxuICAgICAgICBkcmFnTGlzdGVuZXIuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc2Nyb2xsQWx3YXlzS2lsbHMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVDbGlja2luZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZUNsaWNraW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcbi8qXHJcbk9ubHkgaGFuZGxlcyBmb3JlZ3JvdW5kIHNlZ3MuXHJcbkRvZXMgbm90IG93biByZW5kZXJpbmcuIFVzZSBmb3IgbG93LWxldmVsIHV0aWwgbWV0aG9kcyBieSBUaW1lR3JpZC5cclxuKi9cclxudmFyIFRpbWVHcmlkRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkRXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkRXZlbnRSZW5kZXJlcih0aW1lR3JpZCwgZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGltZUdyaWQsIGZpbGxSZW5kZXJlcikgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50aW1lR3JpZCA9IHRpbWVHcmlkO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzKHNlZ3MsIHRoaXMudGltZUdyaWQuZmdDb250YWluZXJFbHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGFycmF5IG9mIGZvcmVncm91bmQgc2VnbWVudHMsIHJlbmRlciBhIERPTSBlbGVtZW50IGZvciBlYWNoLCBjb21wdXRlcyBwb3NpdGlvbixcclxuICAgIC8vIGFuZCBhdHRhY2hlcyB0byB0aGUgY29sdW1uIGlubmVyLWNvbnRhaW5lciBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoc2VncywgY29udGFpbmVyRWxzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3NCeUNvbDtcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHNlZ3NCeUNvbCA9IHRoaXMudGltZUdyaWQuZ3JvdXBTZWdzQnlDb2woc2Vncyk7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLnRpbWVHcmlkLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVGZ1NlZ0Nvb3JkcyhzZWdzQnlDb2xbY29sXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYXR0YWNoU2Vnc0J5Q29sKHNlZ3NCeUNvbCwgY29udGFpbmVyRWxzKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZnU2Vncykge1xyXG4gICAgICAgICAgICB0aGlzLmZnU2Vncy5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGB0aW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdub01lcmlkaWVtVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNjozMFwiIChubyBBTS9QTSlcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgYGRpc3BsYXlFdmVudEVuZGAgdmFsdWUgaWYgb25lIGlzIG5vdCBleHBsaWNsdHkgZGVmaW5lZFxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGV2ZW50IHNlZ21lbnQncyBkZWZhdWx0IHJlbmRlcmluZ1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQgPSBzZWcuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgaXNBbGxEYXkgPSBjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREZWZEcmFnZ2FibGUoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzU3RhcnQgJiYgdmlldy5pc0V2ZW50RGVmUmVzaXphYmxlRnJvbVN0YXJ0KGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNFbmQgJiYgdmlldy5pc0V2ZW50RGVmUmVzaXphYmxlRnJvbUVuZChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kKTtcclxuICAgICAgICB2YXIgc2tpbkNzcyA9IHV0aWxfMS5jc3NUb1N0cih0aGlzLmdldFNraW5Dc3MoZXZlbnREZWYpKTtcclxuICAgICAgICB2YXIgdGltZVRleHQ7XHJcbiAgICAgICAgdmFyIGZ1bGxUaW1lVGV4dDsgLy8gbW9yZSB2ZXJib3NlIHRpbWUgdGV4dC4gZm9yIHRoZSBwcmludCBzdHlsZXNoZWV0XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZVRleHQ7IC8vIGp1c3QgdGhlIHN0YXJ0IHRpbWUgdGV4dFxyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtdGltZS1ncmlkLWV2ZW50JywgJ2ZjLXYtZXZlbnQnKTtcclxuICAgICAgICAvLyBpZiB0aGUgZXZlbnQgYXBwZWFycyB0byBzcGFuIG1vcmUgdGhhbiBvbmUgZGF5Li4uXHJcbiAgICAgICAgaWYgKHZpZXcuaXNNdWx0aURheVJhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGRpc3BsYXkgdGltZSB0ZXh0IG9uIHNlZ21lbnRzIHRoYXQgcnVuIGVudGlyZWx5IHRocm91Z2ggYSBkYXkuXHJcbiAgICAgICAgICAgIC8vIFRoYXQgd291bGQgYXBwZWFyIGFzIG1pZG5pZ2h0LW1pZG5pZ2h0IGFuZCB3b3VsZCBsb29rIGR1bWIuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZGlzcGxheSB0aGUgdGltZSB0ZXh0IGZvciB0aGUgKnNlZ21lbnQncyogdGltZXMgKGxpa2UgNnBtLW1pZG5pZ2h0IG9yIG1pZG5pZ2h0LTEwYW0pXHJcbiAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b25lZFN0YXJ0ID0gY2FsZW5kYXIubXNUb01vbWVudChzZWcuc3RhcnRNcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9uZWRFbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KHNlZy5lbmRNcyk7XHJcbiAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IHRoaXMuX2dldFRpbWVUZXh0KHpvbmVkU3RhcnQsIHpvbmVkRW5kLCBpc0FsbERheSk7XHJcbiAgICAgICAgICAgICAgICBmdWxsVGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXksICdMVCcpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lVGV4dCA9IHRoaXMuX2dldFRpbWVUZXh0KHpvbmVkU3RhcnQsIHpvbmVkRW5kLCBpc0FsbERheSwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcclxuICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICBmdWxsVGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQsICdMVCcpO1xyXG4gICAgICAgICAgICBzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50LCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoZXZlbnREZWYudXJsID9cclxuICAgICAgICAgICAgICAgICcgaHJlZj1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi51cmwpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoc2tpbkNzcyA/XHJcbiAgICAgICAgICAgICAgICAnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAodGltZVRleHQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy10aW1lXCInICtcclxuICAgICAgICAgICAgICAgICAgICAnIGRhdGEtc3RhcnQ9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoc3RhcnRUaW1lVGV4dCkgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAnIGRhdGEtZnVsbD1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShmdWxsVGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4+JyArIHV0aWxfMS5odG1sRXNjYXBlKHRpbWVUZXh0KSArICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnRpdGxlID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1iZ1wiLz4nICtcclxuICAgICAgICAgICAgLyogVE9ETzogd3JpdGUgQ1NTIGZvciB0aGlzXHJcbiAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21TdGFydCA/XHJcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICcnXHJcbiAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21FbmQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L2E+JztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBzZWdtZW50cyB0aGF0IGFyZSBhc3N1bWVkIHRvIGFsbCBsaXZlIGluIHRoZSAqc2FtZSBjb2x1bW4qLFxyXG4gICAgLy8gY29tcHV0ZSB0aGVpciB2ZXJpY2FsL2hvcml6b250YWwgY29vcmRpbmF0ZXMgYW5kIGFzc2lnbiB0byB0aGVpciBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlRmdTZWdDb29yZHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQuY29tcHV0ZVNlZ1ZlcnRpY2FscyhzZWdzKTsgLy8gaG9yaXpvbnRhbHMgcmVsaWVzIG9uIHRoaXNcclxuICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0hvcml6b250YWxzKHNlZ3MpOyAvLyBjb21wdXRlIGhvcml6b250YWwgY29vcmRpbmF0ZXMsIHotaW5kZXgncywgYW5kIHJlb3JkZXIgdGhlIGFycmF5XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5hc3NpZ25TZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgdGhpcy5hc3NpZ25GZ1NlZ0hvcml6b250YWxzKHNlZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGFycmF5IG9mIHNlZ21lbnRzIHRoYXQgYXJlIGFsbCBpbiB0aGUgc2FtZSBjb2x1bW4sIHNldHMgdGhlIGJhY2t3YXJkQ29vcmQgYW5kIGZvcndhcmRDb29yZCBvbiBlYWNoLlxyXG4gICAgLy8gTk9URTogQWxzbyByZW9yZGVycyB0aGUgZ2l2ZW4gYXJyYXkgYnkgZGF0ZSFcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUZnU2VnSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBsZXZlbHM7XHJcbiAgICAgICAgdmFyIGxldmVsMDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7IC8vIG9yZGVyIGJ5IGNlcnRhaW4gY3JpdGVyaWFcclxuICAgICAgICBsZXZlbHMgPSBidWlsZFNsb3RTZWdMZXZlbHMoc2Vncyk7XHJcbiAgICAgICAgY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpO1xyXG4gICAgICAgIGlmICgobGV2ZWwwID0gbGV2ZWxzWzBdKSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhsZXZlbDBbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbDAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2sobGV2ZWwwW2ldLCAwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxjdWxhdGUgc2VnLmZvcndhcmRDb29yZCBhbmQgc2VnLmJhY2t3YXJkQ29vcmQgZm9yIHRoZSBzZWdtZW50LCB3aGVyZSBib3RoIHZhbHVlcyByYW5nZVxyXG4gICAgLy8gZnJvbSAwIHRvIDEuIElmIHRoZSBjYWxlbmRhciBpcyBsZWZ0LXRvLXJpZ2h0LCB0aGUgc2VnLmJhY2t3YXJkQ29vcmQgbWFwcyB0byBcImxlZnRcIiBhbmRcclxuICAgIC8vIHNlZy5mb3J3YXJkQ29vcmQgbWFwcyB0byBcInJpZ2h0XCIgKHZpYSBwZXJjZW50YWdlKS4gVmljZS12ZXJzYSBpZiB0aGUgY2FsZW5kYXIgaXMgcmlnaHQtdG8tbGVmdC5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgXCJzZXJpZXNcIiwgd2hpY2ggbWVhbnMgY29uc2VjdXRpdmUgc2VnbWVudHMgd2l0aCB0aGUgc2FtZSBwcmVzc3VyZVxyXG4gICAgLy8gd2hvJ3Mgd2lkdGggaXMgdW5rbm93biB1bnRpbCBhbiBlZGdlIGhhcyBiZWVuIGhpdC4gYHNlcmllc0JhY2t3YXJkUHJlc3N1cmVgIGlzIHRoZSBudW1iZXIgb2ZcclxuICAgIC8vIHNlZ21lbnRzIGJlaGluZCB0aGlzIG9uZSBpbiB0aGUgY3VycmVudCBzZXJpZXMsIGFuZCBgc2VyaWVzQmFja3dhcmRDb29yZGAgaXMgdGhlIHN0YXJ0aW5nXHJcbiAgICAvLyBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBzZWdtZW50IGluIHRoZSBzZXJpZXMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrID0gZnVuY3Rpb24gKHNlZywgc2VyaWVzQmFja3dhcmRQcmVzc3VyZSwgc2VyaWVzQmFja3dhcmRDb29yZCkge1xyXG4gICAgICAgIHZhciBmb3J3YXJkU2VncyA9IHNlZy5mb3J3YXJkU2VncztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2VnLmZvcndhcmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghZm9yd2FyZFNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZm9yd2FyZCBzZWdtZW50cywgdGhpcyBzZWdtZW50IHNob3VsZCBidXR0IHVwIGFnYWluc3QgdGhlIGVkZ2VcclxuICAgICAgICAgICAgICAgIHNlZy5mb3J3YXJkQ29vcmQgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc29ydCBoaWdoZXN0IHByZXNzdXJlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRGb3J3YXJkU2Vncyhmb3J3YXJkU2Vncyk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNlZ21lbnQncyBmb3J3YXJkQ29vcmQgd2lsbCBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIGJhY2t3YXJkQ29vcmQgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBoaWdoZXN0LXByZXNzdXJlIGZvcndhcmQgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2soZm9yd2FyZFNlZ3NbMF0sIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUgKyAxLCBzZXJpZXNCYWNrd2FyZENvb3JkKTtcclxuICAgICAgICAgICAgICAgIHNlZy5mb3J3YXJkQ29vcmQgPSBmb3J3YXJkU2Vnc1swXS5iYWNrd2FyZENvb3JkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgYmFja3dhcmRDb29yZCBmcm9tIHRoZSBmb3J3YXJkQ29vcmQuIGNvbnNpZGVyIHRoZSBzZXJpZXNcclxuICAgICAgICAgICAgc2VnLmJhY2t3YXJkQ29vcmQgPSBzZWcuZm9yd2FyZENvb3JkIC1cclxuICAgICAgICAgICAgICAgIChzZWcuZm9yd2FyZENvb3JkIC0gc2VyaWVzQmFja3dhcmRDb29yZCkgLyAvLyBhdmFpbGFibGUgd2lkdGggZm9yIHNlcmllc1xyXG4gICAgICAgICAgICAgICAgICAgIChzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSk7IC8vICMgb2Ygc2VnbWVudHMgaW4gdGhlIHNlcmllc1xyXG4gICAgICAgICAgICAvLyB1c2UgdGhpcyBzZWdtZW50J3MgY29vcmRpbmF0ZXMgdG8gY29tcHV0ZWQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsZXNzLXByZXNzdXJpemVkXHJcbiAgICAgICAgICAgIC8vIGZvcndhcmQgc2VnbWVudHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZvcndhcmRTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzW2ldLCAwLCBzZWcuZm9yd2FyZENvb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnNvcnRGb3J3YXJkU2VncyA9IGZ1bmN0aW9uIChmb3J3YXJkU2Vncykge1xyXG4gICAgICAgIGZvcndhcmRTZWdzLnNvcnQodXRpbF8xLnByb3h5KHRoaXMsICdjb21wYXJlRm9yd2FyZFNlZ3MnKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoaWNoIGZvcndhcmQgc2VnbWVudCB0byByZWx5IG9uIG1vcmUgd2hlbiBjb21wdXRpbmcgY29vcmRpbmF0ZXMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXBhcmVGb3J3YXJkU2VncyA9IGZ1bmN0aW9uIChzZWcxLCBzZWcyKSB7XHJcbiAgICAgICAgLy8gcHV0IGhpZ2hlci1wcmVzc3VyZSBmaXJzdFxyXG4gICAgICAgIHJldHVybiBzZWcyLmZvcndhcmRQcmVzc3VyZSAtIHNlZzEuZm9yd2FyZFByZXNzdXJlIHx8XHJcbiAgICAgICAgICAgIC8vIHB1dCBzZWdtZW50cyB0aGF0IGFyZSBjbG9zZXIgdG8gaW5pdGlhbCBlZGdlIGZpcnN0IChhbmQgZmF2b3Igb25lcyB3aXRoIG5vIGNvb3JkcyB5ZXQpXHJcbiAgICAgICAgICAgIChzZWcxLmJhY2t3YXJkQ29vcmQgfHwgMCkgLSAoc2VnMi5iYWNrd2FyZENvb3JkIHx8IDApIHx8XHJcbiAgICAgICAgICAgIC8vIGRvIG5vcm1hbCBzb3J0aW5nLi4uXHJcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZUV2ZW50U2VncyhzZWcxLCBzZWcyKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGhhZCB0aGVpciBwb3NpdGlvbiBjb29yZGluYXRlcyBjb21wdXRlZCxcclxuICAgIC8vIGFzc2lnbnMgcG9zaXRpb24tcmVsYXRlZCBDU1MgdmFsdWVzIHRvIHRoZWlyIGVsZW1lbnRzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5hc3NpZ25GZ1NlZ0hvcml6b250YWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNlZy5lbC5jc3ModGhpcy5nZW5lcmF0ZUZnU2VnSG9yaXpvbnRhbENzcyhzZWcpKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGhlaWdodCBpcyBzaG9ydCwgYWRkIGEgY2xhc3NOYW1lIGZvciBhbHRlcm5hdGUgc3R5bGluZ1xyXG4gICAgICAgICAgICBpZiAoc2VnLmJvdHRvbSAtIHNlZy50b3AgPCAzMCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmFkZENsYXNzKCdmYy1zaG9ydCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcy92YWx1ZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhbiBldmVudCBzZWdtZW50IGVsZW1lbnQuXHJcbiAgICAvLyBDb250YWlucyBpbXBvcnRhbnQgcG9zaXRpb25pbmctcmVsYXRlZCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW55IGV2ZW50IGVsZW1lbnQsIGN1c3RvbWl6ZWQgb3Igbm90LlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUZnU2VnSG9yaXpvbnRhbENzcyA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICB2YXIgc2hvdWxkT3ZlcmxhcCA9IHRoaXMub3B0KCdzbG90RXZlbnRPdmVybGFwJyk7XHJcbiAgICAgICAgdmFyIGJhY2t3YXJkQ29vcmQgPSBzZWcuYmFja3dhcmRDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcclxuICAgICAgICB2YXIgZm9yd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZDsgLy8gdGhlIHJpZ2h0IHNpZGUgaWYgTFRSLiB0aGUgbGVmdCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnRpbWVHcmlkLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKTsgLy8gZ2V0IHRvcC9ib3R0b20gZmlyc3RcclxuICAgICAgICB2YXIgaXNSVEwgPSB0aGlzLnRpbWVHcmlkLmlzUlRMO1xyXG4gICAgICAgIHZhciBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXHJcbiAgICAgICAgdmFyIHJpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSByaWdodCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XHJcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXHJcbiAgICAgICAgICAgIGZvcndhcmRDb29yZCA9IE1hdGgubWluKDEsIGJhY2t3YXJkQ29vcmQgKyAoZm9yd2FyZENvb3JkIC0gYmFja3dhcmRDb29yZCkgKiAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUlRMKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZm9yd2FyZENvb3JkO1xyXG4gICAgICAgICAgICByaWdodCA9IGJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gYmFja3dhcmRDb29yZDtcclxuICAgICAgICAgICAgcmlnaHQgPSAxIC0gZm9yd2FyZENvb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wcy56SW5kZXggPSBzZWcubGV2ZWwgKyAxOyAvLyBjb252ZXJ0IGZyb20gMC1iYXNlIHRvIDEtYmFzZWRcclxuICAgICAgICBwcm9wcy5sZWZ0ID0gbGVmdCAqIDEwMCArICclJztcclxuICAgICAgICBwcm9wcy5yaWdodCA9IHJpZ2h0ICogMTAwICsgJyUnO1xyXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwICYmIHNlZy5mb3J3YXJkUHJlc3N1cmUpIHtcclxuICAgICAgICAgICAgLy8gYWRkIHBhZGRpbmcgdG8gdGhlIGVkZ2Ugc28gdGhhdCBmb3J3YXJkIHN0YWNrZWQgZXZlbnRzIGRvbid0IGNvdmVyIHRoZSByZXNpemVyJ3MgaWNvblxyXG4gICAgICAgICAgICBwcm9wc1tpc1JUTCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lR3JpZEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRFdmVudFJlbmRlcmVyO1xyXG4vLyBCdWlsZHMgYW4gYXJyYXkgb2Ygc2VnbWVudHMgXCJsZXZlbHNcIi4gVGhlIGZpcnN0IGxldmVsIHdpbGwgYmUgdGhlIGxlZnRtb3N0IHRpZXIgb2Ygc2VnbWVudHMgaWYgdGhlIGNhbGVuZGFyIGlzXHJcbi8vIGxlZnQtdG8tcmlnaHQsIG9yIHRoZSByaWdodG1vc3QgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuIEFzc3VtZXMgdGhlIHNlZ21lbnRzIGFyZSBhbHJlYWR5IG9yZGVyZWQgYnkgZGF0ZS5cclxuZnVuY3Rpb24gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpIHtcclxuICAgIHZhciBsZXZlbHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHNlZztcclxuICAgIHZhciBqO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIHRoZSBsZXZlbHMgYW5kIHN0b3Agb24gdGhlIGZpcnN0IGxldmVsIHdoZXJlIHRoZXJlIGFyZSBubyBjb2xsaXNpb25zXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1tqXSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgIChsZXZlbHNbal0gfHwgKGxldmVsc1tqXSA9IFtdKSkucHVzaChzZWcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxldmVscztcclxufVxyXG4vLyBGb3IgZXZlcnkgc2VnbWVudCwgZmlndXJlIG91dCB0aGUgb3RoZXIgc2VnbWVudHMgdGhhdCBhcmUgaW4gc3Vic2VxdWVudFxyXG4vLyBsZXZlbHMgdGhhdCBhbHNvIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZS4gQWNjdW11bGF0ZSBpbiBzZWcuZm9yd2FyZFNlZ3NcclxuZnVuY3Rpb24gY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxldmVsO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgc2VnO1xyXG4gICAgdmFyIGs7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV2ZWwgPSBsZXZlbHNbaV07XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IGxldmVsW2pdO1xyXG4gICAgICAgICAgICBzZWcuZm9yd2FyZFNlZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChrID0gaSArIDE7IGsgPCBsZXZlbHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1trXSwgc2VnLmZvcndhcmRTZWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBGaWd1cmUgb3V0IHdoaWNoIHBhdGggZm9yd2FyZCAodmlhIHNlZy5mb3J3YXJkU2VncykgcmVzdWx0cyBpbiB0aGUgbG9uZ2VzdCBwYXRoIHVudGlsXHJcbi8vIHRoZSBmdXJ0aGVzdCBlZGdlIGlzIHJlYWNoZWQuIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYXRoIHdpbGwgYmUgc2VnLmZvcndhcmRQcmVzc3VyZVxyXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhzZWcpIHtcclxuICAgIHZhciBmb3J3YXJkU2VncyA9IHNlZy5mb3J3YXJkU2VncztcclxuICAgIHZhciBmb3J3YXJkUHJlc3N1cmUgPSAwO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZm9yd2FyZFNlZztcclxuICAgIGlmIChzZWcuZm9yd2FyZFByZXNzdXJlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yd2FyZFNlZyA9IGZvcndhcmRTZWdzW2ldO1xyXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBjaGlsZCdzIG1heGltdW0gZm9yd2FyZCBwYXRoXHJcbiAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGZvcndhcmRTZWcpO1xyXG4gICAgICAgICAgICAvLyBlaXRoZXIgdXNlIHRoZSBleGlzdGluZyBtYXhpbXVtLCBvciB1c2UgdGhlIGNoaWxkJ3MgZm9yd2FyZCBwcmVzc3VyZVxyXG4gICAgICAgICAgICAvLyBwbHVzIG9uZSAoZm9yIHRoZSBmb3J3YXJkU2VnIGl0c2VsZilcclxuICAgICAgICAgICAgZm9yd2FyZFByZXNzdXJlID0gTWF0aC5tYXgoZm9yd2FyZFByZXNzdXJlLCAxICsgZm9yd2FyZFNlZy5mb3J3YXJkUHJlc3N1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWcuZm9yd2FyZFByZXNzdXJlID0gZm9yd2FyZFByZXNzdXJlO1xyXG4gICAgfVxyXG59XHJcbi8vIEZpbmQgYWxsIHRoZSBzZWdtZW50cyBpbiBgb3RoZXJTZWdzYCB0aGF0IHZlcnRpY2FsbHkgY29sbGlkZSB3aXRoIGBzZWdgLlxyXG4vLyBBcHBlbmQgaW50byBhbiBvcHRpb25hbGx5LXN1cHBsaWVkIGByZXN1bHRzYCBhcnJheSBhbmQgcmV0dXJuLlxyXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBvdGhlclNlZ3MsIHJlc3VsdHMpIHtcclxuICAgIGlmIChyZXN1bHRzID09PSB2b2lkIDApIHsgcmVzdWx0cyA9IFtdOyB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpc1Nsb3RTZWdDb2xsaXNpb24oc2VnLCBvdGhlclNlZ3NbaV0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChvdGhlclNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbi8vIERvIHRoZXNlIHNlZ21lbnRzIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZT9cclxuZnVuY3Rpb24gaXNTbG90U2VnQ29sbGlzaW9uKHNlZzEsIHNlZzIpIHtcclxuICAgIHJldHVybiBzZWcxLmJvdHRvbSA+IHNlZzIudG9wICYmIHNlZzEudG9wIDwgc2VnMi5ib3R0b207XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbnZhciBUaW1lR3JpZEhlbHBlclJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWRIZWxwZXJSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkSGVscGVyUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVGltZUdyaWRIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBzb3VyY2VTZWcpIHtcclxuICAgICAgICB2YXIgaGVscGVyTm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBzb3VyY2VFbDtcclxuICAgICAgICAvLyBUT0RPOiBub3QgZ29vZCB0byBjYWxsIGV2ZW50UmVuZGVyZXIgdGhpcyB3YXlcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMoc2VncywgdGhpcy5jb21wb25lbnQuaGVscGVyQ29udGFpbmVyRWxzKTtcclxuICAgICAgICAvLyBUcnkgdG8gbWFrZSB0aGUgc2VnbWVudCB0aGF0IGlzIGluIHRoZSBzYW1lIHJvdyBhcyBzb3VyY2VTZWcgbG9vayB0aGUgc2FtZVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLmNvbCA9PT0gc2VnLmNvbCkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlRWwgPSBzb3VyY2VTZWcuZWw7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzb3VyY2VFbC5jc3MoJ2xlZnQnKSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogc291cmNlRWwuY3NzKCdyaWdodCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLWxlZnQnKSxcclxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tcmlnaHQnKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGVscGVyTm9kZXMucHVzaChzZWcuZWxbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJChoZWxwZXJOb2Rlcyk7IC8vIG11c3QgcmV0dXJuIHRoZSBlbGVtZW50cyByZW5kZXJlZFxyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lR3JpZEhlbHBlclJlbmRlcmVyO1xyXG59KEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZEhlbHBlclJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xyXG52YXIgVGltZUdyaWRGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEZpbGxSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkRmlsbFJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBjb250YWluZXJFbHM7XHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgbG9va3VwXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5iZ0NvbnRhaW5lckVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVscyA9IHRpbWVHcmlkLmJ1c2luZXNzQ29udGFpbmVyRWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaGlnaGxpZ2h0Jykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5oaWdobGlnaHRDb250YWluZXJFbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVHcmlkLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgICAgICB0aW1lR3JpZC5hdHRhY2hTZWdzQnlDb2wodGltZUdyaWQuZ3JvdXBTZWdzQnlDb2woc2VncyksIGNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZy5lbFswXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcbn0oRmlsbFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZEZpbGxSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIEEgcmVjdGFuZ3VsYXIgcGFuZWwgdGhhdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgb3ZlciBvdGhlciBjb250ZW50XHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5PcHRpb25zOlxyXG4gIC0gY2xhc3NOYW1lIChzdHJpbmcpXHJcbiAgLSBjb250ZW50IChIVE1MIHN0cmluZyBvciBqUXVlcnkgZWxlbWVudCBzZXQpXHJcbiAgLSBwYXJlbnRFbFxyXG4gIC0gdG9wXHJcbiAgLSBsZWZ0XHJcbiAgLSByaWdodCAodGhlIHggY29vcmQgb2Ygd2hlcmUgdGhlIHJpZ2h0IGVkZ2Ugc2hvdWxkIGJlLiBub3QgYSBcIkNTU1wiIHJpZ2h0KVxyXG4gIC0gYXV0b0hpZGUgKGJvb2xlYW4pXHJcbiAgLSBzaG93IChjYWxsYmFjaylcclxuICAtIGhpZGUgKGNhbGxiYWNrKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvcG92ZXIob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWFyZ2luID0gMTA7IC8vIHRoZSBzcGFjZSByZXF1aXJlZCBiZXR3ZWVuIHRoZSBwb3BvdmVyIGFuZCB0aGUgZWRnZXMgb2YgdGhlIHNjcm9sbCBjb250YWluZXJcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgLy8gU2hvd3MgdGhlIHBvcG92ZXIgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gUmVuZGVycyBpdCBpZiBub3QgYWxyZWFkeVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbC5zaG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlkZXMgdGhlIHBvcG92ZXIsIHRocm91Z2ggQ1NTLCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIERPTVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5oaWRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpZGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBgdGhpcy5lbGAgYW5kIHJlbmRlcnMgY29udGVudCBpbnNpZGUgb2YgaXRcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIHRoaXMuZWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtcG9wb3ZlclwiLz4nKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpXHJcbiAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBpbml0aWFsbHkgdG8gdGhlIHRvcCBsZWZ0IHRvIGF2b2lkIGNyZWF0aW5nIHNjcm9sbGJhcnNcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmFwcGVuZChvcHRpb25zLmNvbnRlbnQpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhvcHRpb25zLnBhcmVudEVsKTtcclxuICAgICAgICAvLyB3aGVuIGEgY2xpY2sgaGFwcGVucyBvbiBhbnl0aGluZyBpbnNpZGUgd2l0aCBhICdmYy1jbG9zZScgY2xhc3NOYW1lLCBoaWRlIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgdGhpcy5lbC5vbignY2xpY2snLCAnLmZjLWNsb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0hpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicsIHRoaXMuZG9jdW1lbnRNb3VzZWRvd24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZG9jdW1lbnRNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcclxuICAgICAgICBpZiAodGhpcy5lbCAmJiAhJChldi50YXJnZXQpLmNsb3Nlc3QodGhpcy5lbCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBIaWRlcyBhbmQgdW5yZWdpc3RlcnMgYW55IGhhbmRsZXJzXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicpO1xyXG4gICAgfTtcclxuICAgIC8vIFBvc2l0aW9ucyB0aGUgcG9wb3ZlciBvcHRpbWFsbHksIHVzaW5nIHRoZSB0b3AvbGVmdC9yaWdodCBvcHRpb25zXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmVsLm91dGVyV2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5lbC5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIHZhciB3aW5kb3dFbCA9ICQod2luZG93KTtcclxuICAgICAgICB2YXIgdmlld3BvcnRFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQodGhpcy5lbCk7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0VG9wO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydExlZnQ7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0O1xyXG4gICAgICAgIHZhciB0b3A7IC8vIHRoZSBcInBvc2l0aW9uXCIgKG5vdCBcIm9mZnNldFwiKSB2YWx1ZXMgZm9yIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgdmFyIGxlZnQ7IC8vXHJcbiAgICAgICAgLy8gY29tcHV0ZSB0b3AgYW5kIGxlZnRcclxuICAgICAgICB0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMucmlnaHQgLSB3aWR0aDsgLy8gZGVyaXZlIHRoZSBsZWZ0IHZhbHVlIGZyb20gdGhlIHJpZ2h0IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0RWwuaXMod2luZG93KSB8fCB2aWV3cG9ydEVsLmlzKGRvY3VtZW50KSkge1xyXG4gICAgICAgICAgICB2aWV3cG9ydEVsID0gd2luZG93RWw7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wID0gMDsgLy8gdGhlIHdpbmRvdyBpcyBhbHdheXMgYXQgdGhlIHRvcCBsZWZ0XHJcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IDA7IC8vIChhbmQgLm9mZnNldCgpIHdvbid0IHdvcmsgaWYgY2FsbGVkIGhlcmUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2aWV3cG9ydE9mZnNldCA9IHZpZXdwb3J0RWwub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wID0gdmlld3BvcnRPZmZzZXQudG9wO1xyXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSB2aWV3cG9ydE9mZnNldC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgd2luZG93IGlzIHNjcm9sbGVkLCBpdCBjYXVzZXMgdGhlIHZpc2libGUgYXJlYSB0byBiZSBmdXJ0aGVyIGRvd25cclxuICAgICAgICB2aWV3cG9ydFRvcCArPSB3aW5kb3dFbC5zY3JvbGxUb3AoKTtcclxuICAgICAgICB2aWV3cG9ydExlZnQgKz0gd2luZG93RWwuc2Nyb2xsTGVmdCgpO1xyXG4gICAgICAgIC8vIGNvbnN0cmFpbiB0byB0aGUgdmlldyBwb3J0LiBpZiBjb25zdHJhaW5lZCBieSB0d28gZWRnZXMsIGdpdmUgcHJlY2VkZW5jZSB0byB0b3AvbGVmdFxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXdwb3J0Q29uc3RyYWluICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIHZpZXdwb3J0VG9wICsgdmlld3BvcnRFbC5vdXRlckhlaWdodCgpIC0gaGVpZ2h0IC0gdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHZpZXdwb3J0VG9wICsgdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgdmlld3BvcnRMZWZ0ICsgdmlld3BvcnRFbC5vdXRlcldpZHRoKCkgLSB3aWR0aCAtIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHZpZXdwb3J0TGVmdCArIHRoaXMubWFyZ2luKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbC5jc3Moe1xyXG4gICAgICAgICAgICB0b3A6IHRvcCAtIG9yaWdpbi50b3AsXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSBvcmlnaW4ubGVmdFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXHJcbiAgICAvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cclxuICAgIC8vIFRPRE86IGJldHRlciBjb2RlIHJldXNlIGZvciB0aGlzLiBSZXBlYXQgY29kZVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBQb3BvdmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQb3BvdmVyO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKFBvcG92ZXIpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxuLyogRXZlbnQtcmVuZGVyaW5nIG1ldGhvZHMgZm9yIHRoZSBEYXlHcmlkIGNsYXNzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgRGF5R3JpZEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkRXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRFdmVudFJlbmRlcmVyKGRheUdyaWQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRheUdyaWQsIGZpbGxSZW5kZXJlcikgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kYXlHcmlkID0gZGF5R3JpZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmdSYW5nZXMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICAvLyBkb24ndCByZW5kZXIgdGltZWQgYmFja2dyb3VuZCBldmVudHNcclxuICAgICAgICBldmVudFJhbmdlcyA9ICQuZ3JlcChldmVudFJhbmdlcywgZnVuY3Rpb24gKGV2ZW50UmFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UmFuZ2UuZXZlbnREZWYuaXNBbGxEYXkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzLmNhbGwodGhpcywgZXZlbnRSYW5nZXMpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgdGhlIGdpdmVuIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgPSB0aGlzLnJlbmRlclNlZ1Jvd3Moc2Vncyk7XHJcbiAgICAgICAgLy8gYXBwZW5kIHRvIGVhY2ggcm93J3MgY29udGVudCBza2VsZXRvblxyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5yb3dFbHMuZWFjaChmdW5jdGlvbiAoaSwgcm93Tm9kZSkge1xyXG4gICAgICAgICAgICAkKHJvd05vZGUpLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uID4gdGFibGUnKS5hcHBlbmQocm93U3RydWN0c1tpXS50Ym9keUVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzXHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgfHwgW107XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdDtcclxuICAgICAgICB3aGlsZSAoKHJvd1N0cnVjdCA9IHJvd1N0cnVjdHMucG9wKCkpKSB7XHJcbiAgICAgICAgICAgIHJvd1N0cnVjdC50Ym9keUVsLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJvd1N0cnVjdHMgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIFVzZXMgdGhlIGdpdmVuIGV2ZW50cyBhcnJheSB0byBnZW5lcmF0ZSA8dGJvZHk+IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIGVhY2ggcm93J3MgY29udGVudCBza2VsZXRvbi5cclxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2Ygcm93U3RydWN0IG9iamVjdHMgKHNlZSB0aGUgYm90dG9tIG9mIGByZW5kZXJTZWdSb3dgKS5cclxuICAgIC8vIFBSRUNPTkRJVElPTjogZWFjaCBzZWdtZW50IHNob3VkIGFscmVhZHkgaGF2ZSBhIHJlbmRlcmVkIGFuZCBhc3NpZ25lZCBgLmVsYFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gW107XHJcbiAgICAgICAgdmFyIHNlZ1Jvd3M7XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICBzZWdSb3dzID0gdGhpcy5ncm91cFNlZ1Jvd3Moc2Vncyk7IC8vIGdyb3VwIGludG8gbmVzdGVkIGFycmF5c1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgZWFjaCByb3cgb2Ygc2VnbWVudCBncm91cGluZ3NcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHNlZ1Jvd3MubGVuZ3RoOyByb3crKykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3RzLnB1c2godGhpcy5yZW5kZXJTZWdSb3cocm93LCBzZWdSb3dzW3Jvd10pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvd1N0cnVjdHM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSByb3cgIyBhbmQgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYWxsIGluIHRoZSBzYW1lIHJvdywgcmVuZGVyIGEgPHRib2R5PiBlbGVtZW50LCBhIHNrZWxldG9uIHRoYXQgY29udGFpbnNcclxuICAgIC8vIHRoZSBzZWdtZW50cy4gUmV0dXJucyBvYmplY3Qgd2l0aCBhIGJ1bmNoIG9mIGludGVybmFsIGRhdGEgYWJvdXQgaG93IHRoZSByZW5kZXIgd2FzIGNhbGN1bGF0ZWQuXHJcbiAgICAvLyBOT1RFOiBtb2RpZmllcyByb3dTZWdzXHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VnUm93ID0gZnVuY3Rpb24gKHJvdywgcm93U2Vncykge1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmRheUdyaWQuY29sQ250O1xyXG4gICAgICAgIHZhciBzZWdMZXZlbHMgPSB0aGlzLmJ1aWxkU2VnTGV2ZWxzKHJvd1NlZ3MpOyAvLyBncm91cCBpbnRvIHN1Yi1hcnJheXMgb2YgbGV2ZWxzXHJcbiAgICAgICAgdmFyIGxldmVsQ250ID0gTWF0aC5tYXgoMSwgc2VnTGV2ZWxzLmxlbmd0aCk7IC8vIGVuc3VyZSBhdCBsZWFzdCBvbmUgbGV2ZWxcclxuICAgICAgICB2YXIgdGJvZHkgPSAkKCc8dGJvZHkvPicpO1xyXG4gICAgICAgIHZhciBzZWdNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciB3aGljaCBzZWdtZW50cyBhcmUgcmVuZGVyZWQgaW50byB3aGljaCBsZXZlbCtjb2wgY2VsbHNcclxuICAgICAgICB2YXIgY2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIGFsbCA8dGQ+IGVsZW1lbnRzIG9mIHRoZSBsZXZlbCtjb2wgbWF0cml4XHJcbiAgICAgICAgdmFyIGxvbmVDZWxsTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3IgPHRkPiBlbGVtZW50cyB0aGF0IG9ubHkgdGFrZSB1cCBhIHNpbmdsZSBjb2x1bW5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGV2ZWxTZWdzO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIHRyO1xyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHRkO1xyXG4gICAgICAgIC8vIHBvcHVsYXRlcyBlbXB0eSBjZWxscyBmcm9tIHRoZSBjdXJyZW50IGNvbHVtbiAoYGNvbGApIHRvIGBlbmRDb2xgXHJcbiAgICAgICAgZnVuY3Rpb24gZW1wdHlDZWxsc1VudGlsKGVuZENvbCkge1xyXG4gICAgICAgICAgICB3aGlsZSAoY29sIDwgZW5kQ29sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ3JhYiBhIGNlbGwgZnJvbSB0aGUgbGV2ZWwgYWJvdmUgYW5kIGV4dGVuZCBpdHMgcm93c3Bhbi4gb3RoZXJ3aXNlLCBjcmVhdGUgYSBmcmVzaCBjZWxsXHJcbiAgICAgICAgICAgICAgICB0ZCA9IChsb25lQ2VsbE1hdHJpeFtpIC0gMV0gfHwgW10pW2NvbF07XHJcbiAgICAgICAgICAgICAgICBpZiAodGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZC5hdHRyKCdyb3dzcGFuJywgcGFyc2VJbnQodGQuYXR0cigncm93c3BhbicpIHx8IDEsIDEwKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSAkKCc8dGQvPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZCh0ZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldmVsU2VncyA9IHNlZ0xldmVsc1tpXTtcclxuICAgICAgICAgICAgY29sID0gMDtcclxuICAgICAgICAgICAgdHIgPSAkKCc8dHIvPicpO1xyXG4gICAgICAgICAgICBzZWdNYXRyaXgucHVzaChbXSk7XHJcbiAgICAgICAgICAgIGNlbGxNYXRyaXgucHVzaChbXSk7XHJcbiAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICAvLyBsZXZlbENudCBtaWdodCBiZSAxIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZSBubyBhY3R1YWwgbGV2ZWxzLiBwcm90ZWN0IGFnYWluc3QgdGhpcy5cclxuICAgICAgICAgICAgLy8gdGhpcyBzaW5nbGUgZW1wdHkgcm93IGlzIHVzZWZ1bCBmb3Igc3R5bGluZy5cclxuICAgICAgICAgICAgaWYgKGxldmVsU2Vncykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVsU2Vncy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZyA9IGxldmVsU2Vnc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoc2VnLmxlZnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5lciB0aGF0IG9jY3VwaWVzIG9yIG1vcmUgY29sdW1ucy4gYXBwZW5kIHRoZSBldmVudCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHRkID0gJCgnPHRkIGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCIvPicpLmFwcGVuZChzZWcuZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWcubGVmdENvbCAhPT0gc2VnLnJpZ2h0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkLmF0dHIoJ2NvbHNwYW4nLCBzZWcucmlnaHRDb2wgLSBzZWcubGVmdENvbCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29sIDw9IHNlZy5yaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWF0cml4W2ldW2NvbF0gPSBzZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmQodGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVtcHR5Q2VsbHNVbnRpbChjb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSByb3dcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmJvb2tlbmRDZWxscyh0cik7XHJcbiAgICAgICAgICAgIHRib2R5LmFwcGVuZCh0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICB0Ym9keUVsOiB0Ym9keSxcclxuICAgICAgICAgICAgY2VsbE1hdHJpeDogY2VsbE1hdHJpeCxcclxuICAgICAgICAgICAgc2VnTWF0cml4OiBzZWdNYXRyaXgsXHJcbiAgICAgICAgICAgIHNlZ0xldmVsczogc2VnTGV2ZWxzLFxyXG4gICAgICAgICAgICBzZWdzOiByb3dTZWdzXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBTdGFja3MgYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCB3aGljaCBhcmUgYWxsIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LCBpbnRvIHN1YmFycmF5cyBvZiB2ZXJ0aWNhbCBsZXZlbHMuXHJcbiAgICAvLyBOT1RFOiBtb2RpZmllcyBzZWdzXHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRTZWdMZXZlbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBsZXZlbHMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIC8vIEdpdmUgcHJlZmVyZW5jZSB0byBlbGVtZW50cyB3aXRoIGNlcnRhaW4gY3JpdGVyaWEsIHNvIHRoZXkgaGF2ZVxyXG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIGJlIGNsb3NlciB0byB0aGUgdG9wLlxyXG4gICAgICAgIHRoaXMuc29ydEV2ZW50U2VncyhzZWdzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZSB0b3Btb3N0LCB1bnRpbCB0aGUgc2VnbWVudCBkb2Vzbid0IGNvbGxpZGUgd2l0aCBvdGhlciBzZWdtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGF5U2VnQ29sbGlzaW9uKHNlZywgbGV2ZWxzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGBqYCBub3cgaG9sZHMgdGhlIGRlc2lyZWQgc3Vicm93IGluZGV4XHJcbiAgICAgICAgICAgIHNlZy5sZXZlbCA9IGo7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbGV2ZWwgYXJyYXkgaWYgbmVlZGVkIGFuZCBhcHBlbmQgc2VnbWVudFxyXG4gICAgICAgICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3JkZXIgc2VnbWVudHMgbGVmdC10by1yaWdodC4gdmVyeSBpbXBvcnRhbnQgaWYgY2FsZW5kYXIgaXMgUlRMXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBsZXZlbHNbal0uc29ydChjb21wYXJlRGF5U2VnQ29scyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZXZlbHM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyByb3dcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5ncm91cFNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBzZWdSb3dzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF5R3JpZC5yb3dDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdSb3dzLnB1c2goW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdSb3dzW3NlZ3NbaV0ucm93XS5wdXNoKHNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VnUm93cztcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgdGltZUZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdleHRyYVNtYWxsVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNnBcIiBvciBcIjY6MzBwXCJcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgYGRpc3BsYXlFdmVudEVuZGAgdmFsdWUgaWYgb25lIGlzIG5vdCBleHBsaWNsdHkgZGVmaW5lZFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5R3JpZC5jb2xDbnQgPT09IDE7IC8vIHdlJ2xsIGxpa2VseSBoYXZlIHNwYWNlIGlmIHRoZXJlJ3Mgb25seSBvbmUgZGF5XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IGVsZW1lbnQgZm9yIGFuIGluZGl2aWR1YWwgc2VnbWVudFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGlzQWxsRGF5ID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXk7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RGVmRHJhZ2dhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5pc1N0YXJ0ICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgaXNBbGxEYXkgJiZcclxuICAgICAgICAgICAgc2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XHJcbiAgICAgICAgdmFyIHNraW5Dc3MgPSB1dGlsXzEuY3NzVG9TdHIodGhpcy5nZXRTa2luQ3NzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIHRpbWVIdG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHRpbWVUZXh0O1xyXG4gICAgICAgIHZhciB0aXRsZUh0bWw7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktZ3JpZC1ldmVudCcsICdmYy1oLWV2ZW50Jyk7XHJcbiAgICAgICAgLy8gT25seSBkaXNwbGF5IGEgdGltZWQgZXZlbnRzIHRpbWUgaWYgaXQgaXMgdGhlIHN0YXJ0aW5nIHNlZ21lbnRcclxuICAgICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICBpZiAodGltZVRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gJzxzcGFuIGNsYXNzPVwiZmMtdGltZVwiPicgKyB1dGlsXzEuaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGl0bGVIdG1sID1cclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcclxuICAgICAgICAgICAgICAgICh1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSB8fCAnJykgfHwgJyZuYnNwOycpICsgLy8gd2UgYWx3YXlzIHdhbnQgb25lIGxpbmUgb2YgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPic7XHJcbiAgICAgICAgcmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoZXZlbnREZWYudXJsID9cclxuICAgICAgICAgICAgICAgICcgaHJlZj1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi51cmwpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoc2tpbkNzcyA/XHJcbiAgICAgICAgICAgICAgICAnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5kYXlHcmlkLmlzUlRMID9cclxuICAgICAgICAgICAgICAgIHRpdGxlSHRtbCArICcgJyArIHRpbWVIdG1sIDogLy8gcHV0IGEgbmF0dXJhbCBzcGFjZSBpbiBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCArICcgJyArIHRpdGxlSHRtbCAvL1xyXG4gICAgICAgICAgICApICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbUVuZCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtZW5kLXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvYT4nO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlHcmlkRXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkRXZlbnRSZW5kZXJlcjtcclxuLy8gQ29tcHV0ZXMgd2hldGhlciB0d28gc2VnbWVudHMnIGNvbHVtbnMgY29sbGlkZS4gVGhleSBhcmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3cuXHJcbmZ1bmN0aW9uIGlzRGF5U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBvdGhlclNlZztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBvdGhlclNlZyA9IG90aGVyU2Vnc1tpXTtcclxuICAgICAgICBpZiAob3RoZXJTZWcubGVmdENvbCA8PSBzZWcucmlnaHRDb2wgJiZcclxuICAgICAgICAgICAgb3RoZXJTZWcucmlnaHRDb2wgPj0gc2VnLmxlZnRDb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB0aGUgbGVmdG1vc3QgZXZlbnRcclxuZnVuY3Rpb24gY29tcGFyZURheVNlZ0NvbHMoYSwgYikge1xyXG4gICAgcmV0dXJuIGEubGVmdENvbCAtIGIubGVmdENvbDtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxudmFyIERheUdyaWRIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWRIZWxwZXJSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRIZWxwZXJSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgYXNzb2NpYXRlZCBpbnRlcm5hbCBzZWdtZW50IG9iamVjdC4gSXQgY2FuIGJlIG51bGwuXHJcbiAgICBEYXlHcmlkSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHM7XHJcbiAgICAgICAgLy8gVE9ETzogbm90IGdvb2QgdG8gY2FsbCBldmVudFJlbmRlcmVyIHRoaXMgd2F5XHJcbiAgICAgICAgcm93U3RydWN0cyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGluamVjdCBlYWNoIG5ldyBldmVudCBza2VsZXRvbiBpbnRvIGVhY2ggYXNzb2NpYXRlZCByb3dcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yb3dFbHMuZWFjaChmdW5jdGlvbiAocm93LCByb3dOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dFbCA9ICQocm93Tm9kZSk7IC8vIHRoZSAuZmMtcm93XHJcbiAgICAgICAgICAgIHZhciBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlbHBlci1za2VsZXRvblwiPjx0YWJsZS8+PC9kaXY+Jyk7IC8vIHdpbGwgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkXHJcbiAgICAgICAgICAgIHZhciBza2VsZXRvblRvcEVsO1xyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3A7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yaWdpbmFsIHNlZ21lbnQsIG1hdGNoIHRoZSB0b3AgcG9zaXRpb24uIE90aGVyd2lzZSwgcHV0IGl0IGF0IHRoZSByb3cncyB0b3AgbGV2ZWxcclxuICAgICAgICAgICAgaWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcucm93ID09PSByb3cpIHtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wID0gc291cmNlU2VnLmVsLnBvc2l0aW9uKCkudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3BFbCA9IHJvd0VsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNrZWxldG9uVG9wRWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25Ub3BFbCA9IHJvd0VsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uIHRhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvblRvcCA9IHNrZWxldG9uVG9wRWwucG9zaXRpb24oKS50b3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2tlbGV0b25FbC5jc3MoJ3RvcCcsIHNrZWxldG9uVG9wKVxyXG4gICAgICAgICAgICAgICAgLmZpbmQoJ3RhYmxlJylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQocm93U3RydWN0c1tyb3ddLnRib2R5RWwpO1xyXG4gICAgICAgICAgICByb3dFbC5hcHBlbmQoc2tlbGV0b25FbCk7XHJcbiAgICAgICAgICAgIGhlbHBlck5vZGVzLnB1c2goc2tlbGV0b25FbFswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICQoaGVscGVyTm9kZXMpOyAvLyBtdXN0IHJldHVybiB0aGUgZWxlbWVudHMgcmVuZGVyZWRcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEhlbHBlclJlbmRlcmVyO1xyXG59KEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkSGVscGVyUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxudmFyIERheUdyaWRGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkRmlsbFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF5R3JpZEZpbGxSZW5kZXJlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5maWxsU2VnVGFnID0gJ3RkJzsgLy8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGFnIG5hbWVcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2tlbGV0b25FbCA9IHRoaXMucmVuZGVyRmlsbFJvdyh0eXBlLCBzZWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yb3dFbHMuZXEoc2VnLnJvdykuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIHJvdyBvZiBhIGZpbGwuIFJlcXVpcmVzIHRoZSBzZWcncyBlbCB0byBiZSByZW5kZXJlZC5cclxuICAgIERheUdyaWRGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZpbGxSb3cgPSBmdW5jdGlvbiAodHlwZSwgc2VnKSB7XHJcbiAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuY29tcG9uZW50LmNvbENudDtcclxuICAgICAgICB2YXIgc3RhcnRDb2wgPSBzZWcubGVmdENvbDtcclxuICAgICAgICB2YXIgZW5kQ29sID0gc2VnLnJpZ2h0Q29sICsgMTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lO1xyXG4gICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgIHZhciB0ckVsO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gJ2JnZXZlbnQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBjbGFzc05hbWUgKyAnLXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGU+PHRyLz48L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdHJFbCA9IHNrZWxldG9uRWwuZmluZCgndHInKTtcclxuICAgICAgICBpZiAoc3RhcnRDb2wgPiAwKSB7XHJcbiAgICAgICAgICAgIHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyBzdGFydENvbCArICdcIi8+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyRWwuYXBwZW5kKHNlZy5lbC5hdHRyKCdjb2xzcGFuJywgZW5kQ29sIC0gc3RhcnRDb2wpKTtcclxuICAgICAgICBpZiAoZW5kQ29sIDwgY29sQ250KSB7XHJcbiAgICAgICAgICAgIHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyAoY29sQ250IC0gZW5kQ29sKSArICdcIi8+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmJvb2tlbmRDZWxscyh0ckVsKTtcclxuICAgICAgICByZXR1cm4gc2tlbGV0b25FbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEZpbGxSZW5kZXJlcjtcclxufShGaWxsUmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheUdyaWRGaWxsUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyOCk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xyXG4gICAgICAgIHZhciByZW5kZXJVbnpvbmVkUmFuZ2UgPSBfc3VwZXIucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UuY2FsbCh0aGlzLCBjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLmVuZE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgcm93Q250O1xyXG4gICAgICAgIC8vIGVuc3VyZSA2IHdlZWtzXHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdmaXhlZFdlZWtDb3VudCcpKSB7XHJcbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXHJcbiAgICAgICAgICAgIGVuZC5kaWZmKHN0YXJ0LCAnd2Vla3MnLCB0cnVlKSAvLyBkb250Um91bmQ9dHJ1ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBlbmQuYWRkKDYgLSByb3dDbnQsICd3ZWVrcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG59KEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG52YXIgTGlzdEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0RXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RFdmVudFJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIGlmICghc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyRW1wdHlNZXNzYWdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZW5kZXJTZWdMaXN0KHNlZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBnZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGV2ZW50IHJvd1xyXG4gICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IGNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludCA9IHNlZy5mb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRGb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudEZvb3RwcmludCA9IGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgdXJsID0gZXZlbnREZWYudXJsO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gWydmYy1saXN0LWl0ZW0nXS5jb25jYXQodGhpcy5nZXRDbGFzc2VzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIGJnQ29sb3IgPSB0aGlzLmdldEJnQ29sb3IoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciB0aW1lSHRtbDtcclxuICAgICAgICBpZiAoY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHRpbWVIdG1sID0gdmlldy5nZXRBbGxEYXlIdG1sKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaXNNdWx0aURheVJhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5fZ2V0VGltZVRleHQoY2FsZW5kYXIubXNUb01vbWVudChzZWcuc3RhcnRNcyksIGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLmVuZE1zKSwgY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgIHRpbWVIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5nZXRUaW1lVGV4dChldmVudEZvb3RwcmludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtaGFzLXVybCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGlzcGxheUV2ZW50VGltZSA/XHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLXRpbWUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHRpbWVIdG1sIHx8ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLW1hcmtlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtZXZlbnQtZG90XCInICtcclxuICAgICAgICAgICAgKGJnQ29sb3IgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGJnQ29sb3IgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aXRsZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxhJyArICh1cmwgPyAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUodXJsKSArICdcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSB8fCAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIFwiNDowMGFtXCJcclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnbWVkaXVtVGltZUZvcm1hdCcpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0RXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0RXZlbnRSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxudmFyIExpc3RFdmVudFBvaW50aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdEV2ZW50UG9pbnRpbmcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0RXZlbnRQb2ludGluZygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBmb3IgZXZlbnRzIHdpdGggYSB1cmwsIHRoZSB3aG9sZSA8dHI+IHNob3VsZCBiZSBjbGlja2FibGUsXHJcbiAgICAvLyBidXQgaXQncyBpbXBvc3NpYmxlIHRvIHdyYXAgd2l0aCBhbiA8YT4gdGFnLiBzaW11bGF0ZSB0aGlzLlxyXG4gICAgTGlzdEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBzZWcsIGV2KTsgLy8gbWlnaHQgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb25cclxuICAgICAgICAvLyBub3QgY2xpY2tpbmcgb24gb3Igd2l0aGluIGFuIDxhPiB3aXRoIGFuIGhyZWZcclxuICAgICAgICBpZiAoISQoZXYudGFyZ2V0KS5jbG9zZXN0KCdhW2hyZWZdJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHNlZy5mb290cHJpbnQuZXZlbnREZWYudXJsO1xyXG4gICAgICAgICAgICBpZiAodXJsICYmICFldi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7IC8vIHNpbXVsYXRlIGxpbmsgY2xpY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdEV2ZW50UG9pbnRpbmc7XHJcbn0oRXZlbnRQb2ludGluZ18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdEV2ZW50UG9pbnRpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTUpO1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTYpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhBcnJheUV2ZW50U291cmNlXzEuZGVmYXVsdCk7XHJcbkV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5yZWdpc3RlckNsYXNzKEZ1bmNFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhKc29uRmVlZEV2ZW50U291cmNlXzEuZGVmYXVsdCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxudmFyIFN0YW5kYXJkVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEzKTtcclxudmFyIEpxdWVyeVVpVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE0KTtcclxudmFyIEJvb3RzdHJhcDNUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTgpO1xyXG52YXIgQm9vdHN0cmFwNFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1OSk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbSgnc3RhbmRhcmQnLCBTdGFuZGFyZFRoZW1lXzEuZGVmYXVsdCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbSgnanF1ZXJ5LXVpJywgSnF1ZXJ5VWlUaGVtZV8xLmRlZmF1bHQpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmaW5lVGhlbWVTeXN0ZW0oJ2Jvb3RzdHJhcDMnLCBCb290c3RyYXAzVGhlbWVfMS5kZWZhdWx0KTtcclxuVGhlbWVSZWdpc3RyeV8xLmRlZmluZVRoZW1lU3lzdGVtKCdib290c3RyYXA0JywgQm9vdHN0cmFwNFRoZW1lXzEuZGVmYXVsdCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIEJvb3RzdHJhcDNUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJvb3RzdHJhcDNUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJvb3RzdHJhcDNUaGVtZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm9vdHN0cmFwM1RoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb290c3RyYXAzVGhlbWU7XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgIHdpZGdldDogJ2ZjLWJvb3RzdHJhcDMnLFxyXG4gICAgdGFibGVHcmlkOiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgdGFibGVMaXN0OiAndGFibGUnLFxyXG4gICAgdGFibGVMaXN0SGVhZGluZzogJ2FjdGl2ZScsXHJcbiAgICBidXR0b25Hcm91cDogJ2J0bi1ncm91cCcsXHJcbiAgICBidXR0b246ICdidG4gYnRuLWRlZmF1bHQnLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdhY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICAgIHRvZGF5OiAnYWxlcnQgYWxlcnQtaW5mbycsXHJcbiAgICBwb3BvdmVyOiAncGFuZWwgcGFuZWwtZGVmYXVsdCcsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAncGFuZWwtaGVhZGluZycsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ3BhbmVsLWJvZHknLFxyXG4gICAgLy8gZGF5IGdyaWRcclxuICAgIC8vIGZvciBsZWZ0L3JpZ2h0IGJvcmRlciBjb2xvciB3aGVuIGJvcmRlciBpcyBpbnNldCBmcm9tIGVkZ2VzIChhbGwtZGF5IGluIGFnZW5kYSB2aWV3KVxyXG4gICAgLy8gYXZvaWQgYHBhbmVsYCBjbGFzcyBiL2MgZG9uJ3Qgd2FudCBtYXJnaW5zL3JhZGl1cy4gb25seSBib3JkZXIgY29sb3IuXHJcbiAgICBoZWFkZXJSb3c6ICdwYW5lbC1kZWZhdWx0JyxcclxuICAgIGRheVJvdzogJ3BhbmVsLWRlZmF1bHQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnXHJcbn07XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdnbHlwaGljb24nO1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICdnbHlwaGljb24tcmVtb3ZlJyxcclxuICAgIHByZXY6ICdnbHlwaGljb24tY2hldnJvbi1sZWZ0JyxcclxuICAgIG5leHQ6ICdnbHlwaGljb24tY2hldnJvbi1yaWdodCcsXHJcbiAgICBwcmV2WWVhcjogJ2dseXBoaWNvbi1iYWNrd2FyZCcsXHJcbiAgICBuZXh0WWVhcjogJ2dseXBoaWNvbi1mb3J3YXJkJ1xyXG59O1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdib290c3RyYXBHbHlwaGljb25zJztcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnYm9vdHN0cmFwR2x5cGhpY29uJztcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZ2x5cGhpY29uLSc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIEJvb3RzdHJhcDRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJvb3RzdHJhcDRUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJvb3RzdHJhcDRUaGVtZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm9vdHN0cmFwNFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb290c3RyYXA0VGhlbWU7XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgIHdpZGdldDogJ2ZjLWJvb3RzdHJhcDQnLFxyXG4gICAgdGFibGVHcmlkOiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgdGFibGVMaXN0OiAndGFibGUnLFxyXG4gICAgdGFibGVMaXN0SGVhZGluZzogJ3RhYmxlLWFjdGl2ZScsXHJcbiAgICBidXR0b25Hcm91cDogJ2J0bi1ncm91cCcsXHJcbiAgICBidXR0b246ICdidG4gYnRuLXByaW1hcnknLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdhY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICAgIHRvZGF5OiAnYWxlcnQgYWxlcnQtaW5mbycsXHJcbiAgICBwb3BvdmVyOiAnY2FyZCBjYXJkLXByaW1hcnknLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ2NhcmQtaGVhZGVyJyxcclxuICAgIHBvcG92ZXJDb250ZW50OiAnY2FyZC1ib2R5JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICAvLyBmb3IgbGVmdC9yaWdodCBib3JkZXIgY29sb3Igd2hlbiBib3JkZXIgaXMgaW5zZXQgZnJvbSBlZGdlcyAoYWxsLWRheSBpbiBhZ2VuZGEgdmlldylcclxuICAgIC8vIGF2b2lkIGB0YWJsZWAgY2xhc3MgYi9jIGRvbid0IHdhbnQgbWFyZ2lucy9wYWRkaW5nL3N0cnVjdHVyZS4gb25seSBib3JkZXIgY29sb3IuXHJcbiAgICBoZWFkZXJSb3c6ICd0YWJsZS1ib3JkZXJlZCcsXHJcbiAgICBkYXlSb3c6ICd0YWJsZS1ib3JkZXJlZCcsXHJcbiAgICAvLyBsaXN0IHZpZXdcclxuICAgIGxpc3RWaWV3OiAnY2FyZCBjYXJkLXByaW1hcnknXHJcbn07XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYSc7XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ2ZhLXRpbWVzJyxcclxuICAgIHByZXY6ICdmYS1jaGV2cm9uLWxlZnQnLFxyXG4gICAgbmV4dDogJ2ZhLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgcHJldlllYXI6ICdmYS1hbmdsZS1kb3VibGUtbGVmdCcsXHJcbiAgICBuZXh0WWVhcjogJ2ZhLWFuZ2xlLWRvdWJsZS1yaWdodCdcclxufTtcclxuQm9vdHN0cmFwNFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYm9vdHN0cmFwRm9udEF3ZXNvbWUnO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdib290c3RyYXBGb250QXdlc29tZSc7XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZhLSc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgQmFzaWNWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcclxudmFyIE1vbnRoVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjkpO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdiYXNpYycsIHtcclxuICAgICdjbGFzcyc6IEJhc2ljVmlld18xLmRlZmF1bHRcclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2Jhc2ljRGF5Jywge1xyXG4gICAgdHlwZTogJ2Jhc2ljJyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfVxyXG59KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnYmFzaWNXZWVrJywge1xyXG4gICAgdHlwZTogJ2Jhc2ljJyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ21vbnRoJywge1xyXG4gICAgJ2NsYXNzJzogTW9udGhWaWV3XzEuZGVmYXVsdCxcclxuICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZVxyXG4gICAgfVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFZpZXdSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbnZhciBBZ2VuZGFWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNik7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2FnZW5kYScsIHtcclxuICAgICdjbGFzcyc6IEFnZW5kYVZpZXdfMS5kZWZhdWx0LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxyXG4gICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcclxuICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxyXG4gICAgfVxyXG59KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnYWdlbmRhRGF5Jywge1xyXG4gICAgdHlwZTogJ2FnZW5kYScsXHJcbiAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2FnZW5kYVdlZWsnLCB7XHJcbiAgICB0eXBlOiAnYWdlbmRhJyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMwKTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnbGlzdCcsIHtcclxuICAgICdjbGFzcyc6IExpc3RWaWV3XzEuZGVmYXVsdCxcclxuICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JyxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgYnV0dG9uVGV4dDogJ2xpc3QnLFxyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdMTCcsXHJcbiAgICAgICAgbm9FdmVudHNNZXNzYWdlOiAnTm8gZXZlbnRzIHRvIGRpc3BsYXknXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0RGF5Jywge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBsaXN0RGF5Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgYWxsIHdlIG5lZWQuIGZ1bGwgZGF0ZSBpcyBwcm9iYWJseSBpbiBoZWFkZXJcclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3RXZWVrJywge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ2RkZGQnLFxyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdMTCdcclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3RNb250aCcsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3RZZWFyJywge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgeWVhcjogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXHJcbiAgICB9XHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///132\n");

/***/ }),
/* 133 */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///133\n");

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./af\": 9,\n\t\"./af.js\": 9,\n\t\"./ar\": 10,\n\t\"./ar-dz\": 11,\n\t\"./ar-dz.js\": 11,\n\t\"./ar-kw\": 12,\n\t\"./ar-kw.js\": 12,\n\t\"./ar-ly\": 13,\n\t\"./ar-ly.js\": 13,\n\t\"./ar-ma\": 14,\n\t\"./ar-ma.js\": 14,\n\t\"./ar-sa\": 15,\n\t\"./ar-sa.js\": 15,\n\t\"./ar-tn\": 16,\n\t\"./ar-tn.js\": 16,\n\t\"./ar.js\": 10,\n\t\"./az\": 17,\n\t\"./az.js\": 17,\n\t\"./be\": 18,\n\t\"./be.js\": 18,\n\t\"./bg\": 19,\n\t\"./bg.js\": 19,\n\t\"./bm\": 20,\n\t\"./bm.js\": 20,\n\t\"./bn\": 21,\n\t\"./bn.js\": 21,\n\t\"./bo\": 22,\n\t\"./bo.js\": 22,\n\t\"./br\": 23,\n\t\"./br.js\": 23,\n\t\"./bs\": 24,\n\t\"./bs.js\": 24,\n\t\"./ca\": 25,\n\t\"./ca.js\": 25,\n\t\"./cs\": 26,\n\t\"./cs.js\": 26,\n\t\"./cv\": 27,\n\t\"./cv.js\": 27,\n\t\"./cy\": 28,\n\t\"./cy.js\": 28,\n\t\"./da\": 29,\n\t\"./da.js\": 29,\n\t\"./de\": 30,\n\t\"./de-at\": 31,\n\t\"./de-at.js\": 31,\n\t\"./de-ch\": 32,\n\t\"./de-ch.js\": 32,\n\t\"./de.js\": 30,\n\t\"./dv\": 33,\n\t\"./dv.js\": 33,\n\t\"./el\": 34,\n\t\"./el.js\": 34,\n\t\"./en-au\": 35,\n\t\"./en-au.js\": 35,\n\t\"./en-ca\": 36,\n\t\"./en-ca.js\": 36,\n\t\"./en-gb\": 37,\n\t\"./en-gb.js\": 37,\n\t\"./en-ie\": 38,\n\t\"./en-ie.js\": 38,\n\t\"./en-il\": 39,\n\t\"./en-il.js\": 39,\n\t\"./en-nz\": 40,\n\t\"./en-nz.js\": 40,\n\t\"./eo\": 41,\n\t\"./eo.js\": 41,\n\t\"./es\": 42,\n\t\"./es-do\": 43,\n\t\"./es-do.js\": 43,\n\t\"./es-us\": 44,\n\t\"./es-us.js\": 44,\n\t\"./es.js\": 42,\n\t\"./et\": 45,\n\t\"./et.js\": 45,\n\t\"./eu\": 46,\n\t\"./eu.js\": 46,\n\t\"./fa\": 47,\n\t\"./fa.js\": 47,\n\t\"./fi\": 48,\n\t\"./fi.js\": 48,\n\t\"./fo\": 49,\n\t\"./fo.js\": 49,\n\t\"./fr\": 50,\n\t\"./fr-ca\": 51,\n\t\"./fr-ca.js\": 51,\n\t\"./fr-ch\": 52,\n\t\"./fr-ch.js\": 52,\n\t\"./fr.js\": 50,\n\t\"./fy\": 53,\n\t\"./fy.js\": 53,\n\t\"./gd\": 54,\n\t\"./gd.js\": 54,\n\t\"./gl\": 55,\n\t\"./gl.js\": 55,\n\t\"./gom-latn\": 56,\n\t\"./gom-latn.js\": 56,\n\t\"./gu\": 57,\n\t\"./gu.js\": 57,\n\t\"./he\": 58,\n\t\"./he.js\": 58,\n\t\"./hi\": 59,\n\t\"./hi.js\": 59,\n\t\"./hr\": 60,\n\t\"./hr.js\": 60,\n\t\"./hu\": 61,\n\t\"./hu.js\": 61,\n\t\"./hy-am\": 62,\n\t\"./hy-am.js\": 62,\n\t\"./id\": 63,\n\t\"./id.js\": 63,\n\t\"./is\": 64,\n\t\"./is.js\": 64,\n\t\"./it\": 65,\n\t\"./it.js\": 65,\n\t\"./ja\": 66,\n\t\"./ja.js\": 66,\n\t\"./jv\": 67,\n\t\"./jv.js\": 67,\n\t\"./ka\": 68,\n\t\"./ka.js\": 68,\n\t\"./kk\": 69,\n\t\"./kk.js\": 69,\n\t\"./km\": 70,\n\t\"./km.js\": 70,\n\t\"./kn\": 71,\n\t\"./kn.js\": 71,\n\t\"./ko\": 72,\n\t\"./ko.js\": 72,\n\t\"./ky\": 73,\n\t\"./ky.js\": 73,\n\t\"./lb\": 74,\n\t\"./lb.js\": 74,\n\t\"./lo\": 75,\n\t\"./lo.js\": 75,\n\t\"./lt\": 76,\n\t\"./lt.js\": 76,\n\t\"./lv\": 77,\n\t\"./lv.js\": 77,\n\t\"./me\": 78,\n\t\"./me.js\": 78,\n\t\"./mi\": 79,\n\t\"./mi.js\": 79,\n\t\"./mk\": 80,\n\t\"./mk.js\": 80,\n\t\"./ml\": 81,\n\t\"./ml.js\": 81,\n\t\"./mn\": 82,\n\t\"./mn.js\": 82,\n\t\"./mr\": 83,\n\t\"./mr.js\": 83,\n\t\"./ms\": 84,\n\t\"./ms-my\": 85,\n\t\"./ms-my.js\": 85,\n\t\"./ms.js\": 84,\n\t\"./mt\": 86,\n\t\"./mt.js\": 86,\n\t\"./my\": 87,\n\t\"./my.js\": 87,\n\t\"./nb\": 88,\n\t\"./nb.js\": 88,\n\t\"./ne\": 89,\n\t\"./ne.js\": 89,\n\t\"./nl\": 90,\n\t\"./nl-be\": 91,\n\t\"./nl-be.js\": 91,\n\t\"./nl.js\": 90,\n\t\"./nn\": 92,\n\t\"./nn.js\": 92,\n\t\"./pa-in\": 93,\n\t\"./pa-in.js\": 93,\n\t\"./pl\": 94,\n\t\"./pl.js\": 94,\n\t\"./pt\": 95,\n\t\"./pt-br\": 96,\n\t\"./pt-br.js\": 96,\n\t\"./pt.js\": 95,\n\t\"./ro\": 97,\n\t\"./ro.js\": 97,\n\t\"./ru\": 98,\n\t\"./ru.js\": 98,\n\t\"./sd\": 99,\n\t\"./sd.js\": 99,\n\t\"./se\": 100,\n\t\"./se.js\": 100,\n\t\"./si\": 101,\n\t\"./si.js\": 101,\n\t\"./sk\": 102,\n\t\"./sk.js\": 102,\n\t\"./sl\": 103,\n\t\"./sl.js\": 103,\n\t\"./sq\": 104,\n\t\"./sq.js\": 104,\n\t\"./sr\": 105,\n\t\"./sr-cyrl\": 106,\n\t\"./sr-cyrl.js\": 106,\n\t\"./sr.js\": 105,\n\t\"./ss\": 107,\n\t\"./ss.js\": 107,\n\t\"./sv\": 108,\n\t\"./sv.js\": 108,\n\t\"./sw\": 109,\n\t\"./sw.js\": 109,\n\t\"./ta\": 110,\n\t\"./ta.js\": 110,\n\t\"./te\": 111,\n\t\"./te.js\": 111,\n\t\"./tet\": 112,\n\t\"./tet.js\": 112,\n\t\"./tg\": 113,\n\t\"./tg.js\": 113,\n\t\"./th\": 114,\n\t\"./th.js\": 114,\n\t\"./tl-ph\": 115,\n\t\"./tl-ph.js\": 115,\n\t\"./tlh\": 116,\n\t\"./tlh.js\": 116,\n\t\"./tr\": 117,\n\t\"./tr.js\": 117,\n\t\"./tzl\": 118,\n\t\"./tzl.js\": 118,\n\t\"./tzm\": 119,\n\t\"./tzm-latn\": 120,\n\t\"./tzm-latn.js\": 120,\n\t\"./tzm.js\": 119,\n\t\"./ug-cn\": 121,\n\t\"./ug-cn.js\": 121,\n\t\"./uk\": 122,\n\t\"./uk.js\": 122,\n\t\"./ur\": 123,\n\t\"./ur.js\": 123,\n\t\"./uz\": 124,\n\t\"./uz-latn\": 125,\n\t\"./uz-latn.js\": 125,\n\t\"./uz.js\": 124,\n\t\"./vi\": 126,\n\t\"./vi.js\": 126,\n\t\"./x-pseudo\": 127,\n\t\"./x-pseudo.js\": 127,\n\t\"./yo\": 128,\n\t\"./yo.js\": 128,\n\t\"./zh-cn\": 129,\n\t\"./zh-cn.js\": 129,\n\t\"./zh-hk\": 130,\n\t\"./zh-hk.js\": 130,\n\t\"./zh-tw\": 131,\n\t\"./zh-tw.js\": 131\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 134;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSBeXFwuXFwvLiokP2MzMWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vYWZcIjogOSxcblx0XCIuL2FmLmpzXCI6IDksXG5cdFwiLi9hclwiOiAxMCxcblx0XCIuL2FyLWR6XCI6IDExLFxuXHRcIi4vYXItZHouanNcIjogMTEsXG5cdFwiLi9hci1rd1wiOiAxMixcblx0XCIuL2FyLWt3LmpzXCI6IDEyLFxuXHRcIi4vYXItbHlcIjogMTMsXG5cdFwiLi9hci1seS5qc1wiOiAxMyxcblx0XCIuL2FyLW1hXCI6IDE0LFxuXHRcIi4vYXItbWEuanNcIjogMTQsXG5cdFwiLi9hci1zYVwiOiAxNSxcblx0XCIuL2FyLXNhLmpzXCI6IDE1LFxuXHRcIi4vYXItdG5cIjogMTYsXG5cdFwiLi9hci10bi5qc1wiOiAxNixcblx0XCIuL2FyLmpzXCI6IDEwLFxuXHRcIi4vYXpcIjogMTcsXG5cdFwiLi9hei5qc1wiOiAxNyxcblx0XCIuL2JlXCI6IDE4LFxuXHRcIi4vYmUuanNcIjogMTgsXG5cdFwiLi9iZ1wiOiAxOSxcblx0XCIuL2JnLmpzXCI6IDE5LFxuXHRcIi4vYm1cIjogMjAsXG5cdFwiLi9ibS5qc1wiOiAyMCxcblx0XCIuL2JuXCI6IDIxLFxuXHRcIi4vYm4uanNcIjogMjEsXG5cdFwiLi9ib1wiOiAyMixcblx0XCIuL2JvLmpzXCI6IDIyLFxuXHRcIi4vYnJcIjogMjMsXG5cdFwiLi9ici5qc1wiOiAyMyxcblx0XCIuL2JzXCI6IDI0LFxuXHRcIi4vYnMuanNcIjogMjQsXG5cdFwiLi9jYVwiOiAyNSxcblx0XCIuL2NhLmpzXCI6IDI1LFxuXHRcIi4vY3NcIjogMjYsXG5cdFwiLi9jcy5qc1wiOiAyNixcblx0XCIuL2N2XCI6IDI3LFxuXHRcIi4vY3YuanNcIjogMjcsXG5cdFwiLi9jeVwiOiAyOCxcblx0XCIuL2N5LmpzXCI6IDI4LFxuXHRcIi4vZGFcIjogMjksXG5cdFwiLi9kYS5qc1wiOiAyOSxcblx0XCIuL2RlXCI6IDMwLFxuXHRcIi4vZGUtYXRcIjogMzEsXG5cdFwiLi9kZS1hdC5qc1wiOiAzMSxcblx0XCIuL2RlLWNoXCI6IDMyLFxuXHRcIi4vZGUtY2guanNcIjogMzIsXG5cdFwiLi9kZS5qc1wiOiAzMCxcblx0XCIuL2R2XCI6IDMzLFxuXHRcIi4vZHYuanNcIjogMzMsXG5cdFwiLi9lbFwiOiAzNCxcblx0XCIuL2VsLmpzXCI6IDM0LFxuXHRcIi4vZW4tYXVcIjogMzUsXG5cdFwiLi9lbi1hdS5qc1wiOiAzNSxcblx0XCIuL2VuLWNhXCI6IDM2LFxuXHRcIi4vZW4tY2EuanNcIjogMzYsXG5cdFwiLi9lbi1nYlwiOiAzNyxcblx0XCIuL2VuLWdiLmpzXCI6IDM3LFxuXHRcIi4vZW4taWVcIjogMzgsXG5cdFwiLi9lbi1pZS5qc1wiOiAzOCxcblx0XCIuL2VuLWlsXCI6IDM5LFxuXHRcIi4vZW4taWwuanNcIjogMzksXG5cdFwiLi9lbi1uelwiOiA0MCxcblx0XCIuL2VuLW56LmpzXCI6IDQwLFxuXHRcIi4vZW9cIjogNDEsXG5cdFwiLi9lby5qc1wiOiA0MSxcblx0XCIuL2VzXCI6IDQyLFxuXHRcIi4vZXMtZG9cIjogNDMsXG5cdFwiLi9lcy1kby5qc1wiOiA0Myxcblx0XCIuL2VzLXVzXCI6IDQ0LFxuXHRcIi4vZXMtdXMuanNcIjogNDQsXG5cdFwiLi9lcy5qc1wiOiA0Mixcblx0XCIuL2V0XCI6IDQ1LFxuXHRcIi4vZXQuanNcIjogNDUsXG5cdFwiLi9ldVwiOiA0Nixcblx0XCIuL2V1LmpzXCI6IDQ2LFxuXHRcIi4vZmFcIjogNDcsXG5cdFwiLi9mYS5qc1wiOiA0Nyxcblx0XCIuL2ZpXCI6IDQ4LFxuXHRcIi4vZmkuanNcIjogNDgsXG5cdFwiLi9mb1wiOiA0OSxcblx0XCIuL2ZvLmpzXCI6IDQ5LFxuXHRcIi4vZnJcIjogNTAsXG5cdFwiLi9mci1jYVwiOiA1MSxcblx0XCIuL2ZyLWNhLmpzXCI6IDUxLFxuXHRcIi4vZnItY2hcIjogNTIsXG5cdFwiLi9mci1jaC5qc1wiOiA1Mixcblx0XCIuL2ZyLmpzXCI6IDUwLFxuXHRcIi4vZnlcIjogNTMsXG5cdFwiLi9meS5qc1wiOiA1Myxcblx0XCIuL2dkXCI6IDU0LFxuXHRcIi4vZ2QuanNcIjogNTQsXG5cdFwiLi9nbFwiOiA1NSxcblx0XCIuL2dsLmpzXCI6IDU1LFxuXHRcIi4vZ29tLWxhdG5cIjogNTYsXG5cdFwiLi9nb20tbGF0bi5qc1wiOiA1Nixcblx0XCIuL2d1XCI6IDU3LFxuXHRcIi4vZ3UuanNcIjogNTcsXG5cdFwiLi9oZVwiOiA1OCxcblx0XCIuL2hlLmpzXCI6IDU4LFxuXHRcIi4vaGlcIjogNTksXG5cdFwiLi9oaS5qc1wiOiA1OSxcblx0XCIuL2hyXCI6IDYwLFxuXHRcIi4vaHIuanNcIjogNjAsXG5cdFwiLi9odVwiOiA2MSxcblx0XCIuL2h1LmpzXCI6IDYxLFxuXHRcIi4vaHktYW1cIjogNjIsXG5cdFwiLi9oeS1hbS5qc1wiOiA2Mixcblx0XCIuL2lkXCI6IDYzLFxuXHRcIi4vaWQuanNcIjogNjMsXG5cdFwiLi9pc1wiOiA2NCxcblx0XCIuL2lzLmpzXCI6IDY0LFxuXHRcIi4vaXRcIjogNjUsXG5cdFwiLi9pdC5qc1wiOiA2NSxcblx0XCIuL2phXCI6IDY2LFxuXHRcIi4vamEuanNcIjogNjYsXG5cdFwiLi9qdlwiOiA2Nyxcblx0XCIuL2p2LmpzXCI6IDY3LFxuXHRcIi4va2FcIjogNjgsXG5cdFwiLi9rYS5qc1wiOiA2OCxcblx0XCIuL2trXCI6IDY5LFxuXHRcIi4va2suanNcIjogNjksXG5cdFwiLi9rbVwiOiA3MCxcblx0XCIuL2ttLmpzXCI6IDcwLFxuXHRcIi4va25cIjogNzEsXG5cdFwiLi9rbi5qc1wiOiA3MSxcblx0XCIuL2tvXCI6IDcyLFxuXHRcIi4va28uanNcIjogNzIsXG5cdFwiLi9reVwiOiA3Myxcblx0XCIuL2t5LmpzXCI6IDczLFxuXHRcIi4vbGJcIjogNzQsXG5cdFwiLi9sYi5qc1wiOiA3NCxcblx0XCIuL2xvXCI6IDc1LFxuXHRcIi4vbG8uanNcIjogNzUsXG5cdFwiLi9sdFwiOiA3Nixcblx0XCIuL2x0LmpzXCI6IDc2LFxuXHRcIi4vbHZcIjogNzcsXG5cdFwiLi9sdi5qc1wiOiA3Nyxcblx0XCIuL21lXCI6IDc4LFxuXHRcIi4vbWUuanNcIjogNzgsXG5cdFwiLi9taVwiOiA3OSxcblx0XCIuL21pLmpzXCI6IDc5LFxuXHRcIi4vbWtcIjogODAsXG5cdFwiLi9tay5qc1wiOiA4MCxcblx0XCIuL21sXCI6IDgxLFxuXHRcIi4vbWwuanNcIjogODEsXG5cdFwiLi9tblwiOiA4Mixcblx0XCIuL21uLmpzXCI6IDgyLFxuXHRcIi4vbXJcIjogODMsXG5cdFwiLi9tci5qc1wiOiA4Myxcblx0XCIuL21zXCI6IDg0LFxuXHRcIi4vbXMtbXlcIjogODUsXG5cdFwiLi9tcy1teS5qc1wiOiA4NSxcblx0XCIuL21zLmpzXCI6IDg0LFxuXHRcIi4vbXRcIjogODYsXG5cdFwiLi9tdC5qc1wiOiA4Nixcblx0XCIuL215XCI6IDg3LFxuXHRcIi4vbXkuanNcIjogODcsXG5cdFwiLi9uYlwiOiA4OCxcblx0XCIuL25iLmpzXCI6IDg4LFxuXHRcIi4vbmVcIjogODksXG5cdFwiLi9uZS5qc1wiOiA4OSxcblx0XCIuL25sXCI6IDkwLFxuXHRcIi4vbmwtYmVcIjogOTEsXG5cdFwiLi9ubC1iZS5qc1wiOiA5MSxcblx0XCIuL25sLmpzXCI6IDkwLFxuXHRcIi4vbm5cIjogOTIsXG5cdFwiLi9ubi5qc1wiOiA5Mixcblx0XCIuL3BhLWluXCI6IDkzLFxuXHRcIi4vcGEtaW4uanNcIjogOTMsXG5cdFwiLi9wbFwiOiA5NCxcblx0XCIuL3BsLmpzXCI6IDk0LFxuXHRcIi4vcHRcIjogOTUsXG5cdFwiLi9wdC1iclwiOiA5Nixcblx0XCIuL3B0LWJyLmpzXCI6IDk2LFxuXHRcIi4vcHQuanNcIjogOTUsXG5cdFwiLi9yb1wiOiA5Nyxcblx0XCIuL3JvLmpzXCI6IDk3LFxuXHRcIi4vcnVcIjogOTgsXG5cdFwiLi9ydS5qc1wiOiA5OCxcblx0XCIuL3NkXCI6IDk5LFxuXHRcIi4vc2QuanNcIjogOTksXG5cdFwiLi9zZVwiOiAxMDAsXG5cdFwiLi9zZS5qc1wiOiAxMDAsXG5cdFwiLi9zaVwiOiAxMDEsXG5cdFwiLi9zaS5qc1wiOiAxMDEsXG5cdFwiLi9za1wiOiAxMDIsXG5cdFwiLi9zay5qc1wiOiAxMDIsXG5cdFwiLi9zbFwiOiAxMDMsXG5cdFwiLi9zbC5qc1wiOiAxMDMsXG5cdFwiLi9zcVwiOiAxMDQsXG5cdFwiLi9zcS5qc1wiOiAxMDQsXG5cdFwiLi9zclwiOiAxMDUsXG5cdFwiLi9zci1jeXJsXCI6IDEwNixcblx0XCIuL3NyLWN5cmwuanNcIjogMTA2LFxuXHRcIi4vc3IuanNcIjogMTA1LFxuXHRcIi4vc3NcIjogMTA3LFxuXHRcIi4vc3MuanNcIjogMTA3LFxuXHRcIi4vc3ZcIjogMTA4LFxuXHRcIi4vc3YuanNcIjogMTA4LFxuXHRcIi4vc3dcIjogMTA5LFxuXHRcIi4vc3cuanNcIjogMTA5LFxuXHRcIi4vdGFcIjogMTEwLFxuXHRcIi4vdGEuanNcIjogMTEwLFxuXHRcIi4vdGVcIjogMTExLFxuXHRcIi4vdGUuanNcIjogMTExLFxuXHRcIi4vdGV0XCI6IDExMixcblx0XCIuL3RldC5qc1wiOiAxMTIsXG5cdFwiLi90Z1wiOiAxMTMsXG5cdFwiLi90Zy5qc1wiOiAxMTMsXG5cdFwiLi90aFwiOiAxMTQsXG5cdFwiLi90aC5qc1wiOiAxMTQsXG5cdFwiLi90bC1waFwiOiAxMTUsXG5cdFwiLi90bC1waC5qc1wiOiAxMTUsXG5cdFwiLi90bGhcIjogMTE2LFxuXHRcIi4vdGxoLmpzXCI6IDExNixcblx0XCIuL3RyXCI6IDExNyxcblx0XCIuL3RyLmpzXCI6IDExNyxcblx0XCIuL3R6bFwiOiAxMTgsXG5cdFwiLi90emwuanNcIjogMTE4LFxuXHRcIi4vdHptXCI6IDExOSxcblx0XCIuL3R6bS1sYXRuXCI6IDEyMCxcblx0XCIuL3R6bS1sYXRuLmpzXCI6IDEyMCxcblx0XCIuL3R6bS5qc1wiOiAxMTksXG5cdFwiLi91Zy1jblwiOiAxMjEsXG5cdFwiLi91Zy1jbi5qc1wiOiAxMjEsXG5cdFwiLi91a1wiOiAxMjIsXG5cdFwiLi91ay5qc1wiOiAxMjIsXG5cdFwiLi91clwiOiAxMjMsXG5cdFwiLi91ci5qc1wiOiAxMjMsXG5cdFwiLi91elwiOiAxMjQsXG5cdFwiLi91ei1sYXRuXCI6IDEyNSxcblx0XCIuL3V6LWxhdG4uanNcIjogMTI1LFxuXHRcIi4vdXouanNcIjogMTI0LFxuXHRcIi4vdmlcIjogMTI2LFxuXHRcIi4vdmkuanNcIjogMTI2LFxuXHRcIi4veC1wc2V1ZG9cIjogMTI3LFxuXHRcIi4veC1wc2V1ZG8uanNcIjogMTI3LFxuXHRcIi4veW9cIjogMTI4LFxuXHRcIi4veW8uanNcIjogMTI4LFxuXHRcIi4vemgtY25cIjogMTI5LFxuXHRcIi4vemgtY24uanNcIjogMTI5LFxuXHRcIi4vemgtaGtcIjogMTMwLFxuXHRcIi4vemgtaGsuanNcIjogMTMwLFxuXHRcIi4vemgtdHdcIjogMTMxLFxuXHRcIi4vemgtdHcuanNcIjogMTMxXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG5cdHJldHVybiBpZDtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMTM0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUgXlxcLlxcLy4qJFxuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///134\n");

/***/ })
/******/ ]);